(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&u.push(i[o][0]),i[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);u.length;)u.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"05af1349",3:"3d227a19",4:"855f1166",5:"c3e49c8d",6:"251782bc",7:"01608d28",8:"6d6ae631",9:"52b37655",10:"66567ee0",11:"1f4f4ed4",12:"06422b58",13:"899800b9",14:"ea3c8e17",15:"b01969f3",16:"c97582ef",17:"c87f5dfc",18:"7d72f6be",19:"b755ee6c",20:"1014aa6e",21:"f0529276",22:"1bb9495b",23:"b6fa9bcc",24:"09e27301",25:"546b2725",26:"61e25f70",27:"0fa49e95",28:"f8a97284",29:"7542b5d3",30:"74cc9197",31:"8051867b",32:"eff265cc",33:"ece5d882",34:"c1f79bbc",35:"aff5fde4",36:"49b3c8ba",37:"3cc2d286",38:"b1fb1852",39:"cc1653e3",40:"0b0f1f98",41:"57cc6dc4",42:"84ab8021",43:"3cc05505",44:"065a74e8",45:"1de9c020",46:"7da1b5f4",47:"25a680e9",48:"db8a55d4"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;a.push([242,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(0),i=t(38).f,a=t(24),o=t(14),s=t(113),l=t(118),c=t(105);n.exports=function(n,e){var t,p,d,u,m,g=n.target,h=n.global,v=n.stat;if(t=h?r:v?r[g]||s(g,{}):(r[g]||{}).prototype)for(p in e){if(u=e[p],d=n.noTargetGet?(m=i(t,p))&&m.value:t[p],!c(h?p:g+(v?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&a(u,"sham",!0),o(t,p,u,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(64),i=Function.prototype,a=i.bind,o=i.call,s=r&&a.bind(o,o);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(0),i=t(49),a=t(9),o=t(83),s=t(50),l=t(156),c=i("wks"),p=r.Symbol,d=p&&p.for,u=l?p:p&&p.withoutSetter||o;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(p,n)?c[n]=p[n]:c[n]=l&&d?d(e):u(e)}return c[n]}},function(n,e,t){var r=t(121),i=t(14),a=t(262);r||i(Object.prototype,"toString",a,{unsafe:!0})},function(n,e,t){var r=t(64),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){var r=t(2);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(3),i=t(17),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){var r=t(0),i=t(11),a=r.String,o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(0),i=t(80),a=r.String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(0),i=t(8),a=t(158),o=t(157),s=t(10),l=t(85),c=r.TypeError,p=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=d(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return p(n,e,t)}:p:function(n,e,t){if(s(n),e=l(e),s(t),a)try{return p(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(0),i=t(4),a=t(24),o=t(163),s=t(113);n.exports=function(n,e,t,l){var c=!!l&&!!l.unsafe,p=!!l&&!!l.enumerable,d=!!l&&!!l.noTargetGet,u=l&&void 0!==l.name?l.name:e;return i(t)&&o(t,u,l),n===r?(p?n[e]=t:s(e,t),n):(c?!d&&n[e]&&(p=!0):delete n[e],p?n[e]=t:a(n,e,t),n)}},function(n,e,t){var r=t(0),i=t(4),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e){n.exports=!1},function(n,e,t){var r=t(0),i=t(18),a=r.Object;n.exports=function(n){return a(i(n))}},function(n,e,t){var r=t(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(1),i=t(95);r({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,e,t){var r=t(63),i=t(18);n.exports=function(n){return r(i(n))}},function(n,e,t){var r=t(0),i=t(4),a=t(66),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){var r=t(52);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(3),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){var r=t(8),i=t(13),a=t(47);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(176).charAt,i=t(12),a=t(35),o=t(162),s=a.set,l=a.getterFor("String Iterator");o(String,"String",(function(n){s(this,{type:"String Iterator",string:i(n),index:0})}),(function(){var n,e=l(this),t=e.string,i=e.index;return i>=t.length?{value:void 0,done:!0}:(n=r(t,i),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(14),i=t(283),a=Error.prototype;a.toString!==i&&r(a,"toString",i)},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(15);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(193),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):i&&(l=s?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(1),i=t(58).filter;r({target:"Array",proto:!0,forced:!t(93)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),i=t(177),a=t(178),o=t(144),s=t(24),l=t(5),c=l("iterator"),p=l("toStringTag"),d=o.values,u=function(n,e){if(n){if(n[c]!==d)try{s(n,c,d)}catch(e){n[c]=d}if(n[p]||s(n,p,e),i[e])for(var t in o)if(n[t]!==o[t])try{s(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var m in i)u(r[m]&&r[m].prototype,m);u(a,"DOMTokenList")},function(n,e,t){var r,i=t(10),a=t(145),o=t(116),s=t(67),l=t(161),c=t(84),p=t(87),d=p("IE_PROTO"),u=function(){},m=function(n){return"<script>"+n+"<\/script>"},g=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},h=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;h="undefined"!=typeof document?document.domain&&r?g(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):g(r);for(var t=o.length;t--;)delete h.prototype[o[t]];return h()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=i(n),t=new u,u.prototype=null,t[d]=n):t=h(),void 0===e?t:a.f(t,e)}},function(n,e,t){var r=t(3);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r,i,a,o=t(244),s=t(0),l=t(3),c=t(11),p=t(24),d=t(9),u=t(112),m=t(87),g=t(67),h=s.TypeError,v=s.WeakMap;if(o||u.state){var f=u.state||(u.state=new v),b=l(f.get),y=l(f.has),x=l(f.set);r=function(n,e){if(y(f,n))throw new h("Object already initialized");return e.facade=n,x(f,n,e),e},i=function(n){return b(f,n)||{}},a=function(n){return y(f,n)}}else{var w=m("state");g[w]=!0,r=function(n,e){if(d(n,w))throw new h("Object already initialized");return e.facade=n,p(n,w,e),e},i=function(n){return d(n,w)?n[w]:{}},a=function(n){return d(n,w)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=i(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(1),i=t(182);r({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,e,t){var r=t(0),i=t(177),a=t(178),o=t(182),s=t(24),l=function(n){if(n&&n.forEach!==o)try{s(n,"forEach",o)}catch(e){n.forEach=o}};for(var c in i)i[c]&&l(r[c]&&r[c].prototype);l(a)},function(n,e,t){var r=t(8),i=t(7),a=t(117),o=t(47),s=t(20),l=t(85),c=t(9),p=t(158),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){var r=t(64),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){var r=t(1),i=t(0),a=t(39),o=t(279),s=i.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(303),i=t(306);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return g})),t.d(e,"d",(function(){return v})),t.d(e,"k",(function(){return f})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(19),t(44),t(139),t(79),t(137),t(111),t(43),t(36),t(6),t(37),t(31),t(82),t(103),t(155),t(78),t(214),t(26),t(143);var r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";var e=n.match(r),t=e?e[0]:"",i=s(n);return a.test(i)?n:i+".html"+t}function u(n,e){var t=n.hash,i=function(n){var e=n&&n.match(r);if(e)return e[0]}(e);return(!i||t===i)&&s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));for(var r=s(e),i=0;i<n.length;i++)if(s(n[i].regularPath)===r)return Object.assign({},n[i],{type:"page",path:d(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function g(n,e,t,r){var i=t.pages,a=t.themeConfig,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return h(n);var s=o.sidebar||a.sidebar;if(s){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,s),c=l.base,p=l.config;return"auto"===p?h(n):p?p.map((function(n){return function n(e,t,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map((function(e){return n(e,t,r,i+1)})),collapsable:!1!==e.collapsable}}(n,i,c)})):[]}return[]}function h(n){var e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function v(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e,t){"use strict";var r=t(1),i=t(58).map;r({target:"Array",proto:!0,forced:!t(93)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(39),i=t(7),a=t(3),o=t(109),s=t(2),l=t(10),c=t(4),p=t(56),d=t(52),u=t(12),m=t(18),g=t(126),h=t(46),v=t(284),f=t(110),b=t(5)("replace"),y=Math.max,x=Math.min,w=a([].concat),S=a([].push),k=a("".indexOf),j=a("".slice),q="$0"==="a".replace(/./,"$0"),C=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,e,t){var a=C?"$":"$0";return[function(n,t){var r=m(this),a=null==n?void 0:h(n,b);return a?i(a,n,r,t):i(e,u(r),n,t)},function(n,i){var o=l(this),s=u(n);if("string"==typeof i&&-1===k(i,a)&&-1===k(i,"$<")){var m=t(e,o,s,i);if(m.done)return m.value}var h=c(i);h||(i=u(i));var b=o.global;if(b){var q=o.unicode;o.lastIndex=0}for(var C=[];;){var I=f(o,s);if(null===I)break;if(S(C,I),!b)break;""===u(I[0])&&(o.lastIndex=g(s,d(o.lastIndex),q))}for(var M,T="",_=0,E=0;E<C.length;E++){for(var A=u((I=C[E])[0]),B=y(x(p(I.index),s.length),0),R=[],L=1;L<I.length;L++)S(R,void 0===(M=I[L])?M:String(M));var z=I.groups;if(h){var P=w([A],R,B,s);void 0!==z&&S(P,z);var D=u(r(i,void 0,P))}else D=v(A,s,B,R,z,i);B>=_&&(T+=j(s,_,B)+D,_=B+A.length)}return T+j(s,_)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!q||C)},function(n,e,t){"use strict";var r=t(2);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(16),i=t(112);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.5",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.5/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var r=t(51),i=t(2);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,i,a=t(0),o=t(28),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(i=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){var r=t(56),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,e,t){var r=t(0);n.exports=r.Promise},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(61),o=t(91),s=t(11),l=t(115),c=t(22),p=t(20),d=t(74),u=t(5),m=t(93),g=t(71),h=m("slice"),v=u("species"),f=i.Array,b=Math.max;r({target:"Array",proto:!0,forced:!h},{slice:function(n,e){var t,r,i,u=p(this),m=c(u),h=l(n,m),y=l(void 0===e?m:e,m);if(a(u)&&(t=u.constructor,(o(t)&&(t===f||a(t.prototype))||s(t)&&null===(t=t[v]))&&(t=void 0),t===f||void 0===t))return g(u,h,y);for(r=new(void 0===t?f:t)(b(y-h,0)),i=0;h<y;h++,i++)h in u&&d(r,i,u[h]);return r.length=i,r}})},function(n,e,t){t(379),t(380)},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?r:t)(e)}},function(n,e,t){var r=t(3),i=t(21),a=t(64),o=r(r.bind);n.exports=function(n,e){return i(n),void 0===e?n:a?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(57),i=t(3),a=t(63),o=t(17),s=t(22),l=t(148),c=i([].push),p=function(n){var e=1==n,t=2==n,i=3==n,p=4==n,d=6==n,u=7==n,m=5==n||d;return function(g,h,v,f){for(var b,y,x=o(g),w=a(x),S=r(h,v),k=s(w),j=0,q=f||l,C=e?q(g,k):t||u?q(g,0):void 0;k>j;j++)if((m||j in w)&&(y=S(b=w[j],j,x),n))if(e)C[j]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return j;case 2:c(C,b)}else switch(n){case 4:return!1;case 7:c(C,b)}return d?-1:i||p?p:C}};n.exports={forEach:p(0),map:p(1),filter:p(2),some:p(3),every:p(4),find:p(5),findIndex:p(6),filterReject:p(7)}},function(n,e,t){var r=t(160),i=t(116).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){var r=t(13).f,i=t(9),a=t(5)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e,t){var r=t(23);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(75),i=t(288),a=t(289),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(0),i=t(3),a=t(2),o=t(23),s=r.Object,l=i("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?l(n,""):s(n)}:s},function(n,e,t){var r=t(2);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(0),i=t(15),a=t(4),o=t(34),s=t(156),l=r.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return a(e)&&o(e.prototype,l(n))}},function(n,e,t){var r=t(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(8),i=t(9),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(3),i=t(10),a=t(245);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return i(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e,t){var r=t(3);n.exports=r([].slice)},function(n,e,t){var r=t(0),i=t(53),a=t(4),o=t(105),s=t(88),l=t(5),c=t(253),p=t(16),d=t(51),u=i&&i.prototype,m=l("species"),g=!1,h=a(r.PromiseRejectionEvent),v=o("Promise",(function(){var n=s(i),e=n!==String(i);if(!e&&66===d)return!0;if(p&&(!u.catch||!u.finally))return!0;if(d>=51&&/native code/.test(n))return!1;var t=new i((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[m]=r,!(g=t.then((function(){}))instanceof r)||!e&&c&&!h}));n.exports={CONSTRUCTOR:v,REJECTION_EVENT:h,SUBCLASSING:g}},function(n,e,t){"use strict";var r=t(21),i=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new i(n)}},function(n,e,t){"use strict";var r=t(85),i=t(13),a=t(47);n.exports=function(n,e,t){var o=r(e);o in n?i.f(n,o,a(0,t)):n[o]=t}},function(n,e,t){var r=t(29).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(82);var r=t(77);t(81),t(94),t(6),t(125),t(25),t(32),t(188);var i=t(101);t(40),t(26);function a(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(2),o=t(61),s=t(11),l=t(17),c=t(22),p=t(74),d=t(148),u=t(93),m=t(5),g=t(51),h=m("isConcatSpreadable"),v=i.TypeError,f=g>=51||!a((function(){var n=[];return n[h]=!1,n.concat()[0]!==n})),b=u("concat"),y=function(n){if(!s(n))return!1;var e=n[h];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,arity:1,forced:!f||!b},{concat:function(n){var e,t,r,i,a,o=l(this),s=d(o,0),u=0;for(e=-1,r=arguments.length;e<r;e++)if(y(a=-1===e?o:arguments[e])){if(u+(i=c(a))>9007199254740991)throw v("Maximum allowed index exceeded");for(t=0;t<i;t++,u++)t in a&&p(s,u,a[t])}else{if(u>=9007199254740991)throw v("Maximum allowed index exceeded");p(s,u++,a)}return s.length=u,s}})},function(n,e,t){"use strict";t(19);var r,i,a=t(1),o=t(0),s=t(7),l=t(3),c=t(4),p=t(11),d=(r=!1,(i=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&r),u=o.Error,m=l(/./.test);a({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!c(e))return m(this,n);var t=s(e,this,n);if(null!==t&&!p(t))throw new u("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var r=t(0),i=t(121),a=t(4),o=t(23),s=t(5)("toStringTag"),l=r.Object,c="Arguments"==o(function(){return arguments}());n.exports=i?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:c?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){t(271),t(274),t(275),t(124),t(276)},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(61)})},function(n,e,t){var r=t(3),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){var r=t(0),i=t(11),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var r=t(159),i=t(65);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e,t){var r=t(160),i=t(116);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){var r=t(49),i=t(83),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){var r=t(3),i=t(4),a=t(112),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(23),i=t(0);n.exports="process"==r(i.process)},function(n,e,t){var r=t(3),i=t(2),a=t(4),o=t(80),s=t(15),l=t(88),c=function(){},p=[],d=s("Reflect","construct"),u=/^\s*(?:class|function)\b/,m=r(u.exec),g=!u.exec(c),h=function(n){if(!a(n))return!1;try{return d(c,p,n),!0}catch(n){return!1}},v=function(n){if(!a(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return g||!!m(u,l(n))}catch(n){return!0}};v.sham=!0,n.exports=!d||i((function(){var n;return h(h.call)||!h(Object)||!h((function(){n=!0}))||n}))?v:h},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(6);function r(n,e,t,r,i,a,o){try{var s=n[a](o),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,i)}function i(n){return function(){var e=this,t=arguments;return new Promise((function(i,a){var o=n.apply(e,t);function s(n){r(o,i,a,s,l,"next",n)}function l(n){r(o,i,a,s,l,"throw",n)}s(void 0)}))}}},function(n,e,t){var r=t(2),i=t(5),a=t(51),o=i("species");n.exports=function(n){return a>=51||!r((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var r=t(1),i=t(8),a=t(0),o=t(3),s=t(9),l=t(4),c=t(34),p=t(12),d=t(13).f,u=t(118),m=a.Symbol,g=m&&m.prototype;if(i&&l(m)&&(!("description"in g)||void 0!==m().description)){var h={},v=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:p(arguments[0]),e=c(g,this)?new m(n):void 0===n?m():m(n);return""===n&&(h[e]=!0),e};u(v,m),v.prototype=g,g.constructor=v;var f="Symbol(test)"==String(m("test")),b=o(g.toString),y=o(g.valueOf),x=/^Symbol\((.*)\)[^)]+$/,w=o("".replace),S=o("".slice);d(g,"description",{configurable:!0,get:function(){var n=y(this),e=b(n);if(s(h,n))return"";var t=f?S(e,7,-1):w(e,x,"$1");return""===t?void 0:t}}),r({global:!0,constructor:!0,forced:!0},{Symbol:v})}},function(n,e,t){"use strict";var r,i,a=t(7),o=t(3),s=t(12),l=t(189),c=t(108),p=t(49),d=t(33),u=t(35).get,m=t(227),g=t(232),h=p("native-string-replace",String.prototype.replace),v=RegExp.prototype.exec,f=v,b=o("".charAt),y=o("".indexOf),x=o("".replace),w=o("".slice),S=(i=/b*/g,a(v,r=/a/,"a"),a(v,i,"a"),0!==r.lastIndex||0!==i.lastIndex),k=c.BROKEN_CARET,j=void 0!==/()??/.exec("")[1];(S||j||k||m||g)&&(f=function(n){var e,t,r,i,o,c,p,m=this,g=u(m),q=s(n),C=g.raw;if(C)return C.lastIndex=m.lastIndex,e=a(f,C,q),m.lastIndex=C.lastIndex,e;var I=g.groups,M=k&&m.sticky,T=a(l,m),_=m.source,E=0,A=q;if(M&&(T=x(T,"y",""),-1===y(T,"g")&&(T+="g"),A=w(q,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==b(q,m.lastIndex-1))&&(_="(?: "+_+")",A=" "+A,E++),t=new RegExp("^(?:"+_+")",T)),j&&(t=new RegExp("^"+_+"$(?!\\s)",T)),S&&(r=m.lastIndex),i=a(v,M?t:m,A),M?i?(i.input=w(i.input,E),i[0]=w(i[0],E),i.index=m.lastIndex,m.lastIndex+=i[0].length):m.lastIndex=0:S&&i&&(m.lastIndex=m.global?i.index+i[0].length:r),j&&i&&i.length>1&&a(h,i[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0)})),i&&I)for(i.groups=c=d(null),o=0;o<I.length;o++)c[(p=I[o])[0]]=i[p[1]];return i}),n.exports=f},function(n,e,t){var r=t(293),i=t(294),a=t(295),o=t(296),s=t(297);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(195);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(41)(Object,"create");n.exports=r},function(n,e,t){var r=t(315);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(134);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(54),t(6),t(107),t(188),t(25),t(19),t(79);var r=t(77);function i(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,d=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),p=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&u(i),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(114).indexOf,o=t(45),s=i([].indexOf),l=!!s&&1/s([1],1,-0)<0,c=o("indexOf");r({target:"Array",proto:!0,forced:l||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?s(this,n,e)||0:a(this,n,e)}})},function(n,e,t){var r=t(1),i=t(17),a=t(86);r({target:"Object",stat:!0,forced:t(2)((function(){a(1)}))},{keys:function(n){return a(i(n))}})},function(n,e,t){var r=t(2),i=t(4),a=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==p||t!=c&&(i(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",p=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(80),i=t(46),a=t(68),o=t(5)("iterator");n.exports=function(n){if(null!=n)return i(n,o)||i(n,"@@iterator")||a[r(n)]}},function(n,e,t){var r=t(8),i=t(69).EXISTS,a=t(3),o=t(13).f,s=Function.prototype,l=a(s.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,p=a(c.exec);r&&!i&&o(s,"name",{configurable:!0,get:function(){try{return p(c,l(this))[1]}catch(n){return""}}})},function(n,e,t){var r=t(2),i=t(0).RegExp,a=r((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=a||r((function(){return!i("a","y").sticky})),s=a||r((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:o,UNSUPPORTED_Y:a}},function(n,e,t){"use strict";t(19);var r=t(3),i=t(14),a=t(95),o=t(2),s=t(5),l=t(24),c=s("species"),p=RegExp.prototype;n.exports=function(n,e,t,d){var u=s(n),m=!o((function(){var e={};return e[u]=function(){return 7},7!=""[n](e)})),g=m&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[u]=/./[u]),t.exec=function(){return e=!0,null},t[u](""),!e}));if(!m||!g||t){var h=r(/./[u]),v=e(u,""[n],(function(n,e,t,i,o){var s=r(n),l=e.exec;return l===a||l===p.exec?m&&!o?{done:!0,value:h(e,t,i)}:{done:!0,value:s(t,e,i)}:{done:!1}}));i(String.prototype,n,v[0]),i(p,u,v[1])}d&&l(p[u],"sham",!0)}},function(n,e,t){var r=t(0),i=t(7),a=t(10),o=t(4),s=t(23),l=t(95),c=r.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var r=i(t,n,e);return null!==r&&a(r),r}if("RegExp"===s(n))return i(l,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(63),o=t(20),s=t(45),l=i([].join),c=a!=Object,p=s("join",",");r({target:"Array",proto:!0,forced:c||!p},{join:function(n){return l(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(0),i=t(113),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(0),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(20),i=t(115),a=t(22),o=function(n){return function(e,t,o){var s,l=r(e),c=a(l),p=i(o,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(56),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(9),i=t(164),a=t(38),o=t(13);n.exports=function(n,e,t){for(var s=i(e),l=o.f,c=a.f,p=0;p<s.length;p++){var d=s[p];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(0),i=t(9),a=t(4),o=t(17),s=t(87),l=t(166),c=s("IE_PROTO"),p=r.Object,d=p.prototype;n.exports=l?p.getPrototypeOf:function(n){var e=o(n);if(i(e,c))return e[c];var t=e.constructor;return a(t)&&e instanceof t?t.prototype:e instanceof p?d:null}},function(n,e,t){var r=t(10),i=t(167),a=t(5)("species");n.exports=function(n,e){var t,o=r(n).constructor;return void 0===o||null==(t=r(o)[a])?e:i(t)}},function(n,e,t){var r={};r[t(5)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var r=t(0),i=t(115),a=t(22),o=t(74),s=r.Array,l=Math.max;n.exports=function(n,e,t){for(var r=a(n),c=i(e,r),p=i(void 0===t?r:t,r),d=s(l(p-c,0)),u=0;c<p;c++,u++)o(d,u,n[c]);return d.length=u,d}},function(n,e,t){var r=t(1),i=t(15),a=t(39),o=t(7),s=t(3),l=t(2),c=t(61),p=t(4),d=t(11),u=t(65),m=t(71),g=t(50),h=i("JSON","stringify"),v=s(/./.exec),f=s("".charAt),b=s("".charCodeAt),y=s("".replace),x=s(1..toString),w=/[\uD800-\uDFFF]/g,S=/^[\uD800-\uDBFF]$/,k=/^[\uDC00-\uDFFF]$/,j=!g||l((function(){var n=i("Symbol")();return"[null]"!=h([n])||"{}"!=h({a:n})||"{}"!=h(Object(n))})),q=l((function(){return'"\\udf06\\ud834"'!==h("\udf06\ud834")||'"\\udead"'!==h("\udead")})),C=function(n,e){var t=m(arguments),r=e;if((d(e)||void 0!==n)&&!u(n))return c(e)||(e=function(n,e){if(p(r)&&(e=o(r,this,n,e)),!u(e))return e}),t[1]=e,a(h,null,t)},I=function(n,e,t){var r=f(t,e-1),i=f(t,e+1);return v(S,n)&&!v(k,i)||v(k,n)&&!v(S,r)?"\\u"+x(b(n,0),16):n};h&&r({target:"JSON",stat:!0,arity:3,forced:j||q},{stringify:function(n,e,t){var r=m(arguments),i=a(j?C:h,null,r);return q&&"string"==typeof i?y(i,w,I):i}})},function(n,e,t){t(186)("iterator")},function(n,e,t){"use strict";var r=t(176).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(287),i=t(48),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(41)(t(29),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(307),i=t(314),a=t(316),o=t(317),s=t(318);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(27),i=t(134),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(62),i=t(48);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(82);t(81),t(94),t(6),t(125),t(25),t(32);var r=t(101);t(40),t(26);function i(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,i,a=[],o=!0,s=!1;try{for(t=t.call(n);!(o=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);o=!0);}catch(n){s=!0,i=n}finally{try{o||null==t.return||t.return()}finally{if(s)throw i}}return a}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(39),i=t(7),a=t(3),o=t(109),s=t(149),l=t(10),c=t(18),p=t(120),d=t(126),u=t(52),m=t(12),g=t(46),h=t(123),v=t(110),f=t(95),b=t(108),y=t(2),x=b.UNSUPPORTED_Y,w=Math.min,S=[].push,k=a(/./.exec),j=a(S),q=a("".slice);o("split",(function(n,e,t){var a;return a="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var a=m(c(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[a];if(!s(n))return i(e,a,n,o);for(var l,p,d,u=[],g=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),v=0,b=new RegExp(n.source,g+"g");(l=i(f,b,a))&&!((p=b.lastIndex)>v&&(j(u,q(a,v,l.index)),l.length>1&&l.index<a.length&&r(S,u,h(l,1)),d=l[0].length,v=p,u.length>=o));)b.lastIndex===l.index&&b.lastIndex++;return v===a.length?!d&&k(b,"")||j(u,""):j(u,q(a,v)),u.length>o?h(u,0,o):u}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:i(e,this,n,t)}:e,[function(e,t){var r=c(this),o=null==e?void 0:g(e,n);return o?i(o,e,r,t):i(a,m(r),e,t)},function(n,r){var i=l(this),o=m(n),s=t(a,i,o,r,a!==e);if(s.done)return s.value;var c=p(i,RegExp),g=i.unicode,h=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(x?"g":"y"),f=new c(x?"^(?:"+i.source+")":i,h),b=void 0===r?4294967295:r>>>0;if(0===b)return[];if(0===o.length)return null===v(f,o)?[o]:[];for(var y=0,S=0,k=[];S<o.length;){f.lastIndex=x?0:S;var C,I=v(f,x?q(o,S):o);if(null===I||(C=w(u(f.lastIndex+(x?S:0)),o.length))===y)S=d(o,S,g);else{if(j(k,q(o,y,S)),k.length===b)return k;for(var M=1;M<=I.length-1;M++)if(j(k,I[M]),k.length===b)return k;S=y=C}}return j(k,q(o,y)),k}]}),!!y((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),x)},function(n,e,t){"use strict";var r=t(1),i=t(58).some;r({target:"Array",proto:!0,forced:!t(45)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(7),i=t(109),a=t(10),o=t(52),s=t(12),l=t(18),c=t(46),p=t(126),d=t(110);i("match",(function(n,e,t){return[function(e){var t=l(this),i=null==e?void 0:c(e,n);return i?r(i,e,t):new RegExp(e)[n](s(t))},function(n){var r=a(this),i=s(n),l=t(e,r,i);if(l.done)return l.value;if(!r.global)return d(r,i);var c=r.unicode;r.lastIndex=0;for(var u,m=[],g=0;null!==(u=d(r,i));){var h=s(u[0]);m[g]=h,""===h&&(r.lastIndex=p(i,o(r.lastIndex),c)),g++}return 0===g?null:m}]}))},function(n,e,t){var r=t(5),i=t(33),a=t(13),o=r("unscopables"),s=Array.prototype;null==s[o]&&a.f(s,o,{configurable:!0,value:i(null)}),n.exports=function(n){s[o][n]=!0}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",o=r.toStringTag||"@@toStringTag";function s(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{s({},"")}catch(n){s=function(n,e,t){return n[e]=t}}function l(n,e,t,r){var i=e&&e.prototype instanceof d?e:d,a=Object.create(i.prototype),o=new k(r||[]);return a._invoke=function(n,e,t){var r="suspendedStart";return function(i,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw a;return q()}for(t.method=i,t.arg=a;;){var o=t.delegate;if(o){var s=x(o,t);if(s){if(s===p)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=c(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===p)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,o),a}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var p={};function d(){}function u(){}function m(){}var g={};s(g,i,(function(){return this}));var h=Object.getPrototypeOf,v=h&&h(h(j([])));v&&v!==e&&t.call(v,i)&&(g=v);var f=m.prototype=d.prototype=Object.create(g);function b(n){["next","throw","return"].forEach((function(e){s(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(i,a){function o(){return new e((function(r,o){!function r(i,a,o,s){var l=c(n[i],n,a);if("throw"!==l.type){var p=l.arg,d=p.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){r("next",n,o,s)}),(function(n){r("throw",n,o,s)})):e.resolve(d).then((function(n){p.value=n,o(p)}),(function(n){return r("throw",n,o,s)}))}s(l.arg)}(i,a,r,o)}))}return r=r?r.then(o,o):o()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return p;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return p}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,p;var i=r.arg;return i?i.done?(e[n.resultName]=i.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,p):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,p)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function S(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function k(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function j(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:q}}function q(){return{value:void 0,done:!0}}return u.prototype=m,s(f,"constructor",m),s(m,"constructor",u),u.displayName=s(m,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===u||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,s(n,o,"GeneratorFunction")),n.prototype=Object.create(f),n},n.awrap=function(n){return{__await:n}},b(y.prototype),s(y.prototype,a,(function(){return this})),n.AsyncIterator=y,n.async=function(e,t,r,i,a){void 0===a&&(a=Promise);var o=new y(l(e,t,r,i),a);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},b(f),s(f,o,"Generator"),s(f,i,(function(){return this})),s(f,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=j,k.prototype={constructor:k,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(S),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return o.type="throw",o.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],o=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var s=t.call(a,"catchLoc"),l=t.call(a,"finallyLoc");if(s&&l){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&t.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var a=i;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=n,o.arg=e,a?(this.method="next",this.next=a.finallyLoc,p):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),p},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),S(t),p}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var i=r.arg;S(t)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:j(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),p}},n}(n.exports);try{regeneratorRuntime=r}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){var r=t(1),i=t(8),a=t(13).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==a,sham:!i},{defineProperty:a})},function(n,e,t){"use strict";var r=t(69).PROPER,i=t(14),a=t(10),o=t(12),s=t(2),l=t(238),c=RegExp.prototype.toString,p=s((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),d=r&&"toString"!=c.name;(p||d)&&i(RegExp.prototype,"toString",(function(){var n=a(this);return"/"+o(n.source)+"/"+o(l(n))}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(20),i=t(140),a=t(68),o=t(35),s=t(13).f,l=t(162),c=t(16),p=t(8),d=o.set,u=o.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=u(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values");var m=a.Arguments=a.Array;if(i("keys"),i("values"),i("entries"),!c&&p&&"values"!==m.name)try{s(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var r=t(8),i=t(157),a=t(13),o=t(10),s=t(20),l=t(86);e.f=r&&!i?Object.defineProperties:function(n,e){o(n);for(var t,r=s(e),i=l(e),c=i.length,p=0;c>p;)a.f(n,t=i[p++],r[t]);return n}},function(n,e,t){var r=t(0).TypeError;n.exports=function(n,e){if(n<e)throw r("Not enough arguments");return n}},function(n,e,t){var r=t(0),i=t(7),a=t(21),o=t(10),s=t(66),l=t(106),c=r.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(a(t))return o(i(t,n));throw c(s(n)+" is not iterable")}},function(n,e,t){var r=t(263);n.exports=function(n,e){return new(r(n))(0===e?0:e)}},function(n,e,t){var r=t(11),i=t(23),a=t(5)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[a])?!!e:"RegExp"==i(n))}},function(n,e,t){var r=t(4),i=t(11),a=t(70);n.exports=function(n,e,t){var o,s;return a&&r(o=e.constructor)&&o!==t&&i(s=o.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function g(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,s,l,c=0,p=!1,v=!1,f=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,o=n.apply(a,t)}function y(n){return c=n,s=setTimeout(w,e),p?b(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||v&&n-c>=a}function w(){var n=m();if(x(n))return S(n);s=setTimeout(w,function(n){var t=e-(n-l);return v?u(t,a-(n-c)):t}(n))}function S(n){return s=void 0,f&&r?b(n):(r=i=void 0,o)}function k(){var n=m(),t=x(n);if(r=arguments,i=this,l=n,t){if(void 0===s)return y(l);if(v)return s=setTimeout(w,e),b(l)}return void 0===s&&(s=setTimeout(w,e)),o}return e=h(e)||0,g(t)&&(p=!!t.leading,a=(v="maxWait"in t)?d(h(t.maxWait)||0,e):a,f="trailing"in t?!!t.trailing:f),k.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=i=s=void 0},k.flush=function(){return void 0===s?o:S(m())},k}},function(n,e,t){var r=t(3),i=t(18),a=t(12),o=t(154),s=r("".replace),l="["+o+"]",c=RegExp("^"+l+l+"*"),p=RegExp(l+l+"*$"),d=function(n){return function(e){var t=a(i(e));return 1&n&&(t=s(t,c,"")),2&n&&(t=s(t,p,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(3),i=t(14),a=Date.prototype,o=r(a.toString),s=r(a.getTime);"Invalid Date"!=String(new Date(NaN))&&i(a,"toString",(function(){var n=s(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){var r=t(50);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(8),i=t(2);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(8),i=t(2),a=t(84);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(0),i=t(7),a=t(11),o=t(65),s=t(46),l=t(243),c=t(5),p=r.TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,r=s(n,d);if(r){if(void 0===e&&(e="default"),t=i(r,n,e),!a(t)||o(t))return t;throw p("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var r=t(3),i=t(9),a=t(20),o=t(114).indexOf,s=t(67),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,p=[];for(t in r)!i(s,t)&&i(r,t)&&l(p,t);for(;e.length>c;)i(r,t=e[c++])&&(~o(p,t)||l(p,t));return p}},function(n,e,t){var r=t(15);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(16),o=t(69),s=t(4),l=t(228),c=t(119),p=t(70),d=t(60),u=t(24),m=t(14),g=t(5),h=t(68),v=t(165),f=o.PROPER,b=o.CONFIGURABLE,y=v.IteratorPrototype,x=v.BUGGY_SAFARI_ITERATORS,w=g("iterator"),S=function(){return this};n.exports=function(n,e,t,o,g,v,k){l(t,e,o);var j,q,C,I=function(n){if(n===g&&A)return A;if(!x&&n in _)return _[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},M=e+" Iterator",T=!1,_=n.prototype,E=_[w]||_["@@iterator"]||g&&_[g],A=!x&&E||I(g),B="Array"==e&&_.entries||E;if(B&&(j=c(B.call(new n)))!==Object.prototype&&j.next&&(a||c(j)===y||(p?p(j,y):s(j[w])||m(j,w,S)),d(j,M,!0,!0),a&&(h[M]=S)),f&&"values"==g&&E&&"values"!==E.name&&(!a&&b?u(_,"name","values"):(T=!0,A=function(){return i(E,this)})),g)if(q={values:I("values"),keys:v?A:I("keys"),entries:I("entries")},k)for(C in q)(x||T||!(C in _))&&m(_,C,q[C]);else r({target:e,proto:!0,forced:x||T},q);return a&&!k||_[w]===A||m(_,w,A,{name:g}),h[e]=A,q}},function(n,e,t){var r=t(2),i=t(4),a=t(9),o=t(8),s=t(69).CONFIGURABLE,l=t(88),c=t(35),p=c.enforce,d=c.get,u=Object.defineProperty,m=o&&!r((function(){return 8!==u((function(){}),"length",{value:8}).length})),g=String(String).split("String"),h=n.exports=function(n,e,t){if("Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&u(n,"name",{value:e,configurable:!0}),m&&t&&a(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity}),t&&a(t,"constructor")&&t.constructor){if(o)try{u(n,"prototype",{writable:!1})}catch(n){}}else n.prototype=void 0;var r=p(n);return a(r,"source")||(r.source=g.join("string"==typeof e?e:"")),n};Function.prototype.toString=h((function(){return i(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var r=t(15),i=t(3),a=t(59),o=t(89),s=t(10),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r,i,a,o=t(2),s=t(4),l=t(33),c=t(119),p=t(14),d=t(5),u=t(16),m=d("iterator"),g=!1;[].keys&&("next"in(a=[].keys())?(i=c(c(a)))!==Object.prototype&&(r=i):g=!0),null==r||o((function(){var n={};return r[m].call(n)!==n}))?r={}:u&&(r=l(r)),s(r[m])||p(r,m,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:g}},function(n,e,t){var r=t(2);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(0),i=t(91),a=t(66),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a constructor")}},function(n,e,t){var r,i,a,o,s=t(0),l=t(39),c=t(57),p=t(4),d=t(9),u=t(2),m=t(161),g=t(71),h=t(84),v=t(146),f=t(169),b=t(90),y=s.setImmediate,x=s.clearImmediate,w=s.process,S=s.Dispatch,k=s.Function,j=s.MessageChannel,q=s.String,C=0,I={};try{r=s.location}catch(n){}var M=function(n){if(d(I,n)){var e=I[n];delete I[n],e()}},T=function(n){return function(){M(n)}},_=function(n){M(n.data)},E=function(n){s.postMessage(q(n),r.protocol+"//"+r.host)};y&&x||(y=function(n){v(arguments.length,1);var e=p(n)?n:k(n),t=g(arguments,1);return I[++C]=function(){l(e,void 0,t)},i(C),C},x=function(n){delete I[n]},b?i=function(n){w.nextTick(T(n))}:S&&S.now?i=function(n){S.now(T(n))}:j&&!f?(o=(a=new j).port2,a.port1.onmessage=_,i=c(o.postMessage,o)):s.addEventListener&&p(s.postMessage)&&!s.importScripts&&r&&"file:"!==r.protocol&&!u(E)?(i=E,s.addEventListener("message",_,!1)):i="onreadystatechange"in h("script")?function(n){m.appendChild(h("script")).onreadystatechange=function(){m.removeChild(this),M(n)}}:function(n){setTimeout(T(n),0)}),n.exports={set:y,clear:x}},function(n,e,t){var r=t(28);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,e,t){var r=t(0),i=t(57),a=t(7),o=t(10),s=t(66),l=t(171),c=t(22),p=t(34),d=t(147),u=t(106),m=t(172),g=r.TypeError,h=function(n,e){this.stopped=n,this.result=e},v=h.prototype;n.exports=function(n,e,t){var r,f,b,y,x,w,S,k=t&&t.that,j=!(!t||!t.AS_ENTRIES),q=!(!t||!t.IS_ITERATOR),C=!(!t||!t.INTERRUPTED),I=i(e,k),M=function(n){return r&&m(r,"normal",n),new h(!0,n)},T=function(n){return j?(o(n),C?I(n[0],n[1],M):I(n[0],n[1])):C?I(n,M):I(n)};if(q)r=n;else{if(!(f=u(n)))throw g(s(n)+" is not iterable");if(l(f)){for(b=0,y=c(n);y>b;b++)if((x=T(n[b]))&&p(v,x))return x;return new h(!1)}r=d(n,f)}for(w=r.next;!(S=a(w,r)).done;){try{x=T(S.value)}catch(n){m(r,"throw",n)}if("object"==typeof x&&x&&p(v,x))return x}return new h(!1)}},function(n,e,t){var r=t(5),i=t(68),a=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[a]===n)}},function(n,e,t){var r=t(7),i=t(10),a=t(46);n.exports=function(n,e,t){var o,s;i(n);try{if(!(o=a(n,"return"))){if("throw"===e)throw t;return t}o=r(o,n)}catch(n){s=!0,o=n}if("throw"===e)throw t;if(s)throw o;return i(o),t}},function(n,e,t){var r=t(53),i=t(174),a=t(72).CONSTRUCTOR;n.exports=a||!i((function(n){r.all(n).then(void 0,(function(){}))}))},function(n,e,t){var r=t(5)("iterator"),i=!1;try{var a=0,o={next:function(){return{done:!!a++}},return:function(){i=!0}};o[r]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!i)return!1;var t=!1;try{var a={};a[r]=function(){return{next:function(){return{done:t=!0}}}},n(a)}catch(n){}return t}},function(n,e,t){var r=t(10),i=t(11),a=t(73);n.exports=function(n,e){if(r(n),i(e)&&e.constructor===n)return e;var t=a.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var r=t(3),i=t(56),a=t(12),o=t(18),s=r("".charAt),l=r("".charCodeAt),c=r("".slice),p=function(n){return function(e,t){var r,p,d=a(o(e)),u=i(t),m=d.length;return u<0||u>=m?n?"":void 0:(r=l(d,u))<55296||r>56319||u+1===m||(p=l(d,u+1))<56320||p>57343?n?s(d,u):r:n?c(d,u,u+2):p-56320+(r-55296<<10)+65536}};n.exports={codeAt:p(!1),charAt:p(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(84)("span").classList,i=r&&r.constructor&&r.constructor.prototype;n.exports=i===Object.prototype?void 0:i},function(n,e,t){var r=t(1),i=t(2),a=t(17),o=t(119),s=t(166);r({target:"Object",stat:!0,forced:i((function(){o(1)})),sham:!s},{getPrototypeOf:function(n){return o(a(n))}})},function(n,e,t){var r=t(0),i=t(149),a=r.TypeError;n.exports=function(n){if(i(n))throw a("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(5)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(58).forEach,i=t(45)("forEach");n.exports=i?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(2);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(23),i=t(20),a=t(59).f,o=t(123),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==r(n)?function(n){try{return a(n)}catch(n){return o(s)}}(n):a(i(n))}},function(n,e,t){var r=t(5);e.f=r},function(n,e,t){var r=t(272),i=t(9),a=t(185),o=t(13).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});i(e,n)||o(e,n,{value:a.f(n)})}},function(n,e,t){var r=t(50);n.exports=r&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){var r=t(1),i=t(277);r({target:"Array",stat:!0,forced:!t(174)((function(n){Array.from(n)}))},{from:i})},function(n,e,t){"use strict";var r=t(10);n.exports=function(){var n=r(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(8)},{create:t(33)})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(96),i=t(298),a=t(299),o=t(300),s=t(301),l=t(302);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(62),i=t(129);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(319),i=t(48);n.exports=function n(e,t,a,o,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,s))}},function(n,e,t){var r=t(200),i=t(322),a=t(201);n.exports=function(n,e,t,o,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var g=-1,h=!0,v=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++g<p;){var f=n[g],b=e[g];if(o)var y=c?o(b,f,g,e,n,l):o(f,b,g,n,e,l);if(void 0!==y){if(y)continue;h=!1;break}if(v){if(!i(e,(function(n,e){if(!a(v,e)&&(f===n||s(f,n,t,o,l)))return v.push(e)}))){h=!1;break}}else if(f!==b&&!s(f,b,t,o,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var r=t(130),i=t(320),a=t(321);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(332),i=t(338),a=t(206);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(29),i=t(334),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||i;n.exports=l}).call(this,t(151)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(335),i=t(336),a=t(337),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,e,t){var r=t(196),i=t(132);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(41)(t(29),"Set");n.exports=r},function(n,e,t){var r=t(129);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(211),i=t(100);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(27),i=t(133),a=t(349),o=t(352);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){var r=t(0),i=t(39),a=t(4),o=t(28),s=t(71),l=t(146),c=/MSIE .\./.test(o),p=r.Function,d=function(n){return c?function(e,t){var r=l(arguments.length,1)>2,o=a(e)?e:p(e),c=r?s(arguments,2):void 0;return n(r?function(){i(o,this,c)}:o,t)}:n};n.exports={setTimeout:d(r.setTimeout),setInterval:d(r.setInterval)}},function(n,e,t){"use strict";var r=t(0),i=t(3),a=t(21),o=t(11),s=t(9),l=t(71),c=t(64),p=r.Function,d=i([].concat),u=i([].join),m={},g=function(n,e,t){if(!s(m,e)){for(var r=[],i=0;i<e;i++)r[i]="a["+i+"]";m[e]=p("C,a","return new C("+u(r,",")+")")}return m[e](n,t)};n.exports=c?p.bind:function(n){var e=a(this),t=e.prototype,r=l(arguments,1),i=function(){var t=d(r,l(arguments));return this instanceof i?g(e,t.length,t):e.apply(n,t)};return o(t)&&(i.prototype=t),i}},function(n,e,t){"use strict";var r=t(1),i=t(386).start;r({target:"String",proto:!0,forced:t(388)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(70)})},function(n,e,t){var r=t(1),i=t(15),a=t(39),o=t(213),s=t(167),l=t(10),c=t(11),p=t(33),d=t(2),u=i("Reflect","construct"),m=Object.prototype,g=[].push,h=d((function(){function n(){}return!(u((function(){}),[],n)instanceof n)})),v=!d((function(){u((function(){}))})),f=h||v;r({target:"Reflect",stat:!0,forced:f,sham:f},{construct:function(n,e){s(n),l(e);var t=arguments.length<3?n:s(arguments[2]);if(v&&!h)return u(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return a(g,r,e),new(a(o,n,r))}var i=t.prototype,d=p(c(i)?i:m),f=a(n,d,e);return c(f)?f:d}})},function(n,e,t){var r=t(1),i=t(0),a=t(60);r({global:!0},{Reflect:{}}),a(i.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(285),i=t(290),a=t(361),o=t(369),s=t(378),l=t(236),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var a="",o=0,s=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(a+=t.substring(s,o)),s=o+1,a+=e}return s!==o?a+t.substring(s,o):a}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(389),t(30)),a=Object(i.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);t(36),t(6),t(37),t(43),t(31);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},i=(t(390),t(30)),a=Object(i.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(8),i=t(0),a=t(3),o=t(105),s=t(14),l=t(9),c=t(150),p=t(34),d=t(65),u=t(159),m=t(2),g=t(59).f,h=t(38).f,v=t(13).f,f=t(385),b=t(153).trim,y=i.Number,x=y.prototype,w=i.TypeError,S=a("".slice),k=a("".charCodeAt),j=function(n){var e=u(n,"number");return"bigint"==typeof e?e:q(e)},q=function(n){var e,t,r,i,a,o,s,l,c=u(n,"number");if(d(c))throw w("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(e=k(c,0))||45===e){if(88===(t=k(c,2))||120===t)return NaN}else if(48===e){switch(k(c,1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return+c}for(o=(a=S(c,2)).length,s=0;s<o;s++)if((l=k(a,s))<48||l>i)return NaN;return parseInt(a,r)}return+c};if(o("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var C,I=function(n){var e=arguments.length<1?0:y(j(n)),t=this;return p(x,t)&&m((function(){f(t)}))?c(Object(e),t,I):e},M=r?g(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),T=0;M.length>T;T++)l(y,C=M[T])&&!l(I,C)&&v(I,C,h(y,C));I.prototype=x,x.constructor=I,s(i,"Number",I,{constructor:!0})}},function(n,e,t){var r=t(2),i=t(0).RegExp;n.exports=r((function(){var n=i(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var r=t(165).IteratorPrototype,i=t(33),a=t(47),o=t(60),s=t(68),l=function(){return this};n.exports=function(n,e,t,c){var p=e+" Iterator";return n.prototype=i(r,{next:a(+!c,t)}),o(n,p,!1,!0),s[p]=l,n}},function(n,e,t){"use strict";var r=t(15),i=t(13),a=t(5),o=t(8),s=a("species");n.exports=function(n){var e=r(n),t=i.f;o&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(0),i=t(34),a=r.TypeError;n.exports=function(n,e){if(i(e,n))return n;throw a("Incorrect invocation")}},function(n,e,t){var r=t(1),i=t(8),a=t(164),o=t(20),s=t(38),l=t(74);r({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var e,t,r=o(n),i=s.f,c=a(r),p={},d=0;c.length>d;)void 0!==(t=i(r,e=c[d++]))&&l(p,e,t);return p}})},function(n,e,t){var r=t(2),i=t(0).RegExp;n.exports=r((function(){var n=i("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){var r=t(13).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),i=t(114).includes,a=t(2),o=t(140);r({target:"Array",proto:!0,forced:a((function(){return!Array(1).includes()}))},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(180),o=t(18),s=t(12),l=t(181),c=i("".indexOf);r({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~c(s(o(this)),s(a(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(1),i=t(153).trim;r({target:"String",proto:!0,forced:t(383)("trim")},{trim:function(){return i(this)}})},function(n,e,t){var r=t(7),i=t(9),a=t(34),o=t(189),s=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in s||i(n,"flags")||!a(s,n)?e:r(o,n)}},function(n,e,t){var r=t(123),i=Math.floor,a=function(n,e){var t=n.length,l=i(t/2);return t<8?o(n,e):s(n,a(r(n,0,l),e),a(r(n,l),e),e)},o=function(n,e){for(var t,r,i=n.length,a=1;a<i;){for(r=a,t=n[a];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==a++&&(n[r]=t)}return n},s=function(n,e,t,r){for(var i=e.length,a=t.length,o=0,s=0;o<i||s<a;)n[o+s]=o<i&&s<a?r(e[o],t[s])<=0?e[o++]:t[s++]:o<i?e[o++]:t[s++];return n};n.exports=a},function(n,e,t){var r=t(0),i=t(8),a=t(108).MISSED_STICKY,o=t(23),s=t(241),l=t(35).get,c=RegExp.prototype,p=r.TypeError;i&&a&&s(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===o(this))return!!l(this).sticky;throw p("Incompatible receiver, RegExp required")}}})},function(n,e,t){var r=t(163),i=t(13);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),i.f(n,e,t)}},function(n,e,t){n.exports=t(399)},function(n,e,t){var r=t(0),i=t(7),a=t(4),o=t(11),s=r.TypeError;n.exports=function(n,e){var t,r;if("string"===e&&a(t=n.toString)&&!o(r=i(t,n)))return r;if(a(t=n.valueOf)&&!o(r=i(t,n)))return r;if("string"!==e&&a(t=n.toString)&&!o(r=i(t,n)))return r;throw s("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),i=t(4),a=t(88),o=r.WeakMap;n.exports=i(o)&&/native code/.test(a(o))},function(n,e,t){var r=t(0),i=t(4),a=r.String,o=r.TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){t(247),t(254),t(255),t(256),t(257),t(258)},function(n,e,t){"use strict";var r,i,a,o=t(1),s=t(16),l=t(90),c=t(0),p=t(7),d=t(14),u=t(70),m=t(60),g=t(229),h=t(21),v=t(4),f=t(11),b=t(230),y=t(120),x=t(168).set,w=t(248),S=t(251),k=t(122),j=t(252),q=t(35),C=t(53),I=t(72),M=t(73),T=I.CONSTRUCTOR,_=I.REJECTION_EVENT,E=I.SUBCLASSING,A=q.getterFor("Promise"),B=q.set,R=C&&C.prototype,L=C,z=R,P=c.TypeError,D=c.document,O=c.process,N=M.f,F=N,H=!!(D&&D.createEvent&&c.dispatchEvent),V=function(n){var e;return!(!f(n)||!v(e=n.then))&&e},U=function(n,e){var t,r,i,a=e.value,o=1==e.state,s=o?n.ok:n.fail,l=n.resolve,c=n.reject,d=n.domain;try{s?(o||(2===e.rejection&&G(e),e.rejection=1),!0===s?t=a:(d&&d.enter(),t=s(a),d&&(d.exit(),i=!0)),t===n.promise?c(P("Promise-chain cycle")):(r=V(t))?p(r,t,l,c):l(t)):c(a)}catch(n){d&&!i&&d.exit(),c(n)}},$=function(n,e){n.notified||(n.notified=!0,w((function(){for(var t,r=n.reactions;t=r.get();)U(t,n);n.notified=!1,e&&!n.rejection&&W(n)})))},Q=function(n,e,t){var r,i;H?((r=D.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!_&&(i=c["on"+n])?i(r):"unhandledrejection"===n&&S("Unhandled promise rejection",t)},W=function(n){p(x,c,(function(){var e,t=n.facade,r=n.value;if(J(n)&&(e=k((function(){l?O.emit("unhandledRejection",r,t):Q("unhandledrejection",t,r)})),n.rejection=l||J(n)?2:1,e.error))throw e.value}))},J=function(n){return 1!==n.rejection&&!n.parent},G=function(n){p(x,c,(function(){var e=n.facade;l?O.emit("rejectionHandled",e):Q("rejectionhandled",e,n.value)}))},K=function(n,e,t){return function(r){n(e,r,t)}},Y=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,$(n,!0))},X=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw P("Promise can't be resolved itself");var r=V(e);r?w((function(){var t={done:!1};try{p(r,e,K(X,t,n),K(Y,t,n))}catch(e){Y(t,e,n)}})):(n.value=e,n.state=1,$(n,!1))}catch(e){Y({done:!1},e,n)}}};if(T&&(z=(L=function(n){b(this,z),h(n),p(r,this);var e=A(this);try{n(K(X,e),K(Y,e))}catch(n){Y(e,n)}}).prototype,(r=function(n){B(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new j,rejection:!1,state:0,value:void 0})}).prototype=d(z,"then",(function(n,e){var t=A(this),r=N(y(this,L));return t.parent=!0,r.ok=!v(n)||n,r.fail=v(e)&&e,r.domain=l?O.domain:void 0,0==t.state?t.reactions.add(r):w((function(){U(r,t)})),r.promise})),i=function(){var n=new r,e=A(n);this.promise=n,this.resolve=K(X,e),this.reject=K(Y,e)},M.f=N=function(n){return n===L||void 0===n?new i(n):F(n)},!s&&v(C)&&R!==Object.prototype)){a=R.then,E||d(R,"then",(function(n,e){var t=this;return new L((function(n,e){p(a,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete R.constructor}catch(n){}u&&u(R,z)}o({global:!0,constructor:!0,wrap:!0,forced:T},{Promise:L}),m(L,"Promise",!1,!0),g("Promise")},function(n,e,t){var r,i,a,o,s,l,c,p,d=t(0),u=t(57),m=t(38).f,g=t(168).set,h=t(169),v=t(249),f=t(250),b=t(90),y=d.MutationObserver||d.WebKitMutationObserver,x=d.document,w=d.process,S=d.Promise,k=m(d,"queueMicrotask"),j=k&&k.value;j||(r=function(){var n,e;for(b&&(n=w.domain)&&n.exit();i;){e=i.fn,i=i.next;try{e()}catch(n){throw i?o():a=void 0,n}}a=void 0,n&&n.enter()},h||b||f||!y||!x?!v&&S&&S.resolve?((c=S.resolve(void 0)).constructor=S,p=u(c.then,c),o=function(){p(r)}):b?o=function(){w.nextTick(r)}:(g=u(g,d),o=function(){g(r)}):(s=!0,l=x.createTextNode(""),new y(r).observe(l,{characterData:!0}),o=function(){l.data=s=!s})),n.exports=j||function(n){var e={fn:n,next:void 0};a&&(a.next=e),i||(i=e,o()),a=e}},function(n,e,t){var r=t(28),i=t(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==i.Pebble},function(n,e,t){var r=t(28);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(0);n.exports=function(n,e){var t=r.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(21),o=t(73),s=t(122),l=t(170);r({target:"Promise",stat:!0,forced:t(173)},{all:function(n){var e=this,t=o.f(e),r=t.resolve,c=t.reject,p=s((function(){var t=a(e.resolve),o=[],s=0,p=1;l(n,(function(n){var a=s++,l=!1;p++,i(t,e,n).then((function(n){l||(l=!0,o[a]=n,--p||r(o))}),c)})),--p||r(o)}));return p.error&&c(p.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(16),a=t(72).CONSTRUCTOR,o=t(53),s=t(15),l=t(4),c=t(14),p=o&&o.prototype;if(r({target:"Promise",proto:!0,forced:a,real:!0},{catch:function(n){return this.then(void 0,n)}}),!i&&l(o)){var d=s("Promise").prototype.catch;p.catch!==d&&c(p,"catch",d,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(21),o=t(73),s=t(122),l=t(170);r({target:"Promise",stat:!0,forced:t(173)},{race:function(n){var e=this,t=o.f(e),r=t.reject,c=s((function(){var o=a(e.resolve);l(n,(function(n){i(o,e,n).then(t.resolve,r)}))}));return c.error&&r(c.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(73);r({target:"Promise",stat:!0,forced:t(72).CONSTRUCTOR},{reject:function(n){var e=a.f(this);return i(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(15),a=t(16),o=t(53),s=t(72).CONSTRUCTOR,l=t(175),c=i("Promise"),p=a&&!s;r({target:"Promise",stat:!0,forced:a||s},{resolve:function(n){return l(p&&this===c?o:this,n)}})},function(n,e,t){var r=t(1),i=t(260);r({target:"Object",stat:!0,arity:2,forced:Object.assign!==i},{assign:i})},function(n,e,t){"use strict";var r=t(8),i=t(3),a=t(7),o=t(2),s=t(86),l=t(89),c=t(117),p=t(17),d=t(63),u=Object.assign,m=Object.defineProperty,g=i([].concat);n.exports=!u||o((function(){if(r&&1!==u({b:1},u(m({},"a",{enumerable:!0,get:function(){m(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=u({},n)[t]||"abcdefghijklmnopqrst"!=s(u({},e)).join("")}))?function(n,e){for(var t=p(n),i=arguments.length,o=1,u=l.f,m=c.f;i>o;)for(var h,v=d(arguments[o++]),f=u?g(s(v),u(v)):s(v),b=f.length,y=0;b>y;)h=f[y++],r&&!a(m,v,h)||(t[h]=v[h]);return t}:u},function(n,e,t){"use strict";var r=t(1),i=t(16),a=t(53),o=t(2),s=t(15),l=t(4),c=t(120),p=t(175),d=t(14),u=a&&a.prototype;if(r({target:"Promise",proto:!0,real:!0,forced:!!a&&o((function(){u.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,s("Promise")),t=l(n);return this.then(t?function(t){return p(e,n()).then((function(){return t}))}:n,t?function(t){return p(e,n()).then((function(){throw t}))}:n)}}),!i&&l(a)){var m=s("Promise").prototype.finally;u.finally!==m&&d(u,"finally",m,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(121),i=t(80);n.exports=r?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,e,t){var r=t(0),i=t(61),a=t(91),o=t(11),s=t(5)("species"),l=r.Array;n.exports=function(n){var e;return i(n)&&(e=n.constructor,(a(e)&&(e===l||i(e.prototype))||o(e)&&null===(e=e[s]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){"use strict";var r=t(1),i=t(265).left,a=t(45),o=t(51),s=t(90);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),i=t(21),a=t(17),o=t(63),s=t(22),l=r.TypeError,c=function(n){return function(e,t,r,c){i(t);var p=a(e),d=o(p),u=s(p),m=n?u-1:0,g=n?-1:1;if(r<2)for(;;){if(m in d){c=d[m],m+=g;break}if(m+=g,n?m<0:u<=m)throw l("Reduce of empty array with no initial value")}for(;n?m>=0:u>m;m+=g)m in d&&(c=t(c,d[m],m,p));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r,i=t(1),a=t(3),o=t(38).f,s=t(52),l=t(12),c=t(180),p=t(18),d=t(181),u=t(16),m=a("".startsWith),g=a("".slice),h=Math.min,v=d("startsWith");i({target:"String",proto:!0,forced:!!(u||v||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!v},{startsWith:function(n){var e=l(p(this));c(n);var t=s(h(arguments.length>1?arguments[1]:void 0,e.length)),r=l(n);return m?m(e,r,t):g(e,t,t+r.length)===r}})},function(n,e,t){var r=t(1),i=t(183),a=t(2),o=t(11),s=t(268).onFreeze,l=Object.freeze;r({target:"Object",stat:!0,forced:a((function(){l(1)})),sham:!i},{freeze:function(n){return l&&o(n)?l(s(n)):n}})},function(n,e,t){var r=t(1),i=t(3),a=t(67),o=t(11),s=t(9),l=t(13).f,c=t(59),p=t(184),d=t(269),u=t(83),m=t(183),g=!1,h=u("meta"),v=0,f=function(n){l(n,h,{value:{objectID:"O"+v++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},g=!0;var n=c.f,e=i([].splice),t={};t[h]=1,n(t).length&&(c.f=function(t){for(var r=n(t),i=0,a=r.length;i<a;i++)if(r[i]===h){e(r,i,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:p.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,h)){if(!d(n))return"F";if(!e)return"E";f(n)}return n[h].objectID},getWeakData:function(n,e){if(!s(n,h)){if(!d(n))return!0;if(!e)return!1;f(n)}return n[h].weakData},onFreeze:function(n){return m&&g&&d(n)&&!s(n,h)&&f(n),n}};a[h]=!0},function(n,e,t){var r=t(2),i=t(11),a=t(23),o=t(270),s=Object.isExtensible,l=r((function(){s(1)}));n.exports=l||o?function(n){return!!i(n)&&((!o||"ArrayBuffer"!=a(n))&&(!s||s(n)))}:s},function(n,e,t){var r=t(2);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(7),o=t(3),s=t(16),l=t(8),c=t(50),p=t(2),d=t(9),u=t(34),m=t(10),g=t(20),h=t(85),v=t(12),f=t(47),b=t(33),y=t(86),x=t(59),w=t(184),S=t(89),k=t(38),j=t(13),q=t(145),C=t(117),I=t(14),M=t(49),T=t(87),_=t(67),E=t(83),A=t(5),B=t(185),R=t(186),L=t(273),z=t(60),P=t(35),D=t(58).forEach,O=T("hidden"),N=P.set,F=P.getterFor("Symbol"),H=Object.prototype,V=i.Symbol,U=V&&V.prototype,$=i.TypeError,Q=i.QObject,W=k.f,J=j.f,G=w.f,K=C.f,Y=o([].push),X=M("symbols"),Z=M("op-symbols"),nn=M("wks"),en=!Q||!Q.prototype||!Q.prototype.findChild,tn=l&&p((function(){return 7!=b(J({},"a",{get:function(){return J(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=W(H,e);r&&delete H[e],J(n,e,t),r&&n!==H&&J(H,e,r)}:J,rn=function(n,e){var t=X[n]=b(U);return N(t,{type:"Symbol",tag:n,description:e}),l||(t.description=e),t},an=function(n,e,t){n===H&&an(Z,e,t),m(n);var r=h(e);return m(t),d(X,r)?(t.enumerable?(d(n,O)&&n[O][r]&&(n[O][r]=!1),t=b(t,{enumerable:f(0,!1)})):(d(n,O)||J(n,O,f(1,{})),n[O][r]=!0),tn(n,r,t)):J(n,r,t)},on=function(n,e){m(n);var t=g(e),r=y(t).concat(pn(t));return D(r,(function(e){l&&!a(sn,t,e)||an(n,e,t[e])})),n},sn=function(n){var e=h(n),t=a(K,this,e);return!(this===H&&d(X,e)&&!d(Z,e))&&(!(t||!d(this,e)||!d(X,e)||d(this,O)&&this[O][e])||t)},ln=function(n,e){var t=g(n),r=h(e);if(t!==H||!d(X,r)||d(Z,r)){var i=W(t,r);return!i||!d(X,r)||d(t,O)&&t[O][r]||(i.enumerable=!0),i}},cn=function(n){var e=G(g(n)),t=[];return D(e,(function(n){d(X,n)||d(_,n)||Y(t,n)})),t},pn=function(n){var e=n===H,t=G(e?Z:g(n)),r=[];return D(t,(function(n){!d(X,n)||e&&!d(H,n)||Y(r,X[n])})),r};c||(I(U=(V=function(){if(u(U,this))throw $("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?v(arguments[0]):void 0,e=E(n),t=function(n){this===H&&a(t,Z,n),d(this,O)&&d(this[O],e)&&(this[O][e]=!1),tn(this,e,f(1,n))};return l&&en&&tn(H,e,{configurable:!0,set:t}),rn(e,n)}).prototype,"toString",(function(){return F(this).tag})),I(V,"withoutSetter",(function(n){return rn(E(n),n)})),C.f=sn,j.f=an,q.f=on,k.f=ln,x.f=w.f=cn,S.f=pn,B.f=function(n){return rn(A(n),n)},l&&(J(U,"description",{configurable:!0,get:function(){return F(this).description}}),s||I(H,"propertyIsEnumerable",sn,{unsafe:!0}))),r({global:!0,constructor:!0,wrap:!0,forced:!c,sham:!c},{Symbol:V}),D(y(nn),(function(n){R(n)})),r({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),r({target:"Object",stat:!0,forced:!c,sham:!l},{create:function(n,e){return void 0===e?b(n):on(b(n),e)},defineProperty:an,defineProperties:on,getOwnPropertyDescriptor:ln}),r({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),L(),z(V,"Symbol"),_[O]=!0},function(n,e,t){var r=t(0);n.exports=r},function(n,e,t){var r=t(7),i=t(15),a=t(5),o=t(14);n.exports=function(){var n=i("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,s=a("toPrimitive");e&&!e[s]&&o(e,s,(function(n){return r(t,this)}),{arity:1})}},function(n,e,t){var r=t(1),i=t(15),a=t(9),o=t(12),s=t(49),l=t(187),c=s("string-to-symbol-registry"),p=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!l},{for:function(n){var e=o(n);if(a(c,e))return c[e];var t=i("Symbol")(e);return c[e]=t,p[t]=e,t}})},function(n,e,t){var r=t(1),i=t(9),a=t(65),o=t(66),s=t(49),l=t(187),c=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!l},{keyFor:function(n){if(!a(n))throw TypeError(o(n)+" is not a symbol");if(i(c,n))return c[n]}})},function(n,e,t){var r=t(1),i=t(50),a=t(2),o=t(89),s=t(17);r({target:"Object",stat:!0,forced:!i||a((function(){o.f(1)}))},{getOwnPropertySymbols:function(n){var e=o.f;return e?e(s(n)):[]}})},function(n,e,t){"use strict";var r=t(0),i=t(57),a=t(7),o=t(17),s=t(278),l=t(171),c=t(91),p=t(22),d=t(74),u=t(147),m=t(106),g=r.Array;n.exports=function(n){var e=o(n),t=c(this),r=arguments.length,h=r>1?arguments[1]:void 0,v=void 0!==h;v&&(h=i(h,r>2?arguments[2]:void 0));var f,b,y,x,w,S,k=m(e),j=0;if(!k||this==g&&l(k))for(f=p(e),b=t?new this(f):g(f);f>j;j++)S=v?h(e[j],j):e[j],d(b,j,S);else for(w=(x=u(e,k)).next,b=t?new this:[];!(y=a(w,x)).done;j++)S=v?s(x,h,[y.value,j],!0):y.value,d(b,j,S);return b.length=j,b}},function(n,e,t){var r=t(10),i=t(172);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";var r=t(15),i=t(9),a=t(24),o=t(34),s=t(70),l=t(118),c=t(233),p=t(150),d=t(190),u=t(280),m=t(281),g=t(282),h=t(8),v=t(16);n.exports=function(n,e,t,f){var b=f?2:1,y=n.split("."),x=y[y.length-1],w=r.apply(null,y);if(w){var S=w.prototype;if(!v&&i(S,"cause")&&delete S.cause,!t)return w;var k=r("Error"),j=e((function(n,e){var t=d(f?e:n,void 0),r=f?new w(n):new w;return void 0!==t&&a(r,"message",t),g&&a(r,"stack",m(r.stack,2)),this&&o(S,this)&&p(r,this,j),arguments.length>b&&u(r,arguments[b]),r}));if(j.prototype=S,"Error"!==x?s?s(j,k):l(j,k,{name:!0}):h&&"stackTraceLimit"in w&&(c(j,w,"stackTraceLimit"),c(j,w,"prepareStackTrace")),l(j,w),!v)try{S.name!==x&&a(S,"name",x),S.constructor=j}catch(n){}return j}}},function(n,e,t){var r=t(11),i=t(24);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var r=t(3),i=Error,a=r("".replace),o=String(i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var r=t(2),i=t(47);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(8),i=t(2),a=t(10),o=t(33),s=t(190),l=Error.prototype.toString,c=i((function(){if(r){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=c?function(){var n=a(this),e=s(n.name,"Error"),t=s(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){var r=t(3),i=t(17),a=Math.floor,o=r("".charAt),s=r("".replace),l=r("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,p=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,r,d,u){var m=t+n.length,g=r.length,h=p;return void 0!==d&&(d=i(d),h=c),s(u,h,(function(i,s){var c;switch(o(s,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,m);case"<":c=d[l(s,1,-1)];break;default:var p=+s;if(0===p)return i;if(p>g){var u=a(p/10);return 0===u?i:u<=g?void 0===r[u-1]?o(s,1):r[u-1]+o(s,1):i}c=r[p-1]}return void 0===c?"":c}))}},function(n,e,t){var r=t(192),i=t(286);n.exports=function n(e,t,a,o,s){var l=-1,c=e.length;for(a||(a=i),s||(s=[]);++l<c;){var p=e[l];t>0&&a(p)?t>1?n(p,t-1,a,o,s):r(s,p):o||(s[s.length]=p)}return s}},function(n,e,t){var r=t(75),i=t(127),a=t(27),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(62),i=t(48);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(75),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(291),i=t(347),a=t(135),o=t(27),s=t(358);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(292),i=t(346),a=t(209);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(194),i=t(198);n.exports=function(n,e,t,a){var o=t.length,s=o,l=!a;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var p=(c=t[o])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new r;if(a)var g=a(d,u,p,n,e,m);if(!(void 0===g?i(u,d,3,a,m):g))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(97),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(97);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(97);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(97);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(96);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(96),i=t(128),a=t(130);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(196),i=t(304),a=t(129),o=t(197),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?u:s).test(o(n))}},function(n,e,t){var r,i=t(305),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(29)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(308),i=t(96),a=t(128);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(309),i=t(310),a=t(311),o=t(312),s=t(313);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(98);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(98),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(98),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(98);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(99);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(99);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(99);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(99);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(194),i=t(199),a=t(323),o=t(326),s=t(342),l=t(27),c=t(203),p=t(205),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,g,h){var v=l(n),f=l(e),b=v?"[object Array]":s(n),y=f?"[object Array]":s(e),x=(b="[object Arguments]"==b?d:b)==d,w=(y="[object Arguments]"==y?d:y)==d,S=b==y;if(S&&c(n)){if(!c(e))return!1;v=!0,x=!1}if(S&&!x)return h||(h=new r),v||p(n)?i(n,e,t,m,g,h):a(n,e,b,t,m,g,h);if(!(1&t)){var k=x&&u.call(n,"__wrapped__"),j=w&&u.call(e,"__wrapped__");if(k||j){var q=k?n.value():n,C=j?e.value():e;return h||(h=new r),g(q,C,t,m,h)}}return!!S&&(h||(h=new r),o(n,e,t,m,g,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(75),i=t(324),a=t(195),o=t(199),s=t(325),l=t(131),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var g=1&r;if(m||(m=l),n.size!=e.size&&!g)return!1;var h=u.get(n);if(h)return h==e;r|=2,u.set(n,e);var v=o(m(n),m(e),r,c,d,u);return u.delete(n),v;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(29).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(327),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,s){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:i.call(e,u)))return!1}var m=s.get(n),g=s.get(e);if(m&&g)return m==e&&g==n;var h=!0;s.set(n,e),s.set(e,n);for(var v=l;++d<p;){var f=n[u=c[d]],b=e[u];if(a)var y=l?a(b,f,u,e,n,s):a(f,b,u,n,e,s);if(!(void 0===y?f===b||o(f,b,t,a,s):y)){h=!1;break}v||(v="constructor"==u)}if(h&&!v){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var r=t(328),i=t(329),a=t(202);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(192),i=t(27);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(330),i=t(331),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(333),i=t(127),a=t(27),o=t(203),s=t(204),l=t(205),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),p=!t&&i(n),d=!t&&!p&&o(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,g=m?r(n.length,String):[],h=g.length;for(var v in n)!e&&!c.call(n,v)||m&&("length"==v||d&&("offset"==v||"parent"==v)||u&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,h))||g.push(v);return g}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(62),i=t(132),a=t(48),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(193),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(151)(n))},function(n,e,t){var r=t(339),i=t(340),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(341)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(343),i=t(128),a=t(344),o=t(207),s=t(345),l=t(62),c=t(197),p=c(r),d=c(i),u=c(a),m=c(o),g=c(s),h=l;(r&&"[object DataView]"!=h(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=h(new i)||a&&"[object Promise]"!=h(a.resolve())||o&&"[object Set]"!=h(new o)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case g:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var r=t(41)(t(29),"DataView");n.exports=r},function(n,e,t){var r=t(41)(t(29),"Promise");n.exports=r},function(n,e,t){var r=t(41)(t(29),"WeakMap");n.exports=r},function(n,e,t){var r=t(208),i=t(202);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(198),i=t(348),a=t(355),o=t(133),s=t(208),l=t(209),c=t(100);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(210);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(350),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(351);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(130);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(353);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(75),i=t(354),a=t(27),o=t(134),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(356),i=t(357);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(211),i=t(127),a=t(27),o=t(204),s=t(132),l=t(100);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&o(u,p)&&(a(n)||i(n))}},function(n,e,t){var r=t(359),i=t(360),a=t(133),o=t(100);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(210);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(135),i=t(362),a=t(364);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(363),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,s=i(a.length-e,0),l=Array(s);++o<s;)l[o]=a[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=a[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(365),i=t(368)(r);n.exports=i},function(n,e,t){var r=t(366),i=t(367),a=t(135),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(41),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(200),i=t(370),a=t(375),o=t(201),s=t(376),l=t(131);n.exports=function(n,e,t){var c=-1,p=i,d=n.length,u=!0,m=[],g=m;if(t)u=!1,p=a;else if(d>=200){var h=e?null:s(n);if(h)return l(h);u=!1,p=o,g=new r}else g=e?[]:m;n:for(;++c<d;){var v=n[c],f=e?e(v):v;if(v=t||0!==v?v:0,u&&f==f){for(var b=g.length;b--;)if(g[b]===f)continue n;e&&g.push(f),m.push(v)}else p(g,f,t)||(g!==m&&g.push(f),m.push(v))}return m}},function(n,e,t){var r=t(371);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(372),i=t(373),a=t(374);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(207),i=t(377),a=t(131),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(206),i=t(48);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){var r=t(1),i=t(0),a=t(212).setInterval;r({global:!0,bind:!0,forced:i.setInterval!==a},{setInterval:a})},function(n,e,t){var r=t(1),i=t(0),a=t(212).setTimeout;r({global:!0,bind:!0,forced:i.setTimeout!==a},{setTimeout:a})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(69).PROPER,i=t(2),a=t(154);n.exports=function(n){return i((function(){return!!a[n]()||"​᠎"!=="​᠎"[n]()||r&&a[n].name!==n}))}},function(n,e,t){var r=t(1),i=t(213);r({target:"Function",proto:!0,forced:Function.bind!==i},{bind:i})},function(n,e,t){var r=t(3);n.exports=r(1..valueOf)},function(n,e,t){var r=t(3),i=t(52),a=t(12),o=t(387),s=t(18),l=r(o),c=r("".slice),p=Math.ceil,d=function(n){return function(e,t,r){var o,d,u=a(s(e)),m=i(t),g=u.length,h=void 0===r?" ":a(r);return m<=g||""==h?u:((d=l(h,p((o=m-g)/h.length))).length>o&&(d=c(d,0,o)),n?u+d:d+u)}};n.exports={start:d(!1),end:d(!0)}},function(n,e,t){"use strict";var r=t(0),i=t(56),a=t(12),o=t(18),s=r.RangeError;n.exports=function(n){var e=a(o(this)),t="",r=i(n);if(r<0||r==1/0)throw s("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(t+=e);return t}},function(n,e,t){var r=t(28);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";t(215)},function(n,e,t){"use strict";t(216)},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(21),o=t(17),s=t(22),l=t(12),c=t(2),p=t(239),d=t(45),u=t(392),m=t(393),g=t(51),h=t(394),v=[],f=i(v.sort),b=i(v.push),y=c((function(){v.sort(void 0)})),x=c((function(){v.sort(null)})),w=d("sort"),S=!c((function(){if(g)return g<70;if(!(u&&u>3)){if(m)return!0;if(h)return h<603;var n,e,t,r,i="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)v.push({k:e+r,v:t})}for(v.sort((function(n,e){return e.v-n.v})),r=0;r<v.length;r++)e=v[r].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));r({target:"Array",proto:!0,forced:y||!x||!w||!S},{sort:function(n){void 0!==n&&a(n);var e=o(this);if(S)return void 0===n?f(e):f(e,n);var t,r,i=[],c=s(e);for(r=0;r<c;r++)r in e&&b(i,e[r]);for(p(i,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=i.length,r=0;r<t;)e[r]=i[r++];for(;r<c;)delete e[r++];return e}})},function(n,e,t){var r=t(28).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(28);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(28).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(220)},function(n,e,t){"use strict";t(221)},function(n,e,t){"use strict";t.r(e);t(144),t(246),t(259),t(261);var r=t(92),i=(t(141),t(54),t(6),t(25),t(32),t(43),t(31),Object.freeze({}));function a(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function u(n){return"[object RegExp]"===p.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function f(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}f("slot,component",!0);var b=f("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var k=/-(\w)/g,j=S((function(n){return n.replace(k,(function(n,e){return e?e.toUpperCase():""}))})),q=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,I=S((function(n){return n.replace(C,"-$1").toLowerCase()}));var M=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function T(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function _(n,e){for(var t in e)n[t]=e[t];return n}function E(n){for(var e={},t=0;t<n.length;t++)n[t]&&_(e,n[t]);return e}function A(n,e,t){}var B=function(n,e,t){return!1},R=function(n){return n};function L(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return L(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return L(n[t],e[t])}))}catch(n){return!1}}function z(n,e){for(var t=0;t<n.length;t++)if(L(n[t],e))return t;return-1}function P(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var D=["component","directive","filter"],O=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:A,parsePlatformTagName:R,mustUseProp:B,async:!0,_lifecycleHooks:O},F=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^"+F.source+".$_\\d]");var U,$="__proto__"in{},Q="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,J=W&&WXEnvironment.platform.toLowerCase(),G=Q&&window.navigator.userAgent.toLowerCase(),K=G&&/msie|trident/.test(G),Y=G&&G.indexOf("msie 9.0")>0,X=G&&G.indexOf("edge/")>0,Z=(G&&G.indexOf("android"),G&&/iphone|ipad|ipod|ios/.test(G)||"ios"===J),nn=(G&&/chrome\/\d+/.test(G),G&&/phantomjs/.test(G),G&&G.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(Q)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var an=function(){return void 0===U&&(U=!Q&&!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),U},on=Q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,cn="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);ln="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=A,dn=0,un=function(){this.id=dn++,this.subs=[]};un.prototype.addSub=function(n){this.subs.push(n)},un.prototype.removeSub=function(n){y(this.subs,n)},un.prototype.depend=function(){un.target&&un.target.addDep(this)},un.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},un.target=null;var mn=[];function gn(n){mn.push(n),un.target=n}function hn(){mn.pop(),un.target=mn[mn.length-1]}var vn=function(n,e,t,r,i,a,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},fn={child:{configurable:!0}};fn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,fn);var bn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function yn(n){return new vn(void 0,void 0,void 0,String(n))}function xn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,Sn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];H(Sn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var kn=Object.getOwnPropertyNames(Sn),jn=!0;function qn(n){jn=n}var Cn=function(n){this.value=n,this.dep=new un,this.vmCount=0,H(n,"__ob__",this),Array.isArray(n)?($?function(n,e){n.__proto__=e}(n,Sn):function(n,e,t){for(var r=0,i=t.length;r<i;r++){var a=t[r];H(n,a,e[a])}}(n,Sn,kn),this.observeArray(n)):this.walk(n)};function In(n,e){var t;if(c(n)&&!(n instanceof vn))return w(n,"__ob__")&&n.__ob__ instanceof Cn?t=n.__ob__:jn&&!an()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Cn(n)),e&&t&&t.vmCount++,t}function Mn(n,e,t,r,i){var a=new un,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var s=o&&o.get,l=o&&o.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!i&&In(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return un.target&&(a.depend(),c&&(c.dep.depend(),Array.isArray(e)&&En(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!i&&In(e),a.notify())}})}}function Tn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Mn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function _n(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function En(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&En(e)}Cn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Mn(n,e[t])},Cn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e])};var An=N.optionMergeStrategies;function Bn(n,e){if(!e)return n;for(var t,r,i,a=cn?Reflect.ownKeys(e):Object.keys(e),o=0;o<a.length;o++)"__ob__"!==(t=a[o])&&(r=n[t],i=e[t],w(n,t)?r!==i&&d(r)&&d(i)&&Bn(r,i):Tn(n,t,i));return n}function Rn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,i="function"==typeof n?n.call(t,t):n;return r?Bn(r,i):i}:e?n?function(){return Bn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Ln(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function zn(n,e,t,r){var i=Object.create(n||null);return e?_(i,e):i}An.data=function(n,e,t){return t?Rn(n,e,t):e&&"function"!=typeof e?n:Rn(n,e)},O.forEach((function(n){An[n]=Ln})),D.forEach((function(n){An[n+"s"]=zn})),An.watch=function(n,e,t,r){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var a in _(i,n),e){var o=i[a],s=e[a];o&&!Array.isArray(o)&&(o=[o]),i[a]=o?o.concat(s):Array.isArray(s)?s:[s]}return i},An.props=An.methods=An.inject=An.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return _(i,n),e&&_(i,e),i},An.provide=Rn;var Pn=function(n,e){return void 0===e?n:e};function Dn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,a={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(a[j(i)]={type:null});else if(d(t))for(var o in t)i=t[o],a[j(o)]=d(i)?i:{type:i};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(d(t))for(var a in t){var o=t[a];r[a]=d(o)?_({from:a},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Dn(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=Dn(n,e.mixins[r],t);var a,o={};for(a in n)s(a);for(a in e)w(n,a)||s(a);function s(r){var i=An[r]||Pn;o[r]=i(n[r],e[r],t,r)}return o}function On(n,e,t,r){if("string"==typeof t){var i=n[e];if(w(i,t))return i[t];var a=j(t);if(w(i,a))return i[a];var o=q(a);return w(i,o)?i[o]:i[t]||i[a]||i[o]}}function Nn(n,e,t,r){var i=e[n],a=!w(t,n),o=t[n],s=Un(Boolean,i.type);if(s>-1)if(a&&!w(i,"default"))o=!1;else if(""===o||o===I(n)){var l=Un(String,i.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Hn(e.type)?r.call(n):r}(r,i,n);var c=jn;qn(!0),In(o),qn(c)}return o}var Fn=/^\s*function (\w+)/;function Hn(n){var e=n&&n.toString().match(Fn);return e?e[1]:""}function Vn(n,e){return Hn(n)===Hn(e)}function Un(n,e){if(!Array.isArray(e))return Vn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Vn(e[t],n))return t;return-1}function $n(n,e,t){gn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){Wn(n,r,"errorCaptured hook")}}Wn(n,e,t)}finally{hn()}}function Qn(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&g(a)&&!a._handled&&(a.catch((function(n){return $n(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){$n(n,r,i)}return a}function Wn(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Jn(e,null,"config.errorHandler")}Jn(n,e,t)}function Jn(n,e,t){if(!Q&&!W||"undefined"==typeof console)throw n;console.error(n)}var Gn,Kn=!1,Yn=[],Xn=!1;function Zn(){Xn=!1;var n=Yn.slice(0);Yn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var ne=Promise.resolve();Gn=function(){ne.then(Zn),Z&&setTimeout(A)},Kn=!0}else if(K||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Gn="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Zn)}:function(){setTimeout(Zn,0)};else{var ee=1,te=new MutationObserver(Zn),re=document.createTextNode(String(ee));te.observe(re,{characterData:!0}),Gn=function(){ee=(ee+1)%2,re.data=String(ee)},Kn=!0}function ie(n,e){var t;if(Yn.push((function(){if(n)try{n.call(e)}catch(n){$n(n,e,"nextTick")}else t&&t(e)})),Xn||(Xn=!0,Gn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new ln;function oe(n){!function n(e,t){var r,i,a=Array.isArray(e);if(!a&&!c(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(a)for(r=e.length;r--;)n(e[r],t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,ae),ae.clear()}var se=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function le(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Qn(r,null,arguments,e,"v-on handler");for(var i=r.slice(),a=0;a<i.length;a++)Qn(i[a],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,r,i,o){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=se(l),a(c)||(a(p)?(a(c.fns)&&(c=n[l]=le(c,o)),s(d.once)&&(c=n[l]=i(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)a(n[l])&&r((d=se(l)).name,e[l],d.capture)}function pe(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),y(r.fns,l)}a(i)?r=le([l]):o(i.fns)&&s(i.merged)?(r=i).fns.push(l):r=le([i,l]),r.merged=!0,n[e]=r}function de(n,e,t,r,i){if(o(e)){if(w(e,t))return n[t]=e[t],i||delete e[t],!0;if(w(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function ue(n){return l(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var r,i,c,p,d=[];for(r=0;r<e.length;r++)a(i=e[r])||"boolean"==typeof i||(c=d.length-1,p=d[c],Array.isArray(i)?i.length>0&&(me((i=n(i,(t||"")+"_"+r))[0])&&me(p)&&(d[c]=yn(p.text+i[0].text),i.shift()),d.push.apply(d,i)):l(i)?me(p)?d[c]=yn(p.text+i):""!==i&&d.push(yn(i)):me(i)&&me(p)?d[c]=yn(p.text+i.text):(s(e._isVList)&&o(i.tag)&&a(i.key)&&o(t)&&(i.key="__vlist"+t+"_"+r+"__"),d.push(i)));return d}(n):void 0}function me(n){return o(n)&&o(n.text)&&!1===n.isComment}function ge(n,e){if(n){for(var t=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){for(var o=n[a].from,s=e;s;){if(s._provided&&w(s._provided,o)){t[a]=s._provided[o];break}s=s.$parent}if(!s)if("default"in n[a]){var l=n[a].default;t[a]="function"==typeof l?l.call(e):l}else 0}}return t}}function he(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(ve)&&delete t[c];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function fe(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var r,a=Object.keys(e).length>0,o=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==i&&s===t.$key&&!a&&!t.$hasNormal)return t;for(var l in r={},n)n[l]&&"$"!==l[0]&&(r[l]=ye(e,l,n[l]))}else r={};for(var c in e)c in r||(r[c]=xe(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),H(r,"$stable",o),H(r,"$key",s),H(r,"$hasNormal",a),r}function ye(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ue(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!fe(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function xe(n,e){return function(){return n[e]}}function we(n,e){var t,r,i,a,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,i=n.length;r<i;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),p=l.next();!p.done;)t.push(e(p.value,t.length)),p=l.next()}else for(a=Object.keys(n),t=new Array(a.length),r=0,i=a.length;r<i;r++)s=a[r],t[r]=e(n[s],s,r);return o(t)||(t=[]),t._isVList=!0,t}function Se(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=_(_({},r),t)),i=a(t)||("function"==typeof e?e():e)):i=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function ke(n){return On(this.$options,"filters",n)||R}function je(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function qe(n,e,t,r,i){var a=N.keyCodes[e]||t;return i&&r&&!N.keyCodes[e]?je(i,r):a?je(a,n):r?I(r)!==e:void 0===n}function Ce(n,e,t,r,i){if(t)if(c(t)){var a;Array.isArray(t)&&(t=E(t));var o=function(o){if("class"===o||"style"===o||b(o))a=n;else{var s=n.attrs&&n.attrs.type;a=r||N.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(o),c=I(o);l in a||c in a||(a[o]=t[o],i&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var s in t)o(s)}else;return n}function Ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Te(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Me(n,e,t){return Te(n,"__once__"+e+(t?"_"+t:""),!0),n}function Te(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&_e(n[r],e+"_"+r,t);else _e(n,e,t)}function _e(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ee(n,e){if(e)if(d(e)){var t=n.on=n.on?_({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function Ae(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var a=n[i];Array.isArray(a)?Ae(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function Be(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Re(n,e){return"string"==typeof n?e+n:n}function Le(n){n._o=Me,n._n=v,n._s=h,n._l=we,n._t=Se,n._q=L,n._i=z,n._m=Ie,n._f=ke,n._k=qe,n._b=Ce,n._v=yn,n._e=bn,n._u=Ae,n._g=Ee,n._d=Be,n._p=Re}function ze(n,e,t,r,a){var o,l=this,c=a.options;w(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var p=s(c._compiled),d=!p;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||i,this.injections=ge(c.inject,r),this.slots=function(){return l.$slots||be(n.scopedSlots,l.$slots=he(t,r)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),p&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,i){var a=Ve(o,n,e,t,i,d);return a&&!Array.isArray(a)&&(a.fnScopeId=c._scopeId,a.fnContext=r),a}:this._c=function(n,e,t,r){return Ve(o,n,e,t,r,d)}}function Pe(n,e,t,r,i){var a=xn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function De(n,e){for(var t in e)n[j(t)]=e[t]}Le(ze.prototype);var Oe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Oe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){0;var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==i&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=a,n.$attrs=r.data.attrs||i,n.$listeners=t||i,e&&n.$options.props){qn(!1);for(var p=n._props,d=n.$options._propKeys||[],u=0;u<d.length;u++){var m=d[u],g=n.$options.props;p[m]=Nn(m,g,e,n)}qn(!0),n.$options.propsData=e}t=t||i;var h=n.$options._parentListeners;n.$options._parentListeners=t,Ye(n,t,h),c&&(n.$slots=he(a,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,it.push(e)):et(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Ne=Object.keys(Oe);function Fe(n,e,t,r,l){if(!a(n)){var p=t.$options._base;if(c(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=$e;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,l=null,p=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==p&&(clearTimeout(p),p=null))},u=P((function(t){n.resolved=Qe(t,e),i?r.length=0:d(!0)})),m=P((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),h=n(u,m);return c(h)&&(g(h)?a(n.resolved)&&h.then(u,m):g(h.component)&&(h.component.then(u,m),o(h.error)&&(n.errorComp=Qe(h.error,e)),o(h.loading)&&(n.loadingComp=Qe(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),o(h.timeout)&&(p=setTimeout((function(){p=null,a(n.resolved)&&m(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,e,t,r,i){var a=bn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(d,e,t,r,l);e=e||{},jt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),a=i[r],s=e.model.callback;o(a)?(Array.isArray(a)?-1===a.indexOf(s):a!==s)&&(i[r]=[s].concat(a)):i[r]=s}(n.options,e);var u=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in r){var p=I(c);de(i,l,c,p,!0)||de(i,s,c,p,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,r,a){var s=n.options,l={},c=s.props;if(o(c))for(var p in c)l[p]=Nn(p,c,e||i);else o(t.attrs)&&De(l,t.attrs),o(t.props)&&De(l,t.props);var d=new ze(t,l,a,r,n),u=s.render.call(null,d._c,d);if(u instanceof vn)return Pe(u,t,d.parent,s,d);if(Array.isArray(u)){for(var m=ue(u)||[],g=new Array(m.length),h=0;h<m.length;h++)g[h]=Pe(m[h],t,d.parent,s,d);return g}}(n,u,e,t,r);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var h=e.slot;e={},h&&(e.slot=h)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Ne.length;t++){var r=Ne[t],i=e[r],a=Oe[r];i===a||i&&i._merged||(e[r]=i?He(a,i):a)}}(e);var v=n.options.name||l;return new vn("vue-component-"+n.cid+(v?"-"+v:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:m,tag:l,children:r},d)}}}function He(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Ve(n,e,t,r,i,p){return(Array.isArray(t)||l(t))&&(i=r,r=t,t=void 0),s(p)&&(i=2),function(n,e,t,r,i){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===i?r=ue(r):1===i&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var l,p;if("string"==typeof e){var d;p=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),l=N.isReservedTag(e)?new vn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(d=On(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):Fe(d,t,n,r,e)}else l=Fe(e,t,n,r);return Array.isArray(l)?l:o(l)?(o(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];o(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(l,p),o(t)&&function(n){c(n.style)&&oe(n.style);c(n.class)&&oe(n.class)}(t),l):bn()}(n,e,t,r,i)}var Ue,$e=null;function Qe(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function We(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||fe(t)))return t}}function Je(n,e){Ue.$on(n,e)}function Ge(n,e){Ue.$off(n,e)}function Ke(n,e){var t=Ue;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Ye(n,e,t){Ue=n,ce(e,t||{},Je,Ge,Ke,n),Ue=void 0}var Xe=null;function Ze(n){var e=Xe;return Xe=n,function(){Xe=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){gn();var t=n.$options[e],r=e+" hook";if(t)for(var i=0,a=t.length;i<a;i++)Qn(t[i],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),hn()}var rt=[],it=[],at={},ot=!1,st=!1,lt=0;var ct=0,pt=Date.now;if(Q&&!K){var dt=window.performance;dt&&"function"==typeof dt.now&&pt()>document.createEvent("Event").timeStamp&&(pt=function(){return dt.now()})}function ut(){var n,e;for(ct=pt(),st=!0,rt.sort((function(n,e){return n.id-e.id})),lt=0;lt<rt.length;lt++)(n=rt[lt]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=it.slice(),r=rt.slice();lt=rt.length=it.length=0,at={},ot=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),on&&N.devtools&&on.emit("flush")}var mt=0,gt=function(n,e,t,r,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=A)),this.value=this.lazy?void 0:this.get()};gt.prototype.get=function(){var n;gn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;$n(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),hn(),this.cleanupDeps()}return n},gt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},gt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},gt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,st){for(var t=rt.length-1;t>lt&&rt[t].id>n.id;)t--;rt.splice(t+1,0,n)}else rt.push(n);ot||(ot=!0,ie(ut))}}(this)},gt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Qn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},gt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},gt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},gt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ht={enumerable:!0,configurable:!0,get:A,set:A};function vt(n,e,t){ht.get=function(){return this[e][t]},ht.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ht)}function ft(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},i=n.$options._propKeys=[];n.$parent&&qn(!1);var a=function(a){i.push(a);var o=Nn(a,e,t,n);Mn(r,a,o),a in n||vt(n,"_props",a)};for(var o in e)a(o);qn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?A:M(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){gn();try{return n.call(e,e)}catch(n){return $n(n,e,"data()"),{}}finally{hn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&w(r,a)||(o=void 0,36!==(o=(a+"").charCodeAt(0))&&95!==o&&vt(n,"_data",a))}var o;In(e,!0)}(n):In(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var i in e){var a=e[i],o="function"==typeof a?a:a.get;0,r||(t[i]=new gt(n,o||A,A,bt)),i in n||yt(n,i,a)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var i=0;i<r.length;i++)St(n,t,r[i]);else St(n,t,r)}}(n,e.watch)}var bt={lazy:!0};function yt(n,e,t){var r=!an();"function"==typeof t?(ht.get=r?xt(e):wt(t),ht.set=A):(ht.get=t.get?r&&!1!==t.cache?xt(e):wt(t.get):A,ht.set=t.set||A),Object.defineProperty(n,e,ht)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),un.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function St(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var kt=0;function jt(n){var e=n.options;if(n.super){var t=jt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&_(n.extendOptions,r),(e=n.options=Dn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function qt(n){this._init(n)}function Ct(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Dn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)vt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,D.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=_({},o.options),i[r]=o,o}}function It(n){return n&&(n.Ctor.options.name||n.tag)}function Mt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function Tt(n,e){var t=n.cache,r=n.keys,i=n._vnode;for(var a in t){var o=t[a];if(o){var s=o.name;s&&!e(s)&&_t(t,a,r,i)}}}function _t(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=kt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Dn(jt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ye(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=he(e._renderChildren,r),n.$scopedSlots=i,n._c=function(e,t,r,i){return Ve(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Ve(n,e,t,r,i,!0)};var a=t&&t.data;Mn(n,"$attrs",a&&a.attrs||i,null,!0),Mn(n,"$listeners",e._parentListeners||i,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=ge(n.$options.inject,n);e&&(qn(!1),Object.keys(e).forEach((function(t){Mn(n,t,e[t])})),qn(!0))}(e),ft(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(qt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Tn,n.prototype.$delete=_n,n.prototype.$watch=function(n,e,t){if(d(e))return St(this,n,e,t);(t=t||{}).user=!0;var r=new gt(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'+r.expression+'"';gn(),Qn(e,this,[r.value],this,i),hn()}return function(){r.teardown()}}}(qt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var i=0,a=n.length;i<a;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var a,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var s=o.length;s--;)if((a=o[s])===e||a.fn===e){o.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?T(t):t;for(var r=T(arguments,1),i='event handler for "'+n+'"',a=0,o=t.length;a<o;a++)Qn(t[a],e,r,e,i)}return e}}(qt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=Ze(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(qt),function(n){Le(n.prototype),n.prototype.$nextTick=function(n){return ie(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,i=t._parentVnode;i&&(e.$scopedSlots=be(i.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=i;try{$e=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){$n(t,e,"render"),n=e._vnode}finally{$e=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=bn()),n.parent=i,n}}(qt);var Et=[String,RegExp,Array],At={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Et,exclude:Et,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:It(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&_t(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)_t(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Tt(n,(function(n){return Mt(e,n)}))})),this.$watch("exclude",(function(e){Tt(n,(function(n){return!Mt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=We(n),t=e&&e.componentOptions;if(t){var r=It(t),i=this.include,a=this.exclude;if(i&&(!r||!Mt(i,r))||a&&r&&Mt(a,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,y(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:pn,extend:_,mergeOptions:Dn,defineReactive:Mn},n.set=Tn,n.delete=_n,n.nextTick=ie,n.observable=function(n){return In(n),n},n.options=Object.create(null),D.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,_(n.options.components,At),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=T(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Dn(this.options,n),this}}(n),Ct(n),function(n){D.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(qt),Object.defineProperty(qt.prototype,"$isServer",{get:an}),Object.defineProperty(qt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(qt,"FunctionalRenderContext",{value:ze}),qt.version="2.6.14";var Bt=f("style,class"),Rt=f("input,textarea,option,select,progress"),Lt=f("contenteditable,draggable,spellcheck"),zt=f("events,caret,typing,plaintext-only"),Pt=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Dt="http://www.w3.org/1999/xlink",Ot=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Nt=function(n){return Ot(n)?n.slice(6,n.length):""},Ft=function(n){return null==n||!1===n};function Ht(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Vt(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=Vt(e,t.data));return function(n,e){if(o(n)||o(e))return Ut(n,$t(e));return""}(e.staticClass,e.class)}function Vt(n,e){return{staticClass:Ut(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function Ut(n,e){return n?e?n+" "+e:n:e||""}function $t(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)o(e=$t(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Qt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Wt=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Jt=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Gt=function(n){return Wt(n)||Jt(n)};var Kt=Object.create(null);var Yt=f("text,number,password,search,email,tel,url");var Xt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Qt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Zt={create:function(n,e){nr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(nr(n,!0),nr(e))},destroy:function(n){nr(n,!0)}};function nr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,i=n.componentInstance||n.elm,a=r.$refs;e?Array.isArray(a[t])?y(a[t],i):a[t]===i&&(a[t]=void 0):n.data.refInFor?Array.isArray(a[t])?a[t].indexOf(i)<0&&a[t].push(i):a[t]=[i]:a[t]=i}}var er=new vn("",{},[]),tr=["create","activate","update","remove","destroy"];function rr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===i||Yt(r)&&Yt(i)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function ir(n,e,t){var r,i,a={};for(r=e;r<=t;++r)o(i=n[r].key)&&(a[i]=r);return a}var ar={create:or,update:or,destroy:function(n){or(n,er)}};function or(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===er,o=e===er,s=lr(n.data.directives,n.context),l=lr(e.data.directives,e.context),c=[],p=[];for(t in l)r=s[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,pr(i,"update",e,n),i.def&&i.def.componentUpdated&&p.push(i)):(pr(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var d=function(){for(var t=0;t<c.length;t++)pr(c[t],"inserted",e,n)};a?pe(e,"insert",d):d()}p.length&&pe(e,"postpatch",(function(){for(var t=0;t<p.length;t++)pr(p[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||pr(s[t],"unbind",n,n,o)}(n,e)}var sr=Object.create(null);function lr(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=sr),i[cr(r)]=r,r.def=On(e.$options,"directives",r.name);return i}function cr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function pr(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){$n(r,t.context,"directive "+n.name+" "+e+" hook")}}var dr=[Zt,ar];function ur(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,s=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in o(c.__ob__)&&(c=e.data.attrs=_({},c)),c)i=c[r],l[r]!==i&&mr(s,r,i,e.data.pre);for(r in(K||X)&&c.value!==l.value&&mr(s,"value",c.value),l)a(c[r])&&(Ot(r)?s.removeAttributeNS(Dt,Nt(r)):Lt(r)||s.removeAttribute(r))}}function mr(n,e,t,r){r||n.tagName.indexOf("-")>-1?gr(n,e,t):Pt(e)?Ft(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Lt(e)?n.setAttribute(e,function(n,e){return Ft(e)||"false"===e?"false":"contenteditable"===n&&zt(e)?e:"true"}(e,t)):Ot(e)?Ft(t)?n.removeAttributeNS(Dt,Nt(e)):n.setAttributeNS(Dt,e,t):gr(n,e,t)}function gr(n,e,t){if(Ft(t))n.removeAttribute(e);else{if(K&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var hr={create:ur,update:ur};function vr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var s=Ht(e),l=t._transitionClasses;o(l)&&(s=Ut(s,$t(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var fr,br={create:vr,update:vr};function yr(n,e,t){var r=fr;return function i(){var a=e.apply(null,arguments);null!==a&&Sr(n,i,t,r)}}var xr=Kn&&!(nn&&Number(nn[1])<=53);function wr(n,e,t,r){if(xr){var i=ct,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}fr.addEventListener(n,e,tn?{capture:t,passive:r}:t)}function Sr(n,e,t,r){(r||fr).removeEventListener(n,e._wrapper||e,t)}function kr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};fr=e.elm,function(n){if(o(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,r,wr,Sr,yr,e.context),fr=void 0}}var jr,qr={create:kr,update:kr};function Cr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,s=n.data.domProps||{},l=e.data.domProps||{};for(t in o(l.__ob__)&&(l=e.data.domProps=_({},l)),s)t in l||(i[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var c=a(r)?"":String(r);Ir(i,c)&&(i.value=c)}else if("innerHTML"===t&&Jt(i.tagName)&&a(i.innerHTML)){(jr=jr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var p=jr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;p.firstChild;)i.appendChild(p.firstChild)}else if(r!==s[t])try{i[t]=r}catch(n){}}}}function Ir(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Mr={create:Cr,update:Cr},Tr=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function _r(n){var e=Er(n.style);return n.staticStyle?_(n.staticStyle,e):e}function Er(n){return Array.isArray(n)?E(n):"string"==typeof n?Tr(n):n}var Ar,Br=/^--/,Rr=/\s*!important$/,Lr=function(n,e,t){if(Br.test(e))n.style.setProperty(e,t);else if(Rr.test(t))n.style.setProperty(I(e),t.replace(Rr,""),"important");else{var r=Pr(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},zr=["Webkit","Moz","ms"],Pr=S((function(n){if(Ar=Ar||document.createElement("div").style,"filter"!==(n=j(n))&&n in Ar)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<zr.length;t++){var r=zr[t]+e;if(r in Ar)return r}}));function Dr(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,s,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},d=c||p,u=Er(e.data.style)||{};e.data.normalizedStyle=o(u.__ob__)?_({},u):u;var m=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=_r(i.data))&&_(r,t);(t=_r(n.data))&&_(r,t);for(var a=n;a=a.parent;)a.data&&(t=_r(a.data))&&_(r,t);return r}(e,!0);for(s in d)a(m[s])&&Lr(l,s,"");for(s in m)(i=m[s])!==d[s]&&Lr(l,s,null==i?"":i)}}var Or={create:Dr,update:Dr},Nr=/\s+/;function Fr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Hr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Vr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&_(e,Ur(n.name||"v")),_(e,n),e}return"string"==typeof n?Ur(n):void 0}}var Ur=S((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),$r=Q&&!Y,Qr="transition",Wr="transitionend",Jr="animation",Gr="animationend";$r&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Qr="WebkitTransition",Wr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Jr="WebkitAnimation",Gr="webkitAnimationEnd"));var Kr=Q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Yr(n){Kr((function(){Kr(n)}))}function Xr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Fr(n,e))}function Zr(n,e){n._transitionClasses&&y(n._transitionClasses,e),Hr(n,e)}function ni(n,e,t){var r=ti(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var s="transition"===i?Wr:Gr,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),a+1),n.addEventListener(s,p)}var ei=/\b(transform|all)(,|$)/;function ti(n,e){var t,r=window.getComputedStyle(n),i=(r[Qr+"Delay"]||"").split(", "),a=(r[Qr+"Duration"]||"").split(", "),o=ri(i,a),s=(r[Jr+"Delay"]||"").split(", "),l=(r[Jr+"Duration"]||"").split(", "),c=ri(s,l),p=0,d=0;return"transition"===e?o>0&&(t="transition",p=o,d=a.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&ei.test(r[Qr+"Property"])}}function ri(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ii(e)+ii(n[t])})))}function ii(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ai(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Vr(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,l=r.enterClass,p=r.enterToClass,d=r.enterActiveClass,u=r.appearClass,m=r.appearToClass,g=r.appearActiveClass,h=r.beforeEnter,f=r.enter,b=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,w=r.appear,S=r.afterAppear,k=r.appearCancelled,j=r.duration,q=Xe,C=Xe.$vnode;C&&C.parent;)q=C.context,C=C.parent;var I=!q._isMounted||!n.isRootInsert;if(!I||w||""===w){var M=I&&u?u:l,T=I&&g?g:d,_=I&&m?m:p,E=I&&x||h,A=I&&"function"==typeof w?w:f,B=I&&S||b,R=I&&k||y,L=v(c(j)?j.enter:j);0;var z=!1!==i&&!Y,D=li(A),O=t._enterCb=P((function(){z&&(Zr(t,_),Zr(t,T)),O.cancelled?(z&&Zr(t,M),R&&R(t)):B&&B(t),t._enterCb=null}));n.data.show||pe(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),A&&A(t,O)})),E&&E(t),z&&(Xr(t,M),Xr(t,T),Yr((function(){Zr(t,M),O.cancelled||(Xr(t,_),D||(si(L)?setTimeout(O,L):ni(t,s,O)))}))),n.data.show&&(e&&e(),A&&A(t,O)),z||D||O()}}}function oi(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Vr(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,s=r.type,l=r.leaveClass,p=r.leaveToClass,d=r.leaveActiveClass,u=r.beforeLeave,m=r.leave,g=r.afterLeave,h=r.leaveCancelled,f=r.delayLeave,b=r.duration,y=!1!==i&&!Y,x=li(m),w=v(c(b)?b.leave:b);0;var S=t._leaveCb=P((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Zr(t,p),Zr(t,d)),S.cancelled?(y&&Zr(t,l),h&&h(t)):(e(),g&&g(t)),t._leaveCb=null}));f?f(k):k()}function k(){S.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(Xr(t,l),Xr(t,d),Yr((function(){Zr(t,l),S.cancelled||(Xr(t,p),x||(si(w)?setTimeout(S,w):ni(t,s,S)))}))),m&&m(t,S),y||x||S())}}function si(n){return"number"==typeof n&&!isNaN(n)}function li(n){if(a(n))return!1;var e=n.fns;return o(e)?li(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ci(n,e){!0!==e.data.show&&ai(e)}var pi=function(n){var e,t,r={},i=n.modules,c=n.nodeOps;for(e=0;e<tr.length;++e)for(r[tr[e]]=[],t=0;t<i.length;++t)o(i[t][tr[e]])&&r[tr[e]].push(i[t][tr[e]]);function p(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function d(n,e,t,i,a,l,p){if(o(n.elm)&&o(l)&&(n=l[p]=xn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(o(a)){var l=o(n.componentInstance)&&a.keepAlive;if(o(a=a.hook)&&o(a=a.init)&&a(n,!1),o(n.componentInstance))return u(n,e),m(t,n.elm,i),s(l)&&function(n,e,t,i){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(a=s.data)&&o(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](er,s);e.push(s);break}m(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var d=n.data,h=n.children,f=n.tag;o(f)?(n.elm=n.ns?c.createElementNS(n.ns,f):c.createElement(f,n),b(n),g(n,h,e),o(d)&&v(n,e),m(t,n.elm,i)):s(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,i)):(n.elm=c.createTextNode(n.text),m(t,n.elm,i))}}function u(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,h(n)?(v(n,e),b(n)):(nr(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function g(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function h(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var i=0;i<r.create.length;++i)r.create[i](er,n);o(e=n.data.hook)&&(o(e.create)&&e.create(er,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Xe)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,r,i,a){for(;r<=i;++r)d(t[r],a,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(S(r),x(r)):p(r.elm))}}function S(n,e){if(o(e)||o(n.data)){var t,i=r.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&S(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else p(n.elm)}function k(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(o(a)&&rr(n,a))return i}}function j(n,e,t,i,l,p){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=xn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,g=e.data;o(g)&&o(m=g.hook)&&o(m=m.prepatch)&&m(n,e);var v=n.children,f=e.children;if(o(g)&&h(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);o(m=g.hook)&&o(m=m.update)&&m(n,e)}a(e.text)?o(v)&&o(f)?v!==f&&function(n,e,t,r,i){var s,l,p,u=0,m=0,g=e.length-1,h=e[0],v=e[g],f=t.length-1,b=t[0],x=t[f],S=!i;for(0;u<=g&&m<=f;)a(h)?h=e[++u]:a(v)?v=e[--g]:rr(h,b)?(j(h,b,r,t,m),h=e[++u],b=t[++m]):rr(v,x)?(j(v,x,r,t,f),v=e[--g],x=t[--f]):rr(h,x)?(j(h,x,r,t,f),S&&c.insertBefore(n,h.elm,c.nextSibling(v.elm)),h=e[++u],x=t[--f]):rr(v,b)?(j(v,b,r,t,m),S&&c.insertBefore(n,v.elm,h.elm),v=e[--g],b=t[++m]):(a(s)&&(s=ir(e,u,g)),a(l=o(b.key)?s[b.key]:k(b,e,u,g))?d(b,r,n,h.elm,!1,t,m):rr(p=e[l],b)?(j(p,b,r,t,m),e[l]=void 0,S&&c.insertBefore(n,p.elm,h.elm)):d(b,r,n,h.elm,!1,t,m),b=t[++m]);u>g?y(n,a(t[f+1])?null:t[f+1].elm,t,m,f,r):m>f&&w(e,u,g)}(u,v,f,t,p):o(f)?(o(n.text)&&c.setTextContent(u,""),y(u,null,f,0,f.length-1,t)):o(v)?w(v,0,v.length-1):o(n.text)&&c.setTextContent(u,""):n.text!==e.text&&c.setTextContent(u,e.text),o(g)&&o(m=g.hook)&&o(m=m.postpatch)&&m(n,e)}}}function q(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var C=f("attrs,class,staticClass,staticStyle,key");function I(n,e,t,r){var i,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(i=l.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return u(e,t),!0;if(o(a)){if(o(c))if(n.hasChildNodes())if(o(i=l)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,m=0;m<c.length;m++){if(!d||!I(d,c[m],t,r)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else g(e,c,t);if(o(l)){var h=!1;for(var f in l)if(!C(f)){h=!0,v(e,t);break}!h&&l.class&&oe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,p=!1,u=[];if(a(n))p=!0,d(e,u);else{var m=o(n.nodeType);if(!m&&rr(n,e))j(n,e,u,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&I(n,e,u))return q(e,u,!0),n;l=n,n=new vn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var g=n.elm,v=c.parentNode(g);if(d(e,u,g._leaveCb?null:v,c.nextSibling(g)),o(e.parent))for(var f=e.parent,b=h(e);f;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](f);if(f.elm=e.elm,b){for(var S=0;S<r.create.length;++S)r.create[S](er,f);var k=f.data.hook.insert;if(k.merged)for(var C=1;C<k.fns.length;C++)k.fns[C]()}else nr(f);f=f.parent}o(v)?w([n],0,0):o(n.tag)&&x(n)}}return q(e,u,p),e.elm}o(n)&&x(n)}}({nodeOps:Xt,modules:[hr,br,qr,Mr,Or,Q?{create:ci,activate:ci,remove:function(n,e){!0!==n.data.show?oi(n,e):e()}}:{}].concat(dr)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bi(n,"input")}));var di={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?pe(t,"postpatch",(function(){di.componentUpdated(n,e,t)})):ui(n,e,t.context),n._vOptions=[].map.call(n.options,hi)):("textarea"===t.tag||Yt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",vi),n.addEventListener("compositionend",fi),n.addEventListener("change",fi),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){ui(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,hi);if(i.some((function(n,e){return!L(n,r[e])})))(n.multiple?e.value.some((function(n){return gi(n,i)})):e.value!==e.oldValue&&gi(e.value,i))&&bi(n,"change")}}};function ui(n,e,t){mi(n,e,t),(K||X)&&setTimeout((function(){mi(n,e,t)}),0)}function mi(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],i)a=z(r,hi(o))>-1,o.selected!==a&&(o.selected=a);else if(L(hi(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function gi(n,e){return e.every((function(e){return!L(e,n)}))}function hi(n){return"_value"in n?n._value:n.value}function vi(n){n.target.composing=!0}function fi(n){n.target.composing&&(n.target.composing=!1,bi(n.target,"input"))}function bi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function yi(n){return!n.componentInstance||n.data&&n.data.transition?n:yi(n.componentInstance._vnode)}var xi={model:di,show:{bind:function(n,e,t){var r=e.value,i=(t=yi(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,ai(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=yi(t)).data&&t.data.transition?(t.data.show=!0,r?ai(t,(function(){n.style.display=n.__vOriginalDisplay})):oi(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},wi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Si(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Si(We(e.children)):n}function ki(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var a in i)e[j(a)]=i[a];return e}function ji(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var qi=function(n){return n.tag||fe(n)},Ci=function(n){return"show"===n.name},Ii={name:"transition",props:wi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(qi)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=Si(i);if(!a)return i;if(this._leaving)return ji(n,i);var o="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?o+"comment":o+a.tag:l(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var s=(a.data||(a.data={})).transition=ki(this),c=this._vnode,p=Si(c);if(a.data.directives&&a.data.directives.some(Ci)&&(a.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,p)&&!fe(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=_({},s);if("out-in"===r)return this._leaving=!0,pe(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ji(n,i);if("in-out"===r){if(fe(a))return c;var u,m=function(){u()};pe(s,"afterEnter",m),pe(s,"enterCancelled",m),pe(d,"delayLeave",(function(n){u=n}))}}return i}}},Mi=_({tag:String,moveClass:String},wi);function Ti(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function _i(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ei(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+i+"px)",a.transitionDuration="0s"}}delete Mi.mode;var Ai={Transition:Ii,TransitionGroup:{props:Mi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=ki(this),s=0;s<i.length;s++){var l=i[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))a.push(l),t[l.key]=l,(l.data||(l.data={})).transition=o;else;}if(r){for(var c=[],p=[],d=0;d<r.length;d++){var u=r[d];u.data.transition=o,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?c.push(u):p.push(u)}this.kept=n(e,null,c),this.removed=p}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ti),n.forEach(_i),n.forEach(Ei),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Xr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Wr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Wr,n),t._moveCb=null,Zr(t,e))})}})))},methods:{hasMove:function(n,e){if(!$r)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Hr(t,n)})),Fr(t,e),t.style.display="none",this.$el.appendChild(t);var r=ti(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};qt.config.mustUseProp=function(n,e,t){return"value"===t&&Rt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},qt.config.isReservedTag=Gt,qt.config.isReservedAttr=Bt,qt.config.getTagNamespace=function(n){return Jt(n)?"svg":"math"===n?"math":void 0},qt.config.isUnknownElement=function(n){if(!Q)return!0;if(Gt(n))return!1;if(n=n.toLowerCase(),null!=Kt[n])return Kt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Kt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Kt[n]=/HTMLUnknownElement/.test(e.toString())},_(qt.options.directives,xi),_(qt.options.components,Ai),qt.prototype.__patch__=Q?pi:A,qt.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new gt(n,r,A,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&Q?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Q&&setTimeout((function(){N.devtools&&on&&on.emit("init",qt)}),0);var Bi=qt;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Ri(n,e){for(var t in e)n[t]=e[t];return n}var Li=/[!'()*]/g,zi=function(n){return"%"+n.charCodeAt(0).toString(16)},Pi=/%2C/g,Di=function(n){return encodeURIComponent(n).replace(Li,zi).replace(Pi,",")};function Oi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Ni=function(n){return null==n||"object"==typeof n?n:String(n)};function Fi(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Oi(t.shift()),i=t.length>0?Oi(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function Hi(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Di(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Di(e)):r.push(Di(e)+"="+Di(n)))})),r.join("&")}return Di(e)+"="+Di(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Vi=/\/?$/;function Ui(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=$i(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:Ji(e,i),matched:n?Wi(n):[]};return t&&(o.redirectedFrom=Ji(t,i)),Object.freeze(o)}function $i(n){if(Array.isArray(n))return n.map($i);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=$i(n[t]);return e}return n}var Qi=Ui(null,{path:"/"});function Wi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Ji(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||Hi)(r)+i}function Gi(n,e,t){return e===Qi?n===e:!!e&&(n.path&&e.path?n.path.replace(Vi,"")===e.path.replace(Vi,"")&&(t||n.hash===e.hash&&Ki(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Ki(n.query,e.query)&&Ki(n.params,e.params))))}function Ki(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?Ki(a,o):String(a)===String(o)}))}function Yi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var Xi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var o=i.$createElement,s=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),p=0,d=!1;i&&i._routerRoot!==i;){var u=i.$vnode?i.$vnode.data:{};u.routerView&&p++,u.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(a.routerViewDepth=p,d){var m=c[s],g=m&&m.component;return g?(m.configProps&&Zi(g,a,m.route,m.configProps),o(g,a,r)):o()}var h=l.matched[p],v=h&&h.components[s];if(!h||!v)return c[s]=null,o();c[s]={component:v},a.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),Yi(l)};var f=h.props&&h.props[s];return f&&(Ri(c[s],{route:l,configProps:f}),Zi(v,a,l,f)),o(v,a,r)}};function Zi(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=Ri({},i);var a=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function na(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function ea(n){return n.replace(/\/+/g,"/")}var ta=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ra=fa,ia=ca,aa=function(n,e){return da(ca(n,e),e)},oa=da,sa=va,la=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ca(n,e){for(var t,r=[],i=0,a=0,o="",s=e&&e.delimiter||"/";null!=(t=la.exec(n));){var l=t[0],c=t[1],p=t.index;if(o+=n.slice(a,p),a=p+l.length,c)o+=c[1];else{var d=n[a],u=t[2],m=t[3],g=t[4],h=t[5],v=t[6],f=t[7];o&&(r.push(o),o="");var b=null!=u&&null!=d&&d!==u,y="+"===v||"*"===v,x="?"===v||"*"===v,w=t[2]||s,S=g||h;r.push({name:m||i++,prefix:u||"",delimiter:w,optional:x,repeat:y,partial:b,asterisk:!!f,pattern:S?ma(S):f?".*":"[^"+ua(w)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function pa(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function da(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",ha(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?pa:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=a[l.name];if(null==p){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ta(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=o(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function ua(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ma(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ga(n,e){return n.keys=e,n}function ha(n){return n&&n.sensitive?"":"i"}function va(n,e,t){ta(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=ua(s);else{var l=ua(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=ua(t.delimiter||"/"),d=a.slice(-p.length)===p;return r||(a=(d?a.slice(0,-p.length):a)+"(?:"+p+"(?=$))?"),a+=i?"$":r&&d?"":"(?="+p+"|$)",ga(new RegExp("^"+a,ha(t)),e)}function fa(n,e,t){return ta(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ga(n,e)}(n,e):ta(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(fa(n[i],e,t).source);return ga(new RegExp("(?:"+r.join("|")+")",ha(t)),e)}(n,e,t):function(n,e,t){return va(ca(n,t),e,t)}(n,e,t)}ra.parse=ia,ra.compile=aa,ra.tokensToFunction=oa,ra.tokensToRegExp=sa;var ba=Object.create(null);function ya(n,e,t){e=e||{};try{var r=ba[n]||(ba[n]=ra.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function xa(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=Ri({},n)).params;return a&&"object"==typeof a&&(i.params=Ri({},a)),i}if(!i.path&&i.params&&e){(i=Ri({},i))._normalized=!0;var o=Ri(Ri({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=ya(s,o,e.path)}else 0;return i}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",p=l.path?na(l.path,c,t||i.append):c,d=function(n,e,t){void 0===e&&(e={});var r,i=t||Fi;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(Ni):Ni(o)}return r}(l.query,i.query,r&&r.options.parseQuery),u=i.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:p,query:d,hash:u}}var wa,Sa=function(){},ka={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,o=i.route,s=i.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,u=null==p?"router-link-exact-active":p,m=null==this.activeClass?d:this.activeClass,g=null==this.exactActiveClass?u:this.exactActiveClass,h=o.redirectedFrom?Ui(null,xa(o.redirectedFrom),null,t):o;l[g]=Gi(r,h,this.exactPath),l[m]=this.exact||this.exactPath?l[g]:function(n,e){return 0===n.path.replace(Vi,"/").indexOf(e.path.replace(Vi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,h);var v=l[g]?this.ariaCurrentValue:null,f=function(n){ja(n)&&(e.replace?t.replace(a,Sa):t.push(a,Sa))},b={click:ja};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=f})):b[this.event]=f;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:f,isActive:l[m],isExactActive:l[g]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":v};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var S=w.data=Ri({},w.data);for(var k in S.on=S.on||{},S.on){var j=S.on[k];k in b&&(S.on[k]=Array.isArray(j)?j:[j])}for(var q in b)q in S.on?S.on[q].push(b[q]):S.on[q]=f;var C=w.data.attrs=Ri({},w.data.attrs);C.href=s,C["aria-current"]=v}else y.on=b}return n(this.tag,y,this.$slots.default)}};function ja(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var qa="undefined"!=typeof window;function Ca(n,e,t,r,i){var a=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var s=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ea(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var d={path:p,regex:Ia(p,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?ea(o+"/"+i.path):void 0;n(e,t,r,i,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var u=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<u.length;++m){0;var g={path:u[m],children:i.children};n(e,t,r,g,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,o,s,n,i)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:o,nameMap:s}}function Ia(n,e){return ra(n,[],e)}function Ma(n,e){var t=Ca(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var s=xa(n,t,!1,e),c=s.name;if(c){var p=a[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=ya(p.path,s.params),l(p,s,o)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var g=r[m],h=i[g];if(Ta(h.regex,s.path,s.params))return l(h,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,i="function"==typeof r?r(Ui(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var s=i,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){a[c];return o({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var g=function(n,e){return na(n,e.parent?e.parent.path:"/",!0)}(p,n);return o({_normalized:!0,path:ya(g,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:ya(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):Ui(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ca([e||n],r,i,a,t),t&&t.alias.length&&Ca(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Ca(n,r,i,a)}}}function Ta(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?Oi(r[i]):r[i])}return!0}var _a=qa&&window.performance&&window.performance.now?window.performance:Date;function Ea(){return _a.now().toFixed(3)}var Aa=Ea();function Ba(){return Aa}function Ra(n){return Aa=n}var La=Object.create(null);function za(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Ri({},window.history.state);return t.key=Ba(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Oa),function(){window.removeEventListener("popstate",Oa)}}function Pa(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=Ba();if(n)return La[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){Ua(n,a)})).catch((function(n){0})):Ua(o,a))}))}}function Da(){var n=Ba();n&&(La[n]={x:window.pageXOffset,y:window.pageYOffset})}function Oa(n){Da(),n.state&&n.state.key&&Ra(n.state.key)}function Na(n){return Ha(n.x)||Ha(n.y)}function Fa(n){return{x:Ha(n.x)?n.x:window.pageXOffset,y:Ha(n.y)?n.y:window.pageYOffset}}function Ha(n){return"number"==typeof n}var Va=/^#\d/;function Ua(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=Va.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:Ha((t=a).x)?t.x:0,y:Ha(t.y)?t.y:0})}else Na(n)&&(e=Fa(n))}else r&&Na(n)&&(e=Fa(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var $a,Qa=qa&&((-1===($a=window.navigator.userAgent).indexOf("Android 2.")&&-1===$a.indexOf("Android 4.0")||-1===$a.indexOf("Mobile Safari")||-1!==$a.indexOf("Chrome")||-1!==$a.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Wa(n,e){Da();var t=window.history;try{if(e){var r=Ri({},t.state);r.key=Ba(),t.replaceState(r,"",n)}else t.pushState({key:Ra(Ea())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ja(n){Wa(n,!0)}function Ga(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}var Ka={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ya(n,e){return Za(n,e,Ka.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return no.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Xa(n,e){return Za(n,e,Ka.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Za(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var no=["params","query","hash"];function eo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function to(n,e){return eo(n)&&n._isRouter&&(null==e||n.type===e)}function ro(n){return function(e,t,r){var i=!1,a=0,o=null;io(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var l,c=so((function(e){var i;((i=e).__esModule||oo&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:wa.extend(e),t.components[s]=e,--a<=0&&r()})),p=so((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=eo(n)?n:new Error(e),r(o))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),i||r()}}function io(n,e){return ao(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ao(n){return Array.prototype.concat.apply([],n)}var oo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function so(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var lo=function(n,e){this.router=n,this.base=function(n){if(!n)if(qa){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Qi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function co(n,e,t,r){var i=io(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=wa.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return ao(r?i.reverse():i)}function po(n,e){if(e)return function(){return n.apply(e,arguments)}}lo.prototype.listen=function(n){this.cb=n},lo.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},lo.prototype.onError=function(n){this.errorCbs.push(n)},lo.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(to(n,Ka.redirected)&&a===Qi||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},lo.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!to(n)&&eo(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(Gi(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&Pa(this.router,i,n,!1),s(((o=Za(a=i,n,Ka.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,u=p.deactivated,m=p.activated,g=[].concat(function(n){return co(n,"beforeRouteLeave",po,!0)}(u),this.router.beforeHooks,function(n){return co(n,"beforeRouteUpdate",po)}(d),m.map((function(n){return n.beforeEnter})),ro(m)),h=function(e,t){if(r.pending!==n)return s(Xa(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return Za(n,e,Ka.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):eo(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Ya(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Ga(g,h,(function(){Ga(function(n){return co(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),h,(function(){if(r.pending!==n)return s(Xa(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Yi(n)}))}))}))},lo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},lo.prototype.setupListeners=function(){},lo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Qi,this.pending=null};var uo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Qa&&t;r&&this.listeners.push(za());var i=function(){var t=n.current,i=mo(n.base);n.current===Qi&&i===n._startLocation||n.transitionTo(i,(function(n){r&&Pa(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Wa(ea(r.base+n.fullPath)),Pa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ja(ea(r.base+n.fullPath)),Pa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mo(this.base)!==this.current.fullPath){var e=ea(this.base+this.current.fullPath);n?Wa(e):Ja(e)}},e.prototype.getCurrentLocation=function(){return mo(this.base)},e}(lo);function mo(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ea(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var go=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=mo(n);if(!/^\/#/.test(e))return window.location.replace(ea(n+"/#"+e)),!0}(this.base)||ho()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Qa&&e;t&&this.listeners.push(za());var r=function(){var e=n.current;ho()&&n.transitionTo(vo(),(function(r){t&&Pa(n.router,r,e,!0),Qa||yo(r.fullPath)}))},i=Qa?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){bo(n.fullPath),Pa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),Pa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;vo()!==e&&(n?bo(e):yo(e))},e.prototype.getCurrentLocation=function(){return vo()},e}(lo);function ho(){var n=vo();return"/"===n.charAt(0)||(yo("/"+n),!1)}function vo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function fo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function bo(n){Qa?Wa(fo(n)):window.location.hash=n}function yo(n){Qa?Ja(fo(n)):window.location.replace(fo(n))}var xo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){to(n,Ka.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(lo),wo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ma(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Qa&&!1!==n.fallback,this.fallback&&(e="hash"),qa||(e="abstract"),this.mode=e,e){case"history":this.history=new uo(this,n.base);break;case"hash":this.history=new go(this,n.base,this.fallback);break;case"abstract":this.history=new xo(this,n.base);break;default:0}},So={currentRoute:{configurable:!0}};function ko(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}wo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},So.currentRoute.get=function(){return this.history&&this.history.current},wo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof uo||t instanceof go){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;Qa&&i&&"fullPath"in n&&Pa(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},wo.prototype.beforeEach=function(n){return ko(this.beforeHooks,n)},wo.prototype.beforeResolve=function(n){return ko(this.resolveHooks,n)},wo.prototype.afterEach=function(n){return ko(this.afterHooks,n)},wo.prototype.onReady=function(n,e){this.history.onReady(n,e)},wo.prototype.onError=function(n){this.history.onError(n)},wo.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},wo.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},wo.prototype.go=function(n){this.history.go(n)},wo.prototype.back=function(){this.go(-1)},wo.prototype.forward=function(){this.go(1)},wo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},wo.prototype.resolve=function(n,e,t){var r=xa(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ea(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},wo.prototype.getRoutes=function(){return this.matcher.getRoutes()},wo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Qi&&this.history.transitionTo(this.history.getCurrentLocation())},wo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Qi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(wo.prototype,So),wo.install=function n(e){if(!n.installed||wa!==e){n.installed=!0,wa=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Xi),e.component("RouterLink",ka);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},wo.version="3.5.3",wo.isNavigationFailure=to,wo.NavigationFailureType=Ka,wo.START_LOCATION=Qi,qa&&window.Vue&&window.Vue.use(wo);var jo=wo;t(231),t(179),t(264),t(104),t(266),t(36),t(37),t(267);function qo(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(81),t(94),t(125);function Co(n){return(Co="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Io=t(76),Mo=(t(191),t(19),t(44),t(234),t(235),t(40),t(26),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,493))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,492))}}),To={"v-3715a618":function(){return t.e(5).then(t.bind(null,494))},"v-29e10a05":function(){return t.e(6).then(t.bind(null,495))},"v-205aca74":function(){return t.e(7).then(t.bind(null,496))},"v-75b91878":function(){return t.e(8).then(t.bind(null,497))},"v-725e1618":function(){return t.e(10).then(t.bind(null,498))},"v-ed8e3722":function(){return t.e(9).then(t.bind(null,499))},"v-1101483a":function(){return t.e(11).then(t.bind(null,500))},"v-2506c33c":function(){return t.e(12).then(t.bind(null,501))},"v-2631d8fe":function(){return t.e(13).then(t.bind(null,502))},"v-dd4c7ede":function(){return t.e(14).then(t.bind(null,503))},"v-05ff58a7":function(){return t.e(15).then(t.bind(null,504))},"v-65e0a7f2":function(){return t.e(16).then(t.bind(null,505))},"v-2a9abdfa":function(){return t.e(17).then(t.bind(null,506))},"v-8720726a":function(){return t.e(18).then(t.bind(null,507))},"v-4a9ffcac":function(){return t.e(19).then(t.bind(null,508))},"v-1ba1ada2":function(){return t.e(20).then(t.bind(null,509))},"v-286c81e9":function(){return t.e(21).then(t.bind(null,510))},"v-daab1818":function(){return t.e(22).then(t.bind(null,511))},"v-0f37f9f0":function(){return t.e(23).then(t.bind(null,512))},"v-5198e7be":function(){return t.e(24).then(t.bind(null,513))},"v-b0aca0e0":function(){return t.e(25).then(t.bind(null,514))},"v-a6493882":function(){return t.e(26).then(t.bind(null,515))},"v-852ab148":function(){return t.e(28).then(t.bind(null,516))},"v-a0fc14c8":function(){return t.e(27).then(t.bind(null,517))},"v-b70bddee":function(){return t.e(30).then(t.bind(null,518))},"v-62753aac":function(){return t.e(29).then(t.bind(null,519))},"v-1dace089":function(){return t.e(31).then(t.bind(null,520))},"v-53e6eb32":function(){return t.e(32).then(t.bind(null,521))},"v-23d15f89":function(){return t.e(33).then(t.bind(null,522))},"v-3968b695":function(){return t.e(34).then(t.bind(null,523))},"v-70eda528":function(){return t.e(36).then(t.bind(null,524))},"v-5fd81377":function(){return t.e(35).then(t.bind(null,525))},"v-df9543e4":function(){return t.e(39).then(t.bind(null,526))},"v-0b01fcc0":function(){return t.e(38).then(t.bind(null,527))},"v-78cb83ac":function(){return t.e(40).then(t.bind(null,528))},"v-55ea32ac":function(){return t.e(37).then(t.bind(null,529))},"v-3fd3c7b5":function(){return t.e(41).then(t.bind(null,530))},"v-2f47d23e":function(){return t.e(42).then(t.bind(null,531))},"v-4cee0db7":function(){return t.e(43).then(t.bind(null,532))},"v-78a4b30e":function(){return t.e(44).then(t.bind(null,533))},"v-7af8ffe3":function(){return t.e(45).then(t.bind(null,534))},"v-2451e369":function(){return t.e(46).then(t.bind(null,535))},"v-57d76a9a":function(){return t.e(47).then(t.bind(null,536))},"v-c70045c2":function(){return t.e(48).then(t.bind(null,537))}};function _o(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Eo=/-(\w)/g,Ao=_o((function(n){return n.replace(Eo,(function(n,e){return e?e.toUpperCase():""}))})),Bo=/\B([A-Z])/g,Ro=_o((function(n){return n.replace(Bo,"-$1").toLowerCase()})),Lo=_o((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function zo(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Lo(Ao(e))):n(Lo(e))||n(Ro(e))}var Po=Object.assign({},Mo,To),Do=function(n){return Po[n]},Oo=function(n){return To[n]},No=function(n){return Mo[n]},Fo=function(n){return Bi.component(n)};function Ho(n){return zo(Oo,n)}function Vo(n){return zo(No,n)}function Uo(n){return zo(Do,n)}function $o(n){return zo(Fo,n)}function Qo(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if($o(e)||!Uo(e)){n.next=5;break}return n.next=3,Uo(e)();case 3:t=n.sent,Bi.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Wo(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Jo=t(136),Go=(t(124),t(111),t(78),t(222)),Ko=t.n(Go),Yo=t(223),Xo=t.n(Yo),Zo={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Jo.a)(n,1)[0]})).map((function(n){var e=Object(Jo.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Xo()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=es(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Io.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=ts(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Ko()([{name:"description",content:this.$description}],n,this.siteMeta,rs)},updateCanonicalLink:function(){ns(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",es(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){ts(null,this.currentMetaTags),ns()}};function ns(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function es(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function ts(n,e){if(e&&Object(Io.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function rs(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(138);var is=t(152),as={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(is)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+r,o=0;o<t.length;o++){var s=t[o],l=t[o+1],c=0===o&&0===r||r>=s.parentElement.offsetTop+10&&(!l||r<l.parentElement.offsetTop-10),p=decodeURIComponent(this.$route.hash);if(c&&p!==decodeURIComponent(s.hash)){var d=s;if(a===i)for(var u=o+1;u<t.length;u++)if(p===decodeURIComponent(t[u].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},os=(t(107),t(102)),ss=t.n(os),ls={mounted:function(){var n=this;ss.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Bi.component(n.name)||ss.a.start(),t()})),this.$router.afterEach((function(){ss.a.done(),n.isSidebarOpen=!1}))}};t(79),t(55),t(82),t(381);function cs(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(142);function ps(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ds(n,e,t){return e&&ps(n.prototype,e),t&&ps(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(382);var us=function(){function n(){cs(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ds(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,i=n.duration,a=void 0===i?3e3:i,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(o),a>0&&setTimeout((function(){e.close(o)}),a)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),ms={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new us).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(237),t(103),t(137),t(139),t(384);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var gs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},hs={},vs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},fs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:gs[n]},bs=function n(e,t,r){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;i.appendChild(n(t,r,a))})),i},ys=function(n,e,t){var r,i=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},xs=function(n,e){var t,r,i=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=vs(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](i);return a.template=e,a}(s.js,s.html);var l=fs("vue");return s.jsLib.unshift(l),s},ws=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Ss=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function ks(){var n=ys(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=ys(n,"vuepress-plugin-demo-block__code"),t=ys(n,"vuepress-plugin-demo-block__display"),r=ys(n,"vuepress-plugin-demo-block__footer"),i=ys(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),a={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ss(n),htmlTpl:vs("")},o=fs("react"),s=fs("reactDOM");return a.jsLib.unshift(o,s),a}(a,o):"vanilla"===s?ws(a,o):xs(a,o),p=bs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",js.bind(null,p,l,e,r)),fs("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=i.concat(a).concat(fs("cssLib")).concat(fs("jsLib")).join(",");return bs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),fs("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:i.concat(fs("jsLib")).join(";"),css_external:a.concat(fs("cssLib")).join(";"),layout:fs("codepenLayout"),js_pre_processor:fs("codepenJsProcessor"),editors:fs("codepenEditors")});return bs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:fs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!hs[n]){var e=bs("style",{innerHTML:n});document.body.appendChild(e),hs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),i);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();i.appendChild(u.$el)}else"vanilla"===s&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){ks()}),300)}function js(n,e,t,r){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var qs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},ks()},updated:function(){ks()}},Cs=(t(226),"auto"),Is="zoom-in",Ms="zoom-out",Ts="grab",_s="move";function Es(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function As(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Bs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Rs(n,e,t){!function(n){var e=Ls,t=zs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var Ls="transition",zs="transform",Ps="transform",Ds="transitionend";var Os=function(){},Ns={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Os,onClose:Os,onGrab:Os,onMove:Os,onRelease:Os,onBeforeOpen:Os,onBeforeClose:Os,onBeforeGrab:Os,onBeforeRelease:Os,onImageLoading:Os,onImageLoaded:Os},Fs={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Vs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Hs(n)&&!Vs(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Hs(n)&&!Vs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Hs(n){return 0===n.button}function Vs(n){return n.metaKey||n.ctrlKey}var Us={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Rs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Es(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Rs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},$s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Qs=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Ws=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Js={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Bs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ts:Ms,transition:Ps+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Rs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Rs(this.el,{transform:"none"})},grab:function(n,e,t){var r=Gs(),i=r.x-n,a=r.y-e;Rs(this.el,{cursor:_s,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Gs(),i=r.x-n,a=r.y-e;Rs(this.el,{transition:Ps,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Rs(this.el,this.styleClose)},restoreOpenStyle:function(){Rs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Gs(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":$s(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=Gs(),c={x:l.x-o,y:l.y-s},p=c.x/o,d=c.y/s,u=a+Math.min(p,d);if(i&&"string"==typeof i){var m=t||this.el.naturalWidth,g=e||this.el.naturalHeight,h=parseFloat(i)*m/(100*this.rect.width),v=parseFloat(i)*g/(100*this.rect.height);if(u>h||u>v)return{x:h,y:v}}return{x:u,y:u}}};function Gs(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Ks(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Es(n,r,e[r],t)}))}var Ys=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Js),this.overlay=Object.create(Us),this.handler=Object.create(Fs),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Ws({},Ns,e),this.overlay.init(this),this.handler.init(this)}return Qs(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Is,Es(n,"click",this.handler.click),this.options.preloadImage&&As(Bs(n)));return this}},{key:"config",value:function(n){return n?(Ws(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),As(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Es(document,"scroll",this.handler.scroll),Es(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Es(window,"resize",this.handler.resizeWindow);var a=function n(){Es(r,Ds,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Ks(document,e.handler,!0),t(r)};return Es(r,Ds,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Cs,this.overlay.fadeOut(),this.target.zoomOut(),Es(document,"scroll",this.handler.scroll,!1),Es(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Es(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Es(t,Ds,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Ks(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Es(t,Ds,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){Es(i,Ds,n,!1),r(i)};return Es(i,Ds,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=_s,this.target.move(n,e,t);var i=this.target.el,a=function n(){Es(i,Ds,n,!1),r(i)};return Es(i,Ds,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Cs,this.target.restoreOpenStyle();var r=function r(){Es(t,Ds,r,!1),n.lock=!1,n.released=!0,e(t)};return Es(t,Ds,r),this}}}]),n}(),Xs=".theme-vdoing-content img:not(.no-zoom)",Zs=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),nl=Number("500"),el=function(){function n(){cs(this,n),this.instance=new Ys(Zs)}return ds(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xs;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xs,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:nl;setTimeout((function(){return n.update(e)}),t)}}]),n}(),tl=[Zo,as,ls,ms,qs,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new el,this.$vuepress.zooming.updateDelay()}}],rl={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Wo("layout",n),Bi.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},il=t(30),al=Object(il.a)(rl,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(Io.a)(t));break;default:throw new Error("Unknown option name.")}}(al,"mixins",tl);var ol=[{name:"v-3715a618",path:"/computerbasics/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-3715a618").then(t)}},{path:"/computerbasics/index.html",redirect:"/computerbasics/"},{path:"/00.目录页/01.计算机基础.html",redirect:"/computerbasics/"},{name:"v-29e10a05",path:"/tools/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-29e10a05").then(t)}},{path:"/tools/index.html",redirect:"/tools/"},{path:"/00.目录页/02.开发工具.html",redirect:"/tools/"},{name:"v-205aca74",path:"/java/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-205aca74").then(t)}},{path:"/java/index.html",redirect:"/java/"},{path:"/00.目录页/04.Java.html",redirect:"/java/"},{name:"v-75b91878",path:"/javaweb/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-75b91878").then(t)}},{path:"/javaweb/index.html",redirect:"/javaweb/"},{path:"/00.目录页/05.JavaWeb.html",redirect:"/javaweb/"},{name:"v-725e1618",path:"/framework/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-725e1618").then(t)}},{path:"/framework/index.html",redirect:"/framework/"},{path:"/00.目录页/07.框架.html",redirect:"/framework/"},{name:"v-ed8e3722",path:"/database/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-ed8e3722").then(t)}},{path:"/database/index.html",redirect:"/database/"},{path:"/00.目录页/06.数据库.html",redirect:"/database/"},{name:"v-1101483a",path:"/datastructrue/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-1101483a").then(t)}},{path:"/datastructrue/001/index.html",redirect:"/datastructrue/001/"},{path:"/01.计算机基础/01.数据结构/01.红黑树.html",redirect:"/datastructrue/001/"},{name:"v-2506c33c",path:"/computerinternet/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-2506c33c").then(t)}},{path:"/computerinternet/001/index.html",redirect:"/computerinternet/001/"},{path:"/01.计算机基础/02.计算机网络/01.常见状态码.html",redirect:"/computerinternet/001/"},{name:"v-2631d8fe",path:"/operatingsystem/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-2631d8fe").then(t)}},{path:"/operatingsystem/001/index.html",redirect:"/operatingsystem/001/"},{path:"/01.计算机基础/03.操作系统/01.常见问题总结.html",redirect:"/operatingsystem/001/"},{name:"v-dd4c7ede",path:"/markdown/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-dd4c7ede").then(t)}},{path:"/markdown/001/index.html",redirect:"/markdown/001/"},{path:"/02.开发工具/01.Markdown/01.Markdown使用教程.html",redirect:"/markdown/001/"},{name:"v-05ff58a7",path:"/git/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-05ff58a7").then(t)}},{path:"/git/001/index.html",redirect:"/git/001/"},{path:"/02.开发工具/02.Git/01.Git使用手册.html",redirect:"/git/001/"},{name:"v-65e0a7f2",path:"/leetcode/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-65e0a7f2").then(t)}},{path:"/leetcode/001/index.html",redirect:"/leetcode/001/"},{path:"/03.算法/01.LeetCode.html",redirect:"/leetcode/001/"},{name:"v-2a9abdfa",path:"/basis/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-2a9abdfa").then(t)}},{path:"/basis/001/index.html",redirect:"/basis/001/"},{path:"/04.Java/01.基础/01.IO.html",redirect:"/basis/001/"},{name:"v-8720726a",path:"/high/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-8720726a").then(t)}},{path:"/high/001/index.html",redirect:"/high/001/"},{path:"/04.Java/02.高级/01.反射.html",redirect:"/high/001/"},{name:"v-4a9ffcac",path:"/web/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-4a9ffcac").then(t)}},{path:"/web/001/index.html",redirect:"/web/001/"},{path:"/05.JavaWeb/01.基础/01.Web基础概念.html",redirect:"/web/001/"},{name:"v-1ba1ada2",path:"/mysql/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-1ba1ada2").then(t)}},{path:"/mysql/001/index.html",redirect:"/mysql/001/"},{path:"/06.数据库/01.MySQL/01.概述.html",redirect:"/mysql/001/"},{name:"v-286c81e9",path:"/spring/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-286c81e9").then(t)}},{path:"/spring/001/index.html",redirect:"/spring/001/"},{path:"/07.框架/01.Spring/01.概述.html",redirect:"/spring/001/"},{name:"v-daab1818",path:"/springmvc/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-daab1818").then(t)}},{path:"/springmvc/001/index.html",redirect:"/springmvc/001/"},{path:"/07.框架/02.SpringMVC/01.SpringMVC简介.html",redirect:"/springmvc/001/"},{name:"v-0f37f9f0",path:"/springmvc/002/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-0f37f9f0").then(t)}},{path:"/springmvc/002/index.html",redirect:"/springmvc/002/"},{path:"/07.框架/02.SpringMVC/02.HelloWorld.html",redirect:"/springmvc/002/"},{name:"v-5198e7be",path:"/springmvc/003/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-5198e7be").then(t)}},{path:"/springmvc/003/index.html",redirect:"/springmvc/003/"},{path:"/07.框架/02.SpringMVC/03.RequestMapping注解.html",redirect:"/springmvc/003/"},{name:"v-b0aca0e0",path:"/springmvc/004/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-b0aca0e0").then(t)}},{path:"/springmvc/004/index.html",redirect:"/springmvc/004/"},{path:"/07.框架/02.SpringMVC/04.SpringMVC获取请求参数.html",redirect:"/springmvc/004/"},{name:"v-a6493882",path:"/springmvc/005/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-a6493882").then(t)}},{path:"/springmvc/005/index.html",redirect:"/springmvc/005/"},{path:"/07.框架/02.SpringMVC/05.域对象共享数据.html",redirect:"/springmvc/005/"},{name:"v-852ab148",path:"/springmvc/007/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-852ab148").then(t)}},{path:"/springmvc/007/index.html",redirect:"/springmvc/007/"},{path:"/07.框架/02.SpringMVC/07.RESTful.html",redirect:"/springmvc/007/"},{name:"v-a0fc14c8",path:"/springmvc/006/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-a0fc14c8").then(t)}},{path:"/springmvc/006/index.html",redirect:"/springmvc/006/"},{path:"/07.框架/02.SpringMVC/06.SpringMVC的视图.html",redirect:"/springmvc/006/"},{name:"v-b70bddee",path:"/springmvc/009/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-b70bddee").then(t)}},{path:"/springmvc/009/index.html",redirect:"/springmvc/009/"},{path:"/07.框架/02.SpringMVC/09.文件上传和下载.html",redirect:"/springmvc/009/"},{name:"v-62753aac",path:"/springmvc/008/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-62753aac").then(t)}},{path:"/springmvc/008/index.html",redirect:"/springmvc/008/"},{path:"/07.框架/02.SpringMVC/08.RESTful案例.html",redirect:"/springmvc/008/"},{name:"v-1dace089",path:"/springmvc/010/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-1dace089").then(t)}},{path:"/springmvc/010/index.html",redirect:"/springmvc/010/"},{path:"/07.框架/02.SpringMVC/10.拦截器.html",redirect:"/springmvc/010/"},{name:"v-53e6eb32",path:"/springmvc/011/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-53e6eb32").then(t)}},{path:"/springmvc/011/index.html",redirect:"/springmvc/011/"},{path:"/07.框架/02.SpringMVC/11.异常处理器.html",redirect:"/springmvc/011/"},{name:"v-23d15f89",path:"/springmvc/012/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-23d15f89").then(t)}},{path:"/springmvc/012/index.html",redirect:"/springmvc/012/"},{path:"/07.框架/02.SpringMVC/12.注解配置SpringMVC.html",redirect:"/springmvc/012/"},{name:"v-3968b695",path:"/springmvc/013/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-3968b695").then(t)}},{path:"/springmvc/013/index.html",redirect:"/springmvc/013/"},{path:"/07.框架/02.SpringMVC/13.SpringMVC执行流程.html",redirect:"/springmvc/013/"},{name:"v-70eda528",path:"/springboot/002/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-70eda528").then(t)}},{path:"/springboot/002/index.html",redirect:"/springboot/002/"},{path:"/07.框架/03.SpringBoot/02.运维.html",redirect:"/springboot/002/"},{name:"v-5fd81377",path:"/springboot/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-5fd81377").then(t)}},{path:"/springboot/001/index.html",redirect:"/springboot/001/"},{path:"/07.框架/03.SpringBoot/01.快速入门.html",redirect:"/springboot/001/"},{name:"v-df9543e4",path:"/mybatis/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-df9543e4").then(t)}},{path:"/mybatis/001/index.html",redirect:"/mybatis/001/"},{path:"/07.框架/04.MyBatis/01.简介及配置.html",redirect:"/mybatis/001/"},{name:"v-0b01fcc0",path:"/springboot/004/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-0b01fcc0").then(t)}},{path:"/springboot/004/index.html",redirect:"/springboot/004/"},{path:"/07.框架/03.SpringBoot/04.原理.html",redirect:"/springboot/004/"},{name:"v-78cb83ac",path:"/mybatis/002/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-78cb83ac").then(t)}},{path:"/mybatis/002/index.html",redirect:"/mybatis/002/"},{path:"/07.框架/04.MyBatis/02.核心配置文件详解.html",redirect:"/mybatis/002/"},{name:"v-55ea32ac",path:"/springboot/003/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-55ea32ac").then(t)}},{path:"/springboot/003/index.html",redirect:"/springboot/003/"},{path:"/07.框架/03.SpringBoot/03.开发实用篇.html",redirect:"/springboot/003/"},{name:"v-3fd3c7b5",path:"/mybatis/003/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-3fd3c7b5").then(t)}},{path:"/mybatis/003/index.html",redirect:"/mybatis/003/"},{path:"/07.框架/04.MyBatis/03.MyBatis的各种查询功能.html",redirect:"/mybatis/003/"},{name:"v-2f47d23e",path:"/mybatis/004/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-2f47d23e").then(t)}},{path:"/mybatis/004/index.html",redirect:"/mybatis/004/"},{path:"/07.框架/04.MyBatis/04.自定义映射resultMap.html",redirect:"/mybatis/004/"},{name:"v-4cee0db7",path:"/mybatis/005/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-4cee0db7").then(t)}},{path:"/mybatis/005/index.html",redirect:"/mybatis/005/"},{path:"/07.框架/04.MyBatis/05.动态SQL.html",redirect:"/mybatis/005/"},{name:"v-78a4b30e",path:"/mybatis/006/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-78a4b30e").then(t)}},{path:"/mybatis/006/index.html",redirect:"/mybatis/006/"},{path:"/07.框架/04.MyBatis/06.MyBatis的缓存.html",redirect:"/mybatis/006/"},{name:"v-7af8ffe3",path:"/mybatis/007/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-7af8ffe3").then(t)}},{path:"/mybatis/007/index.html",redirect:"/mybatis/007/"},{path:"/07.框架/04.MyBatis/07.MyBatis的逆向工程.html",redirect:"/mybatis/007/"},{name:"v-2451e369",path:"/mybatis/008/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-2451e369").then(t)}},{path:"/mybatis/008/index.html",redirect:"/mybatis/008/"},{path:"/07.框架/04.MyBatis/08.分页插件.html",redirect:"/mybatis/008/"},{name:"v-57d76a9a",path:"/mybatis-plus/001/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-57d76a9a").then(t)}},{path:"/mybatis-plus/001/index.html",redirect:"/mybatis-plus/001/"},{path:"/07.框架/05.MyBatis-Plus/01.简介.html",redirect:"/mybatis-plus/001/"},{name:"v-c70045c2",path:"/",component:al,beforeEnter:function(n,e,t){Qo("Layout","v-c70045c2").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:al}],sl={title:"Coding Ayoung",description:"",base:"/",headTags:[],pages:[{title:"计算机基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.计算机基础",imgUrl:"/img/more.png"}},title:"计算机基础",date:"2020-03-11T21:50:53.000Z",permalink:"/computerbasics/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录页/01.计算机基础.md",key:"v-3715a618",path:"/computerbasics/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"开发工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.开发工具",imgUrl:"/img/more.png"}},title:"开发工具",date:"2020-03-11T21:50:54.000Z",permalink:"/tools/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/02.开发工具.md",key:"v-29e10a05",path:"/tools/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.Java",imgUrl:"/img/more.png"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/java/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.Java.html",relativePath:"00.目录页/04.Java.md",key:"v-205aca74",path:"/java/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"技术",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"05.JavaWeb",imgUrl:"/img/more.png"}},title:"技术",date:"2020-03-11T21:50:55.000Z",permalink:"/javaweb/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.JavaWeb.html",relativePath:"00.目录页/05.JavaWeb.md",key:"v-75b91878",path:"/javaweb/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"框架",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"07.框架",imgUrl:"/img/more.png"}},title:"框架",date:"2020-03-11T21:50:56.000Z",permalink:"/framework/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/07.%E6%A1%86%E6%9E%B6.html",relativePath:"00.目录页/07.框架.md",key:"v-725e1618",path:"/framework/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"06.数据库",imgUrl:"/img/more.png"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/database/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.%E6%95%B0%E6%8D%AE%E5%BA%93.html",relativePath:"00.目录页/06.数据库.md",key:"v-ed8e3722",path:"/database/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"红黑树",frontmatter:{title:"红黑树",date:"2017-06-23T00:00:00.000Z",permalink:"/datastructrue/001/",categories:["计算机基础","数据结构"],tags:["数据结构","计算机基础"],author:null},regularPath:"/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%A2%E9%BB%91%E6%A0%91.html",relativePath:"01.计算机基础/01.数据结构/01.红黑树.md",key:"v-1101483a",path:"/datastructrue/001/",headers:[{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:336}],headersStr:"Reference",content:"# 红黑树\n\n红黑树特点 :\n\n 1. 每个节点非红即黑；\n 2. 根节点总是黑色的；\n 3. 每个叶子节点都是黑色的空节点（NIL节点）；\n 4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；\n 5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\n\n红黑树的应用 ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。\n\n为什么要用红黑树？ 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 漫画：什么是红黑树？（也介绍到了二叉查找树，非常推荐）\n\n相关阅读 ：《红黑树深入剖析及Java实现》（美团点评技术团队）\n\n\n# Reference\n\n * https://javaguide.cn/",normalizedContent:"# 红黑树\n\n红黑树特点 :\n\n 1. 每个节点非红即黑；\n 2. 根节点总是黑色的；\n 3. 每个叶子节点都是黑色的空节点（nil节点）；\n 4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；\n 5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\n\n红黑树的应用 ：treemap、treeset以及jdk1.8的hashmap底层都用到了红黑树。\n\n为什么要用红黑树？ 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 漫画：什么是红黑树？（也介绍到了二叉查找树，非常推荐）\n\n相关阅读 ：《红黑树深入剖析及java实现》（美团点评技术团队）\n\n\n# reference\n\n * https://javaguide.cn/",charsets:{cjk:!0}},{title:"常见状态码",frontmatter:{title:"常见状态码",date:"2017-05-01T00:00:00.000Z",permalink:"/computerinternet/001/",categories:["计算机基础","计算机网络"],tags:["计算机网络","计算机基础"],author:null},regularPath:"/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81.html",relativePath:"01.计算机基础/02.计算机网络/01.常见状态码.md",key:"v-2506c33c",path:"/computerinternet/001/",headers:[{level:3,title:"1xx Informational（信息性状态码）",slug:"_1xx-informational-信息性状态码",normalizedTitle:"1xx informational（信息性状态码）",charIndex:48},{level:3,title:"2xx Success（成功状态码）",slug:"_2xx-success-成功状态码",normalizedTitle:"2xx success（成功状态码）",charIndex:118},{level:3,title:"3xx Redirection（重定向状态码）",slug:"_3xx-redirection-重定向状态码",normalizedTitle:"3xx redirection（重定向状态码）",charIndex:1390},{level:3,title:"4xx Client Error（客户端错误状态码）",slug:"_4xx-client-error-客户端错误状态码",normalizedTitle:"4xx client error（客户端错误状态码）",charIndex:1519},{level:3,title:"5xx Server Error（服务端错误状态码）",slug:"_5xx-server-error-服务端错误状态码",normalizedTitle:"5xx server error（服务端错误状态码）",charIndex:1801},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:1976}],headersStr:"1xx Informational（信息性状态码） 2xx Success（成功状态码） 3xx Redirection（重定向状态码） 4xx Client Error（客户端错误状态码） 5xx Server Error（服务端错误状态码） Reference",content:"HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。\n\n\n\n\n# 1xx Informational（信息性状态码）\n\n相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。\n\n\n# 2xx Success（成功状态码）\n\n * 200 OK ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。\n * 201 Created ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。\n * 202 Accepted ：服务端已经接收到了请求，但是还未处理。\n * 204 No Content ： 服务端已经成功处理了请求，但是没有返回任何内容。\n\n这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。\n\nHTTP RFC 2616对204状态码的描述如下：\n\n> The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant.\n> \n> If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent. This response is primarily intended to allow input for actions to take place without causing a change to the user agent's active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent's active view.\n> \n> The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.\n\n简单来说，204状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。\n\n举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。\n\n\n# 3xx Redirection（重定向状态码）\n\n * 301 Moved Permanently ： 资源被永久重定向了。比如你的网站的网址更换了。\n * 302 Found ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。\n\n\n# 4xx Client Error（客户端错误状态码）\n\n * 400 Bad Request ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。\n * 401 Unauthorized ： 未认证却请求需要认证之后才能访问的资源。\n * 403 Forbidden ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。\n * 404 Not Found ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。\n * 409 Conflict ： 表示请求的资源与服务端当前的存状态在冲突，请求无法被处理。\n\n\n# 5xx Server Error（服务端错误状态码）\n\n * 500 Internal Server Error ： 服务端出问题了（通常是服务端出Bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并为在服务端被正确处理。\n * 502 Bad Gateway ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。\n\n\n# Reference\n\n * https://javaguide.cn/",normalizedContent:"http 状态码用于描述 http 请求的结果，比如2xx 就代表请求被成功处理。\n\n\n\n\n# 1xx informational（信息性状态码）\n\n相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。\n\n\n# 2xx success（成功状态码）\n\n * 200 ok ：请求被成功处理。比如我们发送一个查询用户数据的http 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 http 状态码。\n * 201 created ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 post 请求创建一个新的用户。\n * 202 accepted ：服务端已经接收到了请求，但是还未处理。\n * 204 no content ： 服务端已经成功处理了请求，但是没有返回任何内容。\n\n这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。\n\nhttp rfc 2616对204状态码的描述如下：\n\n> the server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. the response may include new or updated metainformation in the form of entity-headers, which if present should be associated with the requested variant.\n> \n> if the client is a user agent, it should not change its document view from that which caused the request to be sent. this response is primarily intended to allow input for actions to take place without causing a change to the user agent's active document view, although any new or updated metainformation should be applied to the document currently in the user agent's active view.\n> \n> the 204 response must not include a message-body, and thus is always terminated by the first empty line after the header fields.\n\n简单来说，204状态码描述的是我们向服务端发送 http 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。\n\n举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。\n\n\n# 3xx redirection（重定向状态码）\n\n * 301 moved permanently ： 资源被永久重定向了。比如你的网站的网址更换了。\n * 302 found ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。\n\n\n# 4xx client error（客户端错误状态码）\n\n * 400 bad request ： 发送的http请求存在问题。比如请求参数不合法、请求方法错误。\n * 401 unauthorized ： 未认证却请求需要认证之后才能访问的资源。\n * 403 forbidden ：直接拒绝http请求，不处理。一般用来针对非法请求。\n * 404 not found ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。\n * 409 conflict ： 表示请求的资源与服务端当前的存状态在冲突，请求无法被处理。\n\n\n# 5xx server error（服务端错误状态码）\n\n * 500 internal server error ： 服务端出问题了（通常是服务端出bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并为在服务端被正确处理。\n * 502 bad gateway ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。\n\n\n# reference\n\n * https://javaguide.cn/",charsets:{cjk:!0}},{title:"常见问题",frontmatter:{title:"常见问题",date:"2018-01-05T00:00:00.000Z",permalink:"/operatingsystem/001/",categories:["计算机基础","操作系统"],tags:["操作系统","计算机基础"],author:null},regularPath:"/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html",relativePath:"01.计算机基础/03.操作系统/01.常见问题总结.md",key:"v-2631d8fe",path:"/operatingsystem/001/",headers:[{level:2,title:"一 操作系统基础",slug:"一-操作系统基础",normalizedTitle:"一 操作系统基础",charIndex:2},{level:3,title:"1.1 什么是操作系统？",slug:"_1-1-什么是操作系统",normalizedTitle:"1.1 什么是操作系统？",charIndex:65},{level:3,title:"1.2 系统调用",slug:"_1-2-系统调用",normalizedTitle:"1.2 系统调用",charIndex:434},{level:2,title:"二 进程和线程",slug:"二-进程和线程",normalizedTitle:"二 进程和线程",charIndex:996},{level:3,title:"2.1 进程和线程的区别",slug:"_2-1-进程和线程的区别",normalizedTitle:"2.1 进程和线程的区别",charIndex:1008},{level:3,title:"2.2 进程有哪几种状态?",slug:"_2-2-进程有哪几种状态",normalizedTitle:"2.2 进程有哪几种状态?",charIndex:1326},{level:3,title:"2.3 进程间的通信方式",slug:"_2-3-进程间的通信方式",normalizedTitle:"2.3 进程间的通信方式",charIndex:1759},{level:3,title:"2.4 线程间的同步的方式",slug:"_2-4-线程间的同步的方式",normalizedTitle:"2.4 线程间的同步的方式",charIndex:2757},{level:3,title:"2.5 进程的调度算法",slug:"_2-5-进程的调度算法",normalizedTitle:"2.5 进程的调度算法",charIndex:3126},{level:3,title:"2.6 什么是死锁",slug:"_2-6-什么是死锁",normalizedTitle:"2.6 什么是死锁",charIndex:3790},{level:3,title:"2.7 死锁的四个条件",slug:"_2-7-死锁的四个条件",normalizedTitle:"2.7 死锁的四个条件",charIndex:3909},{level:3,title:"2.8 解决死锁的方法",slug:"_2-8-解决死锁的方法",normalizedTitle:"2.8 解决死锁的方法",charIndex:4267},{level:4,title:"死锁的预防",slug:"死锁的预防",normalizedTitle:"死锁的预防",charIndex:4517},{level:4,title:"死锁的避免",slug:"死锁的避免",normalizedTitle:"死锁的避免",charIndex:5276},{level:4,title:"死锁的检测",slug:"死锁的检测",normalizedTitle:"死锁的检测",charIndex:5954},{level:4,title:"死锁检测步骤",slug:"死锁检测步骤",normalizedTitle:"死锁检测步骤",charIndex:6235},{level:4,title:"死锁的解除",slug:"死锁的解除",normalizedTitle:"死锁的解除",charIndex:6535},{level:2,title:"三 操作系统内存管理基础",slug:"三-操作系统内存管理基础",normalizedTitle:"三 操作系统内存管理基础",charIndex:6848},{level:3,title:"3.1 内存管理介绍",slug:"_3-1-内存管理介绍",normalizedTitle:"3.1 内存管理介绍",charIndex:6865},{level:3,title:"3.2 常见的几种内存管理机制",slug:"_3-2-常见的几种内存管理机制",normalizedTitle:"3.2 常见的几种内存管理机制",charIndex:7010},{level:3,title:"3.3 快表和多级页表",slug:"_3-3-快表和多级页表",normalizedTitle:"3.3 快表和多级页表",charIndex:7787},{level:4,title:"快表",slug:"快表",normalizedTitle:"快表",charIndex:7791},{level:4,title:"多级页表",slug:"多级页表",normalizedTitle:"多级页表",charIndex:7794},{level:4,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1199},{level:3,title:"3.4 分页机制和分段机制的共同点和区别",slug:"_3-4-分页机制和分段机制的共同点和区别",normalizedTitle:"3.4 分页机制和分段机制的共同点和区别",charIndex:8736},{level:3,title:"3.5 逻辑(虚拟)地址和物理地址",slug:"_3-5-逻辑-虚拟-地址和物理地址",normalizedTitle:"3.5 逻辑(虚拟)地址和物理地址",charIndex:9022},{level:3,title:"3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?",slug:"_3-6-cpu-寻址了解吗-为什么需要虚拟地址空间",normalizedTitle:"3.6 cpu 寻址了解吗?为什么需要虚拟地址空间?",charIndex:9246},{level:2,title:"四 虚拟内存",slug:"四-虚拟内存",normalizedTitle:"四 虚拟内存",charIndex:10235},{level:3,title:"4.1 什么是虚拟内存(Virtual Memory)?",slug:"_4-1-什么是虚拟内存-virtual-memory",normalizedTitle:"4.1 什么是虚拟内存(virtual memory)?",charIndex:10246},{level:3,title:"4.2 局部性原理",slug:"_4-2-局部性原理",normalizedTitle:"4.2 局部性原理",charIndex:10964},{level:3,title:"4.3 虚拟存储器",slug:"_4-3-虚拟存储器",normalizedTitle:"4.3 虚拟存储器",charIndex:11604},{level:3,title:"4.4 虚拟内存的技术实现",slug:"_4-4-虚拟内存的技术实现",normalizedTitle:"4.4 虚拟内存的技术实现",charIndex:12065},{level:3,title:"4.5 页面置换算法",slug:"_4-5-页面置换算法",normalizedTitle:"4.5 页面置换算法",charIndex:12950},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:13763}],headersStr:"一 操作系统基础 1.1 什么是操作系统？ 1.2 系统调用 二 进程和线程 2.1 进程和线程的区别 2.2 进程有哪几种状态? 2.3 进程间的通信方式 2.4 线程间的同步的方式 2.5 进程的调度算法 2.6 什么是死锁 2.7 死锁的四个条件 2.8 解决死锁的方法 死锁的预防 死锁的避免 死锁的检测 死锁检测步骤 死锁的解除 三 操作系统内存管理基础 3.1 内存管理介绍 3.2 常见的几种内存管理机制 3.3 快表和多级页表 快表 多级页表 总结 3.4 分页机制和分段机制的共同点和区别 3.5 逻辑(虚拟)地址和物理地址 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间? 四 虚拟内存 4.1 什么是虚拟内存(Virtual Memory)? 4.2 局部性原理 4.3 虚拟存储器 4.4 虚拟内存的技术实现 4.5 页面置换算法 Reference",content:"# 一 操作系统基础\n\n面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 Thinkpad ，一手提着他那淡黄的长裙。\n\n\n# 1.1 什么是操作系统？\n\n👨‍💻面试官 ： 先来个简单问题吧！什么是操作系统？\n\n🙋 我 ：我通过以下四点向您介绍一下什么是操作系统吧！\n\n 1. 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。\n 2. 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。\n 3. 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。\n 4. 操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\n\n\n\n\n# 1.2 系统调用\n\n👨‍💻面试官 ：什么是系统调用呢？ 能不能详细介绍一下。\n\n🙋 我 ：介绍系统调用之前，我们先来了解一下用户态和系统态。\n\n根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：\n\n 1. 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。\n 2. 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。\n\n说了用户态和系统态之后，那么什么是系统调用呢？\n\n我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！\n\n也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n\n这些系统调用按功能大致可分为如下几类：\n\n * 设备管理。完成设备的请求或释放，以及设备启动等功能。\n * 文件管理。完成文件的读、写、创建及删除等功能。\n * 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。\n * 进程通信。完成进程之间的消息传递或信号传递等功能。\n * 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。\n\n\n# 二 进程和线程\n\n\n# 2.1 进程和线程的区别\n\n👨‍💻面试官: 好的！我明白了！那你再说一下： 进程和线程的区别。\n\n🙋 我： 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！\n\n\n\n从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。\n\n总结： 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。\n\n\n# 2.2 进程有哪几种状态?\n\n👨‍💻面试官 ： 那你再说说进程有哪几种状态?\n\n🙋 我 ：我们一般把进程大致分为 5 种状态，这一点和线程很像！\n\n * 创建状态(new) ：进程正在被创建，尚未到就绪状态。\n * 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。\n * 运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。\n * 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。\n * 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n\n> 订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。\n\n\n\n\n# 2.3 进程间的通信方式\n\n👨‍💻面试官 ：进程间的通信常见的的有哪几种方式呢?\n\n🙋 我 ：大概有 7 种常见的进程间的通信方式。\n\n> 下面这部分总结参考了:《进程间通信 IPC (InterProcess Communication)》 这篇文章，推荐阅读，总结的非常不错。\n\n 1. 管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\n 2. 有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\n 3. 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n 4. 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。\n 5. 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\n 6. 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n 7. 套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n\n# 2.4 线程间的同步的方式\n\n👨‍💻面试官 ：那线程间的同步的方式有哪些呢?\n\n🙋 我 ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：\n\n 1. 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。\n 2. 信号量(Semaphore) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\n 3. 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\n\n\n# 2.5 进程的调度算法\n\n👨‍💻面试官 ：你知道操作系统中进程的调度算法有哪些吗?\n\n🙋 我 ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！\n\n为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：\n\n * 先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n * 短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n * 时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n * 多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。\n * 优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n\n\n# 2.6 什么是死锁\n\n👨‍💻面试官 ：你知道什么是死锁吗?\n\n🙋 我 ：死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。\n\n\n# 2.7 死锁的四个条件\n\n👨‍💻面试官 ：产生死锁的四个必要条件是什么?\n\n🙋 我 ：如果系统中以下四个条件同时成立，那么就能引起死锁：\n\n * 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。\n * 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。\n * 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\n * 循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，......，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。\n\n注意，只有四个条件同时成立时，死锁才会出现。\n\n\n# 2.8 解决死锁的方法\n\n解决死锁的方法可以从多个角度去分析，一般的情况下，有预防，避免，检测和解除四种。\n\n * 预防 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。\n\n * 避免则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生\n\n * 检测是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。\n\n * 解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来。\n\n# 死锁的预防\n\n死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。\n\n破坏第一个条件 互斥条件：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 往往是不能同时访问的 ，所以这种做法在大多数的场合是行不通的。\n\n破坏第三个条件 非抢占 ：也就是说可以采用 剥夺式调度算法，但剥夺式调度方法目前一般仅适用于 主存资源 和 处理器资源 的分配，并不适用于所以的资源，会导致 资源利用率下降。\n\n所以一般比较实用的 预防死锁的方法，是通过考虑破坏第二个条件和第四个条件。\n\n1、静态分配策略\n\n静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。\n\n静态分配策略逻辑简单，实现也很容易，但这种策略 严重地降低了资源利用率，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 几乎不用的资源而使其他需要该资源的进程产生等待 的情况。\n\n2、层次分配策略\n\n层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。\n\n# 死锁的避免\n\n上面提到的 破坏 死锁产生的四个必要条件之一就可以成功 预防系统发生死锁 ，但是会导致 低效的进程运行 和 资源使用率 。而死锁的避免相反，它的角度是允许系统中同时存在四个必要条件 ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 明智和合理的选择 ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。\n\n我们将系统的状态分为 安全状态 和 不安全状态 ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。\n\n> 如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。\n\n那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 避免死锁算法 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，银行家算法 通过先 试探 分配给该进程资源，然后通过 安全性算法 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 真的分配资源给该进程。\n\n银行家算法详情可见：《一句话+一张图说清楚——银行家算法》 。\n\n操作系统教程树中讲述的银行家算法也比较清晰，可以一看.\n\n死锁的避免(银行家算法)改善解决了 资源使用率低的问题 ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 安全性检查 ，需要花费较多的时间。\n\n# 死锁的检测\n\n对资源的分配加以限制可以 预防和避免 死锁的发生，但是都不利于各进程对系统资源的充分共享。解决死锁问题的另一条途径是 死锁检测和解除 (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 乐观锁 ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 死锁的预防和避免 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。\n\n这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 定时地运行一个 “死锁检测” 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\n\n# 死锁检测步骤\n\n知道了死锁检测的原理，我们可以利用下列步骤编写一个 死锁检测 程序，检测系统是否产生了死锁。\n\n 1. 如果进程-资源分配图中无环路，则此时系统没有发生死锁\n 2. 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。\n 3. 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 拓扑排序)\n\n# 死锁的解除\n\n当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：\n\n 1. 立即结束所有进程的执行，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。\n 2. 撤销涉及死锁的所有进程，解除死锁后继续运行 ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。\n 3. 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。\n 4. 抢占资源 ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。\n\n\n# 三 操作系统内存管理基础\n\n\n# 3.1 内存管理介绍\n\n👨‍💻 面试官: 操作系统的内存管理主要是做什么？\n\n🙋 我： 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n\n\n# 3.2 常见的几种内存管理机制\n\n👨‍💻 面试官: 操作系统的内存管理机制了解吗？内存管理有哪几种方式?\n\n🙋 我： 这个在学习操作系统的时候有了解过。\n\n简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。\n\n 1. 块式管理 ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。\n 2. 页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。\n 3. 段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。\n\n简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。\n\n👨‍💻面试官 ： 回答的还不错！不过漏掉了一个很重要的 段页式管理机制 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。\n\n🙋 我 ：谢谢面试官！刚刚把这个给忘记了～\n\n\n# 3.3 快表和多级页表\n\n👨‍💻面试官 ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！\n\n🙋 我 ：在分页内存管理中，很重要的两点是：\n\n 1. 虚拟地址到物理地址的转换要快。\n 2. 解决虚拟地址空间大，页表也会很大的问题。\n\n# 快表\n\n为了提高虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。\n\n使用快表之后的地址转换流程是这样的：\n\n 1. 根据虚拟地址中的页号查快表；\n 2. 如果该页在快表中，直接从快表中读取相应的物理地址；\n 3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；\n 4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。\n\n# 多级页表\n\n引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章\n\n * 多级页表如何节约内存：https://www.polarxiong.com/archives/多级页表如何节约内存.html\n\n# 总结\n\n为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。\n\n\n# 3.4 分页机制和分段机制的共同点和区别\n\n👨‍💻面试官 ： 分页机制和分段机制有哪些共同点和区别呢？\n\n🙋 我 ：\n\n 1. 共同点 ：\n    * 分页机制和分段机制都是为了提高内存利用率，减少内存碎片。\n    * 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。\n 2. 区别 ：\n    * 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。\n    * 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。\n\n\n# 3.5 逻辑(虚拟)地址和物理地址\n\n👨‍💻面试官 ：你刚刚还提到了逻辑地址和物理地址这两个概念，我不太清楚，你能为我解释一下不？\n\n🙋 我： em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。\n\n\n# 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?\n\n👨‍💻面试官 ：CPU 寻址了解吗?为什么需要虚拟地址空间?\n\n🙋 我 ：这部分我真不清楚！\n\n于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。\n\n> 这部分内容参考了 Microsoft 官网的介绍，地址：https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN\n\n现代处理器使用的是一种称为 虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。如下图所示：\n\n\n\n为什么要有虚拟地址空间呢？\n\n先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存 。但是这样有什么问题呢？\n\n 1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。\n 2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。\n\n总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。\n\n通过虚拟地址访问内存有以下优势：\n\n * 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n * 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。\n * 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n\n\n# 四 虚拟内存\n\n\n# 4.1 什么是虚拟内存(Virtual Memory)?\n\n👨‍💻面试官 ：再问你一个常识性的问题！什么是虚拟内存(Virtual Memory)?\n\n🙋 我 ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？ 正是因为 虚拟内存 的存在，通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。\n\n虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。推荐阅读：《虚拟内存的那点事儿》\n\n维基百科中有几句话是这样介绍虚拟内存的。\n\n> 虚拟内存 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:https://zh.wikipedia.org/wiki/虚拟内存\n\n\n# 4.2 局部性原理\n\n👨‍💻面试官 ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的局部性原理。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。\n\n🙋 我 ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。\n\n> 以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。\n\n早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。\n\n局部性原理表现在以下两个方面：\n\n 1. 时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。\n 2. 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。\n\n时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。\n\n\n# 4.3 虚拟存储器\n\n> 勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。\n\n👨‍💻面试官 ：都说了虚拟内存了。你再讲讲虚拟存储器把！\n\n🙋 我 ：\n\n> 这部分内容来自：王道考研操作系统知识点整理。\n\n基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——虚拟存储器。\n\n实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。\n\n\n# 4.4 虚拟内存的技术实现\n\n👨‍💻面试官 ：虚拟内存技术的实现呢？\n\n🙋 我 ：虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：\n\n 1. 请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。\n 2. 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n 3. 请求段页式存储管理\n\n这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？\n\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。\n\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n\n不管是上面那种实现方式，我们一般都需要：\n\n 1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；\n 2. 缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；\n 3. 虚拟地址空间 ：逻辑地址到物理地址的变换。\n\n\n# 4.5 页面置换算法\n\n👨‍💻面试官 ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 页面置换算法的作用?常见的页面置换算法有哪些?\n\n🙋 我 ：\n\n> 这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。\n\n地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。\n\n> 缺页中断 就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。\n\n当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。\n\n * OPT 页面置换算法（最佳页面置换算法） ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。\n * FIFO（First In First Out） 页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。\n * LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法） ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。\n * LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。\n\n\n# Reference\n\n * https://javaguide.cn/",normalizedContent:"# 一 操作系统基础\n\n面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 thinkpad ，一手提着他那淡黄的长裙。\n\n\n# 1.1 什么是操作系统？\n\n👨‍💻面试官 ： 先来个简单问题吧！什么是操作系统？\n\n🙋 我 ：我通过以下四点向您介绍一下什么是操作系统吧！\n\n 1. 操作系统（operating system，简称 os）是管理计算机硬件与软件资源的程序，是计算机的基石。\n 2. 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。\n 3. 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。\n 4. 操作系统的内核（kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\n\n\n\n\n# 1.2 系统调用\n\n👨‍💻面试官 ：什么是系统调用呢？ 能不能详细介绍一下。\n\n🙋 我 ：介绍系统调用之前，我们先来了解一下用户态和系统态。\n\n根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：\n\n 1. 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。\n 2. 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。\n\n说了用户态和系统态之后，那么什么是系统调用呢？\n\n我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！\n\n也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n\n这些系统调用按功能大致可分为如下几类：\n\n * 设备管理。完成设备的请求或释放，以及设备启动等功能。\n * 文件管理。完成文件的读、写、创建及删除等功能。\n * 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。\n * 进程通信。完成进程之间的消息传递或信号传递等功能。\n * 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。\n\n\n# 二 进程和线程\n\n\n# 2.1 进程和线程的区别\n\n👨‍💻面试官: 好的！我明白了！那你再说一下： 进程和线程的区别。\n\n🙋 我： 好的！ 下图是 java 内存区域，我们从 jvm 的角度来说一下线程和进程之间的关系吧！\n\n\n\n从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (jdk1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。\n\n总结： 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。\n\n\n# 2.2 进程有哪几种状态?\n\n👨‍💻面试官 ： 那你再说说进程有哪几种状态?\n\n🙋 我 ：我们一般把进程大致分为 5 种状态，这一点和线程很像！\n\n * 创建状态(new) ：进程正在被创建，尚未到就绪状态。\n * 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。\n * 运行状态(running) ：进程正在处理器上上运行(单核 cpu 下任意时刻只有一个进程处于运行状态)。\n * 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 io 操作完成。即使处理器空闲，该进程也不能运行。\n * 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n\n> 订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。\n\n\n\n\n# 2.3 进程间的通信方式\n\n👨‍💻面试官 ：进程间的通信常见的的有哪几种方式呢?\n\n🙋 我 ：大概有 7 种常见的进程间的通信方式。\n\n> 下面这部分总结参考了:《进程间通信 ipc (interprocess communication)》 这篇文章，推荐阅读，总结的非常不错。\n\n 1. 管道/匿名管道(pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\n 2. 有名管道(names pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\n 3. 信号(signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n 4. 消息队列(message queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 fifo 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。\n 5. 信号量(semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\n 6. 共享内存(shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n 7. 套接字(sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 tcp/ip 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n\n# 2.4 线程间的同步的方式\n\n👨‍💻面试官 ：那线程间的同步的方式有哪些呢?\n\n🙋 我 ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：\n\n 1. 互斥量(mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 java 中的 synchronized 关键词和各种 lock 都是这种机制。\n 2. 信号量(semaphore) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\n 3. 事件(event) :wait/notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\n\n\n# 2.5 进程的调度算法\n\n👨‍💻面试官 ：你知道操作系统中进程的调度算法有哪些吗?\n\n🙋 我 ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！\n\n为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 cpu 利用率，计算机科学家已经定义了一些算法，它们是：\n\n * 先到先服务(fcfs)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 cpu 时再重新调度。\n * 短作业优先(sjf)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 cpu 时再重新调度。\n * 时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 rr(round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n * 多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，unix 操作系统采取的便是这种调度算法。\n * 优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 fcfs 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n\n\n# 2.6 什么是死锁\n\n👨‍💻面试官 ：你知道什么是死锁吗?\n\n🙋 我 ：死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。\n\n\n# 2.7 死锁的四个条件\n\n👨‍💻面试官 ：产生死锁的四个必要条件是什么?\n\n🙋 我 ：如果系统中以下四个条件同时成立，那么就能引起死锁：\n\n * 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。\n * 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。\n * 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\n * 循环等待：有一组等待进程 {p0, p1,..., pn}， p0 等待的资源被 p1 占有，p1 等待的资源被 p2 占有，......，pn-1 等待的资源被 pn 占有，pn 等待的资源被 p0 占有。\n\n注意，只有四个条件同时成立时，死锁才会出现。\n\n\n# 2.8 解决死锁的方法\n\n解决死锁的方法可以从多个角度去分析，一般的情况下，有预防，避免，检测和解除四种。\n\n * 预防 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。\n\n * 避免则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生\n\n * 检测是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。\n\n * 解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来。\n\n# 死锁的预防\n\n死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。\n\n破坏第一个条件 互斥条件：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 往往是不能同时访问的 ，所以这种做法在大多数的场合是行不通的。\n\n破坏第三个条件 非抢占 ：也就是说可以采用 剥夺式调度算法，但剥夺式调度方法目前一般仅适用于 主存资源 和 处理器资源 的分配，并不适用于所以的资源，会导致 资源利用率下降。\n\n所以一般比较实用的 预防死锁的方法，是通过考虑破坏第二个条件和第四个条件。\n\n1、静态分配策略\n\n静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。\n\n静态分配策略逻辑简单，实现也很容易，但这种策略 严重地降低了资源利用率，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 几乎不用的资源而使其他需要该资源的进程产生等待 的情况。\n\n2、层次分配策略\n\n层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。\n\n# 死锁的避免\n\n上面提到的 破坏 死锁产生的四个必要条件之一就可以成功 预防系统发生死锁 ，但是会导致 低效的进程运行 和 资源使用率 。而死锁的避免相反，它的角度是允许系统中同时存在四个必要条件 ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 明智和合理的选择 ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。\n\n我们将系统的状态分为 安全状态 和 不安全状态 ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。\n\n> 如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。\n\n那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 避免死锁算法 就是 dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，银行家算法 通过先 试探 分配给该进程资源，然后通过 安全性算法 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 真的分配资源给该进程。\n\n银行家算法详情可见：《一句话+一张图说清楚——银行家算法》 。\n\n操作系统教程树中讲述的银行家算法也比较清晰，可以一看.\n\n死锁的避免(银行家算法)改善解决了 资源使用率低的问题 ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 安全性检查 ，需要花费较多的时间。\n\n# 死锁的检测\n\n对资源的分配加以限制可以 预防和避免 死锁的发生，但是都不利于各进程对系统资源的充分共享。解决死锁问题的另一条途径是 死锁检测和解除 (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 乐观锁 ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 死锁的预防和避免 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。\n\n这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 定时地运行一个 “死锁检测” 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\n\n# 死锁检测步骤\n\n知道了死锁检测的原理，我们可以利用下列步骤编写一个 死锁检测 程序，检测系统是否产生了死锁。\n\n 1. 如果进程-资源分配图中无环路，则此时系统没有发生死锁\n 2. 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。\n 3. 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 拓扑排序)\n\n# 死锁的解除\n\n当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：\n\n 1. 立即结束所有进程的执行，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。\n 2. 撤销涉及死锁的所有进程，解除死锁后继续运行 ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。\n 3. 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。\n 4. 抢占资源 ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。\n\n\n# 三 操作系统内存管理基础\n\n\n# 3.1 内存管理介绍\n\n👨‍💻 面试官: 操作系统的内存管理主要是做什么？\n\n🙋 我： 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n\n\n# 3.2 常见的几种内存管理机制\n\n👨‍💻 面试官: 操作系统的内存管理机制了解吗？内存管理有哪几种方式?\n\n🙋 我： 这个在学习操作系统的时候有了解过。\n\n简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。\n\n 1. 块式管理 ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。\n 2. 页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。\n 3. 段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 main、子程序段 x、数据段 d 及栈段 s 等。 段式管理通过段表对应逻辑地址和物理地址。\n\n简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。\n\n👨‍💻面试官 ： 回答的还不错！不过漏掉了一个很重要的 段页式管理机制 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。\n\n🙋 我 ：谢谢面试官！刚刚把这个给忘记了～\n\n\n# 3.3 快表和多级页表\n\n👨‍💻面试官 ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！\n\n🙋 我 ：在分页内存管理中，很重要的两点是：\n\n 1. 虚拟地址到物理地址的转换要快。\n 2. 解决虚拟地址空间大，页表也会很大的问题。\n\n# 快表\n\n为了提高虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（cache），其中的内容是页表的一部分或者全部内容。作为页表的 cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 cpu 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。\n\n使用快表之后的地址转换流程是这样的：\n\n 1. 根据虚拟地址中的页号查快表；\n 2. 如果该页在快表中，直接从快表中读取相应的物理地址；\n 3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；\n 4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。\n\n# 多级页表\n\n引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章\n\n * 多级页表如何节约内存：https://www.polarxiong.com/archives/多级页表如何节约内存.html\n\n# 总结\n\n为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 tlb）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。\n\n\n# 3.4 分页机制和分段机制的共同点和区别\n\n👨‍💻面试官 ： 分页机制和分段机制有哪些共同点和区别呢？\n\n🙋 我 ：\n\n 1. 共同点 ：\n    * 分页机制和分段机制都是为了提高内存利用率，减少内存碎片。\n    * 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。\n 2. 区别 ：\n    * 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。\n    * 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。\n\n\n# 3.5 逻辑(虚拟)地址和物理地址\n\n👨‍💻面试官 ：你刚刚还提到了逻辑地址和物理地址这两个概念，我不太清楚，你能为我解释一下不？\n\n🙋 我： em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 c 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。\n\n\n# 3.6 cpu 寻址了解吗?为什么需要虚拟地址空间?\n\n👨‍💻面试官 ：cpu 寻址了解吗?为什么需要虚拟地址空间?\n\n🙋 我 ：这部分我真不清楚！\n\n于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。\n\n> 这部分内容参考了 microsoft 官网的介绍，地址：https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=msdn\n\n现代处理器使用的是一种称为 虚拟寻址(virtual addressing) 的寻址方式。使用虚拟寻址，cpu 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 cpu 中含有一个被称为 内存管理单元（memory management unit, mmu） 的硬件。如下图所示：\n\n\n\n为什么要有虚拟地址空间呢？\n\n先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存 。但是这样有什么问题呢？\n\n 1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。\n 2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 qq 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，qq 音乐也同样给内存地址 1xxx 赋值，那么 qq 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。\n\n总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。\n\n通过虚拟地址访问内存有以下优势：\n\n * 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n * 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 kb）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。\n * 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n\n\n# 四 虚拟内存\n\n\n# 4.1 什么是虚拟内存(virtual memory)?\n\n👨‍💻面试官 ：再问你一个常识性的问题！什么是虚拟内存(virtual memory)?\n\n🙋 我 ：这个在我们平时使用电脑特别是 windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？ 正是因为 虚拟内存 的存在，通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。\n\n虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。推荐阅读：《虚拟内存的那点事儿》\n\n维基百科中有几句话是这样介绍虚拟内存的。\n\n> 虚拟内存 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 ram）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 windows 家族的“虚拟内存”；linux 的“交换空间”等。from:https://zh.wikipedia.org/wiki/虚拟内存\n\n\n# 4.2 局部性原理\n\n👨‍💻面试官 ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的局部性原理。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。\n\n🙋 我 ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。\n\n> 以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。\n\n早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。\n\n局部性原理表现在以下两个方面：\n\n 1. 时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。\n 2. 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。\n\n时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。\n\n\n# 4.3 虚拟存储器\n\n> 勘误：虚拟存储器又叫做虚拟内存，都是 virtual memory 的翻译，属于同一个概念。\n\n👨‍💻面试官 ：都说了虚拟内存了。你再讲讲虚拟存储器把！\n\n🙋 我 ：\n\n> 这部分内容来自：王道考研操作系统知识点整理。\n\n基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——虚拟存储器。\n\n实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 cpu 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。\n\n\n# 4.4 虚拟内存的技术实现\n\n👨‍💻面试官 ：虚拟内存技术的实现呢？\n\n🙋 我 ：虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：\n\n 1. 请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。\n 2. 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n 3. 请求段页式存储管理\n\n这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？\n\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。\n\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n\n不管是上面那种实现方式，我们一般都需要：\n\n 1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；\n 2. 缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；\n 3. 虚拟地址空间 ：逻辑地址到物理地址的变换。\n\n\n# 4.5 页面置换算法\n\n👨‍💻面试官 ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 页面置换算法的作用?常见的页面置换算法有哪些?\n\n🙋 我 ：\n\n> 这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。\n\n地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。\n\n> 缺页中断 就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。\n\n当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。\n\n * opt 页面置换算法（最佳页面置换算法） ：最佳(optimal, opt)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。\n * fifo（first in first out） 页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。\n * lru （least recently used）页面置换算法（最近最久未使用页面置换算法） ：lru 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最久未使用的页面予以淘汰。\n * lfu （least frequently used）页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。\n\n\n# reference\n\n * https://javaguide.cn/",charsets:{cjk:!0}},{title:"Markdown",frontmatter:{title:"Markdown",permalink:"/markdown/001/",categories:["开发工具","Markdown"],tags:["Markdown"],date:"2018-09-20T00:00:00.000Z"},regularPath:"/02.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.Markdown/01.Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html",relativePath:"02.开发工具/01.Markdown/01.Markdown使用教程.md",key:"v-dd4c7ede",path:"/markdown/001/",headers:[{level:2,title:"一、Markdown",slug:"一、markdown",normalizedTitle:"一、markdown",charIndex:19},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:34},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:87},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:152},{level:2,title:"二、徽章",slug:"二、徽章",normalizedTitle:"二、徽章",charIndex:194},{level:4,title:"什么是徽章",slug:"什么是徽章",normalizedTitle:"什么是徽章",charIndex:202},{level:4,title:"徽章的使用",slug:"徽章的使用",normalizedTitle:"徽章的使用",charIndex:318},{level:2,title:"三、设置目录",slug:"三、设置目录",normalizedTitle:"三、设置目录",charIndex:567},{level:2,title:"四、标题",slug:"四、标题",normalizedTitle:"四、标题",charIndex:1181},{level:2,title:"二级标题",slug:"二级标题",normalizedTitle:"二级标题",charIndex:1199},{level:3,title:"三级标题",slug:"三级标题",normalizedTitle:"三级标题",charIndex:1211},{level:4,title:"四级标题",slug:"四级标题",normalizedTitle:"四级标题",charIndex:1225},{level:5,title:"五级标题",slug:"五级标题",normalizedTitle:"五级标题",charIndex:1241},{level:6,title:"六级标题",slug:"六级标题",normalizedTitle:"六级标题",charIndex:1259},{level:2,title:"五、文本",slug:"五、文本",normalizedTitle:"五、文本",charIndex:1269},{level:3,title:"段落",slug:"段落",normalizedTitle:"段落",charIndex:1281},{level:3,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:1291},{level:3,title:"删除线",slug:"删除线",normalizedTitle:"删除线",charIndex:1301},{level:3,title:"下划线",slug:"下划线",normalizedTitle:"下划线",charIndex:1312},{level:3,title:"文字高亮",slug:"文字高亮",normalizedTitle:"文字高亮",charIndex:1323},{level:3,title:"分隔线",slug:"分隔线",normalizedTitle:"分隔线",charIndex:1335},{level:3,title:"脚注",slug:"脚注",normalizedTitle:"脚注",charIndex:1346},{level:2,title:"六、列表",slug:"六、列表",normalizedTitle:"六、列表",charIndex:1354},{level:3,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:1366},{level:3,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:1378},{level:3,title:"折叠列表",slug:"折叠列表",normalizedTitle:"折叠列表",charIndex:1390},{level:3,title:"带复选框列表",slug:"带复选框列表",normalizedTitle:"带复选框列表",charIndex:1402},{level:3,title:"列表嵌套",slug:"列表嵌套",normalizedTitle:"列表嵌套",charIndex:1416},{level:2,title:"七、区块引用",slug:"七、区块引用",normalizedTitle:"七、区块引用",charIndex:1426},{level:4,title:"区块嵌套",slug:"区块嵌套",normalizedTitle:"区块嵌套",charIndex:1440},{level:4,title:"区块中使用列表",slug:"区块中使用列表",normalizedTitle:"区块中使用列表",charIndex:1452},{level:4,title:"列表中使用区块",slug:"列表中使用区块",normalizedTitle:"列表中使用区块",charIndex:1467},{level:2,title:"八、代码",slug:"八、代码",normalizedTitle:"八、代码",charIndex:1480},{level:3,title:"代码区块",slug:"代码区块",normalizedTitle:"代码区块",charIndex:1492},{level:2,title:"九、链接",slug:"九、链接",normalizedTitle:"九、链接",charIndex:1502},{level:3,title:"变量链接",slug:"变量链接",normalizedTitle:"变量链接",charIndex:1514},{level:3,title:"Github仓库中使用内部链接",slug:"github仓库中使用内部链接",normalizedTitle:"github仓库中使用内部链接",charIndex:4679},{level:3,title:"锚点链接",slug:"锚点链接",normalizedTitle:"锚点链接",charIndex:1547},{level:2,title:"十、图片",slug:"十、图片",normalizedTitle:"十、图片",charIndex:1557},{level:3,title:"图片宽高",slug:"图片宽高",normalizedTitle:"图片宽高",charIndex:1569},{level:3,title:"相对路径以及Github中使用图片",slug:"相对路径以及github中使用图片",normalizedTitle:"相对路径以及github中使用图片",charIndex:1581},{level:2,title:"十一、表格",slug:"十一、表格",normalizedTitle:"十一、表格",charIndex:1604},{level:2,title:"十二、Emoji表情包",slug:"十二、emoji表情包",normalizedTitle:"十二、emoji表情包",charIndex:1615},{level:2,title:"十三、其他技巧",slug:"十三、其他技巧",normalizedTitle:"十三、其他技巧",charIndex:1632},{level:3,title:"支持的 HTML 元素",slug:"支持的-html-元素",normalizedTitle:"支持的 html 元素",charIndex:1647},{level:3,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:1666},{level:3,title:"数学公式",slug:"数学公式",normalizedTitle:"数学公式",charIndex:1676},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:1688},{level:3,title:"流程图",slug:"流程图",normalizedTitle:"流程图",charIndex:1698},{level:3,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:1709},{level:3,title:"甘特图",slug:"甘特图",normalizedTitle:"甘特图",charIndex:1720}],excerpt:'<h1 id="markdown使用教程"><a class="header-anchor" href="#markdown使用教程">#</a> Markdown使用教程</h1>\n<h2 id="一、markdown"><a class="header-anchor" href="#一、markdown">#</a> 一、Markdown</h2>\n<h3 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h3>\n<p><img src="https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png" alt="logo"></p>\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n',headersStr:"一、Markdown 简介 应用 编辑器 二、徽章 什么是徽章 徽章的使用 三、设置目录 四、标题 二级标题 三级标题 四级标题 五级标题 六级标题 五、文本 段落 字体 删除线 下划线 文字高亮 分隔线 脚注 六、列表 无序列表 有序列表 折叠列表 带复选框列表 列表嵌套 七、区块引用 区块嵌套 区块中使用列表 列表中使用区块 八、代码 代码区块 九、链接 变量链接 Github仓库中使用内部链接 锚点链接 十、图片 图片宽高 相对路径以及Github中使用图片 十一、表格 十二、Emoji表情包 十三、其他技巧 支持的 HTML 元素 转义 数学公式 图表 流程图 时序图 甘特图",content:"# Markdown使用教程\n\n\n# 一、Markdown\n\n\n# 简介\n\n\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\n\n\n# 编辑器\n\n推荐使用Typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[TOC]\n\n\n> 注：github暂未支持。\n\n[TOC]\n\n在github生成TOC的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、Markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * Github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及Github中使用图片\n   * 十一、表格\n   * 十二、Emoji表情包\n   * 十三、其他技巧\n     * 支持的 HTML 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个Tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~BAIDU.COM~~\n\n\nBAIDU.COM\n\n\n# 下划线\n\n下划线可以通过 HTML 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   I我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n> 区块引用\n> \n> Typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 baidu 作为网址变量 [Baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n这个链接用 1 作为网址变量 Google\n\n这个链接用 baidu 作为网址变量 Baidu\n\n\n# Github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和HTML的锚点（#）类似\n\n[Markdown](#Markdown)\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nMarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![RUNOOB][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n\n# 相对路径以及Github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、Emoji表情包\n\nEmoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 HTML 元素\n\n不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\n\n使用 Ctrl+Alt+Del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n----------------------------------------\n\n*** 以下部分在Github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n```chart\n,Budget,Income,Expenses,Debt\nJune,5000,8000,4000,6000\nJuly,3000,1000,4000,3000\nAug,5000,7000,6000,3000\nSep,7000,2000,3000,1000\nOct,6000,5000,4000,2000\nNov,4000,3000,5000,\n\ntype: pie\ntitle: Monthly Revenue\nx.title: Amount\ny.title: Month\ny.suffix: $\n​```\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n> 注：在Typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph TD\nA[模块A] --\x3e|A1| B(模块B)\nB --\x3e C{判断条件C}\nC --\x3e|条件C1| D[模块D]\nC --\x3e|条件C2| E[模块E]\nC --\x3e|条件C3| F[模块F]\n​```\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n\n# 甘特图\n\n```mermaid\ngantt\ntitle 甘特图\ndateFormat  YYYY-MM-DD\nsection 项目A\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目B\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n回到顶部",normalizedContent:"# markdown使用教程\n\n\n# 一、markdown\n\n\n# 简介\n\n\n\nmarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 markdown 来撰写帮助文档或是用于论坛上发表消息。例如：github、简书、知乎等\n\n\n# 编辑器\n\n推荐使用typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[toc]\n\n\n> 注：github暂未支持。\n\n[toc]\n\n在github生成toc的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有go语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe readme.md 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及github中使用图片\n   * 十一、表格\n   * 十二、emoji表情包\n   * 十三、其他技巧\n     * 支持的 html 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nmarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~baidu.com~~\n\n\nbaidu.com\n\n\n# 下划线\n\n下划线可以通过 html 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   i我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n> 区块引用\n> \n> typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [google][1]\n这个链接用 baidu 作为网址变量 [baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n这个链接用 1 作为网址变量 google\n\n这个链接用 baidu 作为网址变量 baidu\n\n\n# github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和html的锚点（#）类似\n\n[markdown](#markdown)\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nmarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![runoob][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n\n# 相对路径以及github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、emoji表情包\n\nemoji表情英文名的前后加冒号，typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 html 元素\n\n不在 markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 html 撰写。\n\n目前支持的 html 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd> 重启电脑\n\n\n使用 ctrl+alt+del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nmarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nmarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n----------------------------------------\n\n*** 以下部分在github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 tex 或 latex 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{v}_1 \\times \\mathbf{v}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial x}{\\partial u} &  \\frac{\\partial y}{\\partial u} & 0 \\\\\n\\frac{\\partial x}{\\partial v} &  \\frac{\\partial y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n$$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial x}{\\partial u} & \\frac{\\partial y}{\\partial u} & 0 \\ \\frac{\\partial x}{\\partial v} & \\frac{\\partial y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n```chart\n,budget,income,expenses,debt\njune,5000,8000,4000,6000\njuly,3000,1000,4000,3000\naug,5000,7000,6000,3000\nsep,7000,2000,3000,1000\noct,6000,5000,4000,2000\nnov,4000,3000,5000,\n\ntype: pie\ntitle: monthly revenue\nx.title: amount\ny.title: month\ny.suffix: $\n​```\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n> 注：在typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph td\na[模块a] --\x3e|a1| b(模块b)\nb --\x3e c{判断条件c}\nc --\x3e|条件c1| d[模块d]\nc --\x3e|条件c2| e[模块e]\nc --\x3e|条件c3| f[模块f]\n​```\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n\n# 甘特图\n\n```mermaid\ngantt\ntitle 甘特图\ndateformat  yyyy-mm-dd\nsection 项目a\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目b\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n回到顶部",charsets:{cjk:!0}},{title:"Git",frontmatter:{title:"Git",permalink:"/git/001/",categories:["开发工具","Git"],tags:["Git"],date:"2018-07-12T00:00:00.000Z"},regularPath:"/02.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/02.Git/01.Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html",relativePath:"02.开发工具/02.Git/01.Git使用手册.md",key:"v-05ff58a7",path:"/git/001/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:14},{level:2,title:"创建版本库（仓库）",slug:"创建版本库-仓库",normalizedTitle:"创建版本库（仓库）",charIndex:290},{level:2,title:"添加文件到仓库",slug:"添加文件到仓库",normalizedTitle:"添加文件到仓库",charIndex:446},{level:4,title:"提交描述规范",slug:"提交描述规范",normalizedTitle:"提交描述规范",charIndex:743},{level:2,title:"版本管理",slug:"版本管理",normalizedTitle:"版本管理",charIndex:767},{level:4,title:"提交修改",slug:"提交修改",normalizedTitle:"提交修改",charIndex:866},{level:4,title:"查看版本记录",slug:"查看版本记录",normalizedTitle:"查看版本记录",charIndex:1029},{level:4,title:"回退版本",slug:"回退版本",normalizedTitle:"回退版本",charIndex:1122},{level:4,title:"撤销修改",slug:"撤销修改",normalizedTitle:"撤销修改",charIndex:1467},{level:4,title:"删除文件",slug:"删除文件",normalizedTitle:"删除文件",charIndex:1541},{level:2,title:"远程仓库",slug:"远程仓库",normalizedTitle:"远程仓库",charIndex:1616},{level:4,title:"SSH验证",slug:"ssh验证",normalizedTitle:"ssh验证",charIndex:1624},{level:4,title:"关联远程仓库",slug:"关联远程仓库",normalizedTitle:"关联远程仓库",charIndex:1635},{level:4,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:2637},{level:4,title:"删除远程仓库",slug:"删除远程仓库",normalizedTitle:"删除远程仓库",charIndex:2672},{level:4,title:"从远程库克隆项目",slug:"从远程库克隆项目",normalizedTitle:"从远程库克隆项目",charIndex:2713},{level:5,title:"克隆指定分支",slug:"克隆指定分支",normalizedTitle:"克隆指定分支",charIndex:2755},{level:2,title:"分支管理",slug:"分支管理",normalizedTitle:"分支管理",charIndex:2803},{level:4,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:2811},{level:4,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:2850},{level:4,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:2903},{level:4,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:2939},{level:4,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:3076},{level:4,title:"修改分支名",slug:"修改分支名",normalizedTitle:"修改分支名",charIndex:3113},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3161},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:6585}],excerpt:'<h1 id="git使用手册"><a class="header-anchor" href="#git使用手册">#</a> Git使用手册</h1>\n<h2 id="安装"><a class="header-anchor" href="#安装">#</a> 安装</h2>\n<p>官网下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">https://git-scm.com/downloads<OutboundLink/></a> 下载完成后使用默认进行安装。</p>\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n还需要最后一步设置，在命令行输入：</p>\n\x3c!--beforebegin--\x3e<div class="language-bash extra-class">\x3c!--afterbegin--\x3e<pre v-pre class="language-bash"><code><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>\n<span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span>\n</code></pre>\n\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\n',headersStr:"安装 创建版本库（仓库） 添加文件到仓库 提交描述规范 版本管理 提交修改 查看版本记录 回退版本 撤销修改 删除文件 远程仓库 SSH验证 关联远程仓库 查看远程仓库 删除远程仓库 从远程库克隆项目 克隆指定分支 分支管理 创建分支 查看分支 切换分支 合并分支 删除分支 修改分支名 帮助命令 参考文档",content:"# Git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 Git -> Git Bash，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成Git仓库\ngit init\n\n\n> 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉Git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉Git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n> 也可使用可视化工具查看Git版本历史： 在仓库目录右键 > Git BUI Here\n\n# 回退版本\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n# 回退到上一个版本\n$ git reset --hard HEAD^\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n但是不知道版本号怎么办？Git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# SSH验证\n\n使本机能关联远程仓库，首次需要SSH验证\n\n * 第1步：创建SSH Key。在用户主（C:\\Users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n# 创建SSH Key\nssh-keygen -t rsa -C \"邮件地址\"\n\n\n * 第2步：登陆GitHub，右上角头像 > settings > SSH and GPG keys >Add SSH Key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nSSH验证完成后，在github创建仓库，创建仓库时记得取消 Initialize this repository with a README的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 Initialize this repository with a README 则需先拉取README.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n$ git help\nusage: git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      Clone a repository into a new directory\n   init       Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        Add file contents to the index\n   mv         Move or rename a file, a directory, or a symlink\n   reset      Reset current HEAD to the specified state\n   rm         Remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     Use binary search to find the commit that introduced a bug\n   grep       Print lines matching a pattern\n   log        Show commit logs\n   show       Show various types of objects\n   status     Show the working tree status\n\ngrow, mark and tweak your common history\n   branch     List, create, or delete branches\n   checkout   Switch branches or restore working tree files\n   commit     Record changes to the repository\n   diff       Show changes between commits, commit and working tree, etc\n   merge      Join two or more development histories together\n   rebase     Reapply commits on top of another base tip\n   tag        Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch      Download objects and refs from another repository\n   pull       Fetch from and integrate with another repository or a local branch\n   push       Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用Git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的Git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用GPG签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",normalizedContent:"# git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 git -> git bash，蹦出一个类似命令行窗口的东西，就说明git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n\n\n因为git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成git仓库\ngit init\n\n\n> 也不一定必须在空目录下创建git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n> 也可使用可视化工具查看git版本历史： 在仓库目录右键 > git bui here\n\n# 回退版本\n\n首先，git必须知道当前版本是哪个版本，在git中，用head表示当前版本，也就是最新的提交1094adb...（注意我的提交id和你的肯定不一样），上一个版本就是head^，上上一个版本就是head^^，当然往上100个版本写100个^比较容易数不过来，所以写成head~100。\n\n# 回退到上一个版本\n$ git reset --hard head^\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n但是不知道版本号怎么办？git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# ssh验证\n\n使本机能关联远程仓库，首次需要ssh验证\n\n * 第1步：创建ssh key。在用户主（c:\\users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开shell（windows下打开git bash），创建ssh key：\n\n# 创建ssh key\nssh-keygen -t rsa -c \"邮件地址\"\n\n\n * 第2步：登陆github，右上角头像 > settings > ssh and gpg keys >add ssh key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nssh验证完成后，在github创建仓库，创建仓库时记得取消 initialize this repository with a readme的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 initialize this repository with a readme 则需先拉取readme.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n$ git help\nusage: git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nthese are common git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      clone a repository into a new directory\n   init       create an empty git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        add file contents to the index\n   mv         move or rename a file, a directory, or a symlink\n   reset      reset current head to the specified state\n   rm         remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     use binary search to find the commit that introduced a bug\n   grep       print lines matching a pattern\n   log        show commit logs\n   show       show various types of objects\n   status     show the working tree status\n\ngrow, mark and tweak your common history\n   branch     list, create, or delete branches\n   checkout   switch branches or restore working tree files\n   commit     record changes to the repository\n   diff       show changes between commits, commit and working tree, etc\n   merge      join two or more development histories together\n   rebase     reapply commits on top of another base tip\n   tag        create, list, delete or verify a tag object signed with gpg\n\ncollaborate (see also: git help workflows)\n   fetch      download objects and refs from another repository\n   pull       fetch from and integrate with another repository or a local branch\n   push       update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. see 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用gpg签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",charsets:{cjk:!0}},{title:"LeetCode",frontmatter:{title:"LeetCode",permalink:"/leetcode/001/",categories:["算法"],tags:["LeetCode"],date:"2022-07-15T00:00:00.000Z"},regularPath:"/03.%E7%AE%97%E6%B3%95/01.LeetCode.html",relativePath:"03.算法/01.LeetCode.md",key:"v-65e0a7f2",path:"/leetcode/001/",headers:[{level:2,title:"两数之和",slug:"两数之和",normalizedTitle:"两数之和",charIndex:37},{level:2,title:"数组遍历",slug:"数组遍历",normalizedTitle:"数组遍历",charIndex:47}],headersStr:"两数之和 数组遍历",content:"# Leetcode做题笔记\n\n * Leetcode做题笔记\n   * 两数之和\n   * 数组遍历\n\n\n# 两数之和\n\n题目描述(Easy)：给定一个整数数组nums和一个整数目标值target，请你在该数组中找出 和为目标值target的那两个整数，并返回它们的数组下标。可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。可以按任意顺序返回答案。\n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n分析(Easy)：使用两个for循环迭代遍历\n\n代码：\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> result;\n        for(int i = 0; i < nums.size(); i++){\n            for(int j = i + 1; j < nums.size(); j++) {\n                if(nums[i] + nums[j] == target) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        return result;\n\n    }\n};\n\n\n\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // 哈希集合，记录每个字符是否出现过\n        unordered_set<char> occ;\n        int n = s.size();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n\n        int p = -1;\n        int count  = 0;\n        // 枚举左指针的位置，初始值隐性地表示为 -1\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.erase(s[i - 1]);\n            }\n            while (p + 1 < n && !occ.count(s[p + 1])) {\n                // 不断地移动右指针\n                occ.insert(s[p + 1]);\n                p++;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            count = max(count, p - i + 1);\n        }\n        return count;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int nums1_length = nums1.size();\n        int nums2_length = nums2.size();\n\n        vector <int> num;\n        int nums1index = 0;\n        int nums2index = 0;\n\n\n        while (nums1index < nums1_length && nums2index < nums2_length) {\n            if (nums1[nums1index] <= nums2[nums2index]) {\n                num.push_back(nums1[nums1index]);\n                nums1index++;\n                // num.push_back(nums1[nums1index]);\n            }\n            else {\n                num.push_back(nums2[nums2index]);\n                nums2index++;\n                // num.push_back(nums1[nums2index]);\n            }\n            \n        }\n\n        while (nums1index < nums1_length) {\n            num.push_back(nums1[nums1index]);\n            nums1index++; \n        }\n\n        while (nums2index < nums2_length) {\n            num.push_back(nums2[nums2index]);\n            nums2index++;\n        }\n\n\n\n        if (num.size() % 2 == 0){\n            return (num[num.size() / 2] * 1.0 + num[num.size() / 2 - 1]*1.0) / 2;\n        }\n        else {\n            return num[num.size() / 2] ;\n        }\n\n\n    }\n};\n\n\n\npublic class Solution {\n\n    public String longestPalindrome(String s) {\n        int len = s.length();\n        if (len < 2) {\n            return s;\n        }\n\n        int maxLen = 1;\n        int begin = 0;\n        // dp[i][j] 表示 s[i..j] 是否是回文串\n        boolean[][] dp = new boolean[len][len];\n        // 初始化：所有长度为 1 的子串都是回文串\n        for (int i = 0; i < len; i++) {\n            dp[i][i] = true;\n        }\n\n        char[] charArray = s.toCharArray();\n        // 递推开始\n        // 先枚举子串长度\n        for (int L = 2; L <= len; L++) {\n            // 枚举左边界，左边界的上限设置可以宽松一些\n            for (int i = 0; i < len; i++) {\n                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得\n                int j = L + i - 1;\n                // 如果右边界越界，就可以退出当前循环\n                if (j >= len) {\n                    break;\n                }\n\n                if (charArray[i] != charArray[j]) {\n                    dp[i][j] = false;\n                } else {\n                    // 此时的charArray[i]和charArray[j]已经相等了，所以必然为回文字符串\n                    if (j - i < 3) {\n                        dp[i][j] = true;\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n\n                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置\n                if (dp[i][j] && j - i + 1 > maxLen) {\n                    maxLen = j - i + 1;\n                    begin = i;\n                }\n            }\n        }\n        return s.substring(begin, begin + maxLen);\n    }\n}\n\n\n\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n\n\n        // 这道题目没看懂\n                int m = s.size();\n        int n = p.size();\n\n        auto matches = [&](int i, int j) {\n            if (i == 0) {\n                return false;\n            }\n            if (p[j - 1] == '.') {\n                return true;\n            }\n            return s[i - 1] == p[j - 1];\n        };\n\n        vector<vector<int>> f(m + 1, vector<int>(n + 1));\n        f[0][0] = true;\n        for (int i = 0; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (p[j - 1] == '*') {\n                    f[i][j] |= f[i][j - 2];\n                    if (matches(i, j - 1)) {\n                        f[i][j] |= f[i - 1][j];\n                    }\n                }\n                else {\n                    if (matches(i, j)) {\n                        f[i][j] |= f[i - 1][j - 1];\n                    }\n                }\n            }\n        }\n        return f[m][n];\n\n\n    }\n};\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) :al(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode *head = nullptr;\n        ListNode *tail = nullptr;\n        int carry = 0;\n\n        while (l1 || l2) {\n            int n1 = l1 ? l1->val : 0;\n            int n2 = l2 ? l2->val : 0;\n\n            int sum = n1 + n2 + carry;\n            if(!head) {\n                head = tail = new ListNode(sum % 10);\n            }\n            else {\n                tail->next = new ListNode(sum % 10);\n                tail = tail->next;\n            }\n            carry = sum / 10;\n\n            if(l1) {\n                l1 = l1->next;\n            }\n            if(l2) {\n                l2 = l2->next;\n            }\n        }\n\n        if(carry > 0) {\n            tail->next = new ListNode(carry);\n        }\n        return head;\n\n    }\n};\n\n\n\n\n# 数组遍历\n\n首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集 如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环 如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过 当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++ 当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R--R−− 时间复杂度：O(n^2)O(n 2 )，nn 为数组长度\n\n作者：guanpengchn 链接：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n暴力破解不行\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int> > num;\n        int indeX = -1;\n        for(int i = 0; i < nums.size(); i++) {\n            for(int j = i+ 1; j <nums.size(); j++) {\n                for (int k = j + 1; k < nums.size(); k++ ) {\n                    if (nums[i] + nums[j] + nums[k] == 0) {\n                        indeX++;\n                        num.push_back(vector<int>());\n                        num[indeX].push_back(nums[i]);\n                        num[indeX].push_back(nums[j]);\n                        num[indeX].push_back(nums[k]);\n                    }\n                }\n            }\n        }\n        return num;\n        \n    }\n};\n\n\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n\n        // 排序去重\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        // 枚举 a\n        for (int first = 0; first < n; ++first) {\n            // 需要和上一次枚举的数不相同\n\n            if(nums[first] > 0) {\n                break;\n            }\n            if (first > 0 && nums[first] == nums[first - 1]) {\n                continue;\n            }\n            // c 对应的指针初始指向数组的最右端\n            int third = n - 1;\n            int target = -nums[first];\n            // 枚举 b\n            for (int second = first + 1; second < n; ++second) {\n                // 需要和上一次枚举的数不相同\n                if (second > first + 1 && nums[second] == nums[second - 1]) {\n                    continue;\n                }\n                // 需要保证 b 的指针在 c 的指针的左侧\n                while (second < third && nums[second] + nums[third] > target) {\n                    --third;\n                }\n                // 如果指针重合，随着 b 后续的增加\n                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环\n                if (second == third) {\n                    break;\n                }\n                if (nums[second] + nums[third] == target) {\n                    ans.push_back({nums[first], nums[second], nums[third]});\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n\n\n        if (list1 == NULL) {\n            return list2;\n        }\n        if (list2 == NULL) {\n            return list1;\n        }\n\n        ListNode *head = new ListNode;\n        ListNode *tail = head;\n\n        while (list1 && list2) {\n            int n1 = list1->val;\n            int n2 = list2->val;\n\n            // tail->next = new ListNode();\n            if (n1 <= n2) {\n                tail->next = list1;\n                list1 = list1->next;\n            }\n            else {\n                tail->next = list2;\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n\n        tail->next = list1 == NULL? list2 : list1;\n\n\n        return head->next; \n    }\n};\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n\n\n        // 首先获取长度\n        ListNode *tail = head;\n        int count = 0;\n        while (tail) {\n            count = count + 1;\n            tail = tail->next; \n        }\n\n        // 头插一个指针\n        // 主要目的避免指针赋值错误\n        ListNode* dummy = new ListNode(0, head);\n        tail = dummy;\n        for (int i = 1; i < count - n + 1; ++i) {\n            tail = tail->next;\n        }\n        ListNode *Temptail = tail->next;\n        tail->next = Temptail->next;\n        ListNode* ans = dummy->next;\n        delete dummy;\n        return ans;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        int n = s.size();\n        if (n % 2 == 1 || n == 0) {\n            return false;\n        }\n        stack<char>sta;\n        for(int i = 0; i < n; i++) {\n            char ch = s[i];\n            if (sta.empty()) {\n                sta.push(ch);\n            }\n            else {\n                char tempch = sta.top();\n                if(tempch == '(' && ch == ')' || tempch == '[' && ch == ']' || tempch == '{' && ch == '}') {\n                    sta.pop();\n                }\n                else {\n                    sta.push(ch);\n                }\n            }\n        }\n        if(sta.empty()) {\n            return true;\n        }\n        else {\n            return false;\n        }\n\n    }\n};\n\n\n\nclass Solution {\npublic:\n    vector<string> result;\n    vector<string> letterCombinations(string digits) {\n\n        if(digits.size() == 0) {\n            return result;\n        }\n\n        //从零开始进行深度搜索\n        dfs(digits, 0);\n        return result;\n\n    }\n\n    void dfs(string digits, int index) {\n\n        // 迭代终止条件\n        if(index == digits.length()) {\n            result.push_back(digits);\n            return;\n        }\n\n        // 持续深度搜索\n        switch(digits[index]){\n            case '2': digits[index] = 'a'; dfs(digits,index+1);\n                      digits[index] = 'b'; dfs(digits,index+1);  \n                      digits[index] = 'c'; dfs(digits,index+1);\n                      break;\n            case '3': digits[index] = 'd'; dfs(digits,index+1);\n                      digits[index] = 'e'; dfs(digits,index+1);  \n                      digits[index] = 'f'; dfs(digits,index+1);\n                      break;  \n            case '4': digits[index] = 'g'; dfs(digits,index+1);\n                      digits[index] = 'h'; dfs(digits,index+1);  \n                      digits[index] = 'i'; dfs(digits,index+1);\n                      break;  \n            case '5': digits[index] = 'j'; dfs(digits,index+1);\n                      digits[index] = 'k'; dfs(digits,index+1);  \n                      digits[index] = 'l'; dfs(digits,index+1);\n                      break; \n            case '6': digits[index] = 'm'; dfs(digits,index+1);\n                      digits[index] = 'n'; dfs(digits,index+1);  \n                      digits[index] = 'o'; dfs(digits,index+1);\n                      break;  \n            case '7': digits[index] = 'p'; dfs(digits,index+1);\n                      digits[index] = 'q'; dfs(digits,index+1);  \n                      digits[index] = 'r'; dfs(digits,index+1);\n                      digits[index] = 's'; dfs(digits,index+1);\n                      break;  \n            case '8': digits[index] = 't'; dfs(digits,index+1);\n                      digits[index] = 'u'; dfs(digits,index+1);  \n                      digits[index] = 'v'; dfs(digits,index+1);\n                      break;  \n            case '9': digits[index] = 'w'; dfs(digits,index+1);\n                      digits[index] = 'x'; dfs(digits,index+1);  \n                      digits[index] = 'y'; dfs(digits,index+1);\n                      digits[index] = 'z'; dfs(digits,index+1);\n                      break;\n            \n\n        }\n    }\n};\n\n\n\nclass Solution {\npublic:\n\n    vector<string> result;\n    vector<string> generateParenthesis(int n) {\n        DFS(\"(\", n-1, n);\n        return result;\n    }\n\n    void DFS (string str, int left, int right) {\n        if (left < 0 || right < 0 || right < left) {\n            return;\n        }\n        if (left == 0 && right == 0) {\n            result.push_back(str);\n            return;\n        }\n        DFS(str + '(', left-1, right);\n        DFS(str + ')', left, right-1);\n    }\n\n        \n};\n\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n\n    ListNode* addTwolists(ListNode *a, ListNode *b) {\n        // 要是A为空B不空，直接返回B\n        // 要是A不空但是lists[i]为空返回a\n        if ((!a) || (!b)) {\n            return a ? a: b;\n        }\n        ListNode head, *tail = &head;\n        ListNode *tempa = a;\n        ListNode *tempb = b;\n        while(tempa && tempb) {\n            if (tempa->val >= tempb->val) {\n                tail->next = tempb;\n                tempb = tempb->next;\n            }\n            else {\n                tail->next = tempa;\n                tempa = tempa->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = (tempa ? tempa : tempb);\n        return head.next;\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n\n        ListNode *ans = nullptr;\n        for(size_t i = 0; i < lists.size(); i++) {\n            ans = addTwolists(ans, lists[i]);\n        }\n        return ans;\n    }\n};\n\n\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n\n二分查找\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        if (n == 0) {\n            return -1;\n        }\n        if (n == 1) {\n            return nums[0] == target ? 0 : -1;\n        }\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n\n\n\nclass Solution {\n\n\n    public int[] searchRange(int[] nums, int target) {\n        // 默认找到符合题意最小的\n        int leftIdx = binarySearch(nums, target, true);\n        // 找到比符合题意大的下一个\n        int rightIdx = binarySearch(nums, target, false) - 1;\n        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {\n            return new int[]{leftIdx, rightIdx};\n        } \n        return new int[]{-1, -1};\n    }\n\n    public int binarySearch(int[] nums, int target, boolean lower) {\n        int left = 0, right = nums.length - 1, ans = nums.length;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > target || (lower && nums[mid] >= target)) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n\n\n\nimport JAVA.util.ArrayDeque;\nimport JAVA.util.ArrayList;\nimport JAVA.util.Arrays;\nimport JAVA.util.Deque;\nimport JAVA.util.List;\n\n\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n\n        int len = candidates.length;\n\n\n        // 声明结果\n        List<List<Integer>> result = new ArrayList<>();\n\n        if(len == 0) {\n            return result;\n        }\n\n        // 首先排序\n        Arrays.sort(candidates);\n        Deque<Integer> path = new ArrayDeque<>();\n        DFS(candidates, 0, len, target, path, result);\n        return result;\n    }\n\n    private void DFS (int[] candidates, int begin, int len, int target, Deque<Integer> path, List<List<Integer>> result) {\n\n        // 递归终止条件值只判断等于 0 的情况\n        if (target == 0) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n\n        for (int i = begin; i < len; i++) {\n            if(target - candidates[i] < 0) {\n                break;\n            }\n\n            path.addLast(candidates[i]);\n            DFS(candidates, i, len, target - candidates[i], path, result);\n            path.removeLast();\n        }\n\n    }\n}\n\n\nimport JAVA.util.ArrayList;\nimport JAVA.util.List;\n\n\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n\n\n        // 首先是特判\n        int len = nums.length;\n        // 使用一个动态数组保存所有可能的全排列\n        List<List<Integer>> result = new ArrayList<>();\n\n        if (len == 0) {\n            return result;\n        }\n\n        boolean[] label = new boolean[len];\n        List<Integer> path = new ArrayList<>();\n\n        DFS(nums, 0, len, label, path, result);\n        return result;\n    }\n    \n    public void DFS (int[] nums, int depth, int len, boolean[] label, List<Integer> path, List<List<Integer>> result) {\n\n        if (depth == len) {\n            result.add(path);\n            return;\n        }\n\n        for (int i = 0; i < len; i++) {\n            if (!label[i]) {\n\n                // 保存当前路径到新的list中\n                List<Integer> newPath = new ArrayList<>(path);\n                // 添加状态\n                newPath.add(nums[i]);\n\n                // 保存新的状态\n                boolean[] newLabel = new boolean[len];\n\n                for (int j = 0; j < len; j++) {\n                    newLabel[j] = label[j];\n                }\n                // System.arraycopy(label, 0, len, newLabel, 0, len);\n                newLabel[i] = true;\n                DFS(nums, depth + 1, len, newLabel, newPath, result);\n            }\n        }\n\n    }\n}\n\n\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int[][] matrix_new = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix_new[j][n - i - 1] = matrix[i][j];\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix[i][j] = matrix_new[i][j];\n            }\n        }\n    }\n}\n\n\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n\n        int len = n % 2 == 0? n / 2 : n / 2 + 1;\n\n        for(int i = 0; i < len; i++) {\n            // ArrayList<Integer> newList = new ArrayList<Integer>();\n\n            for (int j = i; j < n-i-1; j++) {\n            \n                if (j >= i) {\n                ArrayList<Integer> newList = new ArrayList<Integer>();\n                newList.add(matrix[n-1-j][i]);  // 13\n                newList.add(matrix[i][j]);  // 1\n                newList.add(matrix[j][n-1-i]);  //10\n                newList.add(matrix[n-1-i][n-1-j]);  // 12\n                matrix[i][j] = newList.get(0);  // 13\n                matrix[j][n-1-i] = newList.get(1);  // 1\n                matrix[n-1-i][n-1-j] = newList.get(2);  // 10\n                matrix[n-1-j][i] = newList.get(3);  // 12\n                }\n            }\n        }\n \n    }\n}\n\n\nclass Solution {\n    // 两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。\n\n    // 遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。\n\n\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        // 由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。\n        for (int i = 0; i < strs.length; i++) {\n            char[] strsArray = strs[i].toCharArray();\n\n            Arrays.sort(strsArray);\n            \n            String key = new String(strsArray);\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(strs[i]);\n            map.put(key, list);\n        }\n\n        return new ArrayList<List<String>>(map.values());\n\n    }\n}\n\n\nclass Solution {\n    public int maxSubArray(int[] nums) {\n\n        int pre = 0;\n        int maxRes = nums[0];\n\n        for(int i = 0; i < nums.length; i++) {\n            pre = Math.max(pre + nums[i], nums[i]);\n\n            maxRes = Math.max(maxRes, pre);\n\n        }\n\n        return maxRes;\n\n    }\n}\n\n\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int maxRes = 0;\n\n        for(int i = 0;  i < nums.length; i++) {\n\n            if(i <= maxRes) {\n                maxRes = Math.max(maxRes, i + nums[i] );\n                if (maxRes >= nums.length-1) {\n                    return true;\n                }\n            }\n\n        }\n        return false;\n\n    }\n}\n\n\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        if(intervals.length == 0) {\n            return new int[][]{};\n        }\n\n        //首先排序，这里应该是lamda表达式\n        // Arrays.sort(intervals,(a,b)->{return a[0]-b[0];});\n        Arrays.sort(intervals,(a,b)->{return a[0]-b[0];});\n\n        int[][] result = new int[intervals.length][2];\n        int index = 0;\n\n        int start = intervals[0][0];\n        int end = intervals[0][1];\n\n        for(int i = 1; i < intervals.length; i++) {\n\n            // 后一个的起点位置小于等于前一个的结束位置可以合并\n            if (intervals[i][0] <= end) {\n\n                // 再去判断后一个点和前一个点结束位置的大小\n                if (intervals[i][1] >= end) {\n                    end = intervals[i][1];\n                }\n                else {\n                    end = end;\n                }\n                // end  = intervals[i][1];\n            }\n            // 不能合并\n            else {\n                result[index][0] = start;\n                result[index][1] = end;\n                index++;\n                // 更新下一个位置\n                start = intervals[i][0];\n                end = intervals[i][1];\n            }\n        }\n\n        result[index][0] = start;\n        result[index][1] = end;\n        return Arrays.copyOfRange(result, 0, index+1);\n    }\n}\n\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] path = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            path[i][0] = 1;\n        }\n        for (int j = 0; j < n; ++j) {\n            path[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                path[i][j] = path[i - 1][j] + path[i][j - 1];\n            }\n        }\n        return path[m - 1][n - 1];\n    }\n}\n\n\nclass Solution {\n    public int minPathSum(int[][] grid) {\n\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int[][] dp = new int[m][n];\n\n        // 状态初始化\n        dp[0][0] = grid[0][0];\n\n        \n        for(int i = 1; i < m; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n\n        for(int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n\n\n        for (int i = 1; i < m ; i++) {\n            for (int j = 1; j < n ; j++) {\n                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n\n        // 返回结果\n        return dp[m-1][n-1];\n    }\n}\n\n\n深度搜索超出时间限制\n\nclass Solution {\n    public int climbStairs(int n) {\n        int count = 0;\n\n        return DFS(n);\n\n    }\n\n    public int DFS(int n) {\n        if (n == 0) {\n            return 1;\n        }\n        if (n < 0) {\n            return 0;\n        }\n        return DFS(n - 1) + DFS(n - 2);\n    }\n}\n\n\n本质上为斐波那契数列\n\nclass Solution {\n    public int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n\n    }\n}\n\n\n// 采用栈进行分析这里有bug\n// (()这种分析不出来\nclass Solution {\n    public int longestValidParentheses(String s) {\n\n        int maxValue = 0;\n        int temp = 0;\n\n        Deque<Integer> stack = new LinkedList<Integer>();\n\n        // 首先放入第一个元素\n        // stack.push(s.chartAt(0));\n\n        for(int i = 0; i < s.length(); i++) {\n\n            // 如果栈空必须放入新元素\n            if (stack.isEmpty()) {\n                stack.push(i);\n            }\n            /// 栈不是空的\n            else {\n                // 栈顶元素为(\n                if (s.charAt(stack.peek()) == '(') {\n\n                    if (s.charAt(i) == ')') {\n                        // 出栈\n                        stack.pop();\n                        temp = temp + 2;\n                    }\n\n                    else {\n                        stack.push(i);\n                    }\n\n                }\n                // 栈顶元素为)\n                else {\n                    maxValue = Math.max(maxValue, temp);\n                    temp = 0;\n                }\n            }\n\n        }\n        return maxValue;\n\n    }\n}\n\n\nclass Solution {\n    public int longestValidParentheses(String s) {\n\n        int maxValue = 0;\n        int left = 0;\n        int right = 0;\n\n\n        // 从前往后\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxValue = Math.max(maxValue, 2 * right);\n            } else if (right > left) {\n                left = right = 0;\n            }\n        }\n\n        //从后往前\n        left = 0;\n        right = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxValue = Math.max(maxValue, 2 * right);\n            } else if (left > right) {\n                left = right = 0;\n            }\n        }\n        return maxValue;\n\n    }\n}\n\n\nclass Solution {\n    public int trap(int[] height) {\n        int area = 0;\n\n        Deque<Integer> stack = new LinkedList<Integer>();\n\n        // 利用栈进行求解\n        // 栈中存储的元素为依次递减的数\n        // 然后根据递增的数进行求解\n\n        for(int i= 0; i < height.length; i++) {\n\n            // 栈不为空且后面的元素开始递增时进行出栈判断\n            while(!stack.isEmpty() && height[i] > height[stack.peek()]) {\n\n                // 获取中间的元素\n                int middle = stack.pop();\n\n                if (stack.isEmpty()) {\n                    break;\n                }\n\n                int left = stack.peek();  // 获取左边的元素\n\n                int Width = i - left - 1;  // 宽度\n\n                int Height = height[i] > height[left] ? height[left] : height[i];  // 获取最小值\n\n                area = area + (Height - height[middle]) * Width;\n\n\n            }\n\n            // 存储每个元素\n            stack.push(i);\n        }\n\n        return area;\n\n    }\n}\n\n\nclass Solution {\n    public void sortColors(int[] nums) {\n\n        int len = nums.length;\n\n        if(len <= 1) {\n            return;\n        }\n        // all in [0, zero) = 0\n        // all in [zero, i) = 1\n        // all in [two, len - 1] = 2\n        \n        // 循环终止条件是 i == two，那么循环可以继续的条件是 i < two\n        // 为了保证初始化的时候 [0, zero) 为空，设置 zero = 0，\n        // 所以下面遍历到 0 的时候，先交换，再加\n        int zero = 0;\n\n        // 为了保证初始化的时候 [two, len - 1] 为空，设置 two = len\n        // 所以下面遍历到 2 的时候，先减，再交换\n        int two = len;\n        int i = 0;\n        // 当 i == two 上面的三个子区间正好覆盖了全部数组\n        // 因此，循环可以继续的条件是 i < two\n\n\n\n        while (i < two) {\n            if(nums[i] == 0) {\n                myswap(nums, i, zero);\n                zero++;\n                i++;\n            }\n            else if (nums[i] == 1){\n                i++;\n            }\n            else {\n                two--;\n                myswap(nums, i, two);\n            }\n\n        }\n\n\n    }\n\n\n    private void myswap(int[] nums, int left, int right) {\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n    }\n}\n\n\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n\n        List<Integer> temp = new ArrayList<Integer>();\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n\n\n        for(int mask = 0; mask < (1 << nums.length); mask++) {\n            temp.clear();\n\n            for(int i = 0; i < nums.length; i++) {\n\n                if ((mask & (1 << i)) != 0) {\n                    temp.add(nums[i]);\n                }\n            }\n\n            res.add(new ArrayList<Integer>(temp));\n\n\n\n\n\n        }\n        return res;\n\n    }\n}\n\n\n\n// 还有递归的中序遍历\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n\n        List<Integer> result = new ArrayList<Integer>();\n        Deque<TreeNode> sta = new LinkedList<TreeNode>();\n\n        while(root != null || !sta.isEmpty()) {\n\n            while(root != null) {\n                sta.push(root);\n                root = root.left;\n            }\n            root = sta.pop();\n            result.add(root.val);\n            root = root.right;\n        }\n\n        return result;\n\n    }\n}\n\n\n\n// 同样也有递归版本\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n\n        // 左右两边同时遍历\n        return check(root, root);\n    }\n\n\n// 1、offer()和add()的区别\n// add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。可以据此在程序中进行有效的判断！\n\n// 2、peek()和element()的区别\n// peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。\n\n// 3、poll()和remove()的区别\n// poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。\n    public boolean check(TreeNode u, TreeNode v){\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\n\n        // 添加一个元素到队尾\n        q.offer(u);\n        q.offer(v);\n\n        while(!q.isEmpty()) {\n            u = q.poll();\n            v = q.poll();\n\n\n            //如果两个节点都为空就继续循环，两者有一个为空就返回false\n            if(u == null && v == null) {\n                continue;\n\n            }\n\n            //如果两个节点都为空就继续循环，两者有一个为空就返回false\n            if ((u == null || v == null)) {\n                return false;\n            }\n\n            if (u.val != v.val) {\n                return false;\n            }\n            //将左节点的左孩子， 右节点的右孩子放入队列\n            q.offer(u.left);\n            q.offer(v.right);\n            \n            \n            q.offer(u.right);\n            q.offer(v.left);\n        }\n        return true;\n\n\n\n\n    }\n}\n\n\n\nclass Solution {\n    public int numTrees(int n) {\n        // 以每一个点为中心分别计算两边\n        //\n        int[] count = new int[n+1];\n        count[0] = 1;\n        count[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n\n            for(int j = 1; j <= i; j++) {\n                count[i] = count[i] + count[j - 1] * count[i - j];\n            }\n        }\n        return count[n];\n\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n\n        if (root == null) {\n            return result;\n        }\n\n\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        // 根节点入队列\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n\n            List<Integer> level = new ArrayList<Integer>();\n\n            int queuelength = queue.size();\n\n            // 把当前队列中所有点对应的下一层全部存起来\n            for(int i = 0; i < queuelength; i++) {\n                // 取出队列先进来的元素\n                TreeNode node = queue.poll();\n                level.add(node.val);\n\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n\n                if(node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n            result.add(level);\n        }\n        return result;\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    public boolean isValidBST(TreeNode root, long min, long max) {\n        if (root == null) {\n            return true;\n        }\n        if (root.val <= min || root.val >= max) {\n            return false;\n        }\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n\n        int count = 0;\n\n        if (root == null) {\n            return count;\n        }\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        // 根节点入队列\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            count = count + 1;\n\n            int queuelength = queue.size();\n            for(int i = 0; i < queuelength; i++) {\n                // 取出队列先进来的元素\n                TreeNode node = queue.poll();\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n\n                if(node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n        }\n        return count;\n    }\n}\n\n\n\n\n深度遍历\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        } else {\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return Math.max(left, right) + 1;\n        }\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n//     我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；\n\n// 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；\n\n// 无论是哪一种情况，我们最后都将当前的节点入栈。\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        // preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]\n        // inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]\n//         3\n//        / \\\n//       9  20\n//      /  /  \\\n//     8  15   7\n//    / \\\n//   5  10\n//  /\n// 4\n\n        if (preorder.length == 0 || preorder == null) {\n            return null;\n        }\n\n\n        // 找到先序遍历的根节点\n        TreeNode root = new TreeNode(preorder[0]);\n        // 声明栈\n        Deque<TreeNode> stack = new LinkedList<TreeNode>();\n        // 根节点入栈\n        stack.push(root);\n\n        int index = 0;\n\n        for(int i = 1; i < preorder.length; i++) {\n            int preorderVal = preorder[i];\n            // peek不改变栈的值(不删除栈顶的值)，pop会把栈顶的值删除。\n            TreeNode node = stack.peek();\n\n            if (node.val != inorder[index]) {\n                node.left = new TreeNode(preorderVal);\n                stack.push(node.left);\n            }\n            else {\n                // 栈中的节点的顺序和它们在前序遍历中出现的顺序是一致\n                // 而且每一个节点的右儿子都还没有被遍历过\n                // 那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的\n                while (!stack.isEmpty() && stack.peek().val == inorder[index]) {\n                    node = stack.pop();\n                    index++;\n                }\n                node.right = new TreeNode(preorderVal);\n                stack.push(node.right);\n            }\n        }\n        return root;\n\n    }\n}\n\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n\n        List<TreeNode> list = new ArrayList<TreeNode>();\n\n        Deque<TreeNode> stack = new LinkedList<TreeNode>();\n\n        TreeNode node = root;\n\n        while(node != null || !stack.isEmpty()) {\n            while (node != null) {\n                list.add(node);\n                stack.push(node);\n                node = node.left;\n            }\n            node = stack.pop();\n            node = node.right;\n        }\n\n        int size = list.size();\n\n        for(int i = 1; i < size; i++) {\n            TreeNode prev = list.get(i-1);\n            TreeNode next = list.get(i);\n            prev.left = null;\n            prev.right = next;\n            next.left = null;\n            next.right = null;\n        }\n    }\n}\n\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int minprice = Integer.MAX_VALUE;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minprice) {\n                minprice = prices[i];\n            } else if (prices[i] - minprice > maxprofit) {\n                maxprofit = prices[i] - minprice;\n            }\n        }\n        return maxprofit;\n    }\n\n}\n\n\n// import JAVA.util.Arrays;\n\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if (nums.length <= 0) {\n            return 0;\n        }\n\n        if (nums.length == 1) {\n            return 1;\n        }\n\n        Arrays.sort(nums);\n        int index = 1;\n        int maxLength = 0;\n\n        for(int i = 0; i < nums.length-1; i++) {\n            if (nums[i+1] != nums[i]) {\n                if (nums[i+1] - nums[i] == 1) {\n                    index++;\n                    // maxLength = index > maxLength ? index : maxLength;\n\n                }\n                else {\n                    index=1;\n                    \n                }\n            }\n            maxLength = index > maxLength ? index : maxLength;\n        }\n        return maxLength;\n    }\n}\n\n\nclass Solution {\n    public int singleNumber(int[] nums) {\n\n        if(nums.length == 1) {\n            return nums[0];\n        }\n\n        // 默认元素全部大于0\n        Map<Integer, Integer> map = new HashMap<>();\n        for (Integer i : nums) {\n            Integer count = map.get(i);\n            count = count == null ? 1 : ++count;\n            map.put(i, count);\n        }\n        for (Integer i : map.keySet()) {\n            Integer count = map.get(i);\n            if (count == 1) {\n                return i;\n            }\n        }\n        return -1; // can't find it.\n\n    }\n}\n\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        Set<ListNode> seen = new HashSet<ListNode>();\n        while (head != null) {\n            if (!seen.add(head)) {\n                return true;\n            }\n            head = head.next;\n        }\n        return false;\n\n    }\n}\n\n// 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，\n// 一快一满。慢指针每次只移动一步，而快指针每次移动两步。\n// 初始时，慢指针在位置 head，而快指针在位置 head.next。\n// 这样一来，如果在移动的过程中，快指针反过来追上慢指针，\n// 就说明该链表为环形链表。否则快指针将到达链表尾部，\n// 该链表不为环形链表。\n\n\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        // 起始：fast、slow = head\n        // 核心：fast = fast.next.next;slow = slow.next;fast==slow?return true:fast\n        // 终止：fast!=null && fast.next!=null\n        if(head == null || head.next == null)return false; \n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n\n\n// slow * 2 = fast;\n// slow = a + b;\n// fast = a + b + c + b = a + 2*b + c;\n// (a + b)*2 = a + 2*b + c;\n// a = c;\n// 口头解释就是\n// 快针走的是慢针的两倍。\n// 慢针走过的路，快针走过一遍。\n// 快针走过的剩余路程，也就是和慢针走过的全部路程相等。(a+b = c+b)\n// 刨去快针追赶慢针的半圈(b)，剩余路程即为所求入环距离(a=c)\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n\n        if(head == null) {\n            return null;\n        }\n\n        ListNode pre = head;\n        ListNode fast = head;\n\n        while(fast != null) {\n\n            pre = pre.next;\n            if(fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n\n            // 二者重合必然有环\n            if(pre == fast) {\n                ListNode pr = head;\n                while (pr != pre) {\n                    pr = pr.next;\n                    pre = pre.next;\n                }\n                return pr;\n            }\n\n        }\n        return null;\n        \n    }\n}\n\n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length / 2];\n    }\n}\n\n\nclass Solution {\n    public int maxProduct(int[] nums) {\n\n        int max = Integer.MIN_VALUE;\n        int imax = 1;\n        int imin = 1;\n\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] < 0) {\n\n                int temp = imax;\n                imax = imin;\n                imin = temp;\n            }\n            \n            imax = Math.max(imax * nums[i], nums[i]);\n            imin = Math.min(imin * nums[i], nums[i]);\n\n            max = Math.max(max, imax);\n        }\n        return max;\n    }\n}\n\n\nclass Solution {\n    public int numIslands(char[][] grid) {\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int count = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n\n    }\n\n    void dfs (char[][] grid, int i, int j) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0') {\n            return;\n        }\n\n        grid[i][j] = '0';\n        dfs(grid, i-1, j);\n        dfs(grid, i+1, j);\n        dfs(grid, i, j-1);\n        dfs(grid, i, j+1);\n    }\n}\n\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        return sortList(head, null);\n\n    }\n\n    public ListNode sortList(ListNode head, ListNode tail) {\n        if (head == null) {\n            return head;\n        }\n        if (head.next == tail) {\n            head.next = null;\n            return head;\n        }\n\n        ListNode slow = head; // 移动到中间的地方\n        ListNode fast = head;  // 移动到尾部\n\n        while(fast != tail) {\n            slow = slow.next;\n            fast = fast.next;\n            if (fast != tail) {\n                fast = fast.next;\n            }\n        }\n\n        ListNode mid = slow;\n        ListNode list1 = sortList(head, mid);\n        ListNode list2 = sortList(mid, tail);\n\n        ListNode res = merge(list1, list2);\n        return res;\n    }\n\n    public ListNode merge(ListNode head1, ListNode head2) {\n\n        ListNode dyhead = new ListNode(0);\n        \n        ListNode temp = dyhead;\n        ListNode temp1 = head1;\n        ListNode temp2 = head2;\n\n        while(temp1 != null && temp2 != null) {\n            if(temp1.val < temp2.val) {\n                temp.next = temp1;\n                temp1 = temp1.next;\n            }\n            else {\n                temp.next = temp2;\n                temp2 = temp2.next;\n            }\n            temp = temp.next;\n        }\n        if (temp1 != null) {\n            temp.next = temp1;\n        }\n        if (temp2 != null) {\n            temp.next = temp2;\n        }\n\n        return dyhead.next;\n\n    }\n}\n\n\nclass MinStack {\n    Deque<Integer> stack;\n    Deque<Integer> minstack;\n    public MinStack() {\n        stack = new LinkedList<Integer>();\n        minstack = new LinkedList<Integer>();\n        minstack.push(Integer.MAX_VALUE);\n\n    }\n    \n    public void push(int val) {\n        stack.push(val);\n        minstack.push(Math.min(val, minstack.peek()));\n    }\n    \n    public void pop() {\n        stack.pop();\n        minstack.pop();\n\n    }\n    \n    public int top() {\n        return stack.peek();\n\n    }\n    \n    public int getMin() {\n        return minstack.peek();\n\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n\n\n\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        if(headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode pA = headA;\n        ListNode pB = headB;\n        while(pA != pB) {\n\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n\n        }\n        return pB;       \n    }\n}\n\n\nclass Solution {\n    public int rob(int[] nums) {\n\n        int len = nums.length;\n        if (len == 1) {\n            return nums[0];\n        }\n        else {\n            int[] dp = new int[len];\n            dp[0] = nums[0];\n            dp[1] = Math.max(nums[0], nums[1]);\n\n            for (int i = 2; i < len; i++) {\n                dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);\n            }\n            return dp[len - 1];\n        }\n\n    }\n}\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        Deque<ListNode> stack = new LinkedList<ListNode>();\n\n        ListNode pHead = head;\n\n        if (pHead == null) {\n            return pHead;\n        }\n\n        while (pHead != null) {\n            stack.push(pHead);\n            pHead = pHead.next;\n        }\n\n        ListNode res = stack.pop();\n        ListNode finalres = res;\n        while(!stack.isEmpty()) {\n            res.next = stack.pop();\n            res = res.next;\n        }\n        res.next = null;\n        return finalres;\n\n        \n    }\n}\n\n\n\n\n// 第二种是双指针\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}\n\n\n\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // 声明存储图结构的变量\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            graph.add(new ArrayList<Integer>());\n        }\n\n        int[] visited = new int[numCourses];\n\n        for(int i = 0; i < prerequisites.length; i++) {\n\n            int nowcourse = prerequisites[i][0];\n            int precourse = prerequisites[i][1];\n\n            // 下标为nowcourse的数组里面的内容是nowcourse的所有前置课程\n            graph.get(nowcourse).add(precourse);\n        }\n\n        // 深度遍历\n\n        for(int i = 0; i < numCourses; i++) {\n            if (dfs(graph, visited, i) == true) {\n                return false;\n            }\n        }\n        return true;\n\n    }\n\n    public boolean dfs(List<List<Integer>> graph, int[] visited, int index) {\n        // 1代表次节点正在被访问, 如果正在被访问的节点，再次被访问，则存在环，无法完成课程\n        if (visited[index] == 1) {\n            return true;\n        }\n        // 2代表节点被访问过，无需再次访问\n        if (visited[index] == 2) {\n            return false;\n        }\n\n\n        // 设置该课程为正在访问的状态\n        visited[index] = 1;\n\n        for (Integer next : graph.get(index)) {\n\n            if (dfs(graph, visited, next) == true) {\n                return true;\n            }\n        }\n\n        // 当前课程已经被访问\n        visited[index] = 2;\n        return false;\n\n    }\n}\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n\n// 整个流程可以分为以下五个步骤：\n// 找到前半部分链表的尾节点。\n// 反转后半部分链表。\n// 判断是否回文。\n// 恢复链表。\n// 返回结果。\n\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n\n        // 找到中间位置和结束位置\n        ListNode slow = head;\n        ListNode fast = head;\n\n\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // 反转后面的数据\n        ListNode middle = slow;\n\n        ListNode secondHalfStart = reverseList(middle.next);\n\n        ListNode p1 = head;\n        ListNode p2 = secondHalfStart;\n\n        boolean result = true;\n\n        while (result && p2 != null) {\n            if (p1.val != p2.val) {\n                result = false;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n\n        middle.next = reverseList(secondHalfStart);\n        return result;\n\n    }\n\n\n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n}\n\n\n\n/**\n     * 递归方式遍历反转\n     */\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n\n        invertTree(root.left);\n        invertTree(root.right);\n        return root;\n    }\n\n    /**\n     * 层序遍历方式反转\n     */\n    public TreeNode invertTreeByQueue(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            TreeNode temp = node.left;\n            node.left = node.right;\n            node.right = temp;\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n        }\n        return root;\n    }\n\n\n\nclass Node {\n    boolean is_end;\n    Node[] son = new Node[26];\n    Node() {\n        is_end = false;\n        for (int i = 0; i < 26; i++) {\n            son[i] = null;\n        }\n    }\n}\n\n\nclass Trie {\n\n    Node root;\n\n    public Trie() {\n        root = new Node();\n    }\n    \n    public void insert(String word) {\n        Node p = root;\n        for(int i = 0; i < word.length(); i++) {\n\n            int val = word.charAt(i) - 'a';\n            if(p.son[val] == null) {\n                p.son[val] = new Node();\n            }\n            p = p.son[val];\n        }\n        p.is_end = true;\n\n    }\n    \n    public boolean search(String word) {\n        Node p = root;\n        for(int i = 0; i < word.length(); i++) {\n\n            int val = word.charAt(i) - 'a';\n            if(p.son[val] == null) {\n                return false;\n            }\n            p = p.son[val];\n        }\n        return p.is_end;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node p = root;\n        for(int i = 0;i < prefix.length();i ++)\n        {\n            int u = prefix.charAt(i) - 'a';\n            if(p.son[u] == null) return false;\n            p = p.son[u]; \n        }\n        return true;\n\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n\n\n// https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\n// 这个题目可以重新做一下\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        Arrays.sort(nums);\n        return nums[nums.length - k];\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    Map<Integer, TreeNode> parent = new HashMap<Integer, TreeNode>();\n    Set<Integer> visited = new HashSet<Integer>();\n\n    public void DFS(TreeNode root) {\n        if (root.left != null) {\n            parent.put(root.left.val, root);\n            DFS(root.left);\n        }\n        if (root.right != null) {\n            parent.put(root.right.val, root);\n            DFS(root.right);\n        }\n    }\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        DFS(root);\n\n\n        // 找到了P的所有父节点\n        while (p!=null) {\n            visited.add(p.val);\n            p = parent.get(p.val);\n        }\n\n        // 根据p的节点去找q的节点\n        while(q!=null) {\n            if (visited.contains(q.val)) {\n                return q;\n            }\n            q = parent.get(q.val);\n        }\n        return null;\n        \n    }\n}\n\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n\n        // 左边的先乘起来\n        int[] resultLeft = new int[nums.length];\n        resultLeft[0] = 1;\n        for(int i = 1; i < nums.length; i++) {\n            resultLeft[i] = nums[i-1] * resultLeft[i-1];\n        }\n\n        // 右边的乘起来\n        int[] resultRight = new int[nums.length];\n        resultRight[nums.length-1] = 1;\n        for(int i = nums.length-2; i >= 0; i--) {\n            resultRight[i] = nums[i+1] * resultRight[i+1];\n        }\n\n        // 左右相乘\n        for(int i = 0; i < nums.length; i++) {\n            nums[i] = resultRight[i] * resultLeft[i];\n        }\n        return nums;\n\n    }\n}\n\n\n\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n\n\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        int i = 0;\n        int j = n - 1;\n\n        while (i < m && j >= 0) {\n\n            if (matrix[i][j] == target) {\n                return true;\n            }\n            else if (matrix[i][j] < target) {\n                i++;\n            }\n            else {\n                j--;\n            }\n        }\n        return false;\n        \n    }\n}\n\n\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n\n        int len = temperatures.length;\n        int [] result = new int[len];\n\n        Deque<Integer> temp = new LinkedList<Integer>();\n\n        for (int i = 0; i < len; i++) {\n            int tempvalue = temperatures[i];\n            while (!temp.isEmpty() && tempvalue > temperatures[temp.peek()]) {\n                int pre = temp.pop();\n                result[pre] = i - pre;\n            }\n            temp.push(i);\n        }\n        return result;\n    }\n}\n\n\nclass Solution {\n    public int countSubstrings(String s) {\n\n        int count = 0;\n        int len = s.length();\n\n        // i 用来控制\n        for (int i = 0; i < 2 * len - 1; i++) {\n\n            int left = i / 2;\n            int right = i / 2 + i % 2;\n            while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {\n                left--;\n                right++;\n                count++;\n            }\n        }\n        return count;\n\n    }\n}\n\n\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        // 我们可以用一个哈希表记录数组 \\textit{nums}nums 中的数字，由于数字范围均在 [1,n][1,n] 中，记录数字后我们再利用哈希表检查 [1,n][1,n] 中的每一个数是否出现，从而找到缺失的数字。\n        // 由于数字范围均在 [1,n][1,n] 中，我们也可以用一个长度为 nn 的数组来代替哈希表。这一做法的空间复杂度是 O(n)O(n) 的。我们的目标是优化空间复杂度到 O(1)O(1)。\n        // 注意到 \\textit{nums}nums 的长度恰好也为 nn，能否让 \\textit{nums}nums 充当哈希表呢？\n        // 由于 \\textit{nums}nums 的数字范围均在 [1,n][1,n] 中，我们可以利用这一范围之外的数字，来表达「是否存在」的含义。\n        // 具体来说，遍历 \\textit{nums}nums，每遇到一个数 xx，就让 \\textit{nums}[x-1]nums[x−1] 增加 nn。\n        // 由于 \\textit{nums}nums 中所有数均在 [1,n][1,n] 中，增加以后，这些数必然大于 nn。最后我们遍历 \\textit{nums}nums，若 \\textit{nums}[i]nums[i] 未大于 nn，就说明没有遇到过数 i+1i+1。\n        // 这样我们就找到了缺失的数字。\n        // 注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 nn 取模来还原出它本来的值。\n        int len  = nums.length;\n        for (int i = 0; i < len; i++) {\n            int x = (nums[i] - 1) % len;\n            nums[x] = nums[x] + len;\n        }\n\n        List<Integer> result = new ArrayList<Integer>();\n        for (int i = 0; i < len; i++) {\n            if (nums[i] <= len) {\n                result.add(i+1);\n            }\n        }\n        return result;\n\n\n    }\n}\n\n\n// 在锻炼算法能力时，重复造轮子是不可避免的，也是应当的。因此读者们也需要尝试使用各种方法自己实现几个具有位计数功能的函数。本方法将使用位运算中移位的操作实现位计数功能。\n\n// 具体地，记 s = x \\oplus ys=x⊕y，我们可以不断地检查 ss 的最低位，如果最低位为 11，那么令计数器加一，然后我们令 ss 整体右移一位，这样 ss 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0s=0 为止。这样计数器中就累计了 ss 的二进制表示中 11 的数量。\n\nclass Solution {\n    // 具体地，记 s = x \\oplus ys=x⊕y，我们可以不断地检查 ss 的最低位，如果最低位为 11，那么令计数器加一，然后我们令 ss 整体右移一位，这样 ss 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0s=0 为止。这样计数器中就累计了 ss 的二进制表示中 11 的数量。\n\n    public int hammingDistance(int x, int y) {\n\n        // 异或操作\n        int s = x ^ y;\n\n        // 统计结果\n        int count = 0;\n        while (s != 0) {\n            // 统计个数\n            count += s & 1;\n            // 向右移1位\n            s >>= 1;\n        }\n        return count;\n\n\n    }\n}\n\n\n``JAVA class Solution { int count = 0; public int findTargetSumWays(int[] nums, int target) { subSum(nums, target, 0, 0); return count; }\n\npublic void subSum(int[] nums, int target, int index, int sub) {\n    if (index == nums.length) {\n        if (target == sub) {\n            count++;\n        }\n    }\n    else {\n        subSum(nums, target, index+1, sub+nums[index]);\n        subSum(nums, target, index+1, sub-nums[index]);\n    }\n\n}\n\n\n}\n\n\n```JAVA\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int sum = 0;\n    public TreeNode convertBST(TreeNode root) {\n\n        if (root != null) {\n            convertBST(root.right);\n            sum = sum + root.val;\n            root.val = sum;\n            convertBST(root.left);\n        }\n        return root;\n\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int result;\n    public int diameterOfBinaryTree(TreeNode root) {\n        result = 1;\n        DFS(root);\n        return result - 1;\n    }\n    public int DFS( TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftlength = DFS(root.left); // 左节点深度\n        int rightlength = DFS(root.right); // 右节点深度\n        result = Math.max(result, rightlength + leftlength + 1); // 更新结果\n\n        return Math.max(leftlength ,rightlength) + 1;\n\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n\n        if(root1 == null) {\n            return root2;\n        }\n        if(root2 == null) {\n            return root1;\n        }\n\n        TreeNode merged = new TreeNode(root1.val + root2.val);\n        merged.left = mergeTrees(root1.left, root2.left);\n        merged.right = mergeTrees(root1.right, root2.right);\n        return merged;\n\n    }\n}\n\n\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n\n        int pre = 0;\n        int count = 0;\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        mp.put(0, 1);\n\n        for(int i = 0; i < nums.length; i++) {\n            pre = pre + nums[i];\n            // 判断是否存在\n            if (mp.containsKey(pre-k)) {\n                count = count + mp.get(pre-k);\n            }\n            // getOrDefault(Object key, V defaultValue)\n            // Map集合中有这个key时，就使用这个key对应的value值\n            // 如果没有就使用默认值defaultValue\n            mp.put(pre, mp.getOrDefault(pre, 0) + 1);\n        }\n        return count;\n\n    }\n}\n\n\nclass Solution {\n    // 讲解\n    public int leastInterval(char[] tasks, int n) {\n\n        // 统计每个字符出现的个数\n        int[] arr = new int[26];\n        for(int i = 0; i < tasks.length; i++) {\n            arr[tasks[i] - 'A']++;\n        }\n\n        // 找到出现字数最多的字符\n        int maxCount = 0;\n        for(int i = 0; i < 26; i++) {\n            maxCount = Math.max(maxCount, arr[i]);\n        }\n\n        // 前maxCount-1行\n        int ret = (maxCount - 1) * (n + 1);\n        for (int i = 0; i < 26; i++) {\n\n            // 计算第maxCount行\n            if (arr[i] == maxCount) {\n                ret++;\n            }\n        }\n        // 一旦列数超过n+1就直接取数组的长度最大值\n        return Math.max(ret, tasks.length);\n    }\n} \n\n\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        // 在算法的实现中，我们可以使用数组来存储字符串 pp 和滑动窗口中每种字母的数量。\n        int slength = s.length();\n        int plength = p.length();\n\n        if (slength < plength) {\n            return new ArrayList<Integer>();\n        }\n\n\n        List<Integer> Slieder = new ArrayList<Integer>();\n    \n        int[] scount = new int[26];\n        int[] pcount = new int[26];\n    \n        // 比较第一个窗口\n        for(int i = 0; i < plength; i++) {\n            scount[s.charAt(i) - 'a']++;\n            pcount[p.charAt(i) - 'a']++;\n        }\n    \n        if (Arrays.equals(scount, pcount)) {\n            Slieder.add(0);\n        }\n    \n        // 后面其他窗口\n        for (int i = 0; i < slength - plength; i++) {\n            scount[s.charAt(i) - 'a']--;\n            scount[s.charAt(i + plength) - 'a']++;\n            if (Arrays.equals(scount, pcount)) {\n                Slieder.add(i + 1);\n            }\n    \n        }\n        return Slieder;\n\n\n    }\n}\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int pathSum(TreeNode root, int targetSum) {\n        if (root == null) {\n            return 0;\n        }\n        int res = DFS(root, targetSum);\n        res += pathSum(root.left, targetSum); // 这里不是DFS,而是pathSum\n        res += pathSum(root.right, targetSum);\n        return res;\n    }\n\n\n    public int DFS(TreeNode root, int targetSum) {\n        int result = 0;\n        if (root == null) {\n            return 0;\n        }\n\n        if (root.val == targetSum) {\n            result++;\n        } \n        result += DFS(root.left, targetSum - root.val);\n        result += DFS(root.right, targetSum - root.val);\n        return result;\n    }\n}\n\n\nclass Solution {\n    public int[][] reconstructQueue(int[][] people) {\n\n        // 将每个人按照身高从大到小进行排序，处理身高相同的人使用的方法类似\n        Arrays.sort(people, new Comparator<int[]>() {\n            public int compare(int[] person1, int[] person2) {\n                if (person1[0] != person2[0]) {\n                    return person2[0] - person1[0];\n                } else {\n                    return person1[1] - person2[1];\n                }\n            }\n        });\n\n        List<int[]> result = new ArrayList<int[]>();\n        // 复习list方法\n        for(int[] person : people) {\n            //\n            result.add(person[1], person);\n        }\n\n        return result.toArray(new int[result.size()][]);\n\n    }\n}\n\n\n完全平方数\nclass Solution {\n    public int numSquares(int n) {\n        int[] res = new int[n+1];\n        for (int i = 1; i <= n; i++) {\n            int minn = Integer.MAX_VALUE;\n            for(int j = 1; j * j <= i; j++) {\n                minn = Math.min(minn, res[i- j * j]);\n            }\n            res[i] = minn + 1;\n        }\n        return res[n];\n    }\n    \n}\n\n\nclass Solution {\n    // https://leetcode.cn/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/\n    // 背包问题\n    public int coinChange(int[] coins, int amount) {\n        int max = amount + 1;\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp,max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n\n            for (int j = 0; j < coins.length; j++) {\n\n                // 硬币面值此时大于i完全没有判断的必要\n                if (coins[j] <= i) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount? -1 :dp[amount];\n\n    }\n\n\n}\n",normalizedContent:"# leetcode做题笔记\n\n * leetcode做题笔记\n   * 两数之和\n   * 数组遍历\n\n\n# 两数之和\n\n题目描述(easy)：给定一个整数数组nums和一个整数目标值target，请你在该数组中找出 和为目标值target的那两个整数，并返回它们的数组下标。可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。可以按任意顺序返回答案。\n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n分析(easy)：使用两个for循环迭代遍历\n\n代码：\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        vector<int> result;\n        for(int i = 0; i < nums.size(); i++){\n            for(int j = i + 1; j < nums.size(); j++) {\n                if(nums[i] + nums[j] == target) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        return result;\n\n    }\n};\n\n\n\n\nclass solution {\npublic:\n    int lengthoflongestsubstring(string s) {\n        // 哈希集合，记录每个字符是否出现过\n        unordered_set<char> occ;\n        int n = s.size();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n\n        int p = -1;\n        int count  = 0;\n        // 枚举左指针的位置，初始值隐性地表示为 -1\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.erase(s[i - 1]);\n            }\n            while (p + 1 < n && !occ.count(s[p + 1])) {\n                // 不断地移动右指针\n                occ.insert(s[p + 1]);\n                p++;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            count = max(count, p - i + 1);\n        }\n        return count;\n    }\n};\n\n\n\nclass solution {\npublic:\n    double findmediansortedarrays(vector<int>& nums1, vector<int>& nums2) {\n        int nums1_length = nums1.size();\n        int nums2_length = nums2.size();\n\n        vector <int> num;\n        int nums1index = 0;\n        int nums2index = 0;\n\n\n        while (nums1index < nums1_length && nums2index < nums2_length) {\n            if (nums1[nums1index] <= nums2[nums2index]) {\n                num.push_back(nums1[nums1index]);\n                nums1index++;\n                // num.push_back(nums1[nums1index]);\n            }\n            else {\n                num.push_back(nums2[nums2index]);\n                nums2index++;\n                // num.push_back(nums1[nums2index]);\n            }\n            \n        }\n\n        while (nums1index < nums1_length) {\n            num.push_back(nums1[nums1index]);\n            nums1index++; \n        }\n\n        while (nums2index < nums2_length) {\n            num.push_back(nums2[nums2index]);\n            nums2index++;\n        }\n\n\n\n        if (num.size() % 2 == 0){\n            return (num[num.size() / 2] * 1.0 + num[num.size() / 2 - 1]*1.0) / 2;\n        }\n        else {\n            return num[num.size() / 2] ;\n        }\n\n\n    }\n};\n\n\n\npublic class solution {\n\n    public string longestpalindrome(string s) {\n        int len = s.length();\n        if (len < 2) {\n            return s;\n        }\n\n        int maxlen = 1;\n        int begin = 0;\n        // dp[i][j] 表示 s[i..j] 是否是回文串\n        boolean[][] dp = new boolean[len][len];\n        // 初始化：所有长度为 1 的子串都是回文串\n        for (int i = 0; i < len; i++) {\n            dp[i][i] = true;\n        }\n\n        char[] chararray = s.tochararray();\n        // 递推开始\n        // 先枚举子串长度\n        for (int l = 2; l <= len; l++) {\n            // 枚举左边界，左边界的上限设置可以宽松一些\n            for (int i = 0; i < len; i++) {\n                // 由 l 和 i 可以确定右边界，即 j - i + 1 = l 得\n                int j = l + i - 1;\n                // 如果右边界越界，就可以退出当前循环\n                if (j >= len) {\n                    break;\n                }\n\n                if (chararray[i] != chararray[j]) {\n                    dp[i][j] = false;\n                } else {\n                    // 此时的chararray[i]和chararray[j]已经相等了，所以必然为回文字符串\n                    if (j - i < 3) {\n                        dp[i][j] = true;\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n\n                // 只要 dp[i][l] == true 成立，就表示子串 s[i..l] 是回文，此时记录回文长度和起始位置\n                if (dp[i][j] && j - i + 1 > maxlen) {\n                    maxlen = j - i + 1;\n                    begin = i;\n                }\n            }\n        }\n        return s.substring(begin, begin + maxlen);\n    }\n}\n\n\n\nclass solution {\npublic:\n    bool ismatch(string s, string p) {\n\n\n        // 这道题目没看懂\n                int m = s.size();\n        int n = p.size();\n\n        auto matches = [&](int i, int j) {\n            if (i == 0) {\n                return false;\n            }\n            if (p[j - 1] == '.') {\n                return true;\n            }\n            return s[i - 1] == p[j - 1];\n        };\n\n        vector<vector<int>> f(m + 1, vector<int>(n + 1));\n        f[0][0] = true;\n        for (int i = 0; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (p[j - 1] == '*') {\n                    f[i][j] |= f[i][j - 2];\n                    if (matches(i, j - 1)) {\n                        f[i][j] |= f[i - 1][j];\n                    }\n                }\n                else {\n                    if (matches(i, j)) {\n                        f[i][j] |= f[i - 1][j - 1];\n                    }\n                }\n            }\n        }\n        return f[m][n];\n\n\n    }\n};\n\n\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) :al(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* addtwonumbers(listnode* l1, listnode* l2) {\n        listnode *head = nullptr;\n        listnode *tail = nullptr;\n        int carry = 0;\n\n        while (l1 || l2) {\n            int n1 = l1 ? l1->val : 0;\n            int n2 = l2 ? l2->val : 0;\n\n            int sum = n1 + n2 + carry;\n            if(!head) {\n                head = tail = new listnode(sum % 10);\n            }\n            else {\n                tail->next = new listnode(sum % 10);\n                tail = tail->next;\n            }\n            carry = sum / 10;\n\n            if(l1) {\n                l1 = l1->next;\n            }\n            if(l2) {\n                l2 = l2->next;\n            }\n        }\n\n        if(carry > 0) {\n            tail->next = new listnode(carry);\n        }\n        return head;\n\n    }\n};\n\n\n\n\n# 数组遍历\n\n首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[l]nums[l] 和 nums[r]nums[r]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集 如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环 如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过 当 sumsum == 00 时，nums[l]nums[l] == nums[l+1]nums[l+1] 则会导致结果重复，应该跳过，l++l++ 当 sumsum == 00 时，nums[r]nums[r] == nums[r-1]nums[r−1] 则会导致结果重复，应该跳过，r--r−− 时间复杂度：o(n^2)o(n 2 )，nn 为数组长度\n\n作者：guanpengchn 链接：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/ 来源：力扣（leetcode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n暴力破解不行\n\nclass solution {\npublic:\n    vector<vector<int>> threesum(vector<int>& nums) {\n        vector<vector<int> > num;\n        int index = -1;\n        for(int i = 0; i < nums.size(); i++) {\n            for(int j = i+ 1; j <nums.size(); j++) {\n                for (int k = j + 1; k < nums.size(); k++ ) {\n                    if (nums[i] + nums[j] + nums[k] == 0) {\n                        index++;\n                        num.push_back(vector<int>());\n                        num[index].push_back(nums[i]);\n                        num[index].push_back(nums[j]);\n                        num[index].push_back(nums[k]);\n                    }\n                }\n            }\n        }\n        return num;\n        \n    }\n};\n\n\n\nclass solution {\npublic:\n    vector<vector<int>> threesum(vector<int>& nums) {\n        int n = nums.size();\n\n        // 排序去重\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        // 枚举 a\n        for (int first = 0; first < n; ++first) {\n            // 需要和上一次枚举的数不相同\n\n            if(nums[first] > 0) {\n                break;\n            }\n            if (first > 0 && nums[first] == nums[first - 1]) {\n                continue;\n            }\n            // c 对应的指针初始指向数组的最右端\n            int third = n - 1;\n            int target = -nums[first];\n            // 枚举 b\n            for (int second = first + 1; second < n; ++second) {\n                // 需要和上一次枚举的数不相同\n                if (second > first + 1 && nums[second] == nums[second - 1]) {\n                    continue;\n                }\n                // 需要保证 b 的指针在 c 的指针的左侧\n                while (second < third && nums[second] + nums[third] > target) {\n                    --third;\n                }\n                // 如果指针重合，随着 b 后续的增加\n                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环\n                if (second == third) {\n                    break;\n                }\n                if (nums[second] + nums[third] == target) {\n                    ans.push_back({nums[first], nums[second], nums[third]});\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* mergetwolists(listnode* list1, listnode* list2) {\n\n\n        if (list1 == null) {\n            return list2;\n        }\n        if (list2 == null) {\n            return list1;\n        }\n\n        listnode *head = new listnode;\n        listnode *tail = head;\n\n        while (list1 && list2) {\n            int n1 = list1->val;\n            int n2 = list2->val;\n\n            // tail->next = new listnode();\n            if (n1 <= n2) {\n                tail->next = list1;\n                list1 = list1->next;\n            }\n            else {\n                tail->next = list2;\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n\n        tail->next = list1 == null? list2 : list1;\n\n\n        return head->next; \n    }\n};\n\n\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* removenthfromend(listnode* head, int n) {\n\n\n        // 首先获取长度\n        listnode *tail = head;\n        int count = 0;\n        while (tail) {\n            count = count + 1;\n            tail = tail->next; \n        }\n\n        // 头插一个指针\n        // 主要目的避免指针赋值错误\n        listnode* dummy = new listnode(0, head);\n        tail = dummy;\n        for (int i = 1; i < count - n + 1; ++i) {\n            tail = tail->next;\n        }\n        listnode *temptail = tail->next;\n        tail->next = temptail->next;\n        listnode* ans = dummy->next;\n        delete dummy;\n        return ans;\n    }\n};\n\n\n\nclass solution {\npublic:\n    bool isvalid(string s) {\n        int n = s.size();\n        if (n % 2 == 1 || n == 0) {\n            return false;\n        }\n        stack<char>sta;\n        for(int i = 0; i < n; i++) {\n            char ch = s[i];\n            if (sta.empty()) {\n                sta.push(ch);\n            }\n            else {\n                char tempch = sta.top();\n                if(tempch == '(' && ch == ')' || tempch == '[' && ch == ']' || tempch == '{' && ch == '}') {\n                    sta.pop();\n                }\n                else {\n                    sta.push(ch);\n                }\n            }\n        }\n        if(sta.empty()) {\n            return true;\n        }\n        else {\n            return false;\n        }\n\n    }\n};\n\n\n\nclass solution {\npublic:\n    vector<string> result;\n    vector<string> lettercombinations(string digits) {\n\n        if(digits.size() == 0) {\n            return result;\n        }\n\n        //从零开始进行深度搜索\n        dfs(digits, 0);\n        return result;\n\n    }\n\n    void dfs(string digits, int index) {\n\n        // 迭代终止条件\n        if(index == digits.length()) {\n            result.push_back(digits);\n            return;\n        }\n\n        // 持续深度搜索\n        switch(digits[index]){\n            case '2': digits[index] = 'a'; dfs(digits,index+1);\n                      digits[index] = 'b'; dfs(digits,index+1);  \n                      digits[index] = 'c'; dfs(digits,index+1);\n                      break;\n            case '3': digits[index] = 'd'; dfs(digits,index+1);\n                      digits[index] = 'e'; dfs(digits,index+1);  \n                      digits[index] = 'f'; dfs(digits,index+1);\n                      break;  \n            case '4': digits[index] = 'g'; dfs(digits,index+1);\n                      digits[index] = 'h'; dfs(digits,index+1);  \n                      digits[index] = 'i'; dfs(digits,index+1);\n                      break;  \n            case '5': digits[index] = 'j'; dfs(digits,index+1);\n                      digits[index] = 'k'; dfs(digits,index+1);  \n                      digits[index] = 'l'; dfs(digits,index+1);\n                      break; \n            case '6': digits[index] = 'm'; dfs(digits,index+1);\n                      digits[index] = 'n'; dfs(digits,index+1);  \n                      digits[index] = 'o'; dfs(digits,index+1);\n                      break;  \n            case '7': digits[index] = 'p'; dfs(digits,index+1);\n                      digits[index] = 'q'; dfs(digits,index+1);  \n                      digits[index] = 'r'; dfs(digits,index+1);\n                      digits[index] = 's'; dfs(digits,index+1);\n                      break;  \n            case '8': digits[index] = 't'; dfs(digits,index+1);\n                      digits[index] = 'u'; dfs(digits,index+1);  \n                      digits[index] = 'v'; dfs(digits,index+1);\n                      break;  \n            case '9': digits[index] = 'w'; dfs(digits,index+1);\n                      digits[index] = 'x'; dfs(digits,index+1);  \n                      digits[index] = 'y'; dfs(digits,index+1);\n                      digits[index] = 'z'; dfs(digits,index+1);\n                      break;\n            \n\n        }\n    }\n};\n\n\n\nclass solution {\npublic:\n\n    vector<string> result;\n    vector<string> generateparenthesis(int n) {\n        dfs(\"(\", n-1, n);\n        return result;\n    }\n\n    void dfs (string str, int left, int right) {\n        if (left < 0 || right < 0 || right < left) {\n            return;\n        }\n        if (left == 0 && right == 0) {\n            result.push_back(str);\n            return;\n        }\n        dfs(str + '(', left-1, right);\n        dfs(str + ')', left, right-1);\n    }\n\n        \n};\n\n\n\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n\n    listnode* addtwolists(listnode *a, listnode *b) {\n        // 要是a为空b不空，直接返回b\n        // 要是a不空但是lists[i]为空返回a\n        if ((!a) || (!b)) {\n            return a ? a: b;\n        }\n        listnode head, *tail = &head;\n        listnode *tempa = a;\n        listnode *tempb = b;\n        while(tempa && tempb) {\n            if (tempa->val >= tempb->val) {\n                tail->next = tempb;\n                tempb = tempb->next;\n            }\n            else {\n                tail->next = tempa;\n                tempa = tempa->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = (tempa ? tempa : tempb);\n        return head.next;\n    }\n    listnode* mergeklists(vector<listnode*>& lists) {\n\n        listnode *ans = nullptr;\n        for(size_t i = 0; i < lists.size(); i++) {\n            ans = addtwolists(ans, lists[i]);\n        }\n        return ans;\n    }\n};\n\n\n\nclass solution {\n    public int search(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n\n二分查找\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        if (n == 0) {\n            return -1;\n        }\n        if (n == 1) {\n            return nums[0] == target ? 0 : -1;\n        }\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n\n\n\nclass solution {\n\n\n    public int[] searchrange(int[] nums, int target) {\n        // 默认找到符合题意最小的\n        int leftidx = binarysearch(nums, target, true);\n        // 找到比符合题意大的下一个\n        int rightidx = binarysearch(nums, target, false) - 1;\n        if (leftidx <= rightidx && rightidx < nums.length && nums[leftidx] == target && nums[rightidx] == target) {\n            return new int[]{leftidx, rightidx};\n        } \n        return new int[]{-1, -1};\n    }\n\n    public int binarysearch(int[] nums, int target, boolean lower) {\n        int left = 0, right = nums.length - 1, ans = nums.length;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > target || (lower && nums[mid] >= target)) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n\n\n\nimport java.util.arraydeque;\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.deque;\nimport java.util.list;\n\n\nclass solution {\n    public list<list<integer>> combinationsum(int[] candidates, int target) {\n\n        int len = candidates.length;\n\n\n        // 声明结果\n        list<list<integer>> result = new arraylist<>();\n\n        if(len == 0) {\n            return result;\n        }\n\n        // 首先排序\n        arrays.sort(candidates);\n        deque<integer> path = new arraydeque<>();\n        dfs(candidates, 0, len, target, path, result);\n        return result;\n    }\n\n    private void dfs (int[] candidates, int begin, int len, int target, deque<integer> path, list<list<integer>> result) {\n\n        // 递归终止条件值只判断等于 0 的情况\n        if (target == 0) {\n            result.add(new arraylist<>(path));\n            return;\n        }\n\n        for (int i = begin; i < len; i++) {\n            if(target - candidates[i] < 0) {\n                break;\n            }\n\n            path.addlast(candidates[i]);\n            dfs(candidates, i, len, target - candidates[i], path, result);\n            path.removelast();\n        }\n\n    }\n}\n\n\nimport java.util.arraylist;\nimport java.util.list;\n\n\nclass solution {\n    public list<list<integer>> permute(int[] nums) {\n\n\n        // 首先是特判\n        int len = nums.length;\n        // 使用一个动态数组保存所有可能的全排列\n        list<list<integer>> result = new arraylist<>();\n\n        if (len == 0) {\n            return result;\n        }\n\n        boolean[] label = new boolean[len];\n        list<integer> path = new arraylist<>();\n\n        dfs(nums, 0, len, label, path, result);\n        return result;\n    }\n    \n    public void dfs (int[] nums, int depth, int len, boolean[] label, list<integer> path, list<list<integer>> result) {\n\n        if (depth == len) {\n            result.add(path);\n            return;\n        }\n\n        for (int i = 0; i < len; i++) {\n            if (!label[i]) {\n\n                // 保存当前路径到新的list中\n                list<integer> newpath = new arraylist<>(path);\n                // 添加状态\n                newpath.add(nums[i]);\n\n                // 保存新的状态\n                boolean[] newlabel = new boolean[len];\n\n                for (int j = 0; j < len; j++) {\n                    newlabel[j] = label[j];\n                }\n                // system.arraycopy(label, 0, len, newlabel, 0, len);\n                newlabel[i] = true;\n                dfs(nums, depth + 1, len, newlabel, newpath, result);\n            }\n        }\n\n    }\n}\n\n\nclass solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int[][] matrix_new = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix_new[j][n - i - 1] = matrix[i][j];\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix[i][j] = matrix_new[i][j];\n            }\n        }\n    }\n}\n\n\nclass solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n\n        int len = n % 2 == 0? n / 2 : n / 2 + 1;\n\n        for(int i = 0; i < len; i++) {\n            // arraylist<integer> newlist = new arraylist<integer>();\n\n            for (int j = i; j < n-i-1; j++) {\n            \n                if (j >= i) {\n                arraylist<integer> newlist = new arraylist<integer>();\n                newlist.add(matrix[n-1-j][i]);  // 13\n                newlist.add(matrix[i][j]);  // 1\n                newlist.add(matrix[j][n-1-i]);  //10\n                newlist.add(matrix[n-1-i][n-1-j]);  // 12\n                matrix[i][j] = newlist.get(0);  // 13\n                matrix[j][n-1-i] = newlist.get(1);  // 1\n                matrix[n-1-i][n-1-j] = newlist.get(2);  // 10\n                matrix[n-1-j][i] = newlist.get(3);  // 12\n                }\n            }\n        }\n \n    }\n}\n\n\nclass solution {\n    // 两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。\n\n    // 遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。\n\n\n    public list<list<string>> groupanagrams(string[] strs) {\n        map<string, list<string>> map = new hashmap<string, list<string>>();\n        // 由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。\n        for (int i = 0; i < strs.length; i++) {\n            char[] strsarray = strs[i].tochararray();\n\n            arrays.sort(strsarray);\n            \n            string key = new string(strsarray);\n            list<string> list = map.getordefault(key, new arraylist<string>());\n            list.add(strs[i]);\n            map.put(key, list);\n        }\n\n        return new arraylist<list<string>>(map.values());\n\n    }\n}\n\n\nclass solution {\n    public int maxsubarray(int[] nums) {\n\n        int pre = 0;\n        int maxres = nums[0];\n\n        for(int i = 0; i < nums.length; i++) {\n            pre = math.max(pre + nums[i], nums[i]);\n\n            maxres = math.max(maxres, pre);\n\n        }\n\n        return maxres;\n\n    }\n}\n\n\nclass solution {\n    public boolean canjump(int[] nums) {\n        int maxres = 0;\n\n        for(int i = 0;  i < nums.length; i++) {\n\n            if(i <= maxres) {\n                maxres = math.max(maxres, i + nums[i] );\n                if (maxres >= nums.length-1) {\n                    return true;\n                }\n            }\n\n        }\n        return false;\n\n    }\n}\n\n\nclass solution {\n    public int[][] merge(int[][] intervals) {\n        if(intervals.length == 0) {\n            return new int[][]{};\n        }\n\n        //首先排序，这里应该是lamda表达式\n        // arrays.sort(intervals,(a,b)->{return a[0]-b[0];});\n        arrays.sort(intervals,(a,b)->{return a[0]-b[0];});\n\n        int[][] result = new int[intervals.length][2];\n        int index = 0;\n\n        int start = intervals[0][0];\n        int end = intervals[0][1];\n\n        for(int i = 1; i < intervals.length; i++) {\n\n            // 后一个的起点位置小于等于前一个的结束位置可以合并\n            if (intervals[i][0] <= end) {\n\n                // 再去判断后一个点和前一个点结束位置的大小\n                if (intervals[i][1] >= end) {\n                    end = intervals[i][1];\n                }\n                else {\n                    end = end;\n                }\n                // end  = intervals[i][1];\n            }\n            // 不能合并\n            else {\n                result[index][0] = start;\n                result[index][1] = end;\n                index++;\n                // 更新下一个位置\n                start = intervals[i][0];\n                end = intervals[i][1];\n            }\n        }\n\n        result[index][0] = start;\n        result[index][1] = end;\n        return arrays.copyofrange(result, 0, index+1);\n    }\n}\n\n\nclass solution {\n    public int uniquepaths(int m, int n) {\n        int[][] path = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            path[i][0] = 1;\n        }\n        for (int j = 0; j < n; ++j) {\n            path[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                path[i][j] = path[i - 1][j] + path[i][j - 1];\n            }\n        }\n        return path[m - 1][n - 1];\n    }\n}\n\n\nclass solution {\n    public int minpathsum(int[][] grid) {\n\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int[][] dp = new int[m][n];\n\n        // 状态初始化\n        dp[0][0] = grid[0][0];\n\n        \n        for(int i = 1; i < m; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n\n        for(int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n\n\n        for (int i = 1; i < m ; i++) {\n            for (int j = 1; j < n ; j++) {\n                dp[i][j] = grid[i][j] + math.min(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n\n        // 返回结果\n        return dp[m-1][n-1];\n    }\n}\n\n\n深度搜索超出时间限制\n\nclass solution {\n    public int climbstairs(int n) {\n        int count = 0;\n\n        return dfs(n);\n\n    }\n\n    public int dfs(int n) {\n        if (n == 0) {\n            return 1;\n        }\n        if (n < 0) {\n            return 0;\n        }\n        return dfs(n - 1) + dfs(n - 2);\n    }\n}\n\n\n本质上为斐波那契数列\n\nclass solution {\n    public int climbstairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n\n    }\n}\n\n\n// 采用栈进行分析这里有bug\n// (()这种分析不出来\nclass solution {\n    public int longestvalidparentheses(string s) {\n\n        int maxvalue = 0;\n        int temp = 0;\n\n        deque<integer> stack = new linkedlist<integer>();\n\n        // 首先放入第一个元素\n        // stack.push(s.chartat(0));\n\n        for(int i = 0; i < s.length(); i++) {\n\n            // 如果栈空必须放入新元素\n            if (stack.isempty()) {\n                stack.push(i);\n            }\n            /// 栈不是空的\n            else {\n                // 栈顶元素为(\n                if (s.charat(stack.peek()) == '(') {\n\n                    if (s.charat(i) == ')') {\n                        // 出栈\n                        stack.pop();\n                        temp = temp + 2;\n                    }\n\n                    else {\n                        stack.push(i);\n                    }\n\n                }\n                // 栈顶元素为)\n                else {\n                    maxvalue = math.max(maxvalue, temp);\n                    temp = 0;\n                }\n            }\n\n        }\n        return maxvalue;\n\n    }\n}\n\n\nclass solution {\n    public int longestvalidparentheses(string s) {\n\n        int maxvalue = 0;\n        int left = 0;\n        int right = 0;\n\n\n        // 从前往后\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charat(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxvalue = math.max(maxvalue, 2 * right);\n            } else if (right > left) {\n                left = right = 0;\n            }\n        }\n\n        //从后往前\n        left = 0;\n        right = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charat(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxvalue = math.max(maxvalue, 2 * right);\n            } else if (left > right) {\n                left = right = 0;\n            }\n        }\n        return maxvalue;\n\n    }\n}\n\n\nclass solution {\n    public int trap(int[] height) {\n        int area = 0;\n\n        deque<integer> stack = new linkedlist<integer>();\n\n        // 利用栈进行求解\n        // 栈中存储的元素为依次递减的数\n        // 然后根据递增的数进行求解\n\n        for(int i= 0; i < height.length; i++) {\n\n            // 栈不为空且后面的元素开始递增时进行出栈判断\n            while(!stack.isempty() && height[i] > height[stack.peek()]) {\n\n                // 获取中间的元素\n                int middle = stack.pop();\n\n                if (stack.isempty()) {\n                    break;\n                }\n\n                int left = stack.peek();  // 获取左边的元素\n\n                int width = i - left - 1;  // 宽度\n\n                int height = height[i] > height[left] ? height[left] : height[i];  // 获取最小值\n\n                area = area + (height - height[middle]) * width;\n\n\n            }\n\n            // 存储每个元素\n            stack.push(i);\n        }\n\n        return area;\n\n    }\n}\n\n\nclass solution {\n    public void sortcolors(int[] nums) {\n\n        int len = nums.length;\n\n        if(len <= 1) {\n            return;\n        }\n        // all in [0, zero) = 0\n        // all in [zero, i) = 1\n        // all in [two, len - 1] = 2\n        \n        // 循环终止条件是 i == two，那么循环可以继续的条件是 i < two\n        // 为了保证初始化的时候 [0, zero) 为空，设置 zero = 0，\n        // 所以下面遍历到 0 的时候，先交换，再加\n        int zero = 0;\n\n        // 为了保证初始化的时候 [two, len - 1] 为空，设置 two = len\n        // 所以下面遍历到 2 的时候，先减，再交换\n        int two = len;\n        int i = 0;\n        // 当 i == two 上面的三个子区间正好覆盖了全部数组\n        // 因此，循环可以继续的条件是 i < two\n\n\n\n        while (i < two) {\n            if(nums[i] == 0) {\n                myswap(nums, i, zero);\n                zero++;\n                i++;\n            }\n            else if (nums[i] == 1){\n                i++;\n            }\n            else {\n                two--;\n                myswap(nums, i, two);\n            }\n\n        }\n\n\n    }\n\n\n    private void myswap(int[] nums, int left, int right) {\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n    }\n}\n\n\n\nclass solution {\n    public list<list<integer>> subsets(int[] nums) {\n\n        list<integer> temp = new arraylist<integer>();\n        list<list<integer>> res = new arraylist<list<integer>>();\n\n\n        for(int mask = 0; mask < (1 << nums.length); mask++) {\n            temp.clear();\n\n            for(int i = 0; i < nums.length; i++) {\n\n                if ((mask & (1 << i)) != 0) {\n                    temp.add(nums[i]);\n                }\n            }\n\n            res.add(new arraylist<integer>(temp));\n\n\n\n\n\n        }\n        return res;\n\n    }\n}\n\n\n\n// 还有递归的中序遍历\nclass solution {\n    public list<integer> inordertraversal(treenode root) {\n\n        list<integer> result = new arraylist<integer>();\n        deque<treenode> sta = new linkedlist<treenode>();\n\n        while(root != null || !sta.isempty()) {\n\n            while(root != null) {\n                sta.push(root);\n                root = root.left;\n            }\n            root = sta.pop();\n            result.add(root.val);\n            root = root.right;\n        }\n\n        return result;\n\n    }\n}\n\n\n\n// 同样也有递归版本\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public boolean issymmetric(treenode root) {\n\n        // 左右两边同时遍历\n        return check(root, root);\n    }\n\n\n// 1、offer()和add()的区别\n// add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。可以据此在程序中进行有效的判断！\n\n// 2、peek()和element()的区别\n// peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出nosuchelementexception异常。\n\n// 3、poll()和remove()的区别\n// poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出nosuchelementexception异常。\n    public boolean check(treenode u, treenode v){\n        queue<treenode> q = new linkedlist<treenode>();\n\n        // 添加一个元素到队尾\n        q.offer(u);\n        q.offer(v);\n\n        while(!q.isempty()) {\n            u = q.poll();\n            v = q.poll();\n\n\n            //如果两个节点都为空就继续循环，两者有一个为空就返回false\n            if(u == null && v == null) {\n                continue;\n\n            }\n\n            //如果两个节点都为空就继续循环，两者有一个为空就返回false\n            if ((u == null || v == null)) {\n                return false;\n            }\n\n            if (u.val != v.val) {\n                return false;\n            }\n            //将左节点的左孩子， 右节点的右孩子放入队列\n            q.offer(u.left);\n            q.offer(v.right);\n            \n            \n            q.offer(u.right);\n            q.offer(v.left);\n        }\n        return true;\n\n\n\n\n    }\n}\n\n\n\nclass solution {\n    public int numtrees(int n) {\n        // 以每一个点为中心分别计算两边\n        //\n        int[] count = new int[n+1];\n        count[0] = 1;\n        count[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n\n            for(int j = 1; j <= i; j++) {\n                count[i] = count[i] + count[j - 1] * count[i - j];\n            }\n        }\n        return count[n];\n\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        list<list<integer>> result = new arraylist<list<integer>>();\n\n        if (root == null) {\n            return result;\n        }\n\n\n        queue<treenode> queue = new linkedlist<treenode>();\n        // 根节点入队列\n        queue.offer(root);\n\n        while (!queue.isempty()) {\n\n            list<integer> level = new arraylist<integer>();\n\n            int queuelength = queue.size();\n\n            // 把当前队列中所有点对应的下一层全部存起来\n            for(int i = 0; i < queuelength; i++) {\n                // 取出队列先进来的元素\n                treenode node = queue.poll();\n                level.add(node.val);\n\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n\n                if(node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n            result.add(level);\n        }\n        return result;\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public boolean isvalidbst(treenode root) {\n        return isvalidbst(root, long.min_value, long.max_value);\n    }\n    public boolean isvalidbst(treenode root, long min, long max) {\n        if (root == null) {\n            return true;\n        }\n        if (root.val <= min || root.val >= max) {\n            return false;\n        }\n        return isvalidbst(root.left, min, root.val) && isvalidbst(root.right, root.val, max);\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public int maxdepth(treenode root) {\n\n        int count = 0;\n\n        if (root == null) {\n            return count;\n        }\n        queue<treenode> queue = new linkedlist<treenode>();\n        // 根节点入队列\n        queue.offer(root);\n\n        while (!queue.isempty()) {\n            count = count + 1;\n\n            int queuelength = queue.size();\n            for(int i = 0; i < queuelength; i++) {\n                // 取出队列先进来的元素\n                treenode node = queue.poll();\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n\n                if(node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n        }\n        return count;\n    }\n}\n\n\n\n\n深度遍历\n\nclass solution {\n    public int maxdepth(treenode root) {\n        if(root == null) {\n            return 0;\n        } else {\n            int left = maxdepth(root.left);\n            int right = maxdepth(root.right);\n            return math.max(left, right) + 1;\n        }\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n\n//     我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；\n\n// 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；\n\n// 无论是哪一种情况，我们最后都将当前的节点入栈。\n    public treenode buildtree(int[] preorder, int[] inorder) {\n        // preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]\n        // inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]\n//         3\n//        / \\\n//       9  20\n//      /  /  \\\n//     8  15   7\n//    / \\\n//   5  10\n//  /\n// 4\n\n        if (preorder.length == 0 || preorder == null) {\n            return null;\n        }\n\n\n        // 找到先序遍历的根节点\n        treenode root = new treenode(preorder[0]);\n        // 声明栈\n        deque<treenode> stack = new linkedlist<treenode>();\n        // 根节点入栈\n        stack.push(root);\n\n        int index = 0;\n\n        for(int i = 1; i < preorder.length; i++) {\n            int preorderval = preorder[i];\n            // peek不改变栈的值(不删除栈顶的值)，pop会把栈顶的值删除。\n            treenode node = stack.peek();\n\n            if (node.val != inorder[index]) {\n                node.left = new treenode(preorderval);\n                stack.push(node.left);\n            }\n            else {\n                // 栈中的节点的顺序和它们在前序遍历中出现的顺序是一致\n                // 而且每一个节点的右儿子都还没有被遍历过\n                // 那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的\n                while (!stack.isempty() && stack.peek().val == inorder[index]) {\n                    node = stack.pop();\n                    index++;\n                }\n                node.right = new treenode(preorderval);\n                stack.push(node.right);\n            }\n        }\n        return root;\n\n    }\n}\n\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public void flatten(treenode root) {\n\n        list<treenode> list = new arraylist<treenode>();\n\n        deque<treenode> stack = new linkedlist<treenode>();\n\n        treenode node = root;\n\n        while(node != null || !stack.isempty()) {\n            while (node != null) {\n                list.add(node);\n                stack.push(node);\n                node = node.left;\n            }\n            node = stack.pop();\n            node = node.right;\n        }\n\n        int size = list.size();\n\n        for(int i = 1; i < size; i++) {\n            treenode prev = list.get(i-1);\n            treenode next = list.get(i);\n            prev.left = null;\n            prev.right = next;\n            next.left = null;\n            next.right = null;\n        }\n    }\n}\n\n\nclass solution {\n    public int maxprofit(int[] prices) {\n        int minprice = integer.max_value;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minprice) {\n                minprice = prices[i];\n            } else if (prices[i] - minprice > maxprofit) {\n                maxprofit = prices[i] - minprice;\n            }\n        }\n        return maxprofit;\n    }\n\n}\n\n\n// import java.util.arrays;\n\nclass solution {\n    public int longestconsecutive(int[] nums) {\n        if (nums.length <= 0) {\n            return 0;\n        }\n\n        if (nums.length == 1) {\n            return 1;\n        }\n\n        arrays.sort(nums);\n        int index = 1;\n        int maxlength = 0;\n\n        for(int i = 0; i < nums.length-1; i++) {\n            if (nums[i+1] != nums[i]) {\n                if (nums[i+1] - nums[i] == 1) {\n                    index++;\n                    // maxlength = index > maxlength ? index : maxlength;\n\n                }\n                else {\n                    index=1;\n                    \n                }\n            }\n            maxlength = index > maxlength ? index : maxlength;\n        }\n        return maxlength;\n    }\n}\n\n\nclass solution {\n    public int singlenumber(int[] nums) {\n\n        if(nums.length == 1) {\n            return nums[0];\n        }\n\n        // 默认元素全部大于0\n        map<integer, integer> map = new hashmap<>();\n        for (integer i : nums) {\n            integer count = map.get(i);\n            count = count == null ? 1 : ++count;\n            map.put(i, count);\n        }\n        for (integer i : map.keyset()) {\n            integer count = map.get(i);\n            if (count == 1) {\n                return i;\n            }\n        }\n        return -1; // can't find it.\n\n    }\n}\n\n\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public boolean hascycle(listnode head) {\n        set<listnode> seen = new hashset<listnode>();\n        while (head != null) {\n            if (!seen.add(head)) {\n                return true;\n            }\n            head = head.next;\n        }\n        return false;\n\n    }\n}\n\n// 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，\n// 一快一满。慢指针每次只移动一步，而快指针每次移动两步。\n// 初始时，慢指针在位置 head，而快指针在位置 head.next。\n// 这样一来，如果在移动的过程中，快指针反过来追上慢指针，\n// 就说明该链表为环形链表。否则快指针将到达链表尾部，\n// 该链表不为环形链表。\n\n\npublic class solution {\n    public boolean hascycle(listnode head) {\n        // 起始：fast、slow = head\n        // 核心：fast = fast.next.next;slow = slow.next;fast==slow?return true:fast\n        // 终止：fast!=null && fast.next!=null\n        if(head == null || head.next == null)return false; \n        listnode fast = head;\n        listnode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n\nclass solution {\n    public boolean wordbreak(string s, list<string> worddict) {\n        set<string> worddictset = new hashset(worddict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && worddictset.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n\n\n// slow * 2 = fast;\n// slow = a + b;\n// fast = a + b + c + b = a + 2*b + c;\n// (a + b)*2 = a + 2*b + c;\n// a = c;\n// 口头解释就是\n// 快针走的是慢针的两倍。\n// 慢针走过的路，快针走过一遍。\n// 快针走过的剩余路程，也就是和慢针走过的全部路程相等。(a+b = c+b)\n// 刨去快针追赶慢针的半圈(b)，剩余路程即为所求入环距离(a=c)\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public listnode detectcycle(listnode head) {\n\n        if(head == null) {\n            return null;\n        }\n\n        listnode pre = head;\n        listnode fast = head;\n\n        while(fast != null) {\n\n            pre = pre.next;\n            if(fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n\n            // 二者重合必然有环\n            if(pre == fast) {\n                listnode pr = head;\n                while (pr != pre) {\n                    pr = pr.next;\n                    pre = pre.next;\n                }\n                return pr;\n            }\n\n        }\n        return null;\n        \n    }\n}\n\n\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        arrays.sort(nums);\n        return nums[nums.length / 2];\n    }\n}\n\n\nclass solution {\n    public int maxproduct(int[] nums) {\n\n        int max = integer.min_value;\n        int imax = 1;\n        int imin = 1;\n\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] < 0) {\n\n                int temp = imax;\n                imax = imin;\n                imin = temp;\n            }\n            \n            imax = math.max(imax * nums[i], nums[i]);\n            imin = math.min(imin * nums[i], nums[i]);\n\n            max = math.max(max, imax);\n        }\n        return max;\n    }\n}\n\n\nclass solution {\n    public int numislands(char[][] grid) {\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int count = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n\n    }\n\n    void dfs (char[][] grid, int i, int j) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0') {\n            return;\n        }\n\n        grid[i][j] = '0';\n        dfs(grid, i-1, j);\n        dfs(grid, i+1, j);\n        dfs(grid, i, j-1);\n        dfs(grid, i, j+1);\n    }\n}\n\n\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode sortlist(listnode head) {\n        return sortlist(head, null);\n\n    }\n\n    public listnode sortlist(listnode head, listnode tail) {\n        if (head == null) {\n            return head;\n        }\n        if (head.next == tail) {\n            head.next = null;\n            return head;\n        }\n\n        listnode slow = head; // 移动到中间的地方\n        listnode fast = head;  // 移动到尾部\n\n        while(fast != tail) {\n            slow = slow.next;\n            fast = fast.next;\n            if (fast != tail) {\n                fast = fast.next;\n            }\n        }\n\n        listnode mid = slow;\n        listnode list1 = sortlist(head, mid);\n        listnode list2 = sortlist(mid, tail);\n\n        listnode res = merge(list1, list2);\n        return res;\n    }\n\n    public listnode merge(listnode head1, listnode head2) {\n\n        listnode dyhead = new listnode(0);\n        \n        listnode temp = dyhead;\n        listnode temp1 = head1;\n        listnode temp2 = head2;\n\n        while(temp1 != null && temp2 != null) {\n            if(temp1.val < temp2.val) {\n                temp.next = temp1;\n                temp1 = temp1.next;\n            }\n            else {\n                temp.next = temp2;\n                temp2 = temp2.next;\n            }\n            temp = temp.next;\n        }\n        if (temp1 != null) {\n            temp.next = temp1;\n        }\n        if (temp2 != null) {\n            temp.next = temp2;\n        }\n\n        return dyhead.next;\n\n    }\n}\n\n\nclass minstack {\n    deque<integer> stack;\n    deque<integer> minstack;\n    public minstack() {\n        stack = new linkedlist<integer>();\n        minstack = new linkedlist<integer>();\n        minstack.push(integer.max_value);\n\n    }\n    \n    public void push(int val) {\n        stack.push(val);\n        minstack.push(math.min(val, minstack.peek()));\n    }\n    \n    public void pop() {\n        stack.pop();\n        minstack.pop();\n\n    }\n    \n    public int top() {\n        return stack.peek();\n\n    }\n    \n    public int getmin() {\n        return minstack.peek();\n\n    }\n}\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack obj = new minstack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getmin();\n */\n\n\n\n\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class solution {\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n\n        if(heada == null || headb == null) {\n            return null;\n        }\n\n        listnode pa = heada;\n        listnode pb = headb;\n        while(pa != pb) {\n\n            pa = pa == null ? headb : pa.next;\n            pb = pb == null ? heada : pb.next;\n\n        }\n        return pb;       \n    }\n}\n\n\nclass solution {\n    public int rob(int[] nums) {\n\n        int len = nums.length;\n        if (len == 1) {\n            return nums[0];\n        }\n        else {\n            int[] dp = new int[len];\n            dp[0] = nums[0];\n            dp[1] = math.max(nums[0], nums[1]);\n\n            for (int i = 2; i < len; i++) {\n                dp[i] = math.max(dp[i-2] + nums[i], dp[i-1]);\n            }\n            return dp[len - 1];\n        }\n\n    }\n}\n\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n    public listnode reverselist(listnode head) {\n        deque<listnode> stack = new linkedlist<listnode>();\n\n        listnode phead = head;\n\n        if (phead == null) {\n            return phead;\n        }\n\n        while (phead != null) {\n            stack.push(phead);\n            phead = phead.next;\n        }\n\n        listnode res = stack.pop();\n        listnode finalres = res;\n        while(!stack.isempty()) {\n            res.next = stack.pop();\n            res = res.next;\n        }\n        res.next = null;\n        return finalres;\n\n        \n    }\n}\n\n\n\n\n// 第二种是双指针\nclass solution {\n    public listnode reverselist(listnode head) {\n        listnode prev = null;\n        listnode curr = head;\n        while (curr != null) {\n            listnode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}\n\n\n\nclass solution {\n    public boolean canfinish(int numcourses, int[][] prerequisites) {\n        // 声明存储图结构的变量\n        list<list<integer>> graph = new arraylist<>();\n        for (int i = 0; i < numcourses; i++) {\n            graph.add(new arraylist<integer>());\n        }\n\n        int[] visited = new int[numcourses];\n\n        for(int i = 0; i < prerequisites.length; i++) {\n\n            int nowcourse = prerequisites[i][0];\n            int precourse = prerequisites[i][1];\n\n            // 下标为nowcourse的数组里面的内容是nowcourse的所有前置课程\n            graph.get(nowcourse).add(precourse);\n        }\n\n        // 深度遍历\n\n        for(int i = 0; i < numcourses; i++) {\n            if (dfs(graph, visited, i) == true) {\n                return false;\n            }\n        }\n        return true;\n\n    }\n\n    public boolean dfs(list<list<integer>> graph, int[] visited, int index) {\n        // 1代表次节点正在被访问, 如果正在被访问的节点，再次被访问，则存在环，无法完成课程\n        if (visited[index] == 1) {\n            return true;\n        }\n        // 2代表节点被访问过，无需再次访问\n        if (visited[index] == 2) {\n            return false;\n        }\n\n\n        // 设置该课程为正在访问的状态\n        visited[index] = 1;\n\n        for (integer next : graph.get(index)) {\n\n            if (dfs(graph, visited, next) == true) {\n                return true;\n            }\n        }\n\n        // 当前课程已经被访问\n        visited[index] = 2;\n        return false;\n\n    }\n}\n\n\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\n\n\n// 整个流程可以分为以下五个步骤：\n// 找到前半部分链表的尾节点。\n// 反转后半部分链表。\n// 判断是否回文。\n// 恢复链表。\n// 返回结果。\n\nclass solution {\n    public boolean ispalindrome(listnode head) {\n\n        // 找到中间位置和结束位置\n        listnode slow = head;\n        listnode fast = head;\n\n\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // 反转后面的数据\n        listnode middle = slow;\n\n        listnode secondhalfstart = reverselist(middle.next);\n\n        listnode p1 = head;\n        listnode p2 = secondhalfstart;\n\n        boolean result = true;\n\n        while (result && p2 != null) {\n            if (p1.val != p2.val) {\n                result = false;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n\n        middle.next = reverselist(secondhalfstart);\n        return result;\n\n    }\n\n\n    private listnode reverselist(listnode head) {\n        listnode prev = null;\n        listnode curr = head;\n        while (curr != null) {\n            listnode nexttemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nexttemp;\n        }\n        return prev;\n    }\n\n}\n\n\n\n/**\n     * 递归方式遍历反转\n     */\n    public treenode inverttree(treenode root) {\n        if (root == null) {\n            return null;\n        }\n\n        treenode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n\n        inverttree(root.left);\n        inverttree(root.right);\n        return root;\n    }\n\n    /**\n     * 层序遍历方式反转\n     */\n    public treenode inverttreebyqueue(treenode root) {\n        if (root == null) {\n            return null;\n        }\n        queue<treenode> queue = new arraydeque<>();\n        queue.offer(root);\n        while (!queue.isempty()) {\n            treenode node = queue.poll();\n            treenode temp = node.left;\n            node.left = node.right;\n            node.right = temp;\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n        }\n        return root;\n    }\n\n\n\nclass node {\n    boolean is_end;\n    node[] son = new node[26];\n    node() {\n        is_end = false;\n        for (int i = 0; i < 26; i++) {\n            son[i] = null;\n        }\n    }\n}\n\n\nclass trie {\n\n    node root;\n\n    public trie() {\n        root = new node();\n    }\n    \n    public void insert(string word) {\n        node p = root;\n        for(int i = 0; i < word.length(); i++) {\n\n            int val = word.charat(i) - 'a';\n            if(p.son[val] == null) {\n                p.son[val] = new node();\n            }\n            p = p.son[val];\n        }\n        p.is_end = true;\n\n    }\n    \n    public boolean search(string word) {\n        node p = root;\n        for(int i = 0; i < word.length(); i++) {\n\n            int val = word.charat(i) - 'a';\n            if(p.son[val] == null) {\n                return false;\n            }\n            p = p.son[val];\n        }\n        return p.is_end;\n    }\n    \n    public boolean startswith(string prefix) {\n        node p = root;\n        for(int i = 0;i < prefix.length();i ++)\n        {\n            int u = prefix.charat(i) - 'a';\n            if(p.son[u] == null) return false;\n            p = p.son[u]; \n        }\n        return true;\n\n    }\n}\n\n/**\n * your trie object will be instantiated and called as such:\n * trie obj = new trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startswith(prefix);\n */\n\n\n// https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\n// 这个题目可以重新做一下\nclass solution {\n    public int findkthlargest(int[] nums, int k) {\n        arrays.sort(nums);\n        return nums[nums.length - k];\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    map<integer, treenode> parent = new hashmap<integer, treenode>();\n    set<integer> visited = new hashset<integer>();\n\n    public void dfs(treenode root) {\n        if (root.left != null) {\n            parent.put(root.left.val, root);\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            parent.put(root.right.val, root);\n            dfs(root.right);\n        }\n    }\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        dfs(root);\n\n\n        // 找到了p的所有父节点\n        while (p!=null) {\n            visited.add(p.val);\n            p = parent.get(p.val);\n        }\n\n        // 根据p的节点去找q的节点\n        while(q!=null) {\n            if (visited.contains(q.val)) {\n                return q;\n            }\n            q = parent.get(q.val);\n        }\n        return null;\n        \n    }\n}\n\n\nclass solution {\n    public int[] productexceptself(int[] nums) {\n\n        // 左边的先乘起来\n        int[] resultleft = new int[nums.length];\n        resultleft[0] = 1;\n        for(int i = 1; i < nums.length; i++) {\n            resultleft[i] = nums[i-1] * resultleft[i-1];\n        }\n\n        // 右边的乘起来\n        int[] resultright = new int[nums.length];\n        resultright[nums.length-1] = 1;\n        for(int i = nums.length-2; i >= 0; i--) {\n            resultright[i] = nums[i+1] * resultright[i+1];\n        }\n\n        // 左右相乘\n        for(int i = 0; i < nums.length; i++) {\n            nums[i] = resultright[i] * resultleft[i];\n        }\n        return nums;\n\n    }\n}\n\n\n\nclass solution {\n    public boolean searchmatrix(int[][] matrix, int target) {\n\n\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        int i = 0;\n        int j = n - 1;\n\n        while (i < m && j >= 0) {\n\n            if (matrix[i][j] == target) {\n                return true;\n            }\n            else if (matrix[i][j] < target) {\n                i++;\n            }\n            else {\n                j--;\n            }\n        }\n        return false;\n        \n    }\n}\n\n\nclass solution {\n    public int[] dailytemperatures(int[] temperatures) {\n\n        int len = temperatures.length;\n        int [] result = new int[len];\n\n        deque<integer> temp = new linkedlist<integer>();\n\n        for (int i = 0; i < len; i++) {\n            int tempvalue = temperatures[i];\n            while (!temp.isempty() && tempvalue > temperatures[temp.peek()]) {\n                int pre = temp.pop();\n                result[pre] = i - pre;\n            }\n            temp.push(i);\n        }\n        return result;\n    }\n}\n\n\nclass solution {\n    public int countsubstrings(string s) {\n\n        int count = 0;\n        int len = s.length();\n\n        // i 用来控制\n        for (int i = 0; i < 2 * len - 1; i++) {\n\n            int left = i / 2;\n            int right = i / 2 + i % 2;\n            while (left >= 0 && right < len && s.charat(left) == s.charat(right)) {\n                left--;\n                right++;\n                count++;\n            }\n        }\n        return count;\n\n    }\n}\n\n\nclass solution {\n    public list<integer> finddisappearednumbers(int[] nums) {\n        // 我们可以用一个哈希表记录数组 \\textit{nums}nums 中的数字，由于数字范围均在 [1,n][1,n] 中，记录数字后我们再利用哈希表检查 [1,n][1,n] 中的每一个数是否出现，从而找到缺失的数字。\n        // 由于数字范围均在 [1,n][1,n] 中，我们也可以用一个长度为 nn 的数组来代替哈希表。这一做法的空间复杂度是 o(n)o(n) 的。我们的目标是优化空间复杂度到 o(1)o(1)。\n        // 注意到 \\textit{nums}nums 的长度恰好也为 nn，能否让 \\textit{nums}nums 充当哈希表呢？\n        // 由于 \\textit{nums}nums 的数字范围均在 [1,n][1,n] 中，我们可以利用这一范围之外的数字，来表达「是否存在」的含义。\n        // 具体来说，遍历 \\textit{nums}nums，每遇到一个数 xx，就让 \\textit{nums}[x-1]nums[x−1] 增加 nn。\n        // 由于 \\textit{nums}nums 中所有数均在 [1,n][1,n] 中，增加以后，这些数必然大于 nn。最后我们遍历 \\textit{nums}nums，若 \\textit{nums}[i]nums[i] 未大于 nn，就说明没有遇到过数 i+1i+1。\n        // 这样我们就找到了缺失的数字。\n        // 注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 nn 取模来还原出它本来的值。\n        int len  = nums.length;\n        for (int i = 0; i < len; i++) {\n            int x = (nums[i] - 1) % len;\n            nums[x] = nums[x] + len;\n        }\n\n        list<integer> result = new arraylist<integer>();\n        for (int i = 0; i < len; i++) {\n            if (nums[i] <= len) {\n                result.add(i+1);\n            }\n        }\n        return result;\n\n\n    }\n}\n\n\n// 在锻炼算法能力时，重复造轮子是不可避免的，也是应当的。因此读者们也需要尝试使用各种方法自己实现几个具有位计数功能的函数。本方法将使用位运算中移位的操作实现位计数功能。\n\n// 具体地，记 s = x \\oplus ys=x⊕y，我们可以不断地检查 ss 的最低位，如果最低位为 11，那么令计数器加一，然后我们令 ss 整体右移一位，这样 ss 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0s=0 为止。这样计数器中就累计了 ss 的二进制表示中 11 的数量。\n\nclass solution {\n    // 具体地，记 s = x \\oplus ys=x⊕y，我们可以不断地检查 ss 的最低位，如果最低位为 11，那么令计数器加一，然后我们令 ss 整体右移一位，这样 ss 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0s=0 为止。这样计数器中就累计了 ss 的二进制表示中 11 的数量。\n\n    public int hammingdistance(int x, int y) {\n\n        // 异或操作\n        int s = x ^ y;\n\n        // 统计结果\n        int count = 0;\n        while (s != 0) {\n            // 统计个数\n            count += s & 1;\n            // 向右移1位\n            s >>= 1;\n        }\n        return count;\n\n\n    }\n}\n\n\n``java class solution { int count = 0; public int findtargetsumways(int[] nums, int target) { subsum(nums, target, 0, 0); return count; }\n\npublic void subsum(int[] nums, int target, int index, int sub) {\n    if (index == nums.length) {\n        if (target == sub) {\n            count++;\n        }\n    }\n    else {\n        subsum(nums, target, index+1, sub+nums[index]);\n        subsum(nums, target, index+1, sub-nums[index]);\n    }\n\n}\n\n\n}\n\n\n```java\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    int sum = 0;\n    public treenode convertbst(treenode root) {\n\n        if (root != null) {\n            convertbst(root.right);\n            sum = sum + root.val;\n            root.val = sum;\n            convertbst(root.left);\n        }\n        return root;\n\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    int result;\n    public int diameterofbinarytree(treenode root) {\n        result = 1;\n        dfs(root);\n        return result - 1;\n    }\n    public int dfs( treenode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftlength = dfs(root.left); // 左节点深度\n        int rightlength = dfs(root.right); // 右节点深度\n        result = math.max(result, rightlength + leftlength + 1); // 更新结果\n\n        return math.max(leftlength ,rightlength) + 1;\n\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public treenode mergetrees(treenode root1, treenode root2) {\n\n        if(root1 == null) {\n            return root2;\n        }\n        if(root2 == null) {\n            return root1;\n        }\n\n        treenode merged = new treenode(root1.val + root2.val);\n        merged.left = mergetrees(root1.left, root2.left);\n        merged.right = mergetrees(root1.right, root2.right);\n        return merged;\n\n    }\n}\n\n\nclass solution {\n    public int subarraysum(int[] nums, int k) {\n\n        int pre = 0;\n        int count = 0;\n        hashmap<integer, integer> mp = new hashmap<>();\n        mp.put(0, 1);\n\n        for(int i = 0; i < nums.length; i++) {\n            pre = pre + nums[i];\n            // 判断是否存在\n            if (mp.containskey(pre-k)) {\n                count = count + mp.get(pre-k);\n            }\n            // getordefault(object key, v defaultvalue)\n            // map集合中有这个key时，就使用这个key对应的value值\n            // 如果没有就使用默认值defaultvalue\n            mp.put(pre, mp.getordefault(pre, 0) + 1);\n        }\n        return count;\n\n    }\n}\n\n\nclass solution {\n    // 讲解\n    public int leastinterval(char[] tasks, int n) {\n\n        // 统计每个字符出现的个数\n        int[] arr = new int[26];\n        for(int i = 0; i < tasks.length; i++) {\n            arr[tasks[i] - 'a']++;\n        }\n\n        // 找到出现字数最多的字符\n        int maxcount = 0;\n        for(int i = 0; i < 26; i++) {\n            maxcount = math.max(maxcount, arr[i]);\n        }\n\n        // 前maxcount-1行\n        int ret = (maxcount - 1) * (n + 1);\n        for (int i = 0; i < 26; i++) {\n\n            // 计算第maxcount行\n            if (arr[i] == maxcount) {\n                ret++;\n            }\n        }\n        // 一旦列数超过n+1就直接取数组的长度最大值\n        return math.max(ret, tasks.length);\n    }\n} \n\n\nclass solution {\n    public list<integer> findanagrams(string s, string p) {\n        // 在算法的实现中，我们可以使用数组来存储字符串 pp 和滑动窗口中每种字母的数量。\n        int slength = s.length();\n        int plength = p.length();\n\n        if (slength < plength) {\n            return new arraylist<integer>();\n        }\n\n\n        list<integer> slieder = new arraylist<integer>();\n    \n        int[] scount = new int[26];\n        int[] pcount = new int[26];\n    \n        // 比较第一个窗口\n        for(int i = 0; i < plength; i++) {\n            scount[s.charat(i) - 'a']++;\n            pcount[p.charat(i) - 'a']++;\n        }\n    \n        if (arrays.equals(scount, pcount)) {\n            slieder.add(0);\n        }\n    \n        // 后面其他窗口\n        for (int i = 0; i < slength - plength; i++) {\n            scount[s.charat(i) - 'a']--;\n            scount[s.charat(i + plength) - 'a']++;\n            if (arrays.equals(scount, pcount)) {\n                slieder.add(i + 1);\n            }\n    \n        }\n        return slieder;\n\n\n    }\n}\n\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n    public int pathsum(treenode root, int targetsum) {\n        if (root == null) {\n            return 0;\n        }\n        int res = dfs(root, targetsum);\n        res += pathsum(root.left, targetsum); // 这里不是dfs,而是pathsum\n        res += pathsum(root.right, targetsum);\n        return res;\n    }\n\n\n    public int dfs(treenode root, int targetsum) {\n        int result = 0;\n        if (root == null) {\n            return 0;\n        }\n\n        if (root.val == targetsum) {\n            result++;\n        } \n        result += dfs(root.left, targetsum - root.val);\n        result += dfs(root.right, targetsum - root.val);\n        return result;\n    }\n}\n\n\nclass solution {\n    public int[][] reconstructqueue(int[][] people) {\n\n        // 将每个人按照身高从大到小进行排序，处理身高相同的人使用的方法类似\n        arrays.sort(people, new comparator<int[]>() {\n            public int compare(int[] person1, int[] person2) {\n                if (person1[0] != person2[0]) {\n                    return person2[0] - person1[0];\n                } else {\n                    return person1[1] - person2[1];\n                }\n            }\n        });\n\n        list<int[]> result = new arraylist<int[]>();\n        // 复习list方法\n        for(int[] person : people) {\n            //\n            result.add(person[1], person);\n        }\n\n        return result.toarray(new int[result.size()][]);\n\n    }\n}\n\n\n完全平方数\nclass solution {\n    public int numsquares(int n) {\n        int[] res = new int[n+1];\n        for (int i = 1; i <= n; i++) {\n            int minn = integer.max_value;\n            for(int j = 1; j * j <= i; j++) {\n                minn = math.min(minn, res[i- j * j]);\n            }\n            res[i] = minn + 1;\n        }\n        return res[n];\n    }\n    \n}\n\n\nclass solution {\n    // https://leetcode.cn/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/\n    // 背包问题\n    public int coinchange(int[] coins, int amount) {\n        int max = amount + 1;\n        int[] dp = new int[amount + 1];\n        arrays.fill(dp,max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n\n            for (int j = 0; j < coins.length; j++) {\n\n                // 硬币面值此时大于i完全没有判断的必要\n                if (coins[j] <= i) {\n                    dp[i] = math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount? -1 :dp[amount];\n\n    }\n\n\n}\n",charsets:{cjk:!0}},{title:"IO",frontmatter:{title:"IO",permalink:"/basis/001/",categories:["Java","基础"],tags:["Java"],date:"2021-07-20T00:00:00.000Z"},regularPath:"/04.Java/01.%E5%9F%BA%E7%A1%80/01.IO.html",relativePath:"04.Java/01.基础/01.IO.md",key:"v-2a9abdfa",path:"/basis/001/",headers:[{level:2,title:"I/O",slug:"i-o",normalizedTitle:"i/o",charIndex:2},{level:3,title:"何为 I/O?",slug:"何为-i-o",normalizedTitle:"何为 i/o?",charIndex:10},{level:3,title:"有哪些常见的 IO 模型?",slug:"有哪些常见的-io-模型",normalizedTitle:"有哪些常见的 io 模型?",charIndex:820},{level:2,title:"Java 中 3 种常见 IO 模型",slug:"java-中-3-种常见-io-模型",normalizedTitle:"java 中 3 种常见 io 模型",charIndex:932},{level:3,title:"BIO (Blocking I/O)",slug:"bio-blocking-i-o",normalizedTitle:"bio (blocking i/o)",charIndex:955},{level:3,title:"NIO (Non-blocking/New I/O)",slug:"nio-non-blocking-new-i-o",normalizedTitle:"nio (non-blocking/new i/o)",charIndex:1142},{level:3,title:"AIO (Asynchronous I/O)",slug:"aio-asynchronous-i-o",normalizedTitle:"aio (asynchronous i/o)",charIndex:2106},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:2392}],headersStr:"I/O 何为 I/O? 有哪些常见的 IO 模型? Java 中 3 种常见 IO 模型 BIO (Blocking I/O) NIO (Non-blocking/New I/O) AIO (Asynchronous I/O) Reference",content:"# I/O\n\n\n# 何为 I/O?\n\nI/O（Input/Outpu） 即输入／输出 。\n\n我们先从计算机结构的角度来解读一下 I/O。\n\n根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。\n\n\n\n输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。\n\n输入设备向计算机输入数据，输出设备接收计算机输出的数据。\n\n从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。\n\n我们再先从应用程序的角度来解读一下 I/O。\n\n根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。\n\n像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。\n\n并且，用户空间的程序不能直接访问内核空间。\n\n当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。\n\n因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间\n\n我们在平常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。\n\n从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。\n\n当应用程序发起 I/O 调用后，会经历两个步骤：\n\n 1. 内核等待 I/O 设备准备好数据\n 2. 内核将数据从内核空间拷贝到用户空间。\n\n\n# 有哪些常见的 IO 模型?\n\nUNIX 系统下， IO 模型一共有 5 种： 同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。\n\n这也是我们经常提到的 5 种 IO 模型。\n\n\n# Java 中 3 种常见 IO 模型\n\n\n# BIO (Blocking I/O)\n\nBIO 属于同步阻塞 IO 模型 。\n\n同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n\n\n\n在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\n\n\n# NIO (Non-blocking/New I/O)\n\nJava 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。\n\nJava 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。\n\n跟着我的思路往下看看，相信你会得到答案！\n\n我们先来看看 同步非阻塞 IO 模型。\n\n\n\n同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。\n\n相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n\n但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\n\n这个时候，I/O 多路复用模型 就上场了。\n\n\n\nIO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的。\n\n> 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。\n> \n>  * select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。\n>  * epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。\n\nIO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。\n\nJava 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。\n\n\n\n\n# AIO (Asynchronous I/O)\n\nAIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。\n\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n\n\n目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。\n\n最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。\n\n\n\n\n# Reference\n\n * https://javaguide.cn/",normalizedContent:"# i/o\n\n\n# 何为 i/o?\n\ni/o（input/outpu） 即输入／输出 。\n\n我们先从计算机结构的角度来解读一下 i/o。\n\n根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。\n\n\n\n输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。\n\n输入设备向计算机输入数据，输出设备接收计算机输出的数据。\n\n从计算机结构的视角来看的话， i/o 描述了计算机系统与外部设备之间通信的过程。\n\n我们再先从应用程序的角度来解读一下 i/o。\n\n根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（user space） 和 内核空间（kernel space ） 。\n\n像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 io 操作，一定是要依赖内核空间的能力。\n\n并且，用户空间的程序不能直接访问内核空间。\n\n当想要执行 io 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。\n\n因此，用户进程想要执行 io 操作的话，必须通过 系统调用 来间接访问内核空间\n\n我们在平常开发过程中接触最多的就是 磁盘 io（读写文件） 和 网络 io（网络请求和响应）。\n\n从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 io 调用（系统调用），操作系统负责的内核执行具体的 io 操作。也就是说，我们的应用程序实际上只是发起了 io 操作的调用而已，具体 io 的执行是由操作系统的内核来完成的。\n\n当应用程序发起 i/o 调用后，会经历两个步骤：\n\n 1. 内核等待 i/o 设备准备好数据\n 2. 内核将数据从内核空间拷贝到用户空间。\n\n\n# 有哪些常见的 io 模型?\n\nunix 系统下， io 模型一共有 5 种： 同步阻塞 i/o、同步非阻塞 i/o、i/o 多路复用、信号驱动 i/o 和异步 i/o。\n\n这也是我们经常提到的 5 种 io 模型。\n\n\n# java 中 3 种常见 io 模型\n\n\n# bio (blocking i/o)\n\nbio 属于同步阻塞 io 模型 。\n\n同步阻塞 io 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n\n\n\n在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 bio 模型是无能为力的。因此，我们需要一种更高效的 i/o 处理模型来应对更高的并发量。\n\n\n# nio (non-blocking/new i/o)\n\njava 中的 nio 于 java 1.4 中引入，对应 java.nio 包，提供了 channel , selector，buffer 等抽象。nio 中的 n 可以理解为 non-blocking，不单纯是 new。它是支持面向缓冲的，基于通道的 i/o 操作方法。 对于高负载、高并发的（网络）应用，应使用 nio 。\n\njava 中的 nio 可以看作是 i/o 多路复用模型。也有很多人认为，java 中的 nio 属于同步非阻塞 io 模型。\n\n跟着我的思路往下看看，相信你会得到答案！\n\n我们先来看看 同步非阻塞 io 模型。\n\n\n\n同步非阻塞 io 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。\n\n相比于同步阻塞 io 模型，同步非阻塞 io 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n\n但是，这种 io 模型同样存在问题：应用程序不断进行 i/o 系统调用轮询数据是否已经准备好的过程是十分消耗 cpu 资源的。\n\n这个时候，i/o 多路复用模型 就上场了。\n\n\n\nio 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的。\n\n> 目前支持 io 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。\n> \n>  * select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。\n>  * epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 io 的执行效率。\n\nio 多路复用模型，通过减少无效的系统调用，减少了对 cpu 资源的消耗。\n\njava 中的 nio ，有一个非常重要的选择器 ( selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。\n\n\n\n\n# aio (asynchronous i/o)\n\naio 也就是 nio 2。java 7 中引入了 nio 的改进版 nio 2,它是异步 io 模型。\n\n异步 io 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n\n\n目前来说 aio 的应用还不是很广泛。netty 之前也尝试使用过 aio，不过又放弃了。这是因为，netty 使用了 aio 之后，在 linux 系统上的性能并没有多少提升。\n\n最后，来一张图，简单总结一下 java 中的 bio、nio、aio。\n\n\n\n\n# reference\n\n * https://javaguide.cn/",charsets:{cjk:!0}},{title:"反射",frontmatter:{title:"反射",category:"Java",tag:["Java","高级"],permalink:"/high/001/",date:"2021-05-18T00:00:00.000Z"},regularPath:"/04.Java/02.%E9%AB%98%E7%BA%A7/01.%E5%8F%8D%E5%B0%84.html",relativePath:"04.Java/02.高级/01.反射.md",key:"v-8720726a",path:"/high/001/",headers:[{level:2,title:"何为反射？",slug:"何为反射",normalizedTitle:"何为反射？",charIndex:2},{level:2,title:"反射的应用场景了解么？",slug:"反射的应用场景了解么",normalizedTitle:"反射的应用场景了解么？",charIndex:140},{level:2,title:"谈谈反射机制的优缺点",slug:"谈谈反射机制的优缺点",normalizedTitle:"谈谈反射机制的优缺点",charIndex:1125},{level:2,title:"反射实战",slug:"反射实战",normalizedTitle:"反射实战",charIndex:1320},{level:3,title:"获取 Class 对象的四种方式",slug:"获取-class-对象的四种方式",normalizedTitle:"获取 class 对象的四种方式",charIndex:1329},{level:3,title:"反射的一些基本操作",slug:"反射的一些基本操作",normalizedTitle:"反射的一些基本操作",charIndex:1956},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:4097}],headersStr:"何为反射？ 反射的应用场景了解么？ 谈谈反射机制的优缺点 反射实战 获取 Class 对象的四种方式 反射的一些基本操作 Reference",content:'# 何为反射？\n\n如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。\n\n反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。\n\n通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\n\n\n# 反射的应用场景了解么？\n\n像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。\n\n但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。\n\n这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。\n\n比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。\n\npublic class DebugInvocationHandler implements InvocationHandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final Object target;\n\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        System.out.println("before method " + method.getName());\n        Object result = method.invoke(target, args);\n        System.out.println("after method " + method.getName());\n        return result;\n    }\n}\n\n\n\n另外，像 Java 中的一大利器 注解 的实现也用到了反射。\n\n为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？\n\n这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\n\n\n# 谈谈反射机制的优缺点\n\n优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\n\n缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：Java Reflection: Why is it so slow?\n\n\n# 反射实战\n\n\n# 获取 Class 对象的四种方式\n\n如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:\n\n1. 知道具体类的情况下可以使用：\n\nClass alunbarClass = TargetObject.class;\n\n\n但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化\n\n2. 通过 Class.forName()传入类的全路径获取：\n\nClass alunbarClass1 = Class.forName("cn.javaguide.TargetObject");\n\n\n3. 通过对象实例instance.getClass()获取：\n\nTargetObject o = new TargetObject();\nClass alunbarClass2 = o.getClass();\n\n\n4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取:\n\nClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");\n\n\n通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行\n\n\n# 反射的一些基本操作\n\n 1. 创建一个我们要使用反射操作的类 TargetObject。\n\npackage cn.javaguide;\n\npublic class TargetObject {\n    private String value;\n\n    public TargetObject() {\n        value = "JavaGuide";\n    }\n\n    public void publicMethod(String s) {\n        System.out.println("I love " + s);\n    }\n\n    private void privateMethod() {\n        System.out.println("value is " + value);\n    }\n}\n\n\n 2. 使用反射操作这个类的方法以及参数\n\npackage cn.javaguide;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {\n        /**\n         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例\n         */\n        Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");\n        TargetObject targetObject = (TargetObject) targetClass.newInstance();\n        /**\n         * 获取 TargetObject 类中定义的所有方法\n         */\n        Method[] methods = targetClass.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(method.getName());\n        }\n\n        /**\n         * 获取指定方法并调用\n         */\n        Method publicMethod = targetClass.getDeclaredMethod("publicMethod",\n                String.class);\n\n        publicMethod.invoke(targetObject, "JavaGuide");\n\n        /**\n         * 获取指定参数并对参数进行修改\n         */\n        Field field = targetClass.getDeclaredField("value");\n        //为了对类中的参数进行修改我们取消安全检查\n        field.setAccessible(true);\n        field.set(targetObject, "JavaGuide");\n\n        /**\n         * 调用 private 方法\n         */\n        Method privateMethod = targetClass.getDeclaredMethod("privateMethod");\n        //为了调用private方法我们取消安全检查\n        privateMethod.setAccessible(true);\n        privateMethod.invoke(targetObject);\n    }\n}\n\n\n\n输出内容：\n\npublicMethod\nprivateMethod\nI love JavaGuide\nvalue is JavaGuide\n\n\n注意 : 有读者提到上面代码运行会抛出 ClassNotFoundException 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 TargetObject 所在的包 。\n\nClass<?> targetClass = Class.forName("cn.javaguide.TargetObject");\n\n\n\n# Reference\n\n * https://javaguide.cn/',normalizedContent:'# 何为反射？\n\n如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。\n\n反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。\n\n通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\n\n\n# 反射的应用场景了解么？\n\n像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。\n\n但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 spring/spring boot、mybatis 等等框架中都大量使用了反射机制。\n\n这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。\n\n比如下面是通过 jdk 实现动态代理的示例代码，其中就使用了反射类 method 来调用指定的方法。\n\npublic class debuginvocationhandler implements invocationhandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final object target;\n\n    public debuginvocationhandler(object target) {\n        this.target = target;\n    }\n\n\n    public object invoke(object proxy, method method, object[] args) throws invocationtargetexception, illegalaccessexception {\n        system.out.println("before method " + method.getname());\n        object result = method.invoke(target, args);\n        system.out.println("after method " + method.getname());\n        return result;\n    }\n}\n\n\n\n另外，像 java 中的一大利器 注解 的实现也用到了反射。\n\n为什么你使用 spring 的时候 ，一个@component注解就声明了一个类为 spring bean 呢？为什么你通过一个 @value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？\n\n这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\n\n\n# 谈谈反射机制的优缺点\n\n优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\n\n缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：java reflection: why is it so slow?\n\n\n# 反射实战\n\n\n# 获取 class 对象的四种方式\n\n如果我们动态获取到这些信息，我们需要依靠 class 对象。class 类对象将一个类的方法、变量等信息告诉运行的程序。java 提供了四种方式获取 class 对象:\n\n1. 知道具体类的情况下可以使用：\n\nclass alunbarclass = targetobject.class;\n\n\n但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 class 对象，通过此方式获取 class 对象不会进行初始化\n\n2. 通过 class.forname()传入类的全路径获取：\n\nclass alunbarclass1 = class.forname("cn.javaguide.targetobject");\n\n\n3. 通过对象实例instance.getclass()获取：\n\ntargetobject o = new targetobject();\nclass alunbarclass2 = o.getclass();\n\n\n4. 通过类加载器xxxclassloader.loadclass()传入类路径获取:\n\nclassloader.getsystemclassloader().loadclass("cn.javaguide.targetobject");\n\n\n通过类加载器获取 class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行\n\n\n# 反射的一些基本操作\n\n 1. 创建一个我们要使用反射操作的类 targetobject。\n\npackage cn.javaguide;\n\npublic class targetobject {\n    private string value;\n\n    public targetobject() {\n        value = "javaguide";\n    }\n\n    public void publicmethod(string s) {\n        system.out.println("i love " + s);\n    }\n\n    private void privatemethod() {\n        system.out.println("value is " + value);\n    }\n}\n\n\n 2. 使用反射操作这个类的方法以及参数\n\npackage cn.javaguide;\n\nimport java.lang.reflect.field;\nimport java.lang.reflect.invocationtargetexception;\nimport java.lang.reflect.method;\n\npublic class main {\n    public static void main(string[] args) throws classnotfoundexception, nosuchmethodexception, illegalaccessexception, instantiationexception, invocationtargetexception, nosuchfieldexception {\n        /**\n         * 获取 targetobject 类的 class 对象并且创建 targetobject 类实例\n         */\n        class<?> targetclass = class.forname("cn.javaguide.targetobject");\n        targetobject targetobject = (targetobject) targetclass.newinstance();\n        /**\n         * 获取 targetobject 类中定义的所有方法\n         */\n        method[] methods = targetclass.getdeclaredmethods();\n        for (method method : methods) {\n            system.out.println(method.getname());\n        }\n\n        /**\n         * 获取指定方法并调用\n         */\n        method publicmethod = targetclass.getdeclaredmethod("publicmethod",\n                string.class);\n\n        publicmethod.invoke(targetobject, "javaguide");\n\n        /**\n         * 获取指定参数并对参数进行修改\n         */\n        field field = targetclass.getdeclaredfield("value");\n        //为了对类中的参数进行修改我们取消安全检查\n        field.setaccessible(true);\n        field.set(targetobject, "javaguide");\n\n        /**\n         * 调用 private 方法\n         */\n        method privatemethod = targetclass.getdeclaredmethod("privatemethod");\n        //为了调用private方法我们取消安全检查\n        privatemethod.setaccessible(true);\n        privatemethod.invoke(targetobject);\n    }\n}\n\n\n\n输出内容：\n\npublicmethod\nprivatemethod\ni love javaguide\nvalue is javaguide\n\n\n注意 : 有读者提到上面代码运行会抛出 classnotfoundexception 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 targetobject 所在的包 。\n\nclass<?> targetclass = class.forname("cn.javaguide.targetobject");\n\n\n\n# reference\n\n * https://javaguide.cn/',charsets:{cjk:!0}},{title:"Web基础概念简介",frontmatter:{title:"Web基础概念简介",date:"2021-10-04T00:00:00.000Z",permalink:"/web/001/",categories:["JavaWeb","基础"],tags:["Java","Web"],author:null},regularPath:"/05.JavaWeb/01.%E5%9F%BA%E7%A1%80/01.Web%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html",relativePath:"05.JavaWeb/01.基础/01.Web基础概念.md",key:"v-4a9ffcac",path:"/web/001/",headers:[{level:2,title:"1、服务器与客户端",slug:"_1、服务器与客户端",normalizedTitle:"1、服务器与客户端",charIndex:3},{level:3,title:"①线下的服务器与客户端",slug:"_1线下的服务器与客户端",normalizedTitle:"①线下的服务器与客户端",charIndex:18},{level:3,title:"②线上的服务器与客户端",slug:"_2线上的服务器与客户端",normalizedTitle:"②线上的服务器与客户端",charIndex:35},{level:3,title:"③客户端的各种形式",slug:"_3客户端的各种形式",normalizedTitle:"③客户端的各种形式",charIndex:52},{level:4,title:"[1]PC端网页",slug:"_1-pc端网页",normalizedTitle:"[1]pc端网页",charIndex:313},{level:4,title:"[2]移动端",slug:"_2-移动端",normalizedTitle:"[2]移动端",charIndex:327},{level:4,title:"[3]Iot设备",slug:"_3-iot设备",normalizedTitle:"[3]iot设备",charIndex:339},{level:3,title:"④服务器的各种形式",slug:"_4服务器的各种形式",normalizedTitle:"④服务器的各种形式",charIndex:67},{level:2,title:"2、服务器端应用程序",slug:"_2、服务器端应用程序",normalizedTitle:"2、服务器端应用程序",charIndex:80},{level:2,title:"3、业务",slug:"_3、业务",normalizedTitle:"3、业务",charIndex:94},{level:2,title:"4、请求和响应",slug:"_4、请求和响应",normalizedTitle:"4、请求和响应",charIndex:102},{level:3,title:"①发生在饭馆的请求和响应",slug:"_1发生在饭馆的请求和响应",normalizedTitle:"①发生在饭馆的请求和响应",charIndex:115},{level:3,title:"②项目中的请求和响应",slug:"_2项目中的请求和响应",normalizedTitle:"②项目中的请求和响应",charIndex:133},{level:2,title:"5、项目的逻辑构成",slug:"_5、项目的逻辑构成",normalizedTitle:"5、项目的逻辑构成",charIndex:147},{level:2,title:"6、架构",slug:"_6、架构",normalizedTitle:"6、架构",charIndex:160},{level:3,title:"①概念",slug:"_1概念",normalizedTitle:"①概念",charIndex:170},{level:3,title:"②发展演变历程",slug:"_2发展演变历程",normalizedTitle:"②发展演变历程",charIndex:179},{level:4,title:"[1]单一架构",slug:"_1-单一架构",normalizedTitle:"[1]单一架构",charIndex:1383},{level:4,title:"[2]分布式架构",slug:"_2-分布式架构",normalizedTitle:"[2]分布式架构",charIndex:1465},{level:3,title:"③单一架构技术体系",slug:"_3单一架构技术体系",normalizedTitle:"③单一架构技术体系",charIndex:192},{level:2,title:"7、本阶段技术体系",slug:"_7、本阶段技术体系",normalizedTitle:"7、本阶段技术体系",charIndex:205},{level:2,title:"8、本阶段案例简介",slug:"_8、本阶段案例简介",normalizedTitle:"8、本阶段案例简介",charIndex:218}],headersStr:"1、服务器与客户端 ①线下的服务器与客户端 ②线上的服务器与客户端 ③客户端的各种形式 [1]PC端网页 [2]移动端 [3]Iot设备 ④服务器的各种形式 2、服务器端应用程序 3、业务 4、请求和响应 ①发生在饭馆的请求和响应 ②项目中的请求和响应 5、项目的逻辑构成 6、架构 ①概念 ②发展演变历程 [1]单一架构 [2]分布式架构 ③单一架构技术体系 7、本阶段技术体系 8、本阶段案例简介",content:" * 1、服务器与客户端\n   * ①线下的服务器与客户端\n   * ②线上的服务器与客户端\n   * ③客户端的各种形式\n   * ④服务器的各种形式\n * 2、服务器端应用程序\n * 3、业务\n * 4、请求和响应\n   * ①发生在饭馆的请求和响应\n   * ②项目中的请求和响应\n * 5、项目的逻辑构成\n * 6、架构\n   * ①概念\n   * ②发展演变历程\n   * ③单一架构技术体系\n * 7、本阶段技术体系\n * 8、本阶段案例简介\n\n\n\n\n# 01. Web基础概念\n\n\n# 1、服务器与客户端\n\n\n# ①线下的服务器与客户端\n\n\n\n\n# ②线上的服务器与客户端\n\n\n\n\n# ③客户端的各种形式\n\n# [1]PC端网页\n\n\n\n# [2]移动端\n\n\n\n# [3]Iot设备\n\n\n\n\n# ④服务器的各种形式\n\n\n# 2、服务器端应用程序\n\n我们要开发的就是服务器端应用程序。\n\n\n\n\n# 3、业务\n\n项目中的功能就是业务。\n\n\n# 4、请求和响应\n\n\n# ①发生在饭馆的请求和响应\n\n\n\n\n# ②项目中的请求和响应\n\n\n\n\n# 5、项目的逻辑构成\n\n * 请求：请求是项目中最基本的逻辑单元，就像万事万物都由原子构成\n   \n   > 举例：点超链接跳转到注册页面\n\n * 功能：一个功能包含很多个请求\n   \n   > 举例：注册用户功能\n   > \n   >  * 请求1：点超链接跳转到注册页面\n   >  * 请求2：发送请求获取短信验证码\n   >  * 请求3：检查用户名是否可用\n   >  * 请求4：提交表单完成注册\n\n * 模块：一个模块包含很多功能\n   \n   > 举例：用户信息管理模块\n   > \n   >  * 功能1：用户注册功能\n   >  * 功能2：用户登录功能\n   >  * 功能3：个人中心——账户安全功能\n   >  * 功能4：个人中心——账户绑定功能\n   >  * 功能5：个人中心——收货地址功能\n   >  * 功能6：个人中心——我的银行卡功能\n\n * 子系统：根据项目规模的不同，子系统这层逻辑概念可能有也可能没有。如果设置了子系统，那么子系统中也必然包含很多模块。其实庞大项目的子系统已经相当于一个项目了，甚至比小型项目整个都大。\n   \n   > 举例：认证中心子系统\n   > \n   >  * 模块1：用户信息管理模块\n   >  * 模块2：权限管理模块\n   >  * 模块3：授权管理模块\n   >  * 模块4：权限检查模块\n\n * 项目：为了解决现实生活中的实际问题开发一个项目，这个项目就是为这个需求提供的一整套解决方案。\n   \n   > 举例：电商项目\n   > \n   >  * 子系统1：认证中心子系统\n   >  * 子系统2：商品管理子系统\n   >  * 子系统3：购物车子系统\n   >  * 子系统4：仓储子系统\n   >  * 子系统5：物流子系统\n   >  * 子系统6：订单子系统\n\n\n\n\n# 6、架构\n\n\n# ①概念\n\n『架构』其实就是项目的『结构』。只不过『结构』这个词太小了，不适合用来描述项目这么大的东西，所以换了另一个更大的词：架构。所以当我们聊一个项目的架构时，我们聊的是项目是由哪些部分组成的。\n\n\n# ②发展演变历程\n\n# [1]单一架构\n\n一个项目就是一个工程，这样的结构就是单一架构，也叫all in one。我们现在的JavaWeb阶段、SSM阶段都是学习单一架构开发技术。\n\n# [2]分布式架构\n\n一个项目中包含很多工程，每个工程作为一个模块。模块之间存在调用关系。分布式架构阶段的技术分为两类：\n\n * Java框架：SpringBoot、SpringCloud、Dubbo等等。\n * 中间件：Redis、ElasticSearch、FastDFS、Nginx、Zookeeper、RabbitMQ等等。\n\n\n\n\n# ③单一架构技术体系\n\n * 视图：用户的操作界面+数据的动态显示\n   * 前端技术：HTML/CSS/JavaScript\n   * 服务器端页面模板技术：Thymeleaf\n * 控制层：处理请求+跳转页面\n   * 服务器：Tomcat\n   * 控制器：Servlet\n   * 域对象：request、session、servletContext\n   * 过滤器：Filter\n   * 监听器：Listener\n   * 异步交互：Ajax\n * 业务逻辑层：业务逻辑计算\n * 持久化层：操作数据库\n\n\n\n\n# 7、本阶段技术体系\n\n\n\n\n# 8、本阶段案例简介\n\n\n\n",normalizedContent:" * 1、服务器与客户端\n   * ①线下的服务器与客户端\n   * ②线上的服务器与客户端\n   * ③客户端的各种形式\n   * ④服务器的各种形式\n * 2、服务器端应用程序\n * 3、业务\n * 4、请求和响应\n   * ①发生在饭馆的请求和响应\n   * ②项目中的请求和响应\n * 5、项目的逻辑构成\n * 6、架构\n   * ①概念\n   * ②发展演变历程\n   * ③单一架构技术体系\n * 7、本阶段技术体系\n * 8、本阶段案例简介\n\n\n\n\n# 01. web基础概念\n\n\n# 1、服务器与客户端\n\n\n# ①线下的服务器与客户端\n\n\n\n\n# ②线上的服务器与客户端\n\n\n\n\n# ③客户端的各种形式\n\n# [1]pc端网页\n\n\n\n# [2]移动端\n\n\n\n# [3]iot设备\n\n\n\n\n# ④服务器的各种形式\n\n\n# 2、服务器端应用程序\n\n我们要开发的就是服务器端应用程序。\n\n\n\n\n# 3、业务\n\n项目中的功能就是业务。\n\n\n# 4、请求和响应\n\n\n# ①发生在饭馆的请求和响应\n\n\n\n\n# ②项目中的请求和响应\n\n\n\n\n# 5、项目的逻辑构成\n\n * 请求：请求是项目中最基本的逻辑单元，就像万事万物都由原子构成\n   \n   > 举例：点超链接跳转到注册页面\n\n * 功能：一个功能包含很多个请求\n   \n   > 举例：注册用户功能\n   > \n   >  * 请求1：点超链接跳转到注册页面\n   >  * 请求2：发送请求获取短信验证码\n   >  * 请求3：检查用户名是否可用\n   >  * 请求4：提交表单完成注册\n\n * 模块：一个模块包含很多功能\n   \n   > 举例：用户信息管理模块\n   > \n   >  * 功能1：用户注册功能\n   >  * 功能2：用户登录功能\n   >  * 功能3：个人中心——账户安全功能\n   >  * 功能4：个人中心——账户绑定功能\n   >  * 功能5：个人中心——收货地址功能\n   >  * 功能6：个人中心——我的银行卡功能\n\n * 子系统：根据项目规模的不同，子系统这层逻辑概念可能有也可能没有。如果设置了子系统，那么子系统中也必然包含很多模块。其实庞大项目的子系统已经相当于一个项目了，甚至比小型项目整个都大。\n   \n   > 举例：认证中心子系统\n   > \n   >  * 模块1：用户信息管理模块\n   >  * 模块2：权限管理模块\n   >  * 模块3：授权管理模块\n   >  * 模块4：权限检查模块\n\n * 项目：为了解决现实生活中的实际问题开发一个项目，这个项目就是为这个需求提供的一整套解决方案。\n   \n   > 举例：电商项目\n   > \n   >  * 子系统1：认证中心子系统\n   >  * 子系统2：商品管理子系统\n   >  * 子系统3：购物车子系统\n   >  * 子系统4：仓储子系统\n   >  * 子系统5：物流子系统\n   >  * 子系统6：订单子系统\n\n\n\n\n# 6、架构\n\n\n# ①概念\n\n『架构』其实就是项目的『结构』。只不过『结构』这个词太小了，不适合用来描述项目这么大的东西，所以换了另一个更大的词：架构。所以当我们聊一个项目的架构时，我们聊的是项目是由哪些部分组成的。\n\n\n# ②发展演变历程\n\n# [1]单一架构\n\n一个项目就是一个工程，这样的结构就是单一架构，也叫all in one。我们现在的javaweb阶段、ssm阶段都是学习单一架构开发技术。\n\n# [2]分布式架构\n\n一个项目中包含很多工程，每个工程作为一个模块。模块之间存在调用关系。分布式架构阶段的技术分为两类：\n\n * java框架：springboot、springcloud、dubbo等等。\n * 中间件：redis、elasticsearch、fastdfs、nginx、zookeeper、rabbitmq等等。\n\n\n\n\n# ③单一架构技术体系\n\n * 视图：用户的操作界面+数据的动态显示\n   * 前端技术：html/css/javascript\n   * 服务器端页面模板技术：thymeleaf\n * 控制层：处理请求+跳转页面\n   * 服务器：tomcat\n   * 控制器：servlet\n   * 域对象：request、session、servletcontext\n   * 过滤器：filter\n   * 监听器：listener\n   * 异步交互：ajax\n * 业务逻辑层：业务逻辑计算\n * 持久化层：操作数据库\n\n\n\n\n# 7、本阶段技术体系\n\n\n\n\n# 8、本阶段案例简介\n\n\n\n",charsets:{cjk:!0}},{title:"概述",frontmatter:{title:"概述",date:"2021-01-05T00:00:00.000Z",permalink:"/mysql/001/",categories:["数据库","MySQL"],tags:["MySQL"]},regularPath:"/06.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL/01.%E6%A6%82%E8%BF%B0.html",relativePath:"06.数据库/01.MySQL/01.概述.md",key:"v-1ba1ada2",path:"/mysql/001/",headers:[{level:2,title:"1. 为什么要使用数据库",slug:"_1-为什么要使用数据库",normalizedTitle:"1. 为什么要使用数据库",charIndex:57},{level:2,title:"2. 数据库与数据库管理系统",slug:"_2-数据库与数据库管理系统",normalizedTitle:"2. 数据库与数据库管理系统",charIndex:250},{level:3,title:"2.1 数据库的相关概念",slug:"_2-1-数据库的相关概念",normalizedTitle:"2.1 数据库的相关概念",charIndex:269},{level:3,title:"2.2 数据库与数据库管理系统的关系",slug:"_2-2-数据库与数据库管理系统的关系",normalizedTitle:"2.2 数据库与数据库管理系统的关系",charIndex:505},{level:3,title:"2.3 常见的数据库管理系统排名(DBMS)",slug:"_2-3-常见的数据库管理系统排名-dbms",normalizedTitle:"2.3 常见的数据库管理系统排名(dbms)",charIndex:641},{level:3,title:"2.4 常见的数据库介绍",slug:"_2-4-常见的数据库介绍",normalizedTitle:"2.4 常见的数据库介绍",charIndex:909},{level:2,title:"3. MySQL介绍",slug:"_3-mysql介绍",normalizedTitle:"3. mysql介绍",charIndex:1729},{level:3,title:"3.1 概述",slug:"_3-1-概述",normalizedTitle:"3.1 概述",charIndex:1746},{level:3,title:"3.2 MySQL发展史重大事件",slug:"_3-2-mysql发展史重大事件",normalizedTitle:"3.2 mysql发展史重大事件",charIndex:2347},{level:3,title:"1.4 关于MySQL 8.0",slug:"_1-4-关于mysql-8-0",normalizedTitle:"1.4 关于mysql 8.0",charIndex:2489},{level:3,title:"1.5 Why choose MySQL?",slug:"_1-5-why-choose-mysql",normalizedTitle:"1.5 why choose mysql?",charIndex:2658},{level:3,title:"1.6 Oracle vs MySQL",slug:"_1-6-oracle-vs-mysql",normalizedTitle:"1.6 oracle vs mysql",charIndex:2835},{level:2,title:"4. RDBMS 与 非RDBMS",slug:"_4-rdbms-与-非rdbms",normalizedTitle:"4. rdbms 与 非rdbms",charIndex:3045},{level:3,title:"4.1 关系型数据库(RDBMS)",slug:"_4-1-关系型数据库-rdbms",normalizedTitle:"4.1 关系型数据库(rdbms)",charIndex:3160},{level:4,title:"4.1.1 实质",slug:"_4-1-1-实质",normalizedTitle:"4.1.1 实质",charIndex:3181},{level:4,title:"4.1.2 优势",slug:"_4-1-2-优势",normalizedTitle:"4.1.2 优势",charIndex:3459},{level:3,title:"4.2 非关系型数据库(非RDBMS)",slug:"_4-2-非关系型数据库-非rdbms",normalizedTitle:"4.2 非关系型数据库(非rdbms)",charIndex:3546},{level:4,title:"4.2.1 介绍",slug:"_4-2-1-介绍",normalizedTitle:"4.2.1 介绍",charIndex:3569},{level:4,title:"4.2.2 有哪些非关系型数据库",slug:"_4-2-2-有哪些非关系型数据库",normalizedTitle:"4.2.2 有哪些非关系型数据库",charIndex:3687},{level:4,title:"4.2.3 NoSQL的演变",slug:"_4-2-3-nosql的演变",normalizedTitle:"4.2.3 nosql的演变",charIndex:4723},{level:3,title:"4.3 小结",slug:"_4-3-小结",normalizedTitle:"4.3 小结",charIndex:5157},{level:2,title:"5. 关系型数据库设计规则",slug:"_5-关系型数据库设计规则",normalizedTitle:"5. 关系型数据库设计规则",charIndex:5306},{level:3,title:"5.1 表、记录、字段",slug:"_5-1-表、记录、字段",normalizedTitle:"5.1 表、记录、字段",charIndex:5490},{level:3,title:"5.2 表的关联关系",slug:"_5-2-表的关联关系",normalizedTitle:"5.2 表的关联关系",charIndex:5833},{level:4,title:"5.2.1 一对一关联（one-to-one）",slug:"_5-2-1-一对一关联-one-to-one",normalizedTitle:"5.2.1 一对一关联（one-to-one）",charIndex:5941},{level:4,title:"5.2.2 一对多关系（one-to-many）",slug:"_5-2-2-一对多关系-one-to-many",normalizedTitle:"5.2.2 一对多关系（one-to-many）",charIndex:6255},{level:4,title:"5.2.3 多对多（many-to-many）",slug:"_5-2-3-多对多-many-to-many",normalizedTitle:"5.2.3 多对多（many-to-many）",charIndex:6426},{level:4,title:"5.3.4 自我引用(Self reference)",slug:"_5-3-4-自我引用-self-reference",normalizedTitle:"5.3.4 自我引用(self reference)",charIndex:7058}],headersStr:"1. 为什么要使用数据库 2. 数据库与数据库管理系统 2.1 数据库的相关概念 2.2 数据库与数据库管理系统的关系 2.3 常见的数据库管理系统排名(DBMS) 2.4 常见的数据库介绍 3. MySQL介绍 3.1 概述 3.2 MySQL发展史重大事件 1.4 关于MySQL 8.0 1.5 Why choose MySQL? 1.6 Oracle vs MySQL 4. RDBMS 与 非RDBMS 4.1 关系型数据库(RDBMS) 4.1.1 实质 4.1.2 优势 4.2 非关系型数据库(非RDBMS) 4.2.1 介绍 4.2.2 有哪些非关系型数据库 4.2.3 NoSQL的演变 4.3 小结 5. 关系型数据库设计规则 5.1 表、记录、字段 5.2 表的关联关系 5.2.1 一对一关联（one-to-one） 5.2.2 一对多关系（one-to-many） 5.2.3 多对多（many-to-many） 5.3.4 自我引用(Self reference)",content:"# 01 数据库概述\n\n----------------------------------------\n\n\n# 1. 为什么要使用数据库\n\n * 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。\n * 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\n\n生活中的例子：\n\n\n\n\n# 2. 数据库与数据库管理系统\n\n\n# 2.1 数据库的相关概念\n\nDB：数据库（DATABASE）\n即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。\nDBMS：数据库管理系统（Database Management System）\n是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。\nSQL：结构化查询语言（Structured Query Language）\n专门用来与数据库通信的语言。\n\n\n# 2.2 数据库与数据库管理系统的关系\n\n数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。\n\n数据库管理系统、数据库和表的关系如图所示：\n\n\n\n\n\n\n# 2.3 常见的数据库管理系统排名(DBMS)\n\n目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。以下是2021年DB-Engines Ranking 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:https://db-engines.com/en/ranking）\n\n\n\n。。。\n\n\n\n对应的走势图：（https://db-engines.com/en/ranking_trend）\n\n\n\n\n# 2.4 常见的数据库介绍\n\nOracle\n\n1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。\n\n2007年，总计85亿美金收购BEA Systems。\n\n2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。\n\n2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。\n\n如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。\n\nSQL Server\n\nSQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。\n\nDB2\n\nIBM公司的数据库产品,收费的。常应用在银行系统中。\n\nPostgreSQL\n\nPostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。\n\nSyBase\n\n已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。\n\nSQLite\n\n嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。\n\ninformix\n\nIBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。\n\n\n# 3. MySQL介绍\n\n\n\n\n# 3.1 概述\n\n * MySQL是一个开放源代码的关系型数据库管理系统，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。\n * 2008被Sun收购（10亿美金），2009年Sun被Oracle收购。MariaDB应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）\n * MySQL6.x 版本之后分为社区版和商业版。\n * MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n * MySQL是开源的，所以你不需要支付额外的费用。\n * MySQL是可以定制的，采用了GPL（GNU General Public License）协议，你可以修改源码来开发自己的MySQL系统。\n * MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n * MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。\n * MySQL使用标准的SQL数据语言形式。\n * MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。\n\n\n# 3.2 MySQL发展史重大事件\n\nMySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。\n\n\n\n\n# 1.4 关于MySQL 8.0\n\nMySQL从5.7版本直接跳跃发布了8.0版本，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。\n\n\n# 1.5 Why choose MySQL?\n\n\n\n为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点：\n\n 1. 开放源代码，使用成本低。\n\n 2. 性能卓越，服务稳定。\n\n 3. 软件体积小，使用简单，并且易于维护。\n\n 4. 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。\n\n 5. 许多互联网公司在用，经过了时间的验证。\n\n\n# 1.6 Oracle vs MySQL\n\nOracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。\n\nMySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。\n\n\n# 4. RDBMS 与 非RDBMS\n\n从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。\n\n\n# 4.1 关系型数据库(RDBMS)\n\n# 4.1.1 实质\n\n * 这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。\n   \n   \n\n * 关系型数据库以行(row)和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table)，一组表组成了一个库(database)。\n\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。\n\n * SQL 就是关系型数据库的查询语言。\n\n\n\n# 4.1.2 优势\n\n * 复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n * 事务支持 使得对于安全性能很高的数据访问要求得以实现。\n\n\n# 4.2 非关系型数据库(非RDBMS)\n\n# 4.2.1 介绍\n\n非关系型数据库，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。同时，通过减少不常用的功能，进一步提高性能。\n\n目前基本上大部分主流的非关系型数据库都是免费的。\n\n# 4.2.2 有哪些非关系型数据库\n\n相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。\n\n键值型数据库\n\n键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。\n\n键值型数据库典型的使用场景是作为内存缓存。Redis是最流行的键值型数据库。\n\n\n\n文档型数据库\n\n此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。\n\n搜索引擎数据库\n\n虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。\n\n典型产品：Solr、Elasticsearch、Splunk 等。\n\n列式数据库\n\n列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。\n\n\n\n图形数据库\n\n图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。\n\n图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。\n\n# 4.2.3 NoSQL的演变\n\n由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 NoSQL 功能的演变：\n\n1970：NoSQL = We have no SQL\n\n1980：NoSQL = Know SQL\n\n2000：NoSQL = No SQL!\n\n2005：NoSQL = Not only SQL\n\n2013：NoSQL = No, SQL!\n\nNoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。\n\n\n# 4.3 小结\n\nNoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有必要的。整套课程将围绕 SQL 展开。\n\n\n# 5. 关系型数据库设计规则\n\n * 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。\n\n * 将数据放到表中，表再放到库中。\n\n * 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。\n\n * 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。\n\n\n# 5.1 表、记录、字段\n\n * E-R（entity-relationship，实体-联系）模型中有三个主要概念是：实体集、属性、联系集。\n\n * 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。\n\n\n\nORM思想 (Object Relational Mapping)体现：\n数据库中的一个表  <---\x3e Java或Python中的一个类\n表中的一条数据  <---\x3e 类中的一个对象（或实体）\n表中的一个列  <----\x3e 类中的一个字段、属性(field)\n\n\n\n# 5.2 表的关联关系\n\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。\n\n * 四种：一对一关联、一对多关联、多对多关联、自我引用\n\n# 5.2.1 一对一关联（one-to-one）\n\n * 在实际的开发中应用不多，因为一对一可以创建成一张表。\n * 举例：设计学生表：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、...\n   \n   * 拆为两个表：两个表的记录是一一对应关系。\n   \n   * 基础信息表（常用信息）：学号、姓名、手机号码、班级、系别\n   \n   * 档案信息表（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、...\n\n * 两种建表原则：\n   * 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\n   * 外键是主键：主表的主键和从表的主键，形成主外键关系。\n\n\n\n# 5.2.2 一对多关系（one-to-many）\n\n * 常见实例场景：客户表和订单表，分类表和商品表，部门表和员工表。\n * 举例：\n   \n   * 员工表：编号、姓名、...、所属部门\n   \n   * 部门表：编号、名称、简介\n\n * 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\n\n\n\n\n\n\n\n# 5.2.3 多对多（many-to-many）\n\n要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。\n\n\n\n * 举例1：学生-课程\n   \n   * 学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别...）\n   \n   * 课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介...）\n   \n   * 选课信息表：一个学生可以选多门课，一门课可以被多个学生选择\n     \n     学号     课程编号  \n     1        1001\n     2        1001\n     1        1002\n     \n\n * 举例2：产品-订单\n   \n   “订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。\n   \n   * 产品表：“产品”表中的每条记录表示一个产品。\n   * 订单表：“订单”表中的每条记录表示一个订单。\n   * 订单明细表：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。\n\n\n\n * 举例3：用户-角色\n * 多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。\n\n\n\n# 5.3.4 自我引用(Self reference)\n\n",normalizedContent:"# 01 数据库概述\n\n----------------------------------------\n\n\n# 1. 为什么要使用数据库\n\n * 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。\n * 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、xml数据文件中。\n\n生活中的例子：\n\n\n\n\n# 2. 数据库与数据库管理系统\n\n\n# 2.1 数据库的相关概念\n\ndb：数据库（database）\n即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。\ndbms：数据库管理系统（database management system）\n是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。\nsql：结构化查询语言（structured query language）\n专门用来与数据库通信的语言。\n\n\n# 2.2 数据库与数据库管理系统的关系\n\n数据库管理系统(dbms)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。\n\n数据库管理系统、数据库和表的关系如图所示：\n\n\n\n\n\n\n# 2.3 常见的数据库管理系统排名(dbms)\n\n目前互联网上常见的数据库管理软件有oracle、mysql、ms sql server、db2、postgresql、access、sybase、informix这几种。以下是2021年db-engines ranking 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:https://db-engines.com/en/ranking）\n\n\n\n。。。\n\n\n\n对应的走势图：（https://db-engines.com/en/ranking_trend）\n\n\n\n\n# 2.4 常见的数据库介绍\n\noracle\n\n1979 年，oracle 2 诞生，它是第一个商用的 rdbms（关系型数据库管理系统）。随着 oracle 软件的名气越来越大，公司也改名叫 oracle 公司。\n\n2007年，总计85亿美金收购bea systems。\n\n2009年，总计74亿美金收购sun。此前的2008年，sun以10亿美金收购mysql。意味着oracle 同时拥有了 mysql 的管理权，至此 oracle 在数据库领域中成为绝对的领导者。\n\n2013年，甲骨文超越ibm，成为继microsoft后全球第二大软件公司。\n\n如今 oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。\n\nsql server\n\nsql server 是微软开发的大型商业数据库，诞生于 1989 年。c#、.net等语言常使用，与winnt完全集成，也可以很好地与microsoft backoffice产品集成。\n\ndb2\n\nibm公司的数据库产品,收费的。常应用在银行系统中。\n\npostgresql\n\npostgresql 的稳定性极强，最符合sql标准，开放源码，具备商业级dbms质量。pg对数据量大的文本以及sql处理较快。\n\nsybase\n\n已经淡出历史舞台。提供了一个非常专业数据建模的工具powerdesigner。\n\nsqlite\n\n嵌入式的小型数据库，应用在手机端。 零配置，sqlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。\n\ninformix\n\nibm公司出品，取自information 和unix的结合，它是第一个被移植到linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。\n\n\n# 3. mysql介绍\n\n\n\n\n# 3.1 概述\n\n * mysql是一个开放源代码的关系型数据库管理系统，由瑞典mysql ab（创始人michael widenius）公司1995年开发，迅速成为开源数据库的 no.1。\n * 2008被sun收购（10亿美金），2009年sun被oracle收购。mariadb应运而生。（mysql 的创造者担心 mysql 有闭源的风险，因此创建了 mysql 的分支项目 mariadb）\n * mysql6.x 版本之后分为社区版和商业版。\n * mysql是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n * mysql是开源的，所以你不需要支付额外的费用。\n * mysql是可以定制的，采用了gpl（gnu general public license）协议，你可以修改源码来开发自己的mysql系统。\n * mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n * mysql支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4gb，64位系统支持最大的表文件为8tb。\n * mysql使用标准的sql数据语言形式。\n * mysql可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括c、c++、python、java、perl、php和ruby等。\n\n\n# 3.2 mysql发展史重大事件\n\nmysql的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了mysql的长足发展。\n\n\n\n\n# 1.4 关于mysql 8.0\n\nmysql从5.7版本直接跳跃发布了8.0版本，可见这是一个令人兴奋的里程碑版本。mysql 8版本在功能上做了显著的改进与增强，开发者对mysql的源代码进行了重构，最突出的一点是多mysql optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。\n\n\n# 1.5 why choose mysql?\n\n\n\n为什么如此多的厂商要选用mysql？大概总结的原因主要有以下几点：\n\n 1. 开放源代码，使用成本低。\n\n 2. 性能卓越，服务稳定。\n\n 3. 软件体积小，使用简单，并且易于维护。\n\n 4. 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。\n\n 5. 许多互联网公司在用，经过了时间的验证。\n\n\n# 1.6 oracle vs mysql\n\noracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。\n\nmysql 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了mysql作为网站数据库（facebook，twitter，youtube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。\n\n\n# 4. rdbms 与 非rdbms\n\n从排名中我们能看出来，关系型数据库绝对是 dbms 的主流，其中使用最多的 dbms 分别是 oracle、mysql 和 sql server。这些都是关系型数据库（rdbms）。\n\n\n# 4.1 关系型数据库(rdbms)\n\n# 4.1.1 实质\n\n * 这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。\n   \n   \n\n * 关系型数据库以行(row)和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table)，一组表组成了一个库(database)。\n\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。\n\n * sql 就是关系型数据库的查询语言。\n\n\n\n# 4.1.2 优势\n\n * 复杂查询 可以用sql语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n * 事务支持 使得对于安全性能很高的数据访问要求得以实现。\n\n\n# 4.2 非关系型数据库(非rdbms)\n\n# 4.2.1 介绍\n\n非关系型数据库，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过sql层的解析，性能非常高。同时，通过减少不常用的功能，进一步提高性能。\n\n目前基本上大部分主流的非关系型数据库都是免费的。\n\n# 4.2.2 有哪些非关系型数据库\n\n相比于 sql，nosql 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 nosql 一词才能将这些技术囊括进来。\n\n键值型数据库\n\n键值型数据库通过 key-value 键值的方式来存储数据，其中 key 和 value 可以是简单的对象，也可以是复杂的对象。key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 where），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。\n\n键值型数据库典型的使用场景是作为内存缓存。redis是最流行的键值型数据库。\n\n\n\n文档型数据库\n\n此类数据库可存放并获取文档，可以是xml、json等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。mongodb 是最流行的文档型数据库。此外，还有couchdb等。\n\n搜索引擎数据库\n\n虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。\n\n典型产品：solr、elasticsearch、splunk 等。\n\n列式数据库\n\n列式数据库是相对于行式存储的数据库，oracle、mysql、sql server 等数据库都是采用的行式存储（row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 i/o，适合于分布式文件系统，不足在于功能相对有限。典型产品：hbase等。\n\n\n\n图形数据库\n\n图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。\n\n图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：neo4j、infogrid等。\n\n# 4.2.3 nosql的演变\n\n由于 sql 一直称霸 dbms，因此许多人在思考是否有一种数据库技术能远离 sql，于是 nosql 诞生了，但是随着发展却发现越来越离不开 sql。到目前为止 nosql 阵营中的 dbms 都会有实现类似 sql 的功能。下面是“nosql”这个名词在不同时期的诠释，从这些释义的变化中可以看出 nosql 功能的演变：\n\n1970：nosql = we have no sql\n\n1980：nosql = know sql\n\n2000：nosql = no sql!\n\n2005：nosql = not only sql\n\n2013：nosql = no, sql!\n\nnosql 对 sql 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。\n\n\n# 4.3 小结\n\nnosql 的分类很多，即便如此，在 dbms 排名中，还是 sql 阵营的比重更大，影响力前 5 的 dbms 中有 4 个是关系型数据库，而排名前 20 的 dbms 中也有 12 个是关系型数据库。所以说，掌握 sql 是非常有必要的。整套课程将围绕 sql 展开。\n\n\n# 5. 关系型数据库设计规则\n\n * 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（structured）。\n\n * 将数据放到表中，表再放到库中。\n\n * 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。\n\n * 表具有一些特性，这些特性定义了数据在表中如何存储，类似java和python中 “类”的设计。\n\n\n# 5.1 表、记录、字段\n\n * e-r（entity-relationship，实体-联系）模型中有三个主要概念是：实体集、属性、联系集。\n\n * 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。\n\n\n\norm思想 (object relational mapping)体现：\n数据库中的一个表  <---\x3e java或python中的一个类\n表中的一条数据  <---\x3e 类中的一个对象（或实体）\n表中的一个列  <----\x3e 类中的一个字段、属性(field)\n\n\n\n# 5.2 表的关联关系\n\n * 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。\n\n * 四种：一对一关联、一对多关联、多对多关联、自我引用\n\n# 5.2.1 一对一关联（one-to-one）\n\n * 在实际的开发中应用不多，因为一对一可以创建成一张表。\n * 举例：设计学生表：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、...\n   \n   * 拆为两个表：两个表的记录是一一对应关系。\n   \n   * 基础信息表（常用信息）：学号、姓名、手机号码、班级、系别\n   \n   * 档案信息表（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、...\n\n * 两种建表原则：\n   * 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\n   * 外键是主键：主表的主键和从表的主键，形成主外键关系。\n\n\n\n# 5.2.2 一对多关系（one-to-many）\n\n * 常见实例场景：客户表和订单表，分类表和商品表，部门表和员工表。\n * 举例：\n   \n   * 员工表：编号、姓名、...、所属部门\n   \n   * 部门表：编号、名称、简介\n\n * 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\n\n\n\n\n\n\n\n# 5.2.3 多对多（many-to-many）\n\n要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。\n\n\n\n * 举例1：学生-课程\n   \n   * 学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别...）\n   \n   * 课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介...）\n   \n   * 选课信息表：一个学生可以选多门课，一门课可以被多个学生选择\n     \n     学号     课程编号  \n     1        1001\n     2        1001\n     1        1002\n     \n\n * 举例2：产品-订单\n   \n   “订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。\n   \n   * 产品表：“产品”表中的每条记录表示一个产品。\n   * 订单表：“订单”表中的每条记录表示一个订单。\n   * 订单明细表：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。\n\n\n\n * 举例3：用户-角色\n * 多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。\n\n\n\n# 5.3.4 自我引用(self reference)\n\n",charsets:{cjk:!0}},{title:"概述",frontmatter:{title:"概述",date:"2022-02-03T17:56:40.000Z",permalink:"/spring/001/",categories:["框架","Spring"],tags:["Spring"],author:{name:"leejiayang"}},regularPath:"/07.%E6%A1%86%E6%9E%B6/01.Spring/01.%E6%A6%82%E8%BF%B0.html",relativePath:"07.框架/01.Spring/01.概述.md",key:"v-286c81e9",path:"/spring/001/",headersStr:null,content:"# 01. 概述\n\n 1. Spring是轻量级的开源的JavaEE框架\n 2. Spring可以解决企业应用开发的复杂性\n 3. Spring有两个核心部分：IOC和Aop\n\n * IOC：控制反转，把创建对象过程交给Spring进行管理\n * Aop：面向切面，不修改源代码进行功能增强\n\n 4. Spring特点\n\n * 方便解耦，简化开发\n * Aop编程支持\n * 方便程序测试\n * 方便和其他框架进行整合\n * 方便进行事务操作\n * 降低API开发难度",normalizedContent:"# 01. 概述\n\n 1. spring是轻量级的开源的javaee框架\n 2. spring可以解决企业应用开发的复杂性\n 3. spring有两个核心部分：ioc和aop\n\n * ioc：控制反转，把创建对象过程交给spring进行管理\n * aop：面向切面，不修改源代码进行功能增强\n\n 4. spring特点\n\n * 方便解耦，简化开发\n * aop编程支持\n * 方便程序测试\n * 方便和其他框架进行整合\n * 方便进行事务操作\n * 降低api开发难度",charsets:{cjk:!0}},{title:"SpringMVC简介",frontmatter:{title:"SpringMVC简介",date:"2022-04-26T00:00:00.000Z",permalink:"/springmvc/001/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/01.SpringMVC%E7%AE%80%E4%BB%8B.html",relativePath:"07.框架/02.SpringMVC/01.SpringMVC简介.md",key:"v-daab1818",path:"/springmvc/001/",headers:[{level:3,title:"1、什么是MVC",slug:"_1、什么是mvc",normalizedTitle:"1、什么是mvc",charIndex:20},{level:3,title:"2、什么是SpringMVC",slug:"_2、什么是springmvc",normalizedTitle:"2、什么是springmvc",charIndex:443},{level:3,title:"3、SpringMVC的特点",slug:"_3、springmvc的特点",normalizedTitle:"3、springmvc的特点",charIndex:684}],headersStr:"1、什么是MVC 2、什么是SpringMVC 3、SpringMVC的特点",content:"# 一、SpringMVC简介\n\n\n# 1、什么是MVC\n\nMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分\n\nM：Model，模型层，指工程中的JavaBean，作用是处理数据\n\nJavaBean分为两类：\n\n * 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等\n * 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。\n\nV：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据\n\nC：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器\n\nMVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器\n\n\n# 2、什么是SpringMVC\n\nSpringMVC是Spring的一个后续产品，是Spring的一个子项目\n\nSpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。\n\n> 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet\n\n\n# 3、SpringMVC的特点\n\n * Spring 家族原生产品，与 IOC 容器等基础设施无缝对接\n * 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理\n * 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案\n * 代码清新简洁，大幅度提升开发效率\n * 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可\n * 性能卓著，尤其适合现代大型、超大型互联网项目要求",normalizedContent:"# 一、springmvc简介\n\n\n# 1、什么是mvc\n\nmvc是一种软件架构的思想，将软件按照模型、视图、控制器来划分\n\nm：model，模型层，指工程中的javabean，作用是处理数据\n\njavabean分为两类：\n\n * 一类称为实体类bean：专门存储业务数据的，如 student、user 等\n * 一类称为业务处理 bean：指 service 或 dao 对象，专门用于处理业务逻辑和数据访问。\n\nv：view，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据\n\nc：controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器\n\nmvc的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被controller接收，controller调用相应的model层处理请求，处理完毕将结果返回到controller，controller再根据请求处理的结果找到相应的view视图，渲染数据后最终响应给浏览器\n\n\n# 2、什么是springmvc\n\nspringmvc是spring的一个后续产品，是spring的一个子项目\n\nspringmvc 是 spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 strust、webwork、strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 springmvc 作为 java ee 项目表述层开发的首选方案。\n\n> 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet\n\n\n# 3、springmvc的特点\n\n * spring 家族原生产品，与 ioc 容器等基础设施无缝对接\n * 基于原生的servlet，通过了功能强大的前端控制器dispatcherservlet，对请求和响应进行统一处理\n * 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案\n * 代码清新简洁，大幅度提升开发效率\n * 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可\n * 性能卓著，尤其适合现代大型、超大型互联网项目要求",charsets:{cjk:!0}},{title:"HelloWorld",frontmatter:{title:"HelloWorld",date:"2022-04-27T00:00:00.000Z",permalink:"/springmvc/002/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/02.HelloWorld.html",relativePath:"07.框架/02.SpringMVC/02.HelloWorld.md",key:"v-0f37f9f0",path:"/springmvc/002/",headers:[{level:3,title:"1、开发环境",slug:"_1、开发环境",normalizedTitle:"1、开发环境",charIndex:19},{level:3,title:"2、创建maven工程",slug:"_2、创建maven工程",normalizedTitle:"2、创建maven工程",charIndex:99},{level:5,title:"a>添加web模块",slug:"a-添加web模块",normalizedTitle:"a&gt;添加web模块",charIndex:null},{level:5,title:"b>打包方式：war",slug:"b-打包方式-war",normalizedTitle:"b&gt;打包方式：war",charIndex:null},{level:5,title:"c>引入依赖",slug:"c-引入依赖",normalizedTitle:"c&gt;引入依赖",charIndex:null},{level:3,title:"3、配置web.xml",slug:"_3、配置web-xml",normalizedTitle:"3、配置web.xml",charIndex:1025},{level:5,title:"a>默认配置方式",slug:"a-默认配置方式",normalizedTitle:"a&gt;默认配置方式",charIndex:null},{level:5,title:"b>扩展配置方式（最优配置方法）",slug:"b-扩展配置方式-最优配置方法",normalizedTitle:"b&gt;扩展配置方式（最优配置方法）",charIndex:null},{level:3,title:"4、创建请求控制器",slug:"_4、创建请求控制器",normalizedTitle:"4、创建请求控制器",charIndex:2927},{level:3,title:"5、创建springMVC的配置文件",slug:"_5、创建springmvc的配置文件",normalizedTitle:"5、创建springmvc的配置文件",charIndex:3194},{level:3,title:"6、测试HelloWorld",slug:"_6、测试helloworld",normalizedTitle:"6、测试helloworld",charIndex:4904},{level:5,title:"a>实现对首页的访问",slug:"a-实现对首页的访问",normalizedTitle:"a&gt;实现对首页的访问",charIndex:null},{level:5,title:"b>通过超链接跳转到指定页面",slug:"b-通过超链接跳转到指定页面",normalizedTitle:"b&gt;通过超链接跳转到指定页面",charIndex:null},{level:3,title:"7、总结",slug:"_7、总结",normalizedTitle:"7、总结",charIndex:5636}],headersStr:"1、开发环境 2、创建maven工程 a>添加web模块 b>打包方式：war c>引入依赖 3、配置web.xml a>默认配置方式 b>扩展配置方式（最优配置方法） 4、创建请求控制器 5、创建springMVC的配置文件 6、测试HelloWorld a>实现对首页的访问 b>通过超链接跳转到指定页面 7、总结",content:'# 二、HelloWorld\n\n\n# 1、开发环境\n\nIDE：idea 2019.2\n\n构建工具：maven3.5.4（解决依赖）\n\n服务器：tomcat7\n\nSpring版本：5.3.1\n\n\n# 2、创建maven工程\n\n# a>添加web模块\n\n# b>打包方式：war\n\n# c>引入依赖\n\n<dependencies>\n    \x3c!-- SpringMVC --\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.1</version>\n    </dependency>\n\n    \x3c!-- 日志 --\x3e\n    <dependency>\n        <groupId>ch.qos.logback</groupId>\n        <artifactId>logback-classic</artifactId>\n        <version>1.2.3</version>\n    </dependency>\n\n    \x3c!-- ServletAPI --\x3e\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>3.1.0</version>\n        <scope>provided</scope>\n    </dependency>\n\n    \x3c!-- Spring5和Thymeleaf整合包 --\x3e\n    <dependency>\n        <groupId>org.thymeleaf</groupId>\n        <artifactId>thymeleaf-spring5</artifactId>\n        <version>3.0.12.RELEASE</version>\n    </dependency>\n</dependencies>\n\n\n注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。\n\n\n\n\n# 3、配置web.xml\n\n注册SpringMVC的前端控制器DispatcherServlet（封装了对所有请求的处理）\n\n# a>默认配置方式\n\n此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为<servlet-name>-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml\n\n\x3c!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    \x3c!--\n        设置springMVC的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n# b>扩展配置方式（最优配置方法）\n\n可通过init-param标签设置SpringMVC配置文件的位置和名称（让webapp文件夹下只放web页面），通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间\n\n\x3c!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    \x3c!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --\x3e\n    <init-param>\n        \x3c!-- contextConfigLocation为固定值 --\x3e\n        <param-name>contextConfigLocation</param-name>\n        \x3c!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --\x3e\n        <param-value>classpath:springMVC.xml</param-value>\n    </init-param>\n    \x3c!-- \n \t\t作为框架的核心组件，在启动过程中有大量的初始化操作要做\n\t\t而这些操作放在第一次请求时才执行会严重影响访问速度\n\t\t因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时\n\t--\x3e\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    \x3c!--\n        设置springMVC的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n> 注：\n> \n> <url-pattern>标签中使用/和/*的区别：\n> \n> /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求\n> \n> 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面\n> \n> /*则能够匹配所有请求（包括jsp文件），例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法\n\n\n# 4、创建请求控制器\n\n由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器\n\n请求控制器中每一个处理请求的方法成为控制器方法\n\n因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过**@Controller**注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在\n\n@Controller\npublic class HelloController {\n    \n}\n\n\n\n# 5、创建springMVC的配置文件\n\n\x3c!-- 自动扫描包 --\x3e\n<context:component-scan base-package="com.atguigu.mvc.controller"/>\n\n\x3c!-- 配置Thymeleaf视图解析器 --\x3e\n<bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver">\n    \x3c!-- 配置视图解析器优先级（由此可见可以配置多个） --\x3e\n    <property name="order" value="1"/>\n    <property name="characterEncoding" value="UTF-8"/>\n    <property name="templateEngine">\n        <bean class="org.thymeleaf.spring5.SpringTemplateEngine">\n            <property name="templateResolver">\n                <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">\n    \n                    \x3c!-- 视图前缀 --\x3e\n                    <property name="prefix" value="/WEB-INF/templates/"/>\n    \n                    \x3c!-- 视图后缀 --\x3e\n                    <property name="suffix" value=".html"/>\n                    <property name="templateMode" value="HTML5"/>\n                    <property name="characterEncoding" value="UTF-8" />\n                </bean>\n            </property>\n        </bean>\n    </property>\n</bean>\n\n\x3c!-- \n   处理静态资源，例如html、js、css、jpg\n  若只设置该标签，则只能访问静态资源，其他请求则无法访问\n  此时必须设置<mvc:annotation-driven/>解决问题\n --\x3e\n<mvc:default-servlet-handler/>\n\n\x3c!-- 开启mvc注解驱动 --\x3e\n<mvc:annotation-driven>\n    <mvc:message-converters>\n        \x3c!-- 处理响应中文内容乱码 --\x3e\n        <bean class="org.springframework.http.converter.StringHttpMessageConverter">\n            <property name="defaultCharset" value="UTF-8" />\n            <property name="supportedMediaTypes">\n                <list>\n                    <value>text/html</value>\n                    <value>application/json</value>\n                </list>\n            </property>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n\n\n\n# 6、测试HelloWorld\n\n# a>实现对首页的访问\n\n在请求控制器中创建处理请求的方法\n\n// @RequestMapping注解：处理请求和控制器方法之间的映射关系\n// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径\n// localhost:8080/springMVC/\n@RequestMapping("/")\npublic String index() {\n    //设置视图名称\n    return "index";\n}\n\n\n以"/"开头表示绝对路径，即为localhost:8080/\n\n# b>通过超链接跳转到指定页面\n\n在主页index.html中设置超链接\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>首页</title>\n</head>\n<body>\n    <h1>首页</h1>\n    \x3c!-- {}里面的是绝对路径 --\x3e\n    \x3c!-- th（Thymeleaf）命名空间会进行自动添加上下文路径--\x3e\n    <a th:href="@{/hello}">HelloWorld</a><br/>\n</body>\n</html>\n\n\n在请求控制器中创建处理请求的方法\n\n@RequestMapping("/hello")\npublic String HelloWorld() {\n    // 同样也会返回视图名称 \n    return "target";\n}\n\n\n\n# 7、总结\n\n浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值（value名字可以省略写）进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面',normalizedContent:'# 二、helloworld\n\n\n# 1、开发环境\n\nide：idea 2019.2\n\n构建工具：maven3.5.4（解决依赖）\n\n服务器：tomcat7\n\nspring版本：5.3.1\n\n\n# 2、创建maven工程\n\n# a>添加web模块\n\n# b>打包方式：war\n\n# c>引入依赖\n\n<dependencies>\n    \x3c!-- springmvc --\x3e\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-webmvc</artifactid>\n        <version>5.3.1</version>\n    </dependency>\n\n    \x3c!-- 日志 --\x3e\n    <dependency>\n        <groupid>ch.qos.logback</groupid>\n        <artifactid>logback-classic</artifactid>\n        <version>1.2.3</version>\n    </dependency>\n\n    \x3c!-- servletapi --\x3e\n    <dependency>\n        <groupid>javax.servlet</groupid>\n        <artifactid>javax.servlet-api</artifactid>\n        <version>3.1.0</version>\n        <scope>provided</scope>\n    </dependency>\n\n    \x3c!-- spring5和thymeleaf整合包 --\x3e\n    <dependency>\n        <groupid>org.thymeleaf</groupid>\n        <artifactid>thymeleaf-spring5</artifactid>\n        <version>3.0.12.release</version>\n    </dependency>\n</dependencies>\n\n\n注：由于 maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。\n\n\n\n\n# 3、配置web.xml\n\n注册springmvc的前端控制器dispatcherservlet（封装了对所有请求的处理）\n\n# a>默认配置方式\n\n此配置作用下，springmvc的配置文件默认位于web-inf下，默认名称为<servlet-name>-servlet.xml，例如，以下配置所对应springmvc的配置文件位于web-inf下，文件名为springmvc-servlet.xml\n\n\x3c!-- 配置springmvc的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    \x3c!--\n        设置springmvc的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n# b>扩展配置方式（最优配置方法）\n\n可通过init-param标签设置springmvc配置文件的位置和名称（让webapp文件夹下只放web页面），通过load-on-startup标签设置springmvc前端控制器dispatcherservlet的初始化时间\n\n\x3c!-- 配置springmvc的前端控制器，对浏览器发送的请求统一进行处理 --\x3e\n<servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n    \x3c!-- 通过初始化参数指定springmvc配置文件的位置和名称 --\x3e\n    <init-param>\n        \x3c!-- contextconfiglocation为固定值 --\x3e\n        <param-name>contextconfiglocation</param-name>\n        \x3c!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --\x3e\n        <param-value>classpath:springmvc.xml</param-value>\n    </init-param>\n    \x3c!-- \n \t\t作为框架的核心组件，在启动过程中有大量的初始化操作要做\n\t\t而这些操作放在第一次请求时才执行会严重影响访问速度\n\t\t因此需要通过此标签将启动控制dispatcherservlet的初始化时间提前到服务器启动时\n\t--\x3e\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    \x3c!--\n        设置springmvc的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    --\x3e\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n\n> 注：\n> \n> <url-pattern>标签中使用/和/*的区别：\n> \n> /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求\n> \n> 因此就可以避免在访问jsp页面时，该请求被dispatcherservlet处理，从而找不到相应的页面\n> \n> /*则能够匹配所有请求（包括jsp文件），例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法\n\n\n# 4、创建请求控制器\n\n由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器\n\n请求控制器中每一个处理请求的方法成为控制器方法\n\n因为springmvc的控制器由一个pojo（普通的java类）担任，因此需要通过**@controller**注解将其标识为一个控制层组件，交给spring的ioc容器管理，此时springmvc才能够识别控制器的存在\n\n@controller\npublic class hellocontroller {\n    \n}\n\n\n\n# 5、创建springmvc的配置文件\n\n\x3c!-- 自动扫描包 --\x3e\n<context:component-scan base-package="com.atguigu.mvc.controller"/>\n\n\x3c!-- 配置thymeleaf视图解析器 --\x3e\n<bean id="viewresolver" class="org.thymeleaf.spring5.view.thymeleafviewresolver">\n    \x3c!-- 配置视图解析器优先级（由此可见可以配置多个） --\x3e\n    <property name="order" value="1"/>\n    <property name="characterencoding" value="utf-8"/>\n    <property name="templateengine">\n        <bean class="org.thymeleaf.spring5.springtemplateengine">\n            <property name="templateresolver">\n                <bean class="org.thymeleaf.spring5.templateresolver.springresourcetemplateresolver">\n    \n                    \x3c!-- 视图前缀 --\x3e\n                    <property name="prefix" value="/web-inf/templates/"/>\n    \n                    \x3c!-- 视图后缀 --\x3e\n                    <property name="suffix" value=".html"/>\n                    <property name="templatemode" value="html5"/>\n                    <property name="characterencoding" value="utf-8" />\n                </bean>\n            </property>\n        </bean>\n    </property>\n</bean>\n\n\x3c!-- \n   处理静态资源，例如html、js、css、jpg\n  若只设置该标签，则只能访问静态资源，其他请求则无法访问\n  此时必须设置<mvc:annotation-driven/>解决问题\n --\x3e\n<mvc:default-servlet-handler/>\n\n\x3c!-- 开启mvc注解驱动 --\x3e\n<mvc:annotation-driven>\n    <mvc:message-converters>\n        \x3c!-- 处理响应中文内容乱码 --\x3e\n        <bean class="org.springframework.http.converter.stringhttpmessageconverter">\n            <property name="defaultcharset" value="utf-8" />\n            <property name="supportedmediatypes">\n                <list>\n                    <value>text/html</value>\n                    <value>application/json</value>\n                </list>\n            </property>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n\n\n\n# 6、测试helloworld\n\n# a>实现对首页的访问\n\n在请求控制器中创建处理请求的方法\n\n// @requestmapping注解：处理请求和控制器方法之间的映射关系\n// @requestmapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径\n// localhost:8080/springmvc/\n@requestmapping("/")\npublic string index() {\n    //设置视图名称\n    return "index";\n}\n\n\n以"/"开头表示绝对路径，即为localhost:8080/\n\n# b>通过超链接跳转到指定页面\n\n在主页index.html中设置超链接\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>首页</title>\n</head>\n<body>\n    <h1>首页</h1>\n    \x3c!-- {}里面的是绝对路径 --\x3e\n    \x3c!-- th（thymeleaf）命名空间会进行自动添加上下文路径--\x3e\n    <a th:href="@{/hello}">helloworld</a><br/>\n</body>\n</html>\n\n\n在请求控制器中创建处理请求的方法\n\n@requestmapping("/hello")\npublic string helloworld() {\n    // 同样也会返回视图名称 \n    return "target";\n}\n\n\n\n# 7、总结\n\n浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器dispatcherservlet处理。前端控制器会读取springmvc的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@requestmapping注解的value属性值（value名字可以省略写）进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过thymeleaf对视图进行渲染，最终转发到视图所对应页面',charsets:{cjk:!0}},{title:"RequestMapping注解",frontmatter:{title:"RequestMapping注解",date:"2022-04-28T00:00:00.000Z",permalink:"/springmvc/003/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/03.RequestMapping%E6%B3%A8%E8%A7%A3.html",relativePath:"07.框架/02.SpringMVC/03.RequestMapping注解.md",key:"v-5198e7be",path:"/springmvc/003/",headers:[{level:3,title:"1、@RequestMapping注解的功能",slug:"_1、-requestmapping注解的功能",normalizedTitle:"1、@requestmapping注解的功能",charIndex:26},{level:3,title:"2、@RequestMapping注解的位置",slug:"_2、-requestmapping注解的位置",normalizedTitle:"2、@requestmapping注解的位置",charIndex:243},{level:3,title:"3、@RequestMapping注解的value属性",slug:"_3、-requestmapping注解的value属性",normalizedTitle:"3、@requestmapping注解的value属性",charIndex:667},{level:3,title:"4、@RequestMapping注解的method属性",slug:"_4、-requestmapping注解的method属性",normalizedTitle:"4、@requestmapping注解的method属性",charIndex:1176},{level:3,title:"5、@RequestMapping注解的params属性（了解）",slug:"_5、-requestmapping注解的params属性-了解",normalizedTitle:"5、@requestmapping注解的params属性（了解）",charIndex:2299},{level:3,title:"6、@RequestMapping注解的headers属性（了解）",slug:"_6、-requestmapping注解的headers属性-了解",normalizedTitle:"6、@requestmapping注解的headers属性（了解）",charIndex:3282},{level:3,title:"7、SpringMVC支持ant风格的路径",slug:"_7、springmvc支持ant风格的路径",normalizedTitle:"7、springmvc支持ant风格的路径",charIndex:3702},{level:3,title:"8、SpringMVC支持路径中的占位符（重点）",slug:"_8、springmvc支持路径中的占位符-重点",normalizedTitle:"8、springmvc支持路径中的占位符（重点）",charIndex:3854}],headersStr:"1、@RequestMapping注解的功能 2、@RequestMapping注解的位置 3、@RequestMapping注解的value属性 4、@RequestMapping注解的method属性 5、@RequestMapping注解的params属性（了解） 6、@RequestMapping注解的headers属性（了解） 7、SpringMVC支持ant风格的路径 8、SpringMVC支持路径中的占位符（重点）",content:'# 三、@RequestMapping注解\n\n\n# 1、@RequestMapping注解的功能\n\n从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。\n\n多个RequestMapping如果请求路径是一样的，RequestMapping不知道具体的请求路径，则会报错，所以必须保证请求路径/请求地址的唯一性。\n\nSpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n\n\n# 2、@RequestMapping注解的位置\n\n@RequestMapping标识一个类：设置映射请求的请求路径的初始信息\n\n@RequestMapping标识一个方法：设置映射请求请求路径的具体信息\n\n@Controller\n@RequestMapping("/test")\npublic class RequestMappingController {\n\n\t//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping\n    @RequestMapping("/testRequestMapping")\n    // @RequestMapping("/test/testRequestMapping")才是正确的表达方式，相当于"类注解+方法注解"\n    public String testRequestMapping(){\n        return "success";\n    }\n\n}\n\n\n\n# 3、@RequestMapping注解的value属性\n\n@RequestMapping注解的value属性通过请求的请求地址匹配请求映射\n\n@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求\n\n@RequestMapping注解的value属性必须设置（其他可以不设置），至少通过请求地址匹配请求映射\n\n<a th:href="@{/testRequestMapping}">测试@RequestMapping的value属性--\x3e/testRequestMapping</a><br>\n<a th:href="@{/test}">测试@RequestMapping的value属性--\x3e/test</a><br>\n\n\n@RequestMapping(\n    // 处理多个请求\n    // 只要满足一个就可以被处理\n    value = {"/testRequestMapping", "/test"}\n)\npublic String testRequestMapping(){\n    return "success";\n}\n\n\n\n# 4、@RequestMapping注解的method属性\n\n@RequestMapping注解的method属性通过请求的请求方式（get或post）（put和delete不是很常用）匹配请求映射\n\nget请求和post请求的区别是什么？？？？？？？？\n\n@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求\n\n不设置method参数默认可以匹配任何类型的请求 设置method就只能匹配的指定的请求方式。\n\nmethod参数可以设置多个值（{值1， 值2， 值3， .....}）\n\n若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method \'POST\' not supported\n\n<a th:href="@{/test}">测试@RequestMapping的value属性--\x3e/test</a><br>\n<form th:action="@{/test}" method="post">\n    <input type="submit">\n</form>\n\n\n// 不知道写什么就把value值和方法名写成一样的\n@RequestMapping(\n        value = {"/testRequestMapping", "/test"},\n        method = {RequestMethod.GET, RequestMethod.POST}\n)\npublic String testRequestMapping(){\n    return "success";\n}\n\n\n> 注：\n> \n> 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解\n> \n> 处理get请求的映射--\x3e@GetMapping\n> \n> 处理post请求的映射--\x3e@PostMapping\n> \n> 处理put请求的映射--\x3e@PutMapping\n> \n> 处理delete请求的映射--\x3e@DeleteMapping\n> \n> 2、常用的请求方式有get，post，put，delete\n> \n> 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理\n> \n> 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到\n\n\n# 5、@RequestMapping注解的params属性（了解）\n\n@RequestMapping注解的params属性通过请求的请求参数匹配请求映射\n\n@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系\n\n"param"：要求请求映射所匹配的请求必须携带param请求参数\n\n"!param"：要求请求映射所匹配的请求必须不能携带param请求参数\n\n"param=value"：要求请求映射所匹配的请求必须携带param请求参数且param=value\n\n"param!=value"：要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n\n@{/test?username=\'admin\'}和@{/test(username=\'admin\')}在解析时本质上没有任何区别，关键在于?会在IDEA中报错,使用()方法则没有报错的提醒，（）会在浏览器中自动被解析为？连接方法\n<a th:href="@{/test(username=\'admin\',password=123456)}">测试@RequestMapping的params属性--\x3e/test</a><br>\n\n\n@RequestMapping(\n        value = {"/testRequestMapping", "/test"}\n        ,method = {RequestMethod.GET, RequestMethod.POST}\n        ,params = {"username","password!=123456"}\n)\npublic String testRequestMapping(){\n    return "success";\n}\n\n\n> 注：\n> \n> 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions "username, password!=123456" not met for actual request parameters: username={admin}, password={123456}\n\n\n# 6、@RequestMapping注解的headers属性（了解）\n\n@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射\n\n@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系\n\n"header"：要求请求映射所匹配的请求必须携带header请求头信息\n\n"!header"：要求请求映射所匹配的请求必须不能携带header请求头信息\n\n"header=value"：要求请求映射所匹配的请求必须携带header请求头信息且header=value\n\n"header!=value"：要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n\n若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到\n\n\n# 7、SpringMVC支持ant风格的路径\n\n以下字符均可以在value属性中进行应用 ？：表示任意的单个字符\n\n*：表示任意的0个或多个字符\n\n**：表示任意的一层或多层目录\n\n注意：在使用*时 只能使用/*/xxx的方式，不能在两个**之前加任何字符，如"/a**a/test"就是错误的。\n\n\n# 8、SpringMVC支持路径中的占位符（重点）\n\n原始方式：/deleteUser?id=1\n\nrest方式：/deleteUser/1\n\nSpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参\n\n<a th:href="@{/testRest/1/admin}">测试路径中的占位符--\x3e/testRest</a><br>\n\n\n@RequestMapping("/testRest/{id}/{username}")\npublic String testRest(@PathVariable("id") String id, @PathVariable("username") String username){\n    System.out.println("id:"+id+",username:"+username);\n    return "success";\n}\n//最终输出的内容为--\x3eid:1,username:admin\n',normalizedContent:'# 三、@requestmapping注解\n\n\n# 1、@requestmapping注解的功能\n\n从注解名称上我们可以看到，@requestmapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。\n\n多个requestmapping如果请求路径是一样的，requestmapping不知道具体的请求路径，则会报错，所以必须保证请求路径/请求地址的唯一性。\n\nspringmvc 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n\n\n# 2、@requestmapping注解的位置\n\n@requestmapping标识一个类：设置映射请求的请求路径的初始信息\n\n@requestmapping标识一个方法：设置映射请求请求路径的具体信息\n\n@controller\n@requestmapping("/test")\npublic class requestmappingcontroller {\n\n\t//此时请求映射所映射的请求的请求路径为：/test/testrequestmapping\n    @requestmapping("/testrequestmapping")\n    // @requestmapping("/test/testrequestmapping")才是正确的表达方式，相当于"类注解+方法注解"\n    public string testrequestmapping(){\n        return "success";\n    }\n\n}\n\n\n\n# 3、@requestmapping注解的value属性\n\n@requestmapping注解的value属性通过请求的请求地址匹配请求映射\n\n@requestmapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求\n\n@requestmapping注解的value属性必须设置（其他可以不设置），至少通过请求地址匹配请求映射\n\n<a th:href="@{/testrequestmapping}">测试@requestmapping的value属性--\x3e/testrequestmapping</a><br>\n<a th:href="@{/test}">测试@requestmapping的value属性--\x3e/test</a><br>\n\n\n@requestmapping(\n    // 处理多个请求\n    // 只要满足一个就可以被处理\n    value = {"/testrequestmapping", "/test"}\n)\npublic string testrequestmapping(){\n    return "success";\n}\n\n\n\n# 4、@requestmapping注解的method属性\n\n@requestmapping注解的method属性通过请求的请求方式（get或post）（put和delete不是很常用）匹配请求映射\n\nget请求和post请求的区别是什么？？？？？？？？\n\n@requestmapping注解的method属性是一个requestmethod类型的数组，表示该请求映射能够匹配多种请求方式的请求\n\n不设置method参数默认可以匹配任何类型的请求 设置method就只能匹配的指定的请求方式。\n\nmethod参数可以设置多个值（{值1， 值2， 值3， .....}）\n\n若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：request method \'post\' not supported\n\n<a th:href="@{/test}">测试@requestmapping的value属性--\x3e/test</a><br>\n<form th:action="@{/test}" method="post">\n    <input type="submit">\n</form>\n\n\n// 不知道写什么就把value值和方法名写成一样的\n@requestmapping(\n        value = {"/testrequestmapping", "/test"},\n        method = {requestmethod.get, requestmethod.post}\n)\npublic string testrequestmapping(){\n    return "success";\n}\n\n\n> 注：\n> \n> 1、对于处理指定请求方式的控制器方法，springmvc中提供了@requestmapping的派生注解\n> \n> 处理get请求的映射--\x3e@getmapping\n> \n> 处理post请求的映射--\x3e@postmapping\n> \n> 处理put请求的映射--\x3e@putmapping\n> \n> 处理delete请求的映射--\x3e@deletemapping\n> \n> 2、常用的请求方式有get，post，put，delete\n> \n> 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理\n> \n> 若要发送put和delete请求，则需要通过spring提供的过滤器hiddenhttpmethodfilter，在restful部分会讲到\n\n\n# 5、@requestmapping注解的params属性（了解）\n\n@requestmapping注解的params属性通过请求的请求参数匹配请求映射\n\n@requestmapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系\n\n"param"：要求请求映射所匹配的请求必须携带param请求参数\n\n"!param"：要求请求映射所匹配的请求必须不能携带param请求参数\n\n"param=value"：要求请求映射所匹配的请求必须携带param请求参数且param=value\n\n"param!=value"：要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n\n@{/test?username=\'admin\'}和@{/test(username=\'admin\')}在解析时本质上没有任何区别，关键在于?会在idea中报错,使用()方法则没有报错的提醒，（）会在浏览器中自动被解析为？连接方法\n<a th:href="@{/test(username=\'admin\',password=123456)}">测试@requestmapping的params属性--\x3e/test</a><br>\n\n\n@requestmapping(\n        value = {"/testrequestmapping", "/test"}\n        ,method = {requestmethod.get, requestmethod.post}\n        ,params = {"username","password!=123456"}\n)\npublic string testrequestmapping(){\n    return "success";\n}\n\n\n> 注：\n> \n> 若当前请求满足@requestmapping注解的value和method属性，但是不满足params属性，此时页面回报错400：parameter conditions "username, password!=123456" not met for actual request parameters: username={admin}, password={123456}\n\n\n# 6、@requestmapping注解的headers属性（了解）\n\n@requestmapping注解的headers属性通过请求的请求头信息匹配请求映射\n\n@requestmapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系\n\n"header"：要求请求映射所匹配的请求必须携带header请求头信息\n\n"!header"：要求请求映射所匹配的请求必须不能携带header请求头信息\n\n"header=value"：要求请求映射所匹配的请求必须携带header请求头信息且header=value\n\n"header!=value"：要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n\n若当前请求满足@requestmapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到\n\n\n# 7、springmvc支持ant风格的路径\n\n以下字符均可以在value属性中进行应用 ？：表示任意的单个字符\n\n*：表示任意的0个或多个字符\n\n**：表示任意的一层或多层目录\n\n注意：在使用*时 只能使用/*/xxx的方式，不能在两个**之前加任何字符，如"/a**a/test"就是错误的。\n\n\n# 8、springmvc支持路径中的占位符（重点）\n\n原始方式：/deleteuser?id=1\n\nrest方式：/deleteuser/1\n\nspringmvc路径中的占位符常用于restful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@requestmapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@pathvariable注解，将占位符所表示的数据赋值给控制器方法的形参\n\n<a th:href="@{/testrest/1/admin}">测试路径中的占位符--\x3e/testrest</a><br>\n\n\n@requestmapping("/testrest/{id}/{username}")\npublic string testrest(@pathvariable("id") string id, @pathvariable("username") string username){\n    system.out.println("id:"+id+",username:"+username);\n    return "success";\n}\n//最终输出的内容为--\x3eid:1,username:admin\n',charsets:{cjk:!0}},{title:"SpringMVC获取请求参数",frontmatter:{title:"SpringMVC获取请求参数",date:"2022-05-01T00:00:00.000Z",permalink:"/springmvc/004/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/04.SpringMVC%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0.html",relativePath:"07.框架/02.SpringMVC/04.SpringMVC获取请求参数.md",key:"v-b0aca0e0",path:"/springmvc/004/",headers:[{level:3,title:"1、通过ServletAPI获取（原生的不推荐用，因为SpringMVC已经有封装了）",slug:"_1、通过servletapi获取-原生的不推荐用-因为springmvc已经有封装了",normalizedTitle:"1、通过servletapi获取（原生的不推荐用，因为springmvc已经有封装了）",charIndex:24},{level:3,title:"2、通过控制器方法的形参获取请求参数",slug:"_2、通过控制器方法的形参获取请求参数",normalizedTitle:"2、通过控制器方法的形参获取请求参数",charIndex:571},{level:3,title:"3、@RequestParam",slug:"_3、-requestparam",normalizedTitle:"3、@requestparam",charIndex:1101},{level:3,title:"4、@RequestHeader",slug:"_4、-requestheader",normalizedTitle:"4、@requestheader",charIndex:1575},{level:3,title:"5、@CookieValue",slug:"_5、-cookievalue",normalizedTitle:"5、@cookievalue",charIndex:1704},{level:3,title:"6、通过POJO获取请求参数",slug:"_6、通过pojo获取请求参数",normalizedTitle:"6、通过pojo获取请求参数",charIndex:1830},{level:3,title:"7、解决获取请求参数的乱码问题",slug:"_7、解决获取请求参数的乱码问题",normalizedTitle:"7、解决获取请求参数的乱码问题",charIndex:2494}],headersStr:"1、通过ServletAPI获取（原生的不推荐用，因为SpringMVC已经有封装了） 2、通过控制器方法的形参获取请求参数 3、@RequestParam 4、@RequestHeader 5、@CookieValue 6、通过POJO获取请求参数 7、解决获取请求参数的乱码问题",content:'# 四、SpringMVC获取请求参数\n\n\n# 1、通过ServletAPI获取（原生的不推荐用，因为SpringMVC已经有封装了）\n\n将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象\n\n@RequestMapping("/testParam")\n// 形参位置的request表示当前请求\n// 这里不能用斜线占位符的方法传递参数\npublic String testParam(HttpServletRequest request){\n    String username = request.getParameter("username");\n    String password = request.getParameter("password");\n    System.out.println("username:"+username+",password:"+password);\n    return "success";\n}\n\n\n<a th:href="@{/testParam(username=\'admin\',password=123456)}">测试获取请求参数--\x3e/testParam</a><br>\n\n\n\n# 2、通过控制器方法的形参获取请求参数\n\n在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参\n\n<a th:href="@{/testParam(username=\'admin\',password=123456)}">测试获取请求参数--\x3e/testParam</a><br>\n\n\n@RequestMapping("/testParam")\npublic String testParam(String username, String password){\n    System.out.println("username:"+username+",password:"+password);\n    return "success";\n}\n\n\n> 注：\n> \n> 若请求所传输的请求参数中有多个同名的请求参数（复选框），此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数\n> \n> 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据\n> \n> 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n\n\n# 3、@RequestParam\n\n@RequestParam是将请求参数和控制器方法的形参创建映射关系\n\n@Request("user_name") String username 将前端的user_name绑定到java中的形参\n\n@RequestParam注解一共有三个属性：\n\nvalue：指定为形参赋值的请求参数的参数名\n\nrequired：设置是否必须传输此请求参数（前端的网页变量必须有输入），默认值为true\n\n若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter \'xxx\' is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null\n\ndefaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值\n\n\n# 4、@RequestHeader\n\n@RequestHeader是将请求头信息和控制器方法的形参创建映射关系\n\n@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n\n\n# 5、@CookieValue\n\n@CookieValue是将cookie数据和控制器方法的形参创建映射关系\n\n@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n\n\n# 6、通过POJO获取请求参数\n\n可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值\n\n<form th:action="@{/testpojo}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    性别：<input type="radio" name="sex" value="男">男<input type="radio" name="sex" value="女">女<br>\n    年龄：<input type="text" name="age"><br>\n    邮箱：<input type="text" name="email"><br>\n    <input type="submit">\n</form>\n\n\n@RequestMapping("/testpojo")\npublic String testPOJO(User user){\n    System.out.println(user);\n    return "success";\n}\n//最终结果--\x3eUser{id=null, username=\'张三\', password=\'123\', age=23, sex=\'男\', email=\'123@qq.com\'}\n\n\n\n# 7、解决获取请求参数的乱码问题\n\n解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册\n\nget请求的乱码是tomcat造成的，解决方法就是在tomcat的server.xml配置文件中进行修改\n\npost请求乱码修改如下\n\n\x3c!--配置springMVC的编码过滤器--\x3e\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>UTF-8</param-value>\n    </init-param>\n    <init-param>\n        \x3c!-- 这里设置相应编码，可以不设置但是推荐设置 --\x3e\n        <param-name>forceResponseEncoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n> 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效',normalizedContent:'# 四、springmvc获取请求参数\n\n\n# 1、通过servletapi获取（原生的不推荐用，因为springmvc已经有封装了）\n\n将httpservletrequest作为控制器方法的形参，此时httpservletrequest类型的参数表示封装了当前请求的请求报文的对象\n\n@requestmapping("/testparam")\n// 形参位置的request表示当前请求\n// 这里不能用斜线占位符的方法传递参数\npublic string testparam(httpservletrequest request){\n    string username = request.getparameter("username");\n    string password = request.getparameter("password");\n    system.out.println("username:"+username+",password:"+password);\n    return "success";\n}\n\n\n<a th:href="@{/testparam(username=\'admin\',password=123456)}">测试获取请求参数--\x3e/testparam</a><br>\n\n\n\n# 2、通过控制器方法的形参获取请求参数\n\n在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在dispatcherservlet中就会将请求参数赋值给相应的形参\n\n<a th:href="@{/testparam(username=\'admin\',password=123456)}">测试获取请求参数--\x3e/testparam</a><br>\n\n\n@requestmapping("/testparam")\npublic string testparam(string username, string password){\n    system.out.println("username:"+username+",password:"+password);\n    return "success";\n}\n\n\n> 注：\n> \n> 若请求所传输的请求参数中有多个同名的请求参数（复选框），此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数\n> \n> 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据\n> \n> 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n\n\n# 3、@requestparam\n\n@requestparam是将请求参数和控制器方法的形参创建映射关系\n\n@request("user_name") string username 将前端的user_name绑定到java中的形参\n\n@requestparam注解一共有三个属性：\n\nvalue：指定为形参赋值的请求参数的参数名\n\nrequired：设置是否必须传输此请求参数（前端的网页变量必须有输入），默认值为true\n\n若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultvalue属性，则页面报错400：required string parameter \'xxx\' is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null\n\ndefaultvalue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值\n\n\n# 4、@requestheader\n\n@requestheader是将请求头信息和控制器方法的形参创建映射关系\n\n@requestheader注解一共有三个属性：value、required、defaultvalue，用法同@requestparam\n\n\n# 5、@cookievalue\n\n@cookievalue是将cookie数据和控制器方法的形参创建映射关系\n\n@cookievalue注解一共有三个属性：value、required、defaultvalue，用法同@requestparam\n\n\n# 6、通过pojo获取请求参数\n\n可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值\n\n<form th:action="@{/testpojo}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    性别：<input type="radio" name="sex" value="男">男<input type="radio" name="sex" value="女">女<br>\n    年龄：<input type="text" name="age"><br>\n    邮箱：<input type="text" name="email"><br>\n    <input type="submit">\n</form>\n\n\n@requestmapping("/testpojo")\npublic string testpojo(user user){\n    system.out.println(user);\n    return "success";\n}\n//最终结果--\x3euser{id=null, username=\'张三\', password=\'123\', age=23, sex=\'男\', email=\'123@qq.com\'}\n\n\n\n# 7、解决获取请求参数的乱码问题\n\n解决获取请求参数的乱码问题，可以使用springmvc提供的编码过滤器characterencodingfilter，但是必须在web.xml中进行注册\n\nget请求的乱码是tomcat造成的，解决方法就是在tomcat的server.xml配置文件中进行修改\n\npost请求乱码修改如下\n\n\x3c!--配置springmvc的编码过滤器--\x3e\n<filter>\n    <filter-name>characterencodingfilter</filter-name>\n    <filter-class>org.springframework.web.filter.characterencodingfilter</filter-class>\n\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n    <init-param>\n        \x3c!-- 这里设置相应编码，可以不设置但是推荐设置 --\x3e\n        <param-name>forceresponseencoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>characterencodingfilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n> 注： springmvc中处理编码的过滤器一定要配置到其他过滤器之前，否则无效',charsets:{cjk:!0}},{title:"域对象共享数据",frontmatter:{title:"域对象共享数据",date:"2022-05-04T00:00:00.000Z",permalink:"/springmvc/005/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/05.%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE.html",relativePath:"07.框架/02.SpringMVC/05.域对象共享数据.md",key:"v-a6493882",path:"/springmvc/005/",headers:[{level:3,title:"1、使用ServletAPI向request域对象共享数据（原生Servlet）",slug:"_1、使用servletapi向request域对象共享数据-原生servlet",normalizedTitle:"1、使用servletapi向request域对象共享数据（原生servlet）",charIndex:30},{level:3,title:"2、使用ModelAndView向request域对象共享数据（springmvc）",slug:"_2、使用modelandview向request域对象共享数据-springmvc",normalizedTitle:"2、使用modelandview向request域对象共享数据（springmvc）",charIndex:353},{level:3,title:"3、使用Model向request域对象共享数据",slug:"_3、使用model向request域对象共享数据",normalizedTitle:"3、使用model向request域对象共享数据",charIndex:852},{level:3,title:"4、使用map向request域对象共享数据",slug:"_4、使用map向request域对象共享数据",normalizedTitle:"4、使用map向request域对象共享数据",charIndex:1027},{level:3,title:"5、使用ModelMap向request域对象共享数据",slug:"_5、使用modelmap向request域对象共享数据",normalizedTitle:"5、使用modelmap向request域对象共享数据",charIndex:1195},{level:3,title:"6、Model、ModelMap、Map的关系",slug:"_6、model、modelmap、map的关系",normalizedTitle:"6、model、modelmap、map的关系",charIndex:1420},{level:3,title:"7、向session域共享数据",slug:"_7、向session域共享数据",normalizedTitle:"7、向session域共享数据",charIndex:1807},{level:3,title:"8、向application域共享数据（此时的域为整个工程，因为在服务器启动时已经被初始化，一般情况下只用request和session）",slug:"_8、向application域共享数据-此时的域为整个工程-因为在服务器启动时已经被初始化-一般情况下只用request和session",normalizedTitle:"8、向application域共享数据（此时的域为整个工程，因为在服务器启动时已经被初始化，一般情况下只用request和session）",charIndex:2115}],headersStr:"1、使用ServletAPI向request域对象共享数据（原生Servlet） 2、使用ModelAndView向request域对象共享数据（springmvc） 3、使用Model向request域对象共享数据 4、使用map向request域对象共享数据 5、使用ModelMap向request域对象共享数据 6、Model、ModelMap、Map的关系 7、向session域共享数据 8、向application域共享数据（此时的域为整个工程，因为在服务器启动时已经被初始化，一般情况下只用request和session）",content:'# 五、域对象共享数据\n\n（request域对象）\n\n\n# 1、使用ServletAPI向request域对象共享数据（原生Servlet）\n\n@RequestMapping("/testServletAPI")\npublic String testServletAPI(HttpServletRequest request){\n    // setaTTRIBUTE为request共享数据的方法\n    request.setAttribute("testScope", "hello,servletAPI");\n    return "success";\n}\n\n\n获取数据方法\n<a th:text="${testScope}">测试获取请求参数--\x3e/testParam</a><br>\n\n\n\n# 2、使用ModelAndView向request域对象共享数据（springmvc）\n\n@RequestMapping("/testModelAndView")\n// 返回值必须为modelandview\npublic ModelAndView testModelAndView(){\n    /**\n     * ModelAndView有Model和View的功能\n     * Model主要用于向请求域共享数据\n     * View主要用于设置视图，实现页面跳转\n     */\n    ModelAndView mav = new ModelAndView();\n    //向请求域共享数据\n    // 处理模型书，即向请求域request共享数据\n    mav.addObject("testScope", "hello,ModelAndView");\n    //设置视图，实现页面跳转\n    // 设置视图名称\n    mav.setViewName("success");\n\n    // 必须返回modelandview\n    return mav;\n}\n\n\n\n# 3、使用Model向request域对象共享数据\n\n@RequestMapping("/testModel")\npublic String testModel(Model model){\n    model.addAttribute("testScope", "hello,Model");\n    return "success";\n}\n\n\n\n# 4、使用map向request域对象共享数据\n\n@RequestMapping("/testMap")\npublic String testMap(Map<String, Object> map){\n    map.put("testScope", "hello,Map");\n    return "success";\n}\n\n\n\n# 5、使用ModelMap向request域对象共享数据\n\n@RequestMapping("/testModelMap")\npublic String testModelMap(ModelMap modelMap){\n    modelMap.addAttribute("testScope", "hello,ModelMap");\n    return "success";\n}\n\n\n二三四五对应的前端页面（springmvc提供的方法）\n\n\n# 6、Model、ModelMap、Map的关系\n\nModel、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的\n\n输出信息是一样的\n\npublic interface Model{}  // 顶层接口\npublic class ModelMap extends LinkedHashMap<String, Object> {}  // 等价于modelmap实现了map\npublic class ExtendedModelMap extends ModelMap implements Model {}\npublic class BindingAwareModelMap extends ExtendedModelMap {}\n\n\n这里需要注意的是： 控制器方法执行之后都会返回同一的ModelAndView对象\n\n\n# 7、向session域共享数据\n\nspringmvc中提供了一些共享数据到session的方法，但是最推荐原生的这种，简单易懂\n\n一个名为sessionarribute的注解可以把共享域中数据共享到session，但是不太好用\n\nsession常用来保存用户的登录状态\n\n@RequestMapping("/testSession")\npublic String testSession(HttpSession session){\n    session.setAttribute("testSessionScope", "hello,session");\n    return "success";\n}\n\n\n\n# 8、向application域共享数据（此时的域为整个工程，因为在服务器启动时已经被初始化，一般情况下只用request和session）\n\n@RequestMapping("/testApplication")\npublic String testApplication(HttpSession session){\n\tServletContext application = session.getServletContext();\n    application.setAttribute("testApplicationScope", "hello,application");\n    return "success";\n}\n\n\n',normalizedContent:'# 五、域对象共享数据\n\n（request域对象）\n\n\n# 1、使用servletapi向request域对象共享数据（原生servlet）\n\n@requestmapping("/testservletapi")\npublic string testservletapi(httpservletrequest request){\n    // setattribute为request共享数据的方法\n    request.setattribute("testscope", "hello,servletapi");\n    return "success";\n}\n\n\n获取数据方法\n<a th:text="${testscope}">测试获取请求参数--\x3e/testparam</a><br>\n\n\n\n# 2、使用modelandview向request域对象共享数据（springmvc）\n\n@requestmapping("/testmodelandview")\n// 返回值必须为modelandview\npublic modelandview testmodelandview(){\n    /**\n     * modelandview有model和view的功能\n     * model主要用于向请求域共享数据\n     * view主要用于设置视图，实现页面跳转\n     */\n    modelandview mav = new modelandview();\n    //向请求域共享数据\n    // 处理模型书，即向请求域request共享数据\n    mav.addobject("testscope", "hello,modelandview");\n    //设置视图，实现页面跳转\n    // 设置视图名称\n    mav.setviewname("success");\n\n    // 必须返回modelandview\n    return mav;\n}\n\n\n\n# 3、使用model向request域对象共享数据\n\n@requestmapping("/testmodel")\npublic string testmodel(model model){\n    model.addattribute("testscope", "hello,model");\n    return "success";\n}\n\n\n\n# 4、使用map向request域对象共享数据\n\n@requestmapping("/testmap")\npublic string testmap(map<string, object> map){\n    map.put("testscope", "hello,map");\n    return "success";\n}\n\n\n\n# 5、使用modelmap向request域对象共享数据\n\n@requestmapping("/testmodelmap")\npublic string testmodelmap(modelmap modelmap){\n    modelmap.addattribute("testscope", "hello,modelmap");\n    return "success";\n}\n\n\n二三四五对应的前端页面（springmvc提供的方法）\n\n\n# 6、model、modelmap、map的关系\n\nmodel、modelmap、map类型的参数其实本质上都是 bindingawaremodelmap 类型的\n\n输出信息是一样的\n\npublic interface model{}  // 顶层接口\npublic class modelmap extends linkedhashmap<string, object> {}  // 等价于modelmap实现了map\npublic class extendedmodelmap extends modelmap implements model {}\npublic class bindingawaremodelmap extends extendedmodelmap {}\n\n\n这里需要注意的是： 控制器方法执行之后都会返回同一的modelandview对象\n\n\n# 7、向session域共享数据\n\nspringmvc中提供了一些共享数据到session的方法，但是最推荐原生的这种，简单易懂\n\n一个名为sessionarribute的注解可以把共享域中数据共享到session，但是不太好用\n\nsession常用来保存用户的登录状态\n\n@requestmapping("/testsession")\npublic string testsession(httpsession session){\n    session.setattribute("testsessionscope", "hello,session");\n    return "success";\n}\n\n\n\n# 8、向application域共享数据（此时的域为整个工程，因为在服务器启动时已经被初始化，一般情况下只用request和session）\n\n@requestmapping("/testapplication")\npublic string testapplication(httpsession session){\n\tservletcontext application = session.getservletcontext();\n    application.setattribute("testapplicationscope", "hello,application");\n    return "success";\n}\n\n\n',charsets:{cjk:!0}},{title:"RESTful",frontmatter:{title:"RESTful",date:"2022-05-08T00:00:00.000Z",permalink:"/springmvc/007/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/07.RESTful.html",relativePath:"07.框架/02.SpringMVC/07.RESTful.md",key:"v-852ab148",path:"/springmvc/007/",headers:[{level:3,title:"1、RESTful简介",slug:"_1、restful简介",normalizedTitle:"1、restful简介",charIndex:16},{level:5,title:"a>资源",slug:"a-资源",normalizedTitle:"a&gt;资源",charIndex:null},{level:5,title:"b>资源的表述",slug:"b-资源的表述",normalizedTitle:"b&gt;资源的表述",charIndex:null},{level:5,title:"c>状态转移",slug:"c-状态转移",normalizedTitle:"c&gt;状态转移",charIndex:null},{level:3,title:"2、RESTful的实现",slug:"_2、restful的实现",normalizedTitle:"2、restful的实现",charIndex:565},{level:3,title:"post和get测试",slug:"post和get测试",normalizedTitle:"post和get测试",charIndex:1001},{level:3,title:"3、HiddenHttpMethodFilter",slug:"_3、hiddenhttpmethodfilter",normalizedTitle:"3、hiddenhttpmethodfilter",charIndex:2750}],headersStr:"1、RESTful简介 a>资源 b>资源的表述 c>状态转移 2、RESTful的实现 post和get测试 3、HiddenHttpMethodFilter",content:'# 七、RESTful\n\n\n# 1、RESTful简介\n\nREST：Representational State Transfer，表现层资源状态转移。\n\n# a>资源\n\n资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。\n\n# b>资源的表述\n\n资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\n\n# c>状态转移\n\n状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n\n\n# 2、RESTful的实现\n\n具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。\n\n它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\n\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n\n操作     传统方式               REST风格\n查询操作   getUserById?id=1   user/1--\x3eget请求方式\n保存操作   saveUser           user--\x3epost请求方式\n删除操作   deleteUser?id=1    user/1--\x3edelete请求方式\n更新操作   updateUser         user--\x3eput请求方式\n\n\n# post和get测试\n\n@Controller\npublic class UserController {\n\n    /**\n     * 使用RESTFul模拟用户资源的增删改查\n     * /user    GET     查询所有用户信息\n     * /user/1    GET     根据用户id查询用户信息\n     * /user    POST     添加用户信息\n     * /user/1    DELETE     删除用户信息\n     * /user    PUT     修改用户信息\n     */\n\n    @RequestMapping(value = "/user", method = RequestMethod.GET)\n    public String getAllUser(){\n        System.out.println("查询所有用户信息");\n        return "success";\n    }\n\n    @RequestMapping(value = "/user/{id}", method = RequestMethod.GET)\n    public String getUserById(){\n        System.out.println("根据id查询用户信息");\n        return "success";\n    }\n\n    @RequestMapping(value = "/user", method = RequestMethod.POST)\n    public String insertUser(String username, String password){\n        System.out.println("添加用户信息："+username+","+password);\n        return "success";\n    }\n\n    @RequestMapping(value = "/user", method = RequestMethod.PUT)\n    public String updateUser(String username, String password){\n        System.out.println("修改用户信息："+username+","+password);\n        return "success";\n    }\n\n}\n\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<a th:href="@{/user}">查询所有用户信息</a><br>\n<a th:href="@{/user/1}">根据id查询用户信息</a><br>\n<form th:action="@{/user}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="添加"><br>\n</form>\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="PUT">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n</body>\n</html>\n\n\n\n# 3、HiddenHttpMethodFilter\n\n由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？\n\nSpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求\n\nHiddenHttpMethodFilter 处理put和delete请求的条件：\n\na>当前请求的请求方式必须为post\n\nb>当前请求必须传输请求参数_method\n\n满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n\n在web.xml中注册HiddenHttpMethodFilter\n\n<filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="PUT">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n\n\n\n> 注：\n> \n> 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter\n> \n> 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter\n> \n> 原因：\n> \n>  * 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的\n> \n>  * request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n> \n>  * 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：\n> \n>  * String paramValue = request.getParameter(this.methodParam);\n>    ',normalizedContent:'# 七、restful\n\n\n# 1、restful简介\n\nrest：representational state transfer，表现层资源状态转移。\n\n# a>资源\n\n资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个uri来标识。uri既是资源的名称，也是资源在web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的uri与其进行交互。\n\n# b>资源的表述\n\n资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如html/xml/json/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\n\n# c>状态转移\n\n状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n\n\n# 2、restful的实现\n\n具体说，就是 http 协议里面，四个表示操作方式的动词：get、post、put、delete。\n\n它们分别对应四种基本操作：get 用来获取资源，post 用来新建资源，put 用来更新资源，delete 用来删除资源。\n\nrest 风格提倡 url 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 url 地址的一部分，以保证整体风格的一致性。\n\n操作     传统方式               rest风格\n查询操作   getuserbyid?id=1   user/1--\x3eget请求方式\n保存操作   saveuser           user--\x3epost请求方式\n删除操作   deleteuser?id=1    user/1--\x3edelete请求方式\n更新操作   updateuser         user--\x3eput请求方式\n\n\n# post和get测试\n\n@controller\npublic class usercontroller {\n\n    /**\n     * 使用restful模拟用户资源的增删改查\n     * /user    get     查询所有用户信息\n     * /user/1    get     根据用户id查询用户信息\n     * /user    post     添加用户信息\n     * /user/1    delete     删除用户信息\n     * /user    put     修改用户信息\n     */\n\n    @requestmapping(value = "/user", method = requestmethod.get)\n    public string getalluser(){\n        system.out.println("查询所有用户信息");\n        return "success";\n    }\n\n    @requestmapping(value = "/user/{id}", method = requestmethod.get)\n    public string getuserbyid(){\n        system.out.println("根据id查询用户信息");\n        return "success";\n    }\n\n    @requestmapping(value = "/user", method = requestmethod.post)\n    public string insertuser(string username, string password){\n        system.out.println("添加用户信息："+username+","+password);\n        return "success";\n    }\n\n    @requestmapping(value = "/user", method = requestmethod.put)\n    public string updateuser(string username, string password){\n        system.out.println("修改用户信息："+username+","+password);\n        return "success";\n    }\n\n}\n\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<a th:href="@{/user}">查询所有用户信息</a><br>\n<a th:href="@{/user/1}">根据id查询用户信息</a><br>\n<form th:action="@{/user}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="添加"><br>\n</form>\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="put">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n</body>\n</html>\n\n\n\n# 3、hiddenhttpmethodfilter\n\n由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？\n\nspringmvc 提供了 hiddenhttpmethodfilter 帮助我们将 post 请求转换为 delete 或 put 请求\n\nhiddenhttpmethodfilter 处理put和delete请求的条件：\n\na>当前请求的请求方式必须为post\n\nb>当前请求必须传输请求参数_method\n\n满足以上条件，hiddenhttpmethodfilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n\n在web.xml中注册hiddenhttpmethodfilter\n\n<filter>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <filter-class>org.springframework.web.filter.hiddenhttpmethodfilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="put">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n\n\n\n> 注：\n> \n> 目前为止，springmvc中提供了两个过滤器：characterencodingfilter和hiddenhttpmethodfilter\n> \n> 在web.xml中注册时，必须先注册characterencodingfilter，再注册hiddenhttpmethodfilter\n> \n> 原因：\n> \n>  * 在 characterencodingfilter 中通过 request.setcharacterencoding(encoding) 方法设置字符集的\n> \n>  * request.setcharacterencoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n> \n>  * 而 hiddenhttpmethodfilter 恰恰有一个获取请求方式的操作：\n> \n>  * string paramvalue = request.getparameter(this.methodparam);\n>    ',charsets:{cjk:!0}},{title:"SpringMVC的视图",frontmatter:{title:"SpringMVC的视图",date:"2022-05-06T00:00:00.000Z",permalink:"/springmvc/006/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/06.SpringMVC%E7%9A%84%E8%A7%86%E5%9B%BE.html",relativePath:"07.框架/02.SpringMVC/06.SpringMVC的视图.md",key:"v-a0fc14c8",path:"/springmvc/006/",headers:[{level:3,title:"1、ThymeleafView",slug:"_1、thymeleafview",normalizedTitle:"1、thymeleafview",charIndex:234},{level:3,title:"2、转发视图（用得少）",slug:"_2、转发视图-用得少",normalizedTitle:"2、转发视图（用得少）",charIndex:464},{level:3,title:"3、重定向视图",slug:"_3、重定向视图",normalizedTitle:"3、重定向视图",charIndex:937},{level:3,title:"4、视图控制器view-controller",slug:"_4、视图控制器view-controller",normalizedTitle:"4、视图控制器view-controller",charIndex:1503},{level:3,title:"5、视图解析器InternalResourceViewResolver(针对jsp)",slug:"_5、视图解析器internalresourceviewresolver-针对jsp",normalizedTitle:"5、视图解析器internalresourceviewresolver(针对jsp)",charIndex:1947},{level:3,title:"1、RESTful简介",slug:"_1、restful简介",normalizedTitle:"1、restful简介",charIndex:2095},{level:5,title:"a>资源",slug:"a-资源",normalizedTitle:"a&gt;资源",charIndex:null},{level:5,title:"b>资源的表述",slug:"b-资源的表述",normalizedTitle:"b&gt;资源的表述",charIndex:null},{level:5,title:"c>状态转移",slug:"c-状态转移",normalizedTitle:"c&gt;状态转移",charIndex:null},{level:3,title:"2、RESTful的实现",slug:"_2、restful的实现",normalizedTitle:"2、restful的实现",charIndex:2644},{level:3,title:"post和get测试",slug:"post和get测试",normalizedTitle:"post和get测试",charIndex:3080},{level:3,title:"3、HiddenHttpMethodFilter",slug:"_3、hiddenhttpmethodfilter",normalizedTitle:"3、hiddenhttpmethodfilter",charIndex:4829},{level:3,title:"1、准备工作",slug:"_1、准备工作",normalizedTitle:"1、准备工作",charIndex:6173},{level:3,title:"2、功能清单",slug:"_2、功能清单",normalizedTitle:"2、功能清单",charIndex:8691},{level:3,title:"3、具体功能：访问首页",slug:"_3、具体功能-访问首页",normalizedTitle:"3、具体功能：访问首页",charIndex:8956},{level:5,title:"a>配置view-controller",slug:"a-配置view-controller",normalizedTitle:"a&gt;配置view-controller",charIndex:null},{level:5,title:"b>创建页面",slug:"b-创建页面",normalizedTitle:"b&gt;创建页面",charIndex:null},{level:3,title:"4、具体功能：查询所有员工数据",slug:"_4、具体功能-查询所有员工数据",normalizedTitle:"4、具体功能：查询所有员工数据",charIndex:9281},{level:5,title:"a>控制器方法",slug:"a-控制器方法",normalizedTitle:"a&gt;控制器方法",charIndex:null},{level:5,title:"b>创建employee_list.html",slug:"b-创建employee-list-html",normalizedTitle:"b&gt;创建employee_list.html",charIndex:null},{level:3,title:"5、具体功能：删除",slug:"_5、具体功能-删除",normalizedTitle:"5、具体功能：删除",charIndex:11042},{level:5,title:"a>创建处理delete请求方式的表单",slug:"a-创建处理delete请求方式的表单",normalizedTitle:"a&gt;创建处理delete请求方式的表单",charIndex:null},{level:5,title:"b>删除超链接绑定点击事件",slug:"b-删除超链接绑定点击事件",normalizedTitle:"b&gt;删除超链接绑定点击事件",charIndex:null},{level:5,title:"c> 开放静态资源访问",slug:"c-开放静态资源访问",normalizedTitle:"c&gt; 开放静态资源访问",charIndex:null},{level:5,title:"d>控制器方法",slug:"d-控制器方法",normalizedTitle:"d&gt;控制器方法",charIndex:null},{level:3,title:"6、具体功能：跳转到添加数据页面",slug:"_6、具体功能-跳转到添加数据页面",normalizedTitle:"6、具体功能：跳转到添加数据页面",charIndex:12406},{level:5,title:"a>配置view-controller",slug:"a-配置view-controller-2",normalizedTitle:"a&gt;配置view-controller",charIndex:null},{level:5,title:"b>创建employee_add.html",slug:"b-创建employee-add-html",normalizedTitle:"b&gt;创建employee_add.html",charIndex:null},{level:3,title:"7、具体功能：执行保存",slug:"_7、具体功能-执行保存",normalizedTitle:"7、具体功能：执行保存",charIndex:13045},{level:5,title:"a>控制器方法",slug:"a-控制器方法-2",normalizedTitle:"a&gt;控制器方法",charIndex:null},{level:3,title:"8、具体功能：跳转到更新数据页面",slug:"_8、具体功能-跳转到更新数据页面",normalizedTitle:"8、具体功能：跳转到更新数据页面",charIndex:13253},{level:5,title:"a>修改超链接",slug:"a-修改超链接",normalizedTitle:"a&gt;修改超链接",charIndex:null},{level:5,title:"b>控制器方法",slug:"b-控制器方法",normalizedTitle:"b&gt;控制器方法",charIndex:null},{level:5,title:"c>创建employee_update.html",slug:"c-创建employee-update-html",normalizedTitle:"c&gt;创建employee_update.html",charIndex:null},{level:3,title:"9、具体功能：执行更新",slug:"_9、具体功能-执行更新",normalizedTitle:"9、具体功能：执行更新",charIndex:14509},{level:5,title:"a>控制器方法",slug:"a-控制器方法-3",normalizedTitle:"a&gt;控制器方法",charIndex:null},{level:3,title:"1、@RequestBody",slug:"_1、-requestbody",normalizedTitle:"1、@requestbody",charIndex:14919},{level:3,title:"2、RequestEntity",slug:"_2、requestentity",normalizedTitle:"2、requestentity",charIndex:15434},{level:3,title:"3、@ResponseBody（用的最多）",slug:"_3、-responsebody-用的最多",normalizedTitle:"3、@responsebody（用的最多）",charIndex:16280},{level:3,title:"4、SpringMVC处理json",slug:"_4、springmvc处理json",normalizedTitle:"4、springmvc处理json",charIndex:16596},{level:3,title:"5、SpringMVC处理ajax",slug:"_5、springmvc处理ajax",normalizedTitle:"5、springmvc处理ajax",charIndex:17271},{level:3,title:"6、@RestController注解",slug:"_6、-restcontroller注解",normalizedTitle:"6、@restcontroller注解",charIndex:18329},{level:3,title:"7、ResponseEntity",slug:"_7、responseentity",normalizedTitle:"7、responseentity",charIndex:18453},{level:3,title:"1、文件下载",slug:"_1、文件下载",normalizedTitle:"1、文件下载",charIndex:18541},{level:3,title:"2、文件上传",slug:"_2、文件上传",normalizedTitle:"2、文件上传",charIndex:19518},{level:3,title:"1、拦截器的配置",slug:"_1、拦截器的配置",normalizedTitle:"1、拦截器的配置",charIndex:20827},{level:3,title:"2、拦截器的三个抽象方法",slug:"_2、拦截器的三个抽象方法",normalizedTitle:"2、拦截器的三个抽象方法",charIndex:21730},{level:3,title:"3、多个拦截器的执行顺序",slug:"_3、多个拦截器的执行顺序",normalizedTitle:"3、多个拦截器的执行顺序",charIndex:21978},{level:3,title:"1、基于配置的异常处理",slug:"_1、基于配置的异常处理",normalizedTitle:"1、基于配置的异常处理",charIndex:22285},{level:3,title:"2、基于注解的异常处理",slug:"_2、基于注解的异常处理",normalizedTitle:"2、基于注解的异常处理",charIndex:23048},{level:3,title:"1、创建初始化类，代替web.xml",slug:"_1、创建初始化类-代替web-xml",normalizedTitle:"1、创建初始化类，代替web.xml",charIndex:23502},{level:3,title:"2、创建SpringConfig配置类，代替spring的配置文件",slug:"_2、创建springconfig配置类-代替spring的配置文件",normalizedTitle:"2、创建springconfig配置类，代替spring的配置文件",charIndex:25022},{level:3,title:"3、创建WebConfig配置类，代替SpringMVC的配置文件",slug:"_3、创建webconfig配置类-代替springmvc的配置文件",normalizedTitle:"3、创建webconfig配置类，代替springmvc的配置文件",charIndex:25135},{level:3,title:"4、测试功能",slug:"_4、测试功能",normalizedTitle:"4、测试功能",charIndex:28094},{level:3,title:"1、SpringMVC常用组件",slug:"_1、springmvc常用组件",normalizedTitle:"1、springmvc常用组件",charIndex:28194},{level:3,title:"2、DispatcherServlet初始化过程",slug:"_2、dispatcherservlet初始化过程",normalizedTitle:"2、dispatcherservlet初始化过程",charIndex:28695},{level:5,title:"a>初始化WebApplicationContext",slug:"a-初始化webapplicationcontext",normalizedTitle:"a&gt;初始化webapplicationcontext",charIndex:null},{level:5,title:"b>创建WebApplicationContext",slug:"b-创建webapplicationcontext",normalizedTitle:"b&gt;创建webapplicationcontext",charIndex:null},{level:5,title:"c>DispatcherServlet初始化策略",slug:"c-dispatcherservlet初始化策略",normalizedTitle:"c&gt;dispatcherservlet初始化策略",charIndex:null},{level:3,title:"3、DispatcherServlet调用组件处理请求",slug:"_3、dispatcherservlet调用组件处理请求",normalizedTitle:"3、dispatcherservlet调用组件处理请求",charIndex:32967},{level:5,title:"a>processRequest()",slug:"a-processrequest",normalizedTitle:"a&gt;processrequest()",charIndex:null},{level:5,title:"b>doService()",slug:"b-doservice",normalizedTitle:"b&gt;doservice()",charIndex:null},{level:5,title:"c>doDispatch()",slug:"c-dodispatch",normalizedTitle:"c&gt;dodispatch()",charIndex:null},{level:5,title:"d>processDispatchResult()",slug:"d-processdispatchresult",normalizedTitle:"d&gt;processdispatchresult()",charIndex:null},{level:3,title:"4、SpringMVC的执行流程",slug:"_4、springmvc的执行流程",normalizedTitle:"4、springmvc的执行流程",charIndex:42480}],headersStr:"1、ThymeleafView 2、转发视图（用得少） 3、重定向视图 4、视图控制器view-controller 5、视图解析器InternalResourceViewResolver(针对jsp) 1、RESTful简介 a>资源 b>资源的表述 c>状态转移 2、RESTful的实现 post和get测试 3、HiddenHttpMethodFilter 1、准备工作 2、功能清单 3、具体功能：访问首页 a>配置view-controller b>创建页面 4、具体功能：查询所有员工数据 a>控制器方法 b>创建employee_list.html 5、具体功能：删除 a>创建处理delete请求方式的表单 b>删除超链接绑定点击事件 c> 开放静态资源访问 d>控制器方法 6、具体功能：跳转到添加数据页面 a>配置view-controller b>创建employee_add.html 7、具体功能：执行保存 a>控制器方法 8、具体功能：跳转到更新数据页面 a>修改超链接 b>控制器方法 c>创建employee_update.html 9、具体功能：执行更新 a>控制器方法 1、@RequestBody 2、RequestEntity 3、@ResponseBody（用的最多） 4、SpringMVC处理json 5、SpringMVC处理ajax 6、@RestController注解 7、ResponseEntity 1、文件下载 2、文件上传 1、拦截器的配置 2、拦截器的三个抽象方法 3、多个拦截器的执行顺序 1、基于配置的异常处理 2、基于注解的异常处理 1、创建初始化类，代替web.xml 2、创建SpringConfig配置类，代替spring的配置文件 3、创建WebConfig配置类，代替SpringMVC的配置文件 4、测试功能 1、SpringMVC常用组件 2、DispatcherServlet初始化过程 a>初始化WebApplicationContext b>创建WebApplicationContext c>DispatcherServlet初始化策略 3、DispatcherServlet调用组件处理请求 a>processRequest() b>doService() c>doDispatch() d>processDispatchResult() 4、SpringMVC的执行流程",content:'# 六、SpringMVC的视图\n\nSpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户\n\nSpringMVC视图的种类很多，默认有转发视图和重定向视图\n\n当工程引入jstl（标签库用来控制网页标签）的依赖，转发视图会自动转换为JstlView\n\n若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView\n\n\n# 1、ThymeleafView\n\n当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转\n\n@RequestMapping("/testHello")\npublic String testHello(){\n    return "hello";  // 这里没有任何前缀会被解析为thymeleafView\n}\n\n\n\n\n\n# 2、转发视图（用得少）\n\nSpringMVC中默认的转发视图 是InternalResourceView\n\nSpringMVC中创建转发视图的情况：\n\n当控制器方法中所设置的视图名称以"forward:"为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部分作为最终路径通过转发的方式实现跳转\n\n例如"forward:/"，"forward:/employee"\n\n// thymeleafView（默认）\n@RequestMapping("/testHello")\npublic String testHello(){\n    return "hello";\n}\n\n// InternalResourceView\n@RequestMapping("/testForward")\npublic String testForward(){\n    return "forward:/testHello";\n}\n\n\n\n\n\n# 3、重定向视图\n\nSpringMVC中默认的重定向视图是RedirectView\n\n当控制器方法中所设置的视图名称以"redirect:"为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n\n例如"redirect:/"，"redirect:/employee"\n\n重定向视图页面网址为testRedirect，但是网页显示hello\n转发视图页面网址为testhello，网页信息显示hello\n@RequestMapping("/testHello")\npublic String testHello(){\n    return "hello";\n}\n@RequestMapping("/testRedirect")\npublic String testRedirect(){\n    return "redirect:/testHello";\n}\n\n\n转发和重定向的区别是什么？？？ severlet详细看 转发不能跨域，重定向可以跨域\n\n\n\n> 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径\n\n\n# 4、视图控制器view-controller\n\n当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示\n\n\x3c!--\n\tpath：设置处理的请求地址\n\tview-name：设置请求地址所对应的视图名称\n--\x3e\n<mvc:view-controller path="/testView" view-name="success"></mvc:view-controller>\n\n\n这里等价于\n\n@RequestMapping("/testView")\npublic String testView(){\n    return "index";\n}\n\n\n> 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签让之前的控制器请求重新生效 <mvc:annotation-driven />\n\n\n# 5、视图解析器InternalResourceViewResolver(针对jsp)\n\n\n\n\n\n\n\n\n\n当没有任何前缀或者forward:"为前缀会被InternalResourceView，以"redirect:"为前缀时会被创建为RedirectView\n\n\n# 七、RESTful\n\n\n# 1、RESTful简介\n\nREST：Representational State Transfer，表现层资源状态转移。\n\n# a>资源\n\n资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。\n\n# b>资源的表述\n\n资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\n\n# c>状态转移\n\n状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n\n\n# 2、RESTful的实现\n\n具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。\n\n它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\n\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n\n操作     传统方式               REST风格\n查询操作   getUserById?id=1   user/1--\x3eget请求方式\n保存操作   saveUser           user--\x3epost请求方式\n删除操作   deleteUser?id=1    user/1--\x3edelete请求方式\n更新操作   updateUser         user--\x3eput请求方式\n\n\n# post和get测试\n\n@Controller\npublic class UserController {\n\n    /**\n     * 使用RESTFul模拟用户资源的增删改查\n     * /user    GET     查询所有用户信息\n     * /user/1    GET     根据用户id查询用户信息\n     * /user    POST     添加用户信息\n     * /user/1    DELETE     删除用户信息\n     * /user    PUT     修改用户信息\n     */\n\n    @RequestMapping(value = "/user", method = RequestMethod.GET)\n    public String getAllUser(){\n        System.out.println("查询所有用户信息");\n        return "success";\n    }\n\n    @RequestMapping(value = "/user/{id}", method = RequestMethod.GET)\n    public String getUserById(){\n        System.out.println("根据id查询用户信息");\n        return "success";\n    }\n\n    @RequestMapping(value = "/user", method = RequestMethod.POST)\n    public String insertUser(String username, String password){\n        System.out.println("添加用户信息："+username+","+password);\n        return "success";\n    }\n\n    @RequestMapping(value = "/user", method = RequestMethod.PUT)\n    public String updateUser(String username, String password){\n        System.out.println("修改用户信息："+username+","+password);\n        return "success";\n    }\n\n}\n\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<a th:href="@{/user}">查询所有用户信息</a><br>\n<a th:href="@{/user/1}">根据id查询用户信息</a><br>\n<form th:action="@{/user}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="添加"><br>\n</form>\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="PUT">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n</body>\n</html>\n\n\n\n# 3、HiddenHttpMethodFilter\n\n由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？\n\nSpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求\n\nHiddenHttpMethodFilter 处理put和delete请求的条件：\n\na>当前请求的请求方式必须为post\n\nb>当前请求必须传输请求参数_method\n\n满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n\n在web.xml中注册HiddenHttpMethodFilter\n\n<filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="PUT">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n\n\n\n> 注：\n> \n> 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter\n> \n> 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter\n> \n> 原因：\n> \n>  * 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的\n> \n>  * request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n> \n>  * 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：\n> \n>  * String paramValue = request.getParameter(this.methodParam);\n>    \n\n\n# 八、RESTful案例\n\n\n# 1、准备工作\n\n和传统 CRUD 一样，实现对员工信息的增删改查。\n\n * 搭建环境\n\n * 准备实体类\n   \n   package com.atguigu.mvc.bean;\n   \n   public class Employee {\n   \n      private Integer id;\n      private String lastName;\n   \n      private String email;\n      //1 male, 0 female\n      private Integer gender;\n      \n      public Integer getId() {\n         return id;\n      }\n   \n      public void setId(Integer id) {\n         this.id = id;\n      }\n   \n      public String getLastName() {\n         return lastName;\n      }\n   \n      public void setLastName(String lastName) {\n         this.lastName = lastName;\n      }\n   \n      public String getEmail() {\n         return email;\n      }\n   \n      public void setEmail(String email) {\n         this.email = email;\n      }\n   \n      public Integer getGender() {\n         return gender;\n      }\n   \n      public void setGender(Integer gender) {\n         this.gender = gender;\n      }\n   \n      public Employee(Integer id, String lastName, String email, Integer gender) {\n         super();\n         this.id = id;\n         this.lastName = lastName;\n         this.email = email;\n         this.gender = gender;\n      }\n   \n      public Employee() {\n      }\n   }\n   \n\n * 准备dao模拟数据\n   \n   package com.atguigu.mvc.dao;\n   \n   import java.util.Collection;\n   import java.util.HashMap;\n   import java.util.Map;\n   \n   import com.atguigu.mvc.bean.Employee;\n   import org.springframework.stereotype.Repository;\n   \n   \n   @Repository\n   public class EmployeeDao {\n   \n      private static Map<Integer, Employee> employees = null;\n      \n      static{\n         employees = new HashMap<Integer, Employee>();\n   \n         employees.put(1001, new Employee(1001, "E-AA", "aa@163.com", 1));\n         employees.put(1002, new Employee(1002, "E-BB", "bb@163.com", 1));\n         employees.put(1003, new Employee(1003, "E-CC", "cc@163.com", 0));\n         employees.put(1004, new Employee(1004, "E-DD", "dd@163.com", 0));\n         employees.put(1005, new Employee(1005, "E-EE", "ee@163.com", 1));\n      }\n      \n      private static Integer initId = 1006;\n      \n      public void save(Employee employee){\n         if(employee.getId() == null){\n            employee.setId(initId++);\n         }\n         employees.put(employee.getId(), employee);\n      }\n      \n      public Collection<Employee> getAll(){\n         return employees.values();\n      }\n      \n      public Employee get(Integer id){\n         return employees.get(id);\n      }\n      \n      public void delete(Integer id){\n         employees.remove(id);\n      }\n   }\n   \n\n\n# 2、功能清单\n\n功能           URL 地址        请求方式\n访问首页√        /             GET\n查询全部数据√      /employee     GET\n删除√          /employee/2   DELETE\n跳转到添加数据页面√   /toAdd        GET\n执行保存√        /employee     POST\n跳转到更新数据页面√   /employee/2   GET\n执行更新√        /employee     PUT\n\n\n# 3、具体功能：访问首页\n\n# a>配置view-controller\n\n这里就不写控制器方法了\n\n<mvc:view-controller path="/" view-name="index"/>\n\n\n# b>创建页面\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8" >\n    <title>Title</title>\n</head>\n<body>\n<h1>首页</h1>\n<a th:href="@{/employee}">访问员工信息</a>\n</body>\n</html>\n\n\n\n# 4、具体功能：查询所有员工数据\n\n# a>控制器方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.GET)\npublic String getEmployeeList(Model model){\n    Collection<Employee> employeeList = employeeDao.getAll();\n    model.addAttribute("employeeList", employeeList);\n    return "employee_list";\n}\n\n\n# b>创建employee_list.html\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Employee Info</title>\n    <script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n</head>\n<body>\n\n    <table border="1" cellpadding="0" cellspacing="0" style="text-align: center;" id="dataTable">\n        <tr>\n            <th colspan="5">Employee Info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastName</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options(<a th:href="@{/toAdd}">add</a>)</th>\n        </tr>\n\n        **th:each是什么意思**\n        <tr th:each="employee : ${employeeList}">\n            <td th:text="${employee.id}"></td>\n            <td th:text="${employee.lastName}"></td>\n            <td th:text="${employee.email}"></td>\n            <td th:text="${employee.gender}"></td>\n            <td>\n                \x3c!-- "@{/employee/${employee.id}}" 写法是错误的，因为$会被当成符号进行解析\n                \'/employee/\'表示请求地址 --\x3e\n                <a class="deleteA" @click="deleteEmployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n                \x3c!-- 或者 --\x3e\n                <a class="deleteA" @click="deleteEmployee" th:href="@{/employee/} + ${employee.id}">delete</a>\n                \x3c!-- 上述两种方法都是正确的  --\x3e\n\n                <a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n            </td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\nth:each是什么意思？？？复习前端知识\n\n\n# 5、具体功能：删除\n\n# a>创建处理delete请求方式的表单\n\n\x3c!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\x3e\n<form id="delete_form" method="post">\n    \x3c!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\x3e\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n\n# b>删除超链接绑定点击事件\n\n引入vue.js\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n\n\n删除超链接\n\n<a class="deleteA" @click="deleteEmployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n\n\n通过vue处理点击事件\n\n<script type="text/javascript">\n    var vue = new Vue({\n        el:"#dataTable",\n        methods:{\n            //event表示当前事件\n            deleteEmployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getElementById("delete_form");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventDefault();\n            }\n        }\n    });\n<\/script>\n\n\n# c> 开放静态资源访问\n\n<mvc:default-servlet-handler />\n\n\nspringmvc先处理请求，能处理就会被处理，不能处理就会交给今天的servelet处理，servelet能处理就处理，不能处理默认的servelet报错\n\n# d>控制器方法\n\n@RequestMapping(value = "/employee/{id}", method = RequestMethod.DELETE)\npublic String deleteEmployee(@PathVariable("id") Integer id){\n    employeeDao.delete(id);\n    return "redirect:/employee";\n}\n\n\n\n# 6、具体功能：跳转到添加数据页面\n\n# a>配置view-controller\n\n<mvc:view-controller path="/toAdd" view-name="employee_add"></mvc:view-controller>\n\n\n# b>创建employee_add.html\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Add Employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    lastName:<input type="text" name="lastName"><br>\n    email:<input type="text" name="email"><br>\n    gender:<input type="radio" name="gender" value="1">male\n    <input type="radio" name="gender" value="0">female<br>\n    <input type="submit" value="add"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 7、具体功能：执行保存\n\n# a>控制器方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.POST)\npublic String addEmployee(Employee employee){\n    employeeDao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 8、具体功能：跳转到更新数据页面\n\n# a>修改超链接\n\n<a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n\n\n# b>控制器方法\n\n@RequestMapping(value = "/employee/{id}", method = RequestMethod.GET)\npublic String getEmployeeById(@PathVariable("id") Integer id, Model model){\n    Employee employee = employeeDao.get(id);\n    model.addAttribute("employee", employee);\n    return "employee_update";\n}\n\n\n# c>创建employee_update.html\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Update Employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    <input type="hidden" name="_method" value="put">\n    <input type="hidden" name="id" th:value="${employee.id}">\n    lastName:<input type="text" name="lastName" th:value="${employee.lastName}"><br>\n    email:<input type="text" name="email" th:value="${employee.email}"><br>\n    \x3c!--\n        th:field="${employee.gender}"可用于单选框或复选框的回显\n        若单选框的value和employee.gender的值一致，则添加checked="checked"属性\n    --\x3e\n    gender:<input type="radio" name="gender" value="1" th:field="${employee.gender}">male\n    <input type="radio" name="gender" value="0" th:field="${employee.gender}">female<br>\n    <input type="submit" value="update"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 9、具体功能：执行更新\n\n# a>控制器方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.PUT)\npublic String updateEmployee(Employee employee){\n    employeeDao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 八、HttpMessageConverter\n\nHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象（浏览器请求服务器），或将Java对象转换为响应报文（服务器相应浏览器）\n\nHttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，\n\nResponseEntity\n\n\n# 1、@RequestBody\n\n@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\n<form th:action="@{/testRequestBody}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit">\n</form>\n\n\n@RequestMapping("/testRequestBody")\npublic String testRequestBody(@RequestBody String requestBody){\n    System.out.println("requestBody:"+requestBody);\n    return "success";\n}\n\n\n输出结果：\n\nrequestBody:username=admin&password=123456\n\n\n# 2、RequestEntity\n\nRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息\n\n@RequestMapping("/testRequestEntity")\npublic String testRequestEntity(RequestEntity<String> requestEntity){\n    System.out.println("requestHeader:"+requestEntity.getHeaders());\n    System.out.println("requestBody:"+requestEntity.getBody());\n    return "success";\n}\n\n\n输出结果： requestHeader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"http://localhost:8080", user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"] requestBody:username=admin&password=123\n\n\n# 3、@ResponseBody（用的最多）\n\n@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n\n@RequestMapping("/testResponseBody")\n@ResponseBody\npublic String testResponseBody(){\n    return "success";\n}\n\n\n也就是加上ResponseBody直接返回字符串，不加则会拼接"前缀+返回字符串+后缀"并打开新页面进行展示信息\n\n结果：浏览器页面显示success\n\n这里要学习一下javaweb中的httpservletResponse对于浏览器数据的响应\n\n\n# 4、SpringMVC处理json\n\n@ResponseBody处理json的步骤：\n\na>导入jackson的依赖\n\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.12.1</version>\n</dependency>\n\n\nb>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串\n\n<mvc:annotation-driven />\n\n\nc>在处理器方法上使用@ResponseBody注解进行标识\n\nd>将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串\n\n@RequestMapping("/testResponseUser")\n@ResponseBody\npublic User testResponseUser(){\n    return new User(1001,"admin","123456",23,"男");\n}\n\n\n浏览器的页面中展示的结果：\n\n{"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}\n\n\n# 5、SpringMVC处理ajax\n\na>请求超链接：\n\n<div id="app">\n\t<a th:href="@{/testAjax}" @click="testAjax">testAjax</a><br>\n</div>\n\n\nb>通过vue和axios处理点击事件：\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n<script type="text/javascript" th:src="@{/static/js/axios.min.js}"><\/script>\n<script type="text/javascript">\n    var vue = new Vue({\n        el:"#app",\n        methods:{\n            testAjax:function (event) {\n                axios({\n                    method:"post",\n                    url:event.target.href,\n                    params:{\n                        username:"admin",\n                        password:"123456"\n                    }\n                }).then(function (response) {\n                    alert(response.data);\n                });\n                event.preventDefault();\n            }\n        }\n    });\n<\/script>\n\n\nc>控制器方法：\n\n@RequestMapping("/testAjax")\n@ResponseBody\npublic String testAjax(String username, String password){\n    System.out.println("username:"+username+",password:"+password);\n    return "hello,ajax";\n}\n\n\n\n# 6、@RestController注解\n\n@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解\n\n\n# 7、ResponseEntity\n\nResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n\n\n# 九、文件上传和下载\n\n\n# 1、文件下载\n\n使用ResponseEntity实现下载文件的功能\n\n@RequestMapping("/testDown")\npublic ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {\n    //获取ServletContext对象\n    ServletContext servletContext = session.getServletContext();\n    //获取服务器中文件的真实路径\n    String realPath = servletContext.getRealPath("/static/https://cdn.jsdelivr.net/gh/leejiayang/BlogImages@main/springmvc/1.jpg");\n    //创建输入流\n    InputStream is = new FileInputStream(realPath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建HttpHeaders对象设置响应头信息\n    MultiValueMap<String, String> headers = new HttpHeaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("Content-Disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    HttpStatus statusCode = HttpStatus.OK;\n    //创建ResponseEntity对象\n    ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);\n    //关闭输入流\n    is.close();\n    return responseEntity;\n}\n\n\n\n# 2、文件上传\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"\n\nSpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\na>添加依赖：\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.1</version>\n</dependency>\n\n\nb>在SpringMVC的配置文件中添加配置：\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--\x3e\n<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"></bean>\n\n\nc>控制器方法：\n\n@RequestMapping("/testUp")\npublic String testUp(MultipartFile photo, HttpSession session) throws IOException {\n    //获取上传的文件的文件名\n    String fileName = photo.getOriginalFilename();\n    //处理文件重名问题\n    // 获取后缀名\n    String hzName = fileName.substring(fileName.lastIndexOf("."));\n    // 将UUID和后缀名拼接真正的文件名\n    fileName = UUID.randomUUID().toString() + hzName;\n    //获取服务器中photo目录的路径\n    ServletContext servletContext = session.getServletContext();\n    String photoPath = servletContext.getRealPath("photo");\n    File file = new File(photoPath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    String finalPath = photoPath + File.separator + fileName;\n    //实现上传功能\n    photo.transferTo(new File(finalPath));\n    return "success";\n}\n\n\n\n# 十、拦截器\n\n\n# 1、拦截器的配置\n\nSpringMVC中的拦截器用于拦截控制器方法的执行\n\nSpringMVC中的拦截器需要实现HandlerInterceptor或者HandlerInterceptorAdapter(已过时)，重写下面的三个方法\n\n事实上是HandlerInterceptorAdapter继承了ASyncHandlerInterceptor, AsyncHandlerInterceptor又继承了HandlerInterceptor\n\nSpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：\n\n最简单的配置方法（第一种配置方法） 表示一个对象\n\n图片里面的设置也会被拦截，因为本质上这个也是控制器方法\n\n\n\n\n\n第二种配置方法\n<mvc:interceptor>\n\x3c!-- <bean class="com.atguigu.interceptor.FirstInterceptor"></bean> --\x3e\n<ref bean="firstInterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n\x3c!-- 拦截所有请求 --\x3e\n\x3c!-- 这里的/*表示访问该页面的上下一层目录 --\x3e\n<mvc:mapping path="/*"/>\n    <mvc:mapping path="/**"/>\n    \x3c!-- 排除不拦截的特殊情况 --\x3e\n    <mvc:exclude-mapping path="/testRequestEntity"/>\n    \x3c!-- 指定拦截 器 --\x3e\n    <ref bean="firstInterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n\t以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n\n# 2、拦截器的三个抽象方法\n\n过滤器的拦截器的区别是什么？？ SpringMVC中的拦截器有三个抽象方法：\n\npreHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\n\npostHandle：控制器方法执行之后执行postHandle()\n\nafterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()\n\n\n# 3、多个拦截器的执行顺序\n\na>若每个拦截器的preHandle()都返回true\n\n此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：\n\npreHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行\n\nb>若某个拦截器的preHandle()返回了false\n\npreHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行\n\n\n# 十一、异常处理器(出现异常跳转指定页面)\n\n\n# 1、基于配置的异常处理\n\nSpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver\n\nHandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver\n\nSpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：\n\n<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">\n    <property name="exceptionMappings">\n        <props>\n        \t\x3c!--\n        \t\tproperties的键表示处理器方法执行过程中出现的异常\n        \t\tproperties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面,themeleaf进行解析，和之前 的解析规则一致\n        \t--\x3e\n            <prop key="java.lang.ArithmeticException">error</prop>\n        </props>\n    </property>\n    \x3c!--\n    \texceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n\n\n    <property name="exceptionAttribute" value="ex"></property>\n</bean>\n\n\n\n# 2、基于注解的异常处理\n\n//@ControllerAdvice将当前类标识为异常处理的组件\n@ControllerAdvice\npublic class ExceptionController {\n\n    //@ExceptionHandler用于设置所标识方法处理的异常\n    @ExceptionHandler(value = ArithmeticException.class, NullPointerException.class)\n    //ex表示当前请求处理中出现的异常对象\n    public String handleArithmeticException(Exception ex, Model model){\n        model.addAttribute("ex", ex);\n        return "error";\n    }\n\n}\n\n\n\n# 十二、注解配置SpringMVC\n\n使用配置类和注解代替web.xml和SpringMVC配置文件的功能\n\n\n# 1、创建初始化类，代替web.xml\n\n在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。\n\nSpring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。\n\nSpring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。\n\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[]{SpringConfig.class};\n    }\n\n    /**\n     * 指定SpringMVC的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        // 返回class数组\n        return new Class[]{WebConfig.class};\n    }\n\n    /**\n     * 指定DispatcherServlet的映射规则(映射规则)，即url-pattern\n     * @return\n     */\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @Override\n    protected Filter[] getServletFilters() {\n        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();\n        encodingFilter.setEncoding("UTF-8");\n        encodingFilter.setForceRequestEncoding(true);\n        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};\n    }\n}\n\n\n\n# 2、创建SpringConfig配置类，代替spring的配置文件\n\n@Configuration\npublic class SpringConfig {\n\t//ssm整合之后，spring的配置信息写在此类中\n}\n\n\n\n# 3、创建WebConfig配置类，代替SpringMVC的配置文件\n\n\n// 扫描组件\n// 视图解析器\n// viewcontroller\n// default-servlet-handler\n// MVC注解驱动\n// 文件上传解析器\n// 异常处理\n// 拦截器\n\n@Configuration\n//扫描组件\n@ComponentScan("com.atguigu.mvc.controller")\n//开启MVC注解驱动\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    //使用默认的servlet处理静态资源\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @Bean\n    public CommonsMultipartResolver multipartResolver(){\n        return new CommonsMultipartResolver();\n    }\n\n    //配置拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        FirstInterceptor firstInterceptor = new FirstInterceptor();\n\n        //  addPathPatterns添加拦截规则\n        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");\n    }\n    \n    //配置视图控制\n    \n    /*@Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/").setViewName("index");\n    }*/\n    \n    //配置异常映射\n    /*@Override\n    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.setProperty("java.lang.ArithmeticException", "error");\n        //设置异常映射\n        exceptionResolver.setExceptionMappings(prop);\n        //设置共享异常信息的键\n        exceptionResolver.setExceptionAttribute("ex");\n        resolvers.add(exceptionResolver);\n    }*/\n\n    // 注意：xml视图解析器要从里到外配置\n    //配置生成模板解析器\n    @Bean\n    public ITemplateResolver templateResolver() {\n        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得\n        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(\n                webApplicationContext.getServletContext());\n\n        // 视图前缀\n        templateResolver.setPrefix("/WEB-INF/templates/");\n        // 视图后缀\n        templateResolver.setSuffix(".html");\n        templateResolver.setCharacterEncoding("UTF-8");\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        return templateResolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setCharacterEncoding("UTF-8");\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    }\n\n\n}\n\n\n\n# 4、测试功能\n\n@RequestMapping("/")\npublic String index(){\n    return "index";\n}\n\n\n\n# 十三、SpringMVC执行流程\n\n\n# 1、SpringMVC常用组件\n\n * DispatcherServlet：前端控制器，不需要工程师开发，由框架提供\n\n作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\n * HandlerMapping：处理器映射器，不需要工程师开发，由框架提供\n\n作用：根据请求的url、method等信息查找Handler，即控制器方法\n\n * Handler：处理器，需要工程师开发\n\n作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n\n * HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供\n\n作用：通过HandlerAdapter对处理器（控制器方法）进行执行\n\n * ViewResolver：视图解析器，不需要工程师开发，由框架提供（页面需要自己写）\n\n作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView\n\n * View：视图，不需要工程师开发，由框架或者视图技术提供\n\n作用：将模型数据通过页面展示给用户\n\n\n\n\n# 2、DispatcherServlet初始化过程\n\nDispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\n\n\n\n# a>初始化WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext initWebApplicationContext() {\n    WebApplicationContext rootContext =\n        WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n\n    if (this.webApplicationContext != null) {\n        // A context instance was injected at construction time -> use it\n        wac = this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) {\n                // The context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getParent() == null) {\n                    // The context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setParent(rootContext);\n                }\n                configureAndRefreshWebApplicationContext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // No context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. If one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findWebApplicationContext();\n    }\n    if (wac == null) {\n        // No context instance is defined for this servlet -> create a local one\n        // 创建WebApplicationContext\n        wac = createWebApplicationContext(rootContext);\n    }\n\n    if (!this.refreshEventReceived) {\n        // Either the context is not a ConfigurableApplicationContext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onRefresh manually here.\n        synchronized (this.onRefreshMonitor) {\n            // 刷新WebApplicationContext\n            onRefresh(wac);\n        }\n    }\n\n    if (this.publishContext) {\n        // Publish the context as a servlet context attribute.\n        // 将IOC容器在应用域共享\n        String attrName = getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    }\n\n    return wac;\n}\n\n\n# b>创建WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {\n    Class<?> contextClass = getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException(\n            "Fatal initialization error in servlet with name \'" + getServletName() +\n            "\': custom WebApplicationContext class [" + contextClass.getName() +\n            "] is not of type ConfigurableWebApplicationContext");\n    }\n    // 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac =\n        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n    wac.setEnvironment(getEnvironment());\n    // 设置父容器\n    wac.setParent(parent);\n    String configLocation = getContextConfigLocation();\n    if (configLocation != null) {\n        wac.setConfigLocation(configLocation);\n    }\n    configureAndRefreshWebApplicationContext(wac);\n\n    return wac;\n}\n\n\n# c>DispatcherServlet初始化策略\n\nFrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法（包含自己需要初始化的方法），初始化策略，即初始化DispatcherServlet的各个组件\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void initStrategies(ApplicationContext context) {\n   initMultipartResolver(context);\n   initLocaleResolver(context);\n   initThemeResolver(context);\n   initHandlerMappings(context);\n   initHandlerAdapters(context);\n   initHandlerExceptionResolvers(context);\n   initRequestToViewNameTranslator(context);\n   initViewResolvers(context);\n   initFlashMapManager(context);\n}\n\n\n\n# 3、DispatcherServlet调用组件处理请求\n\n# a>processRequest()\n\nFrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    long startTime = System.currentTimeMillis();\n    Throwable failureCause = null;\n\n    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext = buildLocaleContext(request);\n\n    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n    initContextHolders(request, localeContext, requestAttributes);\n\n    try {\n\t\t// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写\n        doService(request, response);\n    }\n    catch (ServletException | IOException ex) {\n        failureCause = ex;\n        throw ex;\n    }\n    catch (Throwable ex) {\n        failureCause = ex;\n        throw new NestedServletException("Request processing failed", ex);\n    }\n\n    finally {\n        resetContextHolders(request, previousLocaleContext, previousAttributes);\n        if (requestAttributes != null) {\n            requestAttributes.requestCompleted();\n        }\n        logResult(request, response, failureCause, asyncManager);\n        publishRequestHandledEvent(request, response, startTime, failureCause);\n    }\n}\n\n\n# b>doService()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    logRequest(request);\n\n    // Keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    Map<String, Object> attributesSnapshot = null;\n    if (WebUtils.isIncludeRequest(request)) {\n        attributesSnapshot = new HashMap<>();\n        Enumeration<?> attrNames = request.getAttributeNames();\n        while (attrNames.hasMoreElements()) {\n            String attrName = (String) attrNames.nextElement();\n            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n                attributesSnapshot.put(attrName, request.getAttribute(attrName));\n            }\n        }\n    }\n\n    // Make framework objects available to handlers and view objects.\n    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n    if (this.flashMapManager != null) {\n        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n        if (inputFlashMap != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n        }\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n    }\n\n    RequestPath requestPath = null;\n    if (this.parseRequestPath && !ServletRequestPathUtils.hasParsedRequestPath(request)) {\n        requestPath = ServletRequestPathUtils.parseAndCache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        doDispatch(request, response);\n    }\n    finally {\n        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n            // Restore the original attribute snapshot, in case of an include.\n            if (attributesSnapshot != null) {\n                restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n        }\n        if (requestPath != null) {\n            ServletRequestPathUtils.clearParsedRequestPath(request);\n        }\n    }\n}\n\n\n# c>doDispatch()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // Determine handler for the current request.\n            /*\n            \tmappedHandler：调用链\n                包含handler、interceptorList、interceptorIndex\n            \thandler：浏览器发送的请求所匹配的控制器方法\n            \tinterceptorList：处理控制器方法的所有拦截器集合\n            \tinterceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行\n            */\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n            // Determine handler adapter for the current request.\n           \t// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n            // Process last-modified header, if supported by the handler.\n            String method = request.getMethod();\n            boolean isGet = "GET".equals(method);\n            if (isGet || "HEAD".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n\t\t\t\n            // 调用拦截器的preHandle()\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // Actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            applyDefaultViewName(processedRequest, mv);\n            // 调用拦截器的postHandle()\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        }\n        catch (Exception ex) {\n            dispatchException = ex;\n        }\n        catch (Throwable err) {\n            // As of 4.3, we\'re processing Errors thrown from handler methods as well,\n            // making them available for @ExceptionHandler methods and other scenarios.\n            dispatchException = new NestedServletException("Handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    }\n    catch (Exception ex) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n    }\n    catch (Throwable err) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler,\n                               new NestedServletException("Handler processing failed", err));\n    }\n    finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            // Instead of postHandle and afterCompletion\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        }\n        else {\n            // Clean up any resources used by a multipart request.\n            if (multipartRequestParsed) {\n                cleanupMultipart(processedRequest);\n            }\n        }\n    }\n}\n\n\n# d>processDispatchResult()\n\nprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,\n                                   @Nullable Exception exception) throws Exception {\n\n    boolean errorView = false;\n\n    if (exception != null) {\n        if (exception instanceof ModelAndViewDefiningException) {\n            logger.debug("ModelAndViewDefiningException encountered", exception);\n            mv = ((ModelAndViewDefiningException) exception).getModelAndView();\n        }\n        else {\n            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n            mv = processHandlerException(request, response, handler, exception);\n            errorView = (mv != null);\n        }\n    }\n\n    // Did the handler return a view to render?\n    if (mv != null && !mv.wasCleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorView) {\n            WebUtils.clearErrorRequestAttributes(request);\n        }\n    }\n    else {\n        if (logger.isTraceEnabled()) {\n            logger.trace("No view rendering, null ModelAndView returned.");\n        }\n    }\n\n    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n        // Concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedHandler != null) {\n        // Exception (if any) is already handled..\n        // 调用拦截器的afterCompletion()\n        mappedHandler.triggerAfterCompletion(request, response, null);\n    }\n}\n\n\n\n# 4、SpringMVC的执行流程\n\n 1. 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\n\n 2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n\na) 不存在\n\ni. 再判断是否配置了mvc:default-servlet-handler\n\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\n\n\n\n\n\nb) 存在则执行下面的流程\n\n 3. 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\n\n 4. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\n\n 5. 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n\n 6. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n\na) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n\nb) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n\n 7.  Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\n\n 8.  此时将开始执行拦截器的postHandle(...)方法【逆向】。\n\n 9.  根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\n\n 10. 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\n\n 11. 将渲染结果返回给客户端。',normalizedContent:'# 六、springmvc的视图\n\nspringmvc中的视图是view接口，视图的作用渲染数据，将模型model中的数据展示给用户\n\nspringmvc视图的种类很多，默认有转发视图和重定向视图\n\n当工程引入jstl（标签库用来控制网页标签）的依赖，转发视图会自动转换为jstlview\n\n若使用的视图技术为thymeleaf，在springmvc的配置文件中配置了thymeleaf的视图解析器，由此视图解析器解析之后所得到的是thymeleafview\n\n\n# 1、thymeleafview\n\n当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被springmvc配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转\n\n@requestmapping("/testhello")\npublic string testhello(){\n    return "hello";  // 这里没有任何前缀会被解析为thymeleafview\n}\n\n\n\n\n\n# 2、转发视图（用得少）\n\nspringmvc中默认的转发视图 是internalresourceview\n\nspringmvc中创建转发视图的情况：\n\n当控制器方法中所设置的视图名称以"forward:"为前缀时，创建internalresourceview视图，此时的视图名称不会被springmvc配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部分作为最终路径通过转发的方式实现跳转\n\n例如"forward:/"，"forward:/employee"\n\n// thymeleafview（默认）\n@requestmapping("/testhello")\npublic string testhello(){\n    return "hello";\n}\n\n// internalresourceview\n@requestmapping("/testforward")\npublic string testforward(){\n    return "forward:/testhello";\n}\n\n\n\n\n\n# 3、重定向视图\n\nspringmvc中默认的重定向视图是redirectview\n\n当控制器方法中所设置的视图名称以"redirect:"为前缀时，创建redirectview视图，此时的视图名称不会被springmvc配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n\n例如"redirect:/"，"redirect:/employee"\n\n重定向视图页面网址为testredirect，但是网页显示hello\n转发视图页面网址为testhello，网页信息显示hello\n@requestmapping("/testhello")\npublic string testhello(){\n    return "hello";\n}\n@requestmapping("/testredirect")\npublic string testredirect(){\n    return "redirect:/testhello";\n}\n\n\n转发和重定向的区别是什么？？？ severlet详细看 转发不能跨域，重定向可以跨域\n\n\n\n> 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径\n\n\n# 4、视图控制器view-controller\n\n当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示\n\n\x3c!--\n\tpath：设置处理的请求地址\n\tview-name：设置请求地址所对应的视图名称\n--\x3e\n<mvc:view-controller path="/testview" view-name="success"></mvc:view-controller>\n\n\n这里等价于\n\n@requestmapping("/testview")\npublic string testview(){\n    return "index";\n}\n\n\n> 注： 当springmvc中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在springmvc的核心配置文件中设置开启mvc注解驱动的标签让之前的控制器请求重新生效 <mvc:annotation-driven />\n\n\n# 5、视图解析器internalresourceviewresolver(针对jsp)\n\n\n\n\n\n\n\n\n\n当没有任何前缀或者forward:"为前缀会被internalresourceview，以"redirect:"为前缀时会被创建为redirectview\n\n\n# 七、restful\n\n\n# 1、restful简介\n\nrest：representational state transfer，表现层资源状态转移。\n\n# a>资源\n\n资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个uri来标识。uri既是资源的名称，也是资源在web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的uri与其进行交互。\n\n# b>资源的表述\n\n资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如html/xml/json/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\n\n# c>状态转移\n\n状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n\n\n# 2、restful的实现\n\n具体说，就是 http 协议里面，四个表示操作方式的动词：get、post、put、delete。\n\n它们分别对应四种基本操作：get 用来获取资源，post 用来新建资源，put 用来更新资源，delete 用来删除资源。\n\nrest 风格提倡 url 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 url 地址的一部分，以保证整体风格的一致性。\n\n操作     传统方式               rest风格\n查询操作   getuserbyid?id=1   user/1--\x3eget请求方式\n保存操作   saveuser           user--\x3epost请求方式\n删除操作   deleteuser?id=1    user/1--\x3edelete请求方式\n更新操作   updateuser         user--\x3eput请求方式\n\n\n# post和get测试\n\n@controller\npublic class usercontroller {\n\n    /**\n     * 使用restful模拟用户资源的增删改查\n     * /user    get     查询所有用户信息\n     * /user/1    get     根据用户id查询用户信息\n     * /user    post     添加用户信息\n     * /user/1    delete     删除用户信息\n     * /user    put     修改用户信息\n     */\n\n    @requestmapping(value = "/user", method = requestmethod.get)\n    public string getalluser(){\n        system.out.println("查询所有用户信息");\n        return "success";\n    }\n\n    @requestmapping(value = "/user/{id}", method = requestmethod.get)\n    public string getuserbyid(){\n        system.out.println("根据id查询用户信息");\n        return "success";\n    }\n\n    @requestmapping(value = "/user", method = requestmethod.post)\n    public string insertuser(string username, string password){\n        system.out.println("添加用户信息："+username+","+password);\n        return "success";\n    }\n\n    @requestmapping(value = "/user", method = requestmethod.put)\n    public string updateuser(string username, string password){\n        system.out.println("修改用户信息："+username+","+password);\n        return "success";\n    }\n\n}\n\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<a th:href="@{/user}">查询所有用户信息</a><br>\n<a th:href="@{/user/1}">根据id查询用户信息</a><br>\n<form th:action="@{/user}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="添加"><br>\n</form>\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="put">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n</body>\n</html>\n\n\n\n# 3、hiddenhttpmethodfilter\n\n由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？\n\nspringmvc 提供了 hiddenhttpmethodfilter 帮助我们将 post 请求转换为 delete 或 put 请求\n\nhiddenhttpmethodfilter 处理put和delete请求的条件：\n\na>当前请求的请求方式必须为post\n\nb>当前请求必须传输请求参数_method\n\n满足以上条件，hiddenhttpmethodfilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n\n在web.xml中注册hiddenhttpmethodfilter\n\n<filter>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <filter-class>org.springframework.web.filter.hiddenhttpmethodfilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n<form th:action="@{/user}" method="post">\n    <input type="hidden" name="_method" value="put">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit" value="修改"><br>\n</form>\n\n\n\n> 注：\n> \n> 目前为止，springmvc中提供了两个过滤器：characterencodingfilter和hiddenhttpmethodfilter\n> \n> 在web.xml中注册时，必须先注册characterencodingfilter，再注册hiddenhttpmethodfilter\n> \n> 原因：\n> \n>  * 在 characterencodingfilter 中通过 request.setcharacterencoding(encoding) 方法设置字符集的\n> \n>  * request.setcharacterencoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n> \n>  * 而 hiddenhttpmethodfilter 恰恰有一个获取请求方式的操作：\n> \n>  * string paramvalue = request.getparameter(this.methodparam);\n>    \n\n\n# 八、restful案例\n\n\n# 1、准备工作\n\n和传统 crud 一样，实现对员工信息的增删改查。\n\n * 搭建环境\n\n * 准备实体类\n   \n   package com.atguigu.mvc.bean;\n   \n   public class employee {\n   \n      private integer id;\n      private string lastname;\n   \n      private string email;\n      //1 male, 0 female\n      private integer gender;\n      \n      public integer getid() {\n         return id;\n      }\n   \n      public void setid(integer id) {\n         this.id = id;\n      }\n   \n      public string getlastname() {\n         return lastname;\n      }\n   \n      public void setlastname(string lastname) {\n         this.lastname = lastname;\n      }\n   \n      public string getemail() {\n         return email;\n      }\n   \n      public void setemail(string email) {\n         this.email = email;\n      }\n   \n      public integer getgender() {\n         return gender;\n      }\n   \n      public void setgender(integer gender) {\n         this.gender = gender;\n      }\n   \n      public employee(integer id, string lastname, string email, integer gender) {\n         super();\n         this.id = id;\n         this.lastname = lastname;\n         this.email = email;\n         this.gender = gender;\n      }\n   \n      public employee() {\n      }\n   }\n   \n\n * 准备dao模拟数据\n   \n   package com.atguigu.mvc.dao;\n   \n   import java.util.collection;\n   import java.util.hashmap;\n   import java.util.map;\n   \n   import com.atguigu.mvc.bean.employee;\n   import org.springframework.stereotype.repository;\n   \n   \n   @repository\n   public class employeedao {\n   \n      private static map<integer, employee> employees = null;\n      \n      static{\n         employees = new hashmap<integer, employee>();\n   \n         employees.put(1001, new employee(1001, "e-aa", "aa@163.com", 1));\n         employees.put(1002, new employee(1002, "e-bb", "bb@163.com", 1));\n         employees.put(1003, new employee(1003, "e-cc", "cc@163.com", 0));\n         employees.put(1004, new employee(1004, "e-dd", "dd@163.com", 0));\n         employees.put(1005, new employee(1005, "e-ee", "ee@163.com", 1));\n      }\n      \n      private static integer initid = 1006;\n      \n      public void save(employee employee){\n         if(employee.getid() == null){\n            employee.setid(initid++);\n         }\n         employees.put(employee.getid(), employee);\n      }\n      \n      public collection<employee> getall(){\n         return employees.values();\n      }\n      \n      public employee get(integer id){\n         return employees.get(id);\n      }\n      \n      public void delete(integer id){\n         employees.remove(id);\n      }\n   }\n   \n\n\n# 2、功能清单\n\n功能           url 地址        请求方式\n访问首页√        /             get\n查询全部数据√      /employee     get\n删除√          /employee/2   delete\n跳转到添加数据页面√   /toadd        get\n执行保存√        /employee     post\n跳转到更新数据页面√   /employee/2   get\n执行更新√        /employee     put\n\n\n# 3、具体功能：访问首页\n\n# a>配置view-controller\n\n这里就不写控制器方法了\n\n<mvc:view-controller path="/" view-name="index"/>\n\n\n# b>创建页面\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8" >\n    <title>title</title>\n</head>\n<body>\n<h1>首页</h1>\n<a th:href="@{/employee}">访问员工信息</a>\n</body>\n</html>\n\n\n\n# 4、具体功能：查询所有员工数据\n\n# a>控制器方法\n\n@requestmapping(value = "/employee", method = requestmethod.get)\npublic string getemployeelist(model model){\n    collection<employee> employeelist = employeedao.getall();\n    model.addattribute("employeelist", employeelist);\n    return "employee_list";\n}\n\n\n# b>创建employee_list.html\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>employee info</title>\n    <script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n</head>\n<body>\n\n    <table border="1" cellpadding="0" cellspacing="0" style="text-align: center;" id="datatable">\n        <tr>\n            <th colspan="5">employee info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastname</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options(<a th:href="@{/toadd}">add</a>)</th>\n        </tr>\n\n        **th:each是什么意思**\n        <tr th:each="employee : ${employeelist}">\n            <td th:text="${employee.id}"></td>\n            <td th:text="${employee.lastname}"></td>\n            <td th:text="${employee.email}"></td>\n            <td th:text="${employee.gender}"></td>\n            <td>\n                \x3c!-- "@{/employee/${employee.id}}" 写法是错误的，因为$会被当成符号进行解析\n                \'/employee/\'表示请求地址 --\x3e\n                <a class="deletea" @click="deleteemployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n                \x3c!-- 或者 --\x3e\n                <a class="deletea" @click="deleteemployee" th:href="@{/employee/} + ${employee.id}">delete</a>\n                \x3c!-- 上述两种方法都是正确的  --\x3e\n\n                <a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n            </td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\nth:each是什么意思？？？复习前端知识\n\n\n# 5、具体功能：删除\n\n# a>创建处理delete请求方式的表单\n\n\x3c!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\x3e\n<form id="delete_form" method="post">\n    \x3c!-- hiddenhttpmethodfilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\x3e\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n\n# b>删除超链接绑定点击事件\n\n引入vue.js\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n\n\n删除超链接\n\n<a class="deletea" @click="deleteemployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n\n\n通过vue处理点击事件\n\n<script type="text/javascript">\n    var vue = new vue({\n        el:"#datatable",\n        methods:{\n            //event表示当前事件\n            deleteemployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getelementbyid("delete_form");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventdefault();\n            }\n        }\n    });\n<\/script>\n\n\n# c> 开放静态资源访问\n\n<mvc:default-servlet-handler />\n\n\nspringmvc先处理请求，能处理就会被处理，不能处理就会交给今天的servelet处理，servelet能处理就处理，不能处理默认的servelet报错\n\n# d>控制器方法\n\n@requestmapping(value = "/employee/{id}", method = requestmethod.delete)\npublic string deleteemployee(@pathvariable("id") integer id){\n    employeedao.delete(id);\n    return "redirect:/employee";\n}\n\n\n\n# 6、具体功能：跳转到添加数据页面\n\n# a>配置view-controller\n\n<mvc:view-controller path="/toadd" view-name="employee_add"></mvc:view-controller>\n\n\n# b>创建employee_add.html\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>add employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    lastname:<input type="text" name="lastname"><br>\n    email:<input type="text" name="email"><br>\n    gender:<input type="radio" name="gender" value="1">male\n    <input type="radio" name="gender" value="0">female<br>\n    <input type="submit" value="add"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 7、具体功能：执行保存\n\n# a>控制器方法\n\n@requestmapping(value = "/employee", method = requestmethod.post)\npublic string addemployee(employee employee){\n    employeedao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 8、具体功能：跳转到更新数据页面\n\n# a>修改超链接\n\n<a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n\n\n# b>控制器方法\n\n@requestmapping(value = "/employee/{id}", method = requestmethod.get)\npublic string getemployeebyid(@pathvariable("id") integer id, model model){\n    employee employee = employeedao.get(id);\n    model.addattribute("employee", employee);\n    return "employee_update";\n}\n\n\n# c>创建employee_update.html\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>update employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    <input type="hidden" name="_method" value="put">\n    <input type="hidden" name="id" th:value="${employee.id}">\n    lastname:<input type="text" name="lastname" th:value="${employee.lastname}"><br>\n    email:<input type="text" name="email" th:value="${employee.email}"><br>\n    \x3c!--\n        th:field="${employee.gender}"可用于单选框或复选框的回显\n        若单选框的value和employee.gender的值一致，则添加checked="checked"属性\n    --\x3e\n    gender:<input type="radio" name="gender" value="1" th:field="${employee.gender}">male\n    <input type="radio" name="gender" value="0" th:field="${employee.gender}">female<br>\n    <input type="submit" value="update"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 9、具体功能：执行更新\n\n# a>控制器方法\n\n@requestmapping(value = "/employee", method = requestmethod.put)\npublic string updateemployee(employee employee){\n    employeedao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 八、httpmessageconverter\n\nhttpmessageconverter，报文信息转换器，将请求报文转换为java对象（浏览器请求服务器），或将java对象转换为响应报文（服务器相应浏览器）\n\nhttpmessageconverter提供了两个注解和两个类型：@requestbody，@responsebody，requestentity，\n\nresponseentity\n\n\n# 1、@requestbody\n\n@requestbody可以获取请求体，需要在控制器方法设置一个形参，使用@requestbody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\n<form th:action="@{/testrequestbody}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit">\n</form>\n\n\n@requestmapping("/testrequestbody")\npublic string testrequestbody(@requestbody string requestbody){\n    system.out.println("requestbody:"+requestbody);\n    return "success";\n}\n\n\n输出结果：\n\nrequestbody:username=admin&password=123456\n\n\n# 2、requestentity\n\nrequestentity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getheaders()获取请求头信息，通过getbody()获取请求体信息\n\n@requestmapping("/testrequestentity")\npublic string testrequestentity(requestentity<string> requestentity){\n    system.out.println("requestheader:"+requestentity.getheaders());\n    system.out.println("requestbody:"+requestentity.getbody());\n    return "success";\n}\n\n\n输出结果： requestheader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" not a;brand";v="99", "chromium";v="90", "google chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"http://localhost:8080", user-agent:"mozilla/5.0 (windows nt 10.0; win64; x64) applewebkit/537.36 (khtml, like gecko) chrome/90.0.4430.93 safari/537.36"] requestbody:username=admin&password=123\n\n\n# 3、@responsebody（用的最多）\n\n@responsebody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n\n@requestmapping("/testresponsebody")\n@responsebody\npublic string testresponsebody(){\n    return "success";\n}\n\n\n也就是加上responsebody直接返回字符串，不加则会拼接"前缀+返回字符串+后缀"并打开新页面进行展示信息\n\n结果：浏览器页面显示success\n\n这里要学习一下javaweb中的httpservletresponse对于浏览器数据的响应\n\n\n# 4、springmvc处理json\n\n@responsebody处理json的步骤：\n\na>导入jackson的依赖\n\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>2.12.1</version>\n</dependency>\n\n\nb>在springmvc的核心配置文件中开启mvc的注解驱动，此时在handleradaptor中会自动装配一个消息转换器：mappingjackson2httpmessageconverter，可以将响应到浏览器的java对象转换为json格式的字符串\n\n<mvc:annotation-driven />\n\n\nc>在处理器方法上使用@responsebody注解进行标识\n\nd>将java对象直接作为控制器方法的返回值返回，就会自动转换为json格式的字符串\n\n@requestmapping("/testresponseuser")\n@responsebody\npublic user testresponseuser(){\n    return new user(1001,"admin","123456",23,"男");\n}\n\n\n浏览器的页面中展示的结果：\n\n{"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}\n\n\n# 5、springmvc处理ajax\n\na>请求超链接：\n\n<div id="app">\n\t<a th:href="@{/testajax}" @click="testajax">testajax</a><br>\n</div>\n\n\nb>通过vue和axios处理点击事件：\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n<script type="text/javascript" th:src="@{/static/js/axios.min.js}"><\/script>\n<script type="text/javascript">\n    var vue = new vue({\n        el:"#app",\n        methods:{\n            testajax:function (event) {\n                axios({\n                    method:"post",\n                    url:event.target.href,\n                    params:{\n                        username:"admin",\n                        password:"123456"\n                    }\n                }).then(function (response) {\n                    alert(response.data);\n                });\n                event.preventdefault();\n            }\n        }\n    });\n<\/script>\n\n\nc>控制器方法：\n\n@requestmapping("/testajax")\n@responsebody\npublic string testajax(string username, string password){\n    system.out.println("username:"+username+",password:"+password);\n    return "hello,ajax";\n}\n\n\n\n# 6、@restcontroller注解\n\n@restcontroller注解是springmvc提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@controller注解，并且为其中的每个方法添加了@responsebody注解\n\n\n# 7、responseentity\n\nresponseentity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n\n\n# 九、文件上传和下载\n\n\n# 1、文件下载\n\n使用responseentity实现下载文件的功能\n\n@requestmapping("/testdown")\npublic responseentity<byte[]> testresponseentity(httpsession session) throws ioexception {\n    //获取servletcontext对象\n    servletcontext servletcontext = session.getservletcontext();\n    //获取服务器中文件的真实路径\n    string realpath = servletcontext.getrealpath("/static/https://cdn.jsdelivr.net/gh/leejiayang/blogimages@main/springmvc/1.jpg");\n    //创建输入流\n    inputstream is = new fileinputstream(realpath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建httpheaders对象设置响应头信息\n    multivaluemap<string, string> headers = new httpheaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("content-disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    httpstatus statuscode = httpstatus.ok;\n    //创建responseentity对象\n    responseentity<byte[]> responseentity = new responseentity<>(bytes, headers, statuscode);\n    //关闭输入流\n    is.close();\n    return responseentity;\n}\n\n\n\n# 2、文件上传\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"\n\nspringmvc中将上传的文件封装到multipartfile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\na>添加依赖：\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupid>commons-fileupload</groupid>\n    <artifactid>commons-fileupload</artifactid>\n    <version>1.3.1</version>\n</dependency>\n\n\nb>在springmvc的配置文件中添加配置：\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为multipartfile对象--\x3e\n<bean id="multipartresolver" class="org.springframework.web.multipart.commons.commonsmultipartresolver"></bean>\n\n\nc>控制器方法：\n\n@requestmapping("/testup")\npublic string testup(multipartfile photo, httpsession session) throws ioexception {\n    //获取上传的文件的文件名\n    string filename = photo.getoriginalfilename();\n    //处理文件重名问题\n    // 获取后缀名\n    string hzname = filename.substring(filename.lastindexof("."));\n    // 将uuid和后缀名拼接真正的文件名\n    filename = uuid.randomuuid().tostring() + hzname;\n    //获取服务器中photo目录的路径\n    servletcontext servletcontext = session.getservletcontext();\n    string photopath = servletcontext.getrealpath("photo");\n    file file = new file(photopath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    string finalpath = photopath + file.separator + filename;\n    //实现上传功能\n    photo.transferto(new file(finalpath));\n    return "success";\n}\n\n\n\n# 十、拦截器\n\n\n# 1、拦截器的配置\n\nspringmvc中的拦截器用于拦截控制器方法的执行\n\nspringmvc中的拦截器需要实现handlerinterceptor或者handlerinterceptoradapter(已过时)，重写下面的三个方法\n\n事实上是handlerinterceptoradapter继承了asynchandlerinterceptor, asynchandlerinterceptor又继承了handlerinterceptor\n\nspringmvc的拦截器必须在springmvc的配置文件中进行配置：\n\n最简单的配置方法（第一种配置方法） 表示一个对象\n\n图片里面的设置也会被拦截，因为本质上这个也是控制器方法\n\n\n\n\n\n第二种配置方法\n<mvc:interceptor>\n\x3c!-- <bean class="com.atguigu.interceptor.firstinterceptor"></bean> --\x3e\n<ref bean="firstinterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- 以上两种配置方式都是对dispatcherservlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n\x3c!-- 拦截所有请求 --\x3e\n\x3c!-- 这里的/*表示访问该页面的上下一层目录 --\x3e\n<mvc:mapping path="/*"/>\n    <mvc:mapping path="/**"/>\n    \x3c!-- 排除不拦截的特殊情况 --\x3e\n    <mvc:exclude-mapping path="/testrequestentity"/>\n    \x3c!-- 指定拦截 器 --\x3e\n    <ref bean="firstinterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n\t以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n\n# 2、拦截器的三个抽象方法\n\n过滤器的拦截器的区别是什么？？ springmvc中的拦截器有三个抽象方法：\n\nprehandle：控制器方法执行之前执行prehandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\n\nposthandle：控制器方法执行之后执行posthandle()\n\naftercomplation：处理完视图和模型数据，渲染视图完毕之后执行aftercomplation()\n\n\n# 3、多个拦截器的执行顺序\n\na>若每个拦截器的prehandle()都返回true\n\n此时多个拦截器的执行顺序和拦截器在springmvc的配置文件的配置顺序有关：\n\nprehandle()会按照配置的顺序执行，而posthandle()和aftercomplation()会按照配置的反序执行\n\nb>若某个拦截器的prehandle()返回了false\n\nprehandle()返回false和它之前的拦截器的prehandle()都会执行，posthandle()都不执行，返回false的拦截器之前的拦截器的aftercomplation()会执行\n\n\n# 十一、异常处理器(出现异常跳转指定页面)\n\n\n# 1、基于配置的异常处理\n\nspringmvc提供了一个处理控制器方法执行过程中所出现的异常的接口：handlerexceptionresolver\n\nhandlerexceptionresolver接口的实现类有：defaulthandlerexceptionresolver和simplemappingexceptionresolver\n\nspringmvc提供了自定义的异常处理器simplemappingexceptionresolver，使用方式：\n\n<bean class="org.springframework.web.servlet.handler.simplemappingexceptionresolver">\n    <property name="exceptionmappings">\n        <props>\n        \t\x3c!--\n        \t\tproperties的键表示处理器方法执行过程中出现的异常\n        \t\tproperties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面,themeleaf进行解析，和之前 的解析规则一致\n        \t--\x3e\n            <prop key="java.lang.arithmeticexception">error</prop>\n        </props>\n    </property>\n    \x3c!--\n    \texceptionattribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n\n\n    <property name="exceptionattribute" value="ex"></property>\n</bean>\n\n\n\n# 2、基于注解的异常处理\n\n//@controlleradvice将当前类标识为异常处理的组件\n@controlleradvice\npublic class exceptioncontroller {\n\n    //@exceptionhandler用于设置所标识方法处理的异常\n    @exceptionhandler(value = arithmeticexception.class, nullpointerexception.class)\n    //ex表示当前请求处理中出现的异常对象\n    public string handlearithmeticexception(exception ex, model model){\n        model.addattribute("ex", ex);\n        return "error";\n    }\n\n}\n\n\n\n# 十二、注解配置springmvc\n\n使用配置类和注解代替web.xml和springmvc配置文件的功能\n\n\n# 1、创建初始化类，代替web.xml\n\n在servlet3.0环境中，容器会在类路径中查找实现javax.servlet.servletcontainerinitializer接口的类，如果找到的话就用它来配置servlet容器。\n\nspring提供了这个接口的实现，名为springservletcontainerinitializer，这个类反过来又会查找实现webapplicationinitializer的类并将配置的任务交给它们来完成。\n\nspring3.2引入了一个便利的webapplicationinitializer基础实现，名为abstractannotationconfigdispatcherservletinitializer，当我们的类扩展了abstractannotationconfigdispatcherservletinitializer并将其部署到servlet3.0容器的时候，容器会自动发现它，并用它来配置servlet上下文。\n\npublic class webinit extends abstractannotationconfigdispatcherservletinitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getrootconfigclasses() {\n        return new class[]{springconfig.class};\n    }\n\n    /**\n     * 指定springmvc的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getservletconfigclasses() {\n        // 返回class数组\n        return new class[]{webconfig.class};\n    }\n\n    /**\n     * 指定dispatcherservlet的映射规则(映射规则)，即url-pattern\n     * @return\n     */\n    @override\n    protected string[] getservletmappings() {\n        return new string[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @override\n    protected filter[] getservletfilters() {\n        characterencodingfilter encodingfilter = new characterencodingfilter();\n        encodingfilter.setencoding("utf-8");\n        encodingfilter.setforcerequestencoding(true);\n        hiddenhttpmethodfilter hiddenhttpmethodfilter = new hiddenhttpmethodfilter();\n        return new filter[]{encodingfilter, hiddenhttpmethodfilter};\n    }\n}\n\n\n\n# 2、创建springconfig配置类，代替spring的配置文件\n\n@configuration\npublic class springconfig {\n\t//ssm整合之后，spring的配置信息写在此类中\n}\n\n\n\n# 3、创建webconfig配置类，代替springmvc的配置文件\n\n\n// 扫描组件\n// 视图解析器\n// viewcontroller\n// default-servlet-handler\n// mvc注解驱动\n// 文件上传解析器\n// 异常处理\n// 拦截器\n\n@configuration\n//扫描组件\n@componentscan("com.atguigu.mvc.controller")\n//开启mvc注解驱动\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    //使用默认的servlet处理静态资源\n    @override\n    public void configuredefaultservlethandling(defaultservlethandlerconfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @bean\n    public commonsmultipartresolver multipartresolver(){\n        return new commonsmultipartresolver();\n    }\n\n    //配置拦截器\n    @override\n    public void addinterceptors(interceptorregistry registry) {\n        firstinterceptor firstinterceptor = new firstinterceptor();\n\n        //  addpathpatterns添加拦截规则\n        registry.addinterceptor(firstinterceptor).addpathpatterns("/**");\n    }\n    \n    //配置视图控制\n    \n    /*@override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        registry.addviewcontroller("/").setviewname("index");\n    }*/\n    \n    //配置异常映射\n    /*@override\n    public void configurehandlerexceptionresolvers(list<handlerexceptionresolver> resolvers) {\n        simplemappingexceptionresolver exceptionresolver = new simplemappingexceptionresolver();\n        properties prop = new properties();\n        prop.setproperty("java.lang.arithmeticexception", "error");\n        //设置异常映射\n        exceptionresolver.setexceptionmappings(prop);\n        //设置共享异常信息的键\n        exceptionresolver.setexceptionattribute("ex");\n        resolvers.add(exceptionresolver);\n    }*/\n\n    // 注意：xml视图解析器要从里到外配置\n    //配置生成模板解析器\n    @bean\n    public itemplateresolver templateresolver() {\n        webapplicationcontext webapplicationcontext = contextloader.getcurrentwebapplicationcontext();\n        // servletcontexttemplateresolver需要一个servletcontext作为构造参数，可通过webapplicationcontext 的方法获得\n        servletcontexttemplateresolver templateresolver = new servletcontexttemplateresolver(\n                webapplicationcontext.getservletcontext());\n\n        // 视图前缀\n        templateresolver.setprefix("/web-inf/templates/");\n        // 视图后缀\n        templateresolver.setsuffix(".html");\n        templateresolver.setcharacterencoding("utf-8");\n        templateresolver.settemplatemode(templatemode.html);\n        return templateresolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @bean\n    public springtemplateengine templateengine(itemplateresolver templateresolver) {\n        springtemplateengine templateengine = new springtemplateengine();\n        templateengine.settemplateresolver(templateresolver);\n        return templateengine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @bean\n    public viewresolver viewresolver(springtemplateengine templateengine) {\n        thymeleafviewresolver viewresolver = new thymeleafviewresolver();\n        viewresolver.setcharacterencoding("utf-8");\n        viewresolver.settemplateengine(templateengine);\n        return viewresolver;\n    }\n\n\n}\n\n\n\n# 4、测试功能\n\n@requestmapping("/")\npublic string index(){\n    return "index";\n}\n\n\n\n# 十三、springmvc执行流程\n\n\n# 1、springmvc常用组件\n\n * dispatcherservlet：前端控制器，不需要工程师开发，由框架提供\n\n作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\n * handlermapping：处理器映射器，不需要工程师开发，由框架提供\n\n作用：根据请求的url、method等信息查找handler，即控制器方法\n\n * handler：处理器，需要工程师开发\n\n作用：在dispatcherservlet的控制下handler对具体的用户请求进行处理\n\n * handleradapter：处理器适配器，不需要工程师开发，由框架提供\n\n作用：通过handleradapter对处理器（控制器方法）进行执行\n\n * viewresolver：视图解析器，不需要工程师开发，由框架提供（页面需要自己写）\n\n作用：进行视图解析，得到相应的视图，例如：thymeleafview、internalresourceview、redirectview\n\n * view：视图，不需要工程师开发，由框架或者视图技术提供\n\n作用：将模型数据通过页面展示给用户\n\n\n\n\n# 2、dispatcherservlet初始化过程\n\ndispatcherservlet 本质上是一个 servlet，所以天然的遵循 servlet 的生命周期。所以宏观上是 servlet 生命周期来进行调度。\n\n\n\n# a>初始化webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext initwebapplicationcontext() {\n    webapplicationcontext rootcontext =\n        webapplicationcontextutils.getwebapplicationcontext(getservletcontext());\n    webapplicationcontext wac = null;\n\n    if (this.webapplicationcontext != null) {\n        // a context instance was injected at construction time -> use it\n        wac = this.webapplicationcontext;\n        if (wac instanceof configurablewebapplicationcontext) {\n            configurablewebapplicationcontext cwac = (configurablewebapplicationcontext) wac;\n            if (!cwac.isactive()) {\n                // the context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getparent() == null) {\n                    // the context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setparent(rootcontext);\n                }\n                configureandrefreshwebapplicationcontext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // no context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. if one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findwebapplicationcontext();\n    }\n    if (wac == null) {\n        // no context instance is defined for this servlet -> create a local one\n        // 创建webapplicationcontext\n        wac = createwebapplicationcontext(rootcontext);\n    }\n\n    if (!this.refresheventreceived) {\n        // either the context is not a configurableapplicationcontext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onrefresh manually here.\n        synchronized (this.onrefreshmonitor) {\n            // 刷新webapplicationcontext\n            onrefresh(wac);\n        }\n    }\n\n    if (this.publishcontext) {\n        // publish the context as a servlet context attribute.\n        // 将ioc容器在应用域共享\n        string attrname = getservletcontextattributename();\n        getservletcontext().setattribute(attrname, wac);\n    }\n\n    return wac;\n}\n\n\n# b>创建webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext createwebapplicationcontext(@nullable applicationcontext parent) {\n    class<?> contextclass = getcontextclass();\n    if (!configurablewebapplicationcontext.class.isassignablefrom(contextclass)) {\n        throw new applicationcontextexception(\n            "fatal initialization error in servlet with name \'" + getservletname() +\n            "\': custom webapplicationcontext class [" + contextclass.getname() +\n            "] is not of type configurablewebapplicationcontext");\n    }\n    // 通过反射创建 ioc 容器对象\n    configurablewebapplicationcontext wac =\n        (configurablewebapplicationcontext) beanutils.instantiateclass(contextclass);\n\n    wac.setenvironment(getenvironment());\n    // 设置父容器\n    wac.setparent(parent);\n    string configlocation = getcontextconfiglocation();\n    if (configlocation != null) {\n        wac.setconfiglocation(configlocation);\n    }\n    configureandrefreshwebapplicationcontext(wac);\n\n    return wac;\n}\n\n\n# c>dispatcherservlet初始化策略\n\nframeworkservlet创建webapplicationcontext后，刷新容器，调用onrefresh(wac)，此方法在dispatcherservlet中进行了重写，调用了initstrategies(context)方法（包含自己需要初始化的方法），初始化策略，即初始化dispatcherservlet的各个组件\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void initstrategies(applicationcontext context) {\n   initmultipartresolver(context);\n   initlocaleresolver(context);\n   initthemeresolver(context);\n   inithandlermappings(context);\n   inithandleradapters(context);\n   inithandlerexceptionresolvers(context);\n   initrequesttoviewnametranslator(context);\n   initviewresolvers(context);\n   initflashmapmanager(context);\n}\n\n\n\n# 3、dispatcherservlet调用组件处理请求\n\n# a>processrequest()\n\nframeworkservlet重写httpservlet中的service()和doxxx()，这些方法中调用了processrequest(request, response)\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected final void processrequest(httpservletrequest request, httpservletresponse response)\n    throws servletexception, ioexception {\n\n    long starttime = system.currenttimemillis();\n    throwable failurecause = null;\n\n    localecontext previouslocalecontext = localecontextholder.getlocalecontext();\n    localecontext localecontext = buildlocalecontext(request);\n\n    requestattributes previousattributes = requestcontextholder.getrequestattributes();\n    servletrequestattributes requestattributes = buildrequestattributes(request, response, previousattributes);\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n    asyncmanager.registercallableinterceptor(frameworkservlet.class.getname(), new requestbindinginterceptor());\n\n    initcontextholders(request, localecontext, requestattributes);\n\n    try {\n\t\t// 执行服务，doservice()是一个抽象方法，在dispatcherservlet中进行了重写\n        doservice(request, response);\n    }\n    catch (servletexception | ioexception ex) {\n        failurecause = ex;\n        throw ex;\n    }\n    catch (throwable ex) {\n        failurecause = ex;\n        throw new nestedservletexception("request processing failed", ex);\n    }\n\n    finally {\n        resetcontextholders(request, previouslocalecontext, previousattributes);\n        if (requestattributes != null) {\n            requestattributes.requestcompleted();\n        }\n        logresult(request, response, failurecause, asyncmanager);\n        publishrequesthandledevent(request, response, starttime, failurecause);\n    }\n}\n\n\n# b>doservice()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\n@override\nprotected void doservice(httpservletrequest request, httpservletresponse response) throws exception {\n    logrequest(request);\n\n    // keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    map<string, object> attributessnapshot = null;\n    if (webutils.isincluderequest(request)) {\n        attributessnapshot = new hashmap<>();\n        enumeration<?> attrnames = request.getattributenames();\n        while (attrnames.hasmoreelements()) {\n            string attrname = (string) attrnames.nextelement();\n            if (this.cleanupafterinclude || attrname.startswith(default_strategies_prefix)) {\n                attributessnapshot.put(attrname, request.getattribute(attrname));\n            }\n        }\n    }\n\n    // make framework objects available to handlers and view objects.\n    request.setattribute(web_application_context_attribute, getwebapplicationcontext());\n    request.setattribute(locale_resolver_attribute, this.localeresolver);\n    request.setattribute(theme_resolver_attribute, this.themeresolver);\n    request.setattribute(theme_source_attribute, getthemesource());\n\n    if (this.flashmapmanager != null) {\n        flashmap inputflashmap = this.flashmapmanager.retrieveandupdate(request, response);\n        if (inputflashmap != null) {\n            request.setattribute(input_flash_map_attribute, collections.unmodifiablemap(inputflashmap));\n        }\n        request.setattribute(output_flash_map_attribute, new flashmap());\n        request.setattribute(flash_map_manager_attribute, this.flashmapmanager);\n    }\n\n    requestpath requestpath = null;\n    if (this.parserequestpath && !servletrequestpathutils.hasparsedrequestpath(request)) {\n        requestpath = servletrequestpathutils.parseandcache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        dodispatch(request, response);\n    }\n    finally {\n        if (!webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n            // restore the original attribute snapshot, in case of an include.\n            if (attributessnapshot != null) {\n                restoreattributesafterinclude(request, attributessnapshot);\n            }\n        }\n        if (requestpath != null) {\n            servletrequestpathutils.clearparsedrequestpath(request);\n        }\n    }\n}\n\n\n# c>dodispatch()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception {\n    httpservletrequest processedrequest = request;\n    handlerexecutionchain mappedhandler = null;\n    boolean multipartrequestparsed = false;\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n\n    try {\n        modelandview mv = null;\n        exception dispatchexception = null;\n\n        try {\n            processedrequest = checkmultipart(request);\n            multipartrequestparsed = (processedrequest != request);\n\n            // determine handler for the current request.\n            /*\n            \tmappedhandler：调用链\n                包含handler、interceptorlist、interceptorindex\n            \thandler：浏览器发送的请求所匹配的控制器方法\n            \tinterceptorlist：处理控制器方法的所有拦截器集合\n            \tinterceptorindex：拦截器索引，控制拦截器aftercompletion()的执行\n            */\n            mappedhandler = gethandler(processedrequest);\n            if (mappedhandler == null) {\n                nohandlerfound(processedrequest, response);\n                return;\n            }\n\n            // determine handler adapter for the current request.\n           \t// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            handleradapter ha = gethandleradapter(mappedhandler.gethandler());\n\n            // process last-modified header, if supported by the handler.\n            string method = request.getmethod();\n            boolean isget = "get".equals(method);\n            if (isget || "head".equals(method)) {\n                long lastmodified = ha.getlastmodified(request, mappedhandler.gethandler());\n                if (new servletwebrequest(request, response).checknotmodified(lastmodified) && isget) {\n                    return;\n                }\n            }\n\t\t\t\n            // 调用拦截器的prehandle()\n            if (!mappedhandler.applyprehandle(processedrequest, response)) {\n                return;\n            }\n\n            // actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得modelandview对象\n            mv = ha.handle(processedrequest, response, mappedhandler.gethandler());\n\n            if (asyncmanager.isconcurrenthandlingstarted()) {\n                return;\n            }\n\n            applydefaultviewname(processedrequest, mv);\n            // 调用拦截器的posthandle()\n            mappedhandler.applyposthandle(processedrequest, response, mv);\n        }\n        catch (exception ex) {\n            dispatchexception = ex;\n        }\n        catch (throwable err) {\n            // as of 4.3, we\'re processing errors thrown from handler methods as well,\n            // making them available for @exceptionhandler methods and other scenarios.\n            dispatchexception = new nestedservletexception("handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processdispatchresult(processedrequest, response, mappedhandler, mv, dispatchexception);\n    }\n    catch (exception ex) {\n        triggeraftercompletion(processedrequest, response, mappedhandler, ex);\n    }\n    catch (throwable err) {\n        triggeraftercompletion(processedrequest, response, mappedhandler,\n                               new nestedservletexception("handler processing failed", err));\n    }\n    finally {\n        if (asyncmanager.isconcurrenthandlingstarted()) {\n            // instead of posthandle and aftercompletion\n            if (mappedhandler != null) {\n                mappedhandler.applyafterconcurrenthandlingstarted(processedrequest, response);\n            }\n        }\n        else {\n            // clean up any resources used by a multipart request.\n            if (multipartrequestparsed) {\n                cleanupmultipart(processedrequest);\n            }\n        }\n    }\n}\n\n\n# d>processdispatchresult()\n\nprivate void processdispatchresult(httpservletrequest request, httpservletresponse response,\n                                   @nullable handlerexecutionchain mappedhandler, @nullable modelandview mv,\n                                   @nullable exception exception) throws exception {\n\n    boolean errorview = false;\n\n    if (exception != null) {\n        if (exception instanceof modelandviewdefiningexception) {\n            logger.debug("modelandviewdefiningexception encountered", exception);\n            mv = ((modelandviewdefiningexception) exception).getmodelandview();\n        }\n        else {\n            object handler = (mappedhandler != null ? mappedhandler.gethandler() : null);\n            mv = processhandlerexception(request, response, handler, exception);\n            errorview = (mv != null);\n        }\n    }\n\n    // did the handler return a view to render?\n    if (mv != null && !mv.wascleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorview) {\n            webutils.clearerrorrequestattributes(request);\n        }\n    }\n    else {\n        if (logger.istraceenabled()) {\n            logger.trace("no view rendering, null modelandview returned.");\n        }\n    }\n\n    if (webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n        // concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedhandler != null) {\n        // exception (if any) is already handled..\n        // 调用拦截器的aftercompletion()\n        mappedhandler.triggeraftercompletion(request, response, null);\n    }\n}\n\n\n\n# 4、springmvc的执行流程\n\n 1. 用户向服务器发送请求，请求被springmvc 前端控制器 dispatcherservlet捕获。\n\n 2. dispatcherservlet对请求url进行解析，得到请求资源标识符（uri），判断请求uri对应的映射：\n\na) 不存在\n\ni. 再判断是否配置了mvc:default-servlet-handler\n\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：js,css,html），找不到客户端也会展示404错误\n\n\n\n\n\nb) 存在则执行下面的流程\n\n 3. 根据该uri，调用handlermapping获得该handler配置的所有相关的对象（包括handler对象以及handler对象对应的拦截器），最后以handlerexecutionchain执行链对象的形式返回。\n\n 4. dispatcherservlet 根据获得的handler，选择一个合适的handleradapter。\n\n 5. 如果成功获得handleradapter，此时将开始执行拦截器的prehandler(…)方法【正向】\n\n 6. 提取request中的模型数据，填充handler入参，开始执行handler（controller)方法，处理请求。在填充handler的入参过程中，根据你的配置，spring将帮你做一些额外的工作：\n\na) httpmessageconveter： 将请求消息（如json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n\nb) 数据转换：对请求消息进行数据转换。如string转换成integer、double等\n\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中\n\n 7.  handler执行完成后，向dispatcherservlet 返回一个modelandview对象。\n\n 8.  此时将开始执行拦截器的posthandle(...)方法【逆向】。\n\n 9.  根据返回的modelandview（此时会判断是否存在异常：如果存在异常，则执行handlerexceptionresolver进行异常处理）选择一个适合的viewresolver进行视图解析，根据model和view，来渲染视图。\n\n 10. 渲染视图完毕执行拦截器的aftercompletion(…)方法【逆向】。\n\n 11. 将渲染结果返回给客户端。',charsets:{cjk:!0}},{title:"文件上传和下载",frontmatter:{title:"文件上传和下载",date:"2022-05-11T00:00:00.000Z",permalink:"/springmvc/009/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/09.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD.html",relativePath:"07.框架/02.SpringMVC/09.文件上传和下载.md",key:"v-b70bddee",path:"/springmvc/009/",headers:[{level:3,title:"1、文件下载",slug:"_1、文件下载",normalizedTitle:"1、文件下载",charIndex:16},{level:3,title:"2、文件上传",slug:"_2、文件上传",normalizedTitle:"2、文件上传",charIndex:993}],headersStr:"1、文件下载 2、文件上传",content:'# 九、文件上传和下载\n\n\n# 1、文件下载\n\n使用ResponseEntity实现下载文件的功能\n\n@RequestMapping("/testDown")\npublic ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {\n    //获取ServletContext对象\n    ServletContext servletContext = session.getServletContext();\n    //获取服务器中文件的真实路径\n    String realPath = servletContext.getRealPath("/static/https://cdn.jsdelivr.net/gh/leejiayang/BlogImages@main/springmvc/1.jpg");\n    //创建输入流\n    InputStream is = new FileInputStream(realPath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建HttpHeaders对象设置响应头信息\n    MultiValueMap<String, String> headers = new HttpHeaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("Content-Disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    HttpStatus statusCode = HttpStatus.OK;\n    //创建ResponseEntity对象\n    ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);\n    //关闭输入流\n    is.close();\n    return responseEntity;\n}\n\n\n\n# 2、文件上传\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"\n\nSpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\na>添加依赖：\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.1</version>\n</dependency>\n\n\nb>在SpringMVC的配置文件中添加配置：\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--\x3e\n<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"></bean>\n\n\nc>控制器方法：\n\n@RequestMapping("/testUp")\npublic String testUp(MultipartFile photo, HttpSession session) throws IOException {\n    //获取上传的文件的文件名\n    String fileName = photo.getOriginalFilename();\n    //处理文件重名问题\n    // 获取后缀名\n    String hzName = fileName.substring(fileName.lastIndexOf("."));\n    // 将UUID和后缀名拼接真正的文件名\n    fileName = UUID.randomUUID().toString() + hzName;\n    //获取服务器中photo目录的路径\n    ServletContext servletContext = session.getServletContext();\n    String photoPath = servletContext.getRealPath("photo");\n    File file = new File(photoPath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    String finalPath = photoPath + File.separator + fileName;\n    //实现上传功能\n    photo.transferTo(new File(finalPath));\n    return "success";\n}\n',normalizedContent:'# 九、文件上传和下载\n\n\n# 1、文件下载\n\n使用responseentity实现下载文件的功能\n\n@requestmapping("/testdown")\npublic responseentity<byte[]> testresponseentity(httpsession session) throws ioexception {\n    //获取servletcontext对象\n    servletcontext servletcontext = session.getservletcontext();\n    //获取服务器中文件的真实路径\n    string realpath = servletcontext.getrealpath("/static/https://cdn.jsdelivr.net/gh/leejiayang/blogimages@main/springmvc/1.jpg");\n    //创建输入流\n    inputstream is = new fileinputstream(realpath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建httpheaders对象设置响应头信息\n    multivaluemap<string, string> headers = new httpheaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("content-disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    httpstatus statuscode = httpstatus.ok;\n    //创建responseentity对象\n    responseentity<byte[]> responseentity = new responseentity<>(bytes, headers, statuscode);\n    //关闭输入流\n    is.close();\n    return responseentity;\n}\n\n\n\n# 2、文件上传\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"\n\nspringmvc中将上传的文件封装到multipartfile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\na>添加依赖：\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupid>commons-fileupload</groupid>\n    <artifactid>commons-fileupload</artifactid>\n    <version>1.3.1</version>\n</dependency>\n\n\nb>在springmvc的配置文件中添加配置：\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为multipartfile对象--\x3e\n<bean id="multipartresolver" class="org.springframework.web.multipart.commons.commonsmultipartresolver"></bean>\n\n\nc>控制器方法：\n\n@requestmapping("/testup")\npublic string testup(multipartfile photo, httpsession session) throws ioexception {\n    //获取上传的文件的文件名\n    string filename = photo.getoriginalfilename();\n    //处理文件重名问题\n    // 获取后缀名\n    string hzname = filename.substring(filename.lastindexof("."));\n    // 将uuid和后缀名拼接真正的文件名\n    filename = uuid.randomuuid().tostring() + hzname;\n    //获取服务器中photo目录的路径\n    servletcontext servletcontext = session.getservletcontext();\n    string photopath = servletcontext.getrealpath("photo");\n    file file = new file(photopath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    string finalpath = photopath + file.separator + filename;\n    //实现上传功能\n    photo.transferto(new file(finalpath));\n    return "success";\n}\n',charsets:{cjk:!0}},{title:"RESTful案例",frontmatter:{title:"RESTful案例",date:"2022-05-10T00:00:00.000Z",permalink:"/springmvc/008/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/08.RESTful%E6%A1%88%E4%BE%8B.html",relativePath:"07.框架/02.SpringMVC/08.RESTful案例.md",key:"v-62753aac",path:"/springmvc/008/",headers:[{level:3,title:"1、准备工作",slug:"_1、准备工作",normalizedTitle:"1、准备工作",charIndex:18},{level:3,title:"2、功能清单",slug:"_2、功能清单",normalizedTitle:"2、功能清单",charIndex:2536},{level:3,title:"3、具体功能：访问首页",slug:"_3、具体功能-访问首页",normalizedTitle:"3、具体功能：访问首页",charIndex:2801},{level:5,title:"a>配置view-controller",slug:"a-配置view-controller",normalizedTitle:"a&gt;配置view-controller",charIndex:null},{level:5,title:"b>创建页面",slug:"b-创建页面",normalizedTitle:"b&gt;创建页面",charIndex:null},{level:3,title:"4、具体功能：查询所有员工数据",slug:"_4、具体功能-查询所有员工数据",normalizedTitle:"4、具体功能：查询所有员工数据",charIndex:3126},{level:5,title:"a>控制器方法",slug:"a-控制器方法",normalizedTitle:"a&gt;控制器方法",charIndex:null},{level:5,title:"b>创建employee_list.html",slug:"b-创建employee-list-html",normalizedTitle:"b&gt;创建employee_list.html",charIndex:null},{level:3,title:"5、具体功能：删除",slug:"_5、具体功能-删除",normalizedTitle:"5、具体功能：删除",charIndex:4887},{level:5,title:"a>创建处理delete请求方式的表单",slug:"a-创建处理delete请求方式的表单",normalizedTitle:"a&gt;创建处理delete请求方式的表单",charIndex:null},{level:5,title:"b>删除超链接绑定点击事件",slug:"b-删除超链接绑定点击事件",normalizedTitle:"b&gt;删除超链接绑定点击事件",charIndex:null},{level:5,title:"c> 开放静态资源访问",slug:"c-开放静态资源访问",normalizedTitle:"c&gt; 开放静态资源访问",charIndex:null},{level:5,title:"d>控制器方法",slug:"d-控制器方法",normalizedTitle:"d&gt;控制器方法",charIndex:null},{level:3,title:"6、具体功能：跳转到添加数据页面",slug:"_6、具体功能-跳转到添加数据页面",normalizedTitle:"6、具体功能：跳转到添加数据页面",charIndex:6251},{level:5,title:"a>配置view-controller",slug:"a-配置view-controller-2",normalizedTitle:"a&gt;配置view-controller",charIndex:null},{level:5,title:"b>创建employee_add.html",slug:"b-创建employee-add-html",normalizedTitle:"b&gt;创建employee_add.html",charIndex:null},{level:3,title:"7、具体功能：执行保存",slug:"_7、具体功能-执行保存",normalizedTitle:"7、具体功能：执行保存",charIndex:6890},{level:5,title:"a>控制器方法",slug:"a-控制器方法-2",normalizedTitle:"a&gt;控制器方法",charIndex:null},{level:3,title:"8、具体功能：跳转到更新数据页面",slug:"_8、具体功能-跳转到更新数据页面",normalizedTitle:"8、具体功能：跳转到更新数据页面",charIndex:7098},{level:5,title:"a>修改超链接",slug:"a-修改超链接",normalizedTitle:"a&gt;修改超链接",charIndex:null},{level:5,title:"b>控制器方法",slug:"b-控制器方法",normalizedTitle:"b&gt;控制器方法",charIndex:null},{level:5,title:"c>创建employee_update.html",slug:"c-创建employee-update-html",normalizedTitle:"c&gt;创建employee_update.html",charIndex:null},{level:3,title:"9、具体功能：执行更新",slug:"_9、具体功能-执行更新",normalizedTitle:"9、具体功能：执行更新",charIndex:8354},{level:5,title:"a>控制器方法",slug:"a-控制器方法-3",normalizedTitle:"a&gt;控制器方法",charIndex:null},{level:3,title:"1、@RequestBody",slug:"_1、-requestbody",normalizedTitle:"1、@requestbody",charIndex:8764},{level:3,title:"2、RequestEntity",slug:"_2、requestentity",normalizedTitle:"2、requestentity",charIndex:9279},{level:3,title:"3、@ResponseBody（用的最多）",slug:"_3、-responsebody-用的最多",normalizedTitle:"3、@responsebody（用的最多）",charIndex:10125},{level:3,title:"4、SpringMVC处理json",slug:"_4、springmvc处理json",normalizedTitle:"4、springmvc处理json",charIndex:10441},{level:3,title:"5、SpringMVC处理ajax",slug:"_5、springmvc处理ajax",normalizedTitle:"5、springmvc处理ajax",charIndex:11116},{level:3,title:"6、@RestController注解",slug:"_6、-restcontroller注解",normalizedTitle:"6、@restcontroller注解",charIndex:12174},{level:3,title:"7、ResponseEntity",slug:"_7、responseentity",normalizedTitle:"7、responseentity",charIndex:12298},{level:3,title:"1、文件下载",slug:"_1、文件下载",normalizedTitle:"1、文件下载",charIndex:12386},{level:3,title:"2、文件上传",slug:"_2、文件上传",normalizedTitle:"2、文件上传",charIndex:13363},{level:3,title:"1、拦截器的配置",slug:"_1、拦截器的配置",normalizedTitle:"1、拦截器的配置",charIndex:14672},{level:3,title:"2、拦截器的三个抽象方法",slug:"_2、拦截器的三个抽象方法",normalizedTitle:"2、拦截器的三个抽象方法",charIndex:15575},{level:3,title:"3、多个拦截器的执行顺序",slug:"_3、多个拦截器的执行顺序",normalizedTitle:"3、多个拦截器的执行顺序",charIndex:15823},{level:3,title:"1、基于配置的异常处理",slug:"_1、基于配置的异常处理",normalizedTitle:"1、基于配置的异常处理",charIndex:16130},{level:3,title:"2、基于注解的异常处理",slug:"_2、基于注解的异常处理",normalizedTitle:"2、基于注解的异常处理",charIndex:16893},{level:3,title:"1、创建初始化类，代替web.xml",slug:"_1、创建初始化类-代替web-xml",normalizedTitle:"1、创建初始化类，代替web.xml",charIndex:17347},{level:3,title:"2、创建SpringConfig配置类，代替spring的配置文件",slug:"_2、创建springconfig配置类-代替spring的配置文件",normalizedTitle:"2、创建springconfig配置类，代替spring的配置文件",charIndex:18867},{level:3,title:"3、创建WebConfig配置类，代替SpringMVC的配置文件",slug:"_3、创建webconfig配置类-代替springmvc的配置文件",normalizedTitle:"3、创建webconfig配置类，代替springmvc的配置文件",charIndex:18980},{level:3,title:"4、测试功能",slug:"_4、测试功能",normalizedTitle:"4、测试功能",charIndex:21939},{level:3,title:"1、SpringMVC常用组件",slug:"_1、springmvc常用组件",normalizedTitle:"1、springmvc常用组件",charIndex:22039},{level:3,title:"2、DispatcherServlet初始化过程",slug:"_2、dispatcherservlet初始化过程",normalizedTitle:"2、dispatcherservlet初始化过程",charIndex:22540},{level:5,title:"a>初始化WebApplicationContext",slug:"a-初始化webapplicationcontext",normalizedTitle:"a&gt;初始化webapplicationcontext",charIndex:null},{level:5,title:"b>创建WebApplicationContext",slug:"b-创建webapplicationcontext",normalizedTitle:"b&gt;创建webapplicationcontext",charIndex:null},{level:5,title:"c>DispatcherServlet初始化策略",slug:"c-dispatcherservlet初始化策略",normalizedTitle:"c&gt;dispatcherservlet初始化策略",charIndex:null},{level:3,title:"3、DispatcherServlet调用组件处理请求",slug:"_3、dispatcherservlet调用组件处理请求",normalizedTitle:"3、dispatcherservlet调用组件处理请求",charIndex:26812},{level:5,title:"a>processRequest()",slug:"a-processrequest",normalizedTitle:"a&gt;processrequest()",charIndex:null},{level:5,title:"b>doService()",slug:"b-doservice",normalizedTitle:"b&gt;doservice()",charIndex:null},{level:5,title:"c>doDispatch()",slug:"c-dodispatch",normalizedTitle:"c&gt;dodispatch()",charIndex:null},{level:5,title:"d>processDispatchResult()",slug:"d-processdispatchresult",normalizedTitle:"d&gt;processdispatchresult()",charIndex:null},{level:3,title:"4、SpringMVC的执行流程",slug:"_4、springmvc的执行流程",normalizedTitle:"4、springmvc的执行流程",charIndex:36325}],headersStr:"1、准备工作 2、功能清单 3、具体功能：访问首页 a>配置view-controller b>创建页面 4、具体功能：查询所有员工数据 a>控制器方法 b>创建employee_list.html 5、具体功能：删除 a>创建处理delete请求方式的表单 b>删除超链接绑定点击事件 c> 开放静态资源访问 d>控制器方法 6、具体功能：跳转到添加数据页面 a>配置view-controller b>创建employee_add.html 7、具体功能：执行保存 a>控制器方法 8、具体功能：跳转到更新数据页面 a>修改超链接 b>控制器方法 c>创建employee_update.html 9、具体功能：执行更新 a>控制器方法 1、@RequestBody 2、RequestEntity 3、@ResponseBody（用的最多） 4、SpringMVC处理json 5、SpringMVC处理ajax 6、@RestController注解 7、ResponseEntity 1、文件下载 2、文件上传 1、拦截器的配置 2、拦截器的三个抽象方法 3、多个拦截器的执行顺序 1、基于配置的异常处理 2、基于注解的异常处理 1、创建初始化类，代替web.xml 2、创建SpringConfig配置类，代替spring的配置文件 3、创建WebConfig配置类，代替SpringMVC的配置文件 4、测试功能 1、SpringMVC常用组件 2、DispatcherServlet初始化过程 a>初始化WebApplicationContext b>创建WebApplicationContext c>DispatcherServlet初始化策略 3、DispatcherServlet调用组件处理请求 a>processRequest() b>doService() c>doDispatch() d>processDispatchResult() 4、SpringMVC的执行流程",content:'# 八、RESTful案例\n\n\n# 1、准备工作\n\n和传统 CRUD 一样，实现对员工信息的增删改查。\n\n * 搭建环境\n\n * 准备实体类\n   \n   package com.atguigu.mvc.bean;\n   \n   public class Employee {\n   \n      private Integer id;\n      private String lastName;\n   \n      private String email;\n      //1 male, 0 female\n      private Integer gender;\n      \n      public Integer getId() {\n         return id;\n      }\n   \n      public void setId(Integer id) {\n         this.id = id;\n      }\n   \n      public String getLastName() {\n         return lastName;\n      }\n   \n      public void setLastName(String lastName) {\n         this.lastName = lastName;\n      }\n   \n      public String getEmail() {\n         return email;\n      }\n   \n      public void setEmail(String email) {\n         this.email = email;\n      }\n   \n      public Integer getGender() {\n         return gender;\n      }\n   \n      public void setGender(Integer gender) {\n         this.gender = gender;\n      }\n   \n      public Employee(Integer id, String lastName, String email, Integer gender) {\n         super();\n         this.id = id;\n         this.lastName = lastName;\n         this.email = email;\n         this.gender = gender;\n      }\n   \n      public Employee() {\n      }\n   }\n   \n\n * 准备dao模拟数据\n   \n   package com.atguigu.mvc.dao;\n   \n   import java.util.Collection;\n   import java.util.HashMap;\n   import java.util.Map;\n   \n   import com.atguigu.mvc.bean.Employee;\n   import org.springframework.stereotype.Repository;\n   \n   \n   @Repository\n   public class EmployeeDao {\n   \n      private static Map<Integer, Employee> employees = null;\n      \n      static{\n         employees = new HashMap<Integer, Employee>();\n   \n         employees.put(1001, new Employee(1001, "E-AA", "aa@163.com", 1));\n         employees.put(1002, new Employee(1002, "E-BB", "bb@163.com", 1));\n         employees.put(1003, new Employee(1003, "E-CC", "cc@163.com", 0));\n         employees.put(1004, new Employee(1004, "E-DD", "dd@163.com", 0));\n         employees.put(1005, new Employee(1005, "E-EE", "ee@163.com", 1));\n      }\n      \n      private static Integer initId = 1006;\n      \n      public void save(Employee employee){\n         if(employee.getId() == null){\n            employee.setId(initId++);\n         }\n         employees.put(employee.getId(), employee);\n      }\n      \n      public Collection<Employee> getAll(){\n         return employees.values();\n      }\n      \n      public Employee get(Integer id){\n         return employees.get(id);\n      }\n      \n      public void delete(Integer id){\n         employees.remove(id);\n      }\n   }\n   \n\n\n# 2、功能清单\n\n功能           URL 地址        请求方式\n访问首页√        /             GET\n查询全部数据√      /employee     GET\n删除√          /employee/2   DELETE\n跳转到添加数据页面√   /toAdd        GET\n执行保存√        /employee     POST\n跳转到更新数据页面√   /employee/2   GET\n执行更新√        /employee     PUT\n\n\n# 3、具体功能：访问首页\n\n# a>配置view-controller\n\n这里就不写控制器方法了\n\n<mvc:view-controller path="/" view-name="index"/>\n\n\n# b>创建页面\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8" >\n    <title>Title</title>\n</head>\n<body>\n<h1>首页</h1>\n<a th:href="@{/employee}">访问员工信息</a>\n</body>\n</html>\n\n\n\n# 4、具体功能：查询所有员工数据\n\n# a>控制器方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.GET)\npublic String getEmployeeList(Model model){\n    Collection<Employee> employeeList = employeeDao.getAll();\n    model.addAttribute("employeeList", employeeList);\n    return "employee_list";\n}\n\n\n# b>创建employee_list.html\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Employee Info</title>\n    <script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n</head>\n<body>\n\n    <table border="1" cellpadding="0" cellspacing="0" style="text-align: center;" id="dataTable">\n        <tr>\n            <th colspan="5">Employee Info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastName</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options(<a th:href="@{/toAdd}">add</a>)</th>\n        </tr>\n\n        **th:each是什么意思**\n        <tr th:each="employee : ${employeeList}">\n            <td th:text="${employee.id}"></td>\n            <td th:text="${employee.lastName}"></td>\n            <td th:text="${employee.email}"></td>\n            <td th:text="${employee.gender}"></td>\n            <td>\n                \x3c!-- "@{/employee/${employee.id}}" 写法是错误的，因为$会被当成符号进行解析\n                \'/employee/\'表示请求地址 --\x3e\n                <a class="deleteA" @click="deleteEmployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n                \x3c!-- 或者 --\x3e\n                <a class="deleteA" @click="deleteEmployee" th:href="@{/employee/} + ${employee.id}">delete</a>\n                \x3c!-- 上述两种方法都是正确的  --\x3e\n\n                <a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n            </td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\nth:each是什么意思？？？复习前端知识\n\n\n# 5、具体功能：删除\n\n# a>创建处理delete请求方式的表单\n\n\x3c!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\x3e\n<form id="delete_form" method="post">\n    \x3c!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\x3e\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n\n# b>删除超链接绑定点击事件\n\n引入vue.js\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n\n\n删除超链接\n\n<a class="deleteA" @click="deleteEmployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n\n\n通过vue处理点击事件\n\n<script type="text/javascript">\n    var vue = new Vue({\n        el:"#dataTable",\n        methods:{\n            //event表示当前事件\n            deleteEmployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getElementById("delete_form");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventDefault();\n            }\n        }\n    });\n<\/script>\n\n\n# c> 开放静态资源访问\n\n<mvc:default-servlet-handler />\n\n\nspringmvc先处理请求，能处理就会被处理，不能处理就会交给今天的servelet处理，servelet能处理就处理，不能处理默认的servelet报错\n\n# d>控制器方法\n\n@RequestMapping(value = "/employee/{id}", method = RequestMethod.DELETE)\npublic String deleteEmployee(@PathVariable("id") Integer id){\n    employeeDao.delete(id);\n    return "redirect:/employee";\n}\n\n\n\n# 6、具体功能：跳转到添加数据页面\n\n# a>配置view-controller\n\n<mvc:view-controller path="/toAdd" view-name="employee_add"></mvc:view-controller>\n\n\n# b>创建employee_add.html\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Add Employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    lastName:<input type="text" name="lastName"><br>\n    email:<input type="text" name="email"><br>\n    gender:<input type="radio" name="gender" value="1">male\n    <input type="radio" name="gender" value="0">female<br>\n    <input type="submit" value="add"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 7、具体功能：执行保存\n\n# a>控制器方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.POST)\npublic String addEmployee(Employee employee){\n    employeeDao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 8、具体功能：跳转到更新数据页面\n\n# a>修改超链接\n\n<a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n\n\n# b>控制器方法\n\n@RequestMapping(value = "/employee/{id}", method = RequestMethod.GET)\npublic String getEmployeeById(@PathVariable("id") Integer id, Model model){\n    Employee employee = employeeDao.get(id);\n    model.addAttribute("employee", employee);\n    return "employee_update";\n}\n\n\n# c>创建employee_update.html\n\n<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>Update Employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    <input type="hidden" name="_method" value="put">\n    <input type="hidden" name="id" th:value="${employee.id}">\n    lastName:<input type="text" name="lastName" th:value="${employee.lastName}"><br>\n    email:<input type="text" name="email" th:value="${employee.email}"><br>\n    \x3c!--\n        th:field="${employee.gender}"可用于单选框或复选框的回显\n        若单选框的value和employee.gender的值一致，则添加checked="checked"属性\n    --\x3e\n    gender:<input type="radio" name="gender" value="1" th:field="${employee.gender}">male\n    <input type="radio" name="gender" value="0" th:field="${employee.gender}">female<br>\n    <input type="submit" value="update"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 9、具体功能：执行更新\n\n# a>控制器方法\n\n@RequestMapping(value = "/employee", method = RequestMethod.PUT)\npublic String updateEmployee(Employee employee){\n    employeeDao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 八、HttpMessageConverter\n\nHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象（浏览器请求服务器），或将Java对象转换为响应报文（服务器相应浏览器）\n\nHttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，\n\nResponseEntity\n\n\n# 1、@RequestBody\n\n@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\n<form th:action="@{/testRequestBody}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit">\n</form>\n\n\n@RequestMapping("/testRequestBody")\npublic String testRequestBody(@RequestBody String requestBody){\n    System.out.println("requestBody:"+requestBody);\n    return "success";\n}\n\n\n输出结果：\n\nrequestBody:username=admin&password=123456\n\n\n# 2、RequestEntity\n\nRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息\n\n@RequestMapping("/testRequestEntity")\npublic String testRequestEntity(RequestEntity<String> requestEntity){\n    System.out.println("requestHeader:"+requestEntity.getHeaders());\n    System.out.println("requestBody:"+requestEntity.getBody());\n    return "success";\n}\n\n\n输出结果： requestHeader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"http://localhost:8080", user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"] requestBody:username=admin&password=123\n\n\n# 3、@ResponseBody（用的最多）\n\n@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n\n@RequestMapping("/testResponseBody")\n@ResponseBody\npublic String testResponseBody(){\n    return "success";\n}\n\n\n也就是加上ResponseBody直接返回字符串，不加则会拼接"前缀+返回字符串+后缀"并打开新页面进行展示信息\n\n结果：浏览器页面显示success\n\n这里要学习一下javaweb中的httpservletResponse对于浏览器数据的响应\n\n\n# 4、SpringMVC处理json\n\n@ResponseBody处理json的步骤：\n\na>导入jackson的依赖\n\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.12.1</version>\n</dependency>\n\n\nb>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串\n\n<mvc:annotation-driven />\n\n\nc>在处理器方法上使用@ResponseBody注解进行标识\n\nd>将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串\n\n@RequestMapping("/testResponseUser")\n@ResponseBody\npublic User testResponseUser(){\n    return new User(1001,"admin","123456",23,"男");\n}\n\n\n浏览器的页面中展示的结果：\n\n{"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}\n\n\n# 5、SpringMVC处理ajax\n\na>请求超链接：\n\n<div id="app">\n\t<a th:href="@{/testAjax}" @click="testAjax">testAjax</a><br>\n</div>\n\n\nb>通过vue和axios处理点击事件：\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n<script type="text/javascript" th:src="@{/static/js/axios.min.js}"><\/script>\n<script type="text/javascript">\n    var vue = new Vue({\n        el:"#app",\n        methods:{\n            testAjax:function (event) {\n                axios({\n                    method:"post",\n                    url:event.target.href,\n                    params:{\n                        username:"admin",\n                        password:"123456"\n                    }\n                }).then(function (response) {\n                    alert(response.data);\n                });\n                event.preventDefault();\n            }\n        }\n    });\n<\/script>\n\n\nc>控制器方法：\n\n@RequestMapping("/testAjax")\n@ResponseBody\npublic String testAjax(String username, String password){\n    System.out.println("username:"+username+",password:"+password);\n    return "hello,ajax";\n}\n\n\n\n# 6、@RestController注解\n\n@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解\n\n\n# 7、ResponseEntity\n\nResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n\n\n# 九、文件上传和下载\n\n\n# 1、文件下载\n\n使用ResponseEntity实现下载文件的功能\n\n@RequestMapping("/testDown")\npublic ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {\n    //获取ServletContext对象\n    ServletContext servletContext = session.getServletContext();\n    //获取服务器中文件的真实路径\n    String realPath = servletContext.getRealPath("/static/https://cdn.jsdelivr.net/gh/leejiayang/BlogImages@main/springmvc/1.jpg");\n    //创建输入流\n    InputStream is = new FileInputStream(realPath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建HttpHeaders对象设置响应头信息\n    MultiValueMap<String, String> headers = new HttpHeaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("Content-Disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    HttpStatus statusCode = HttpStatus.OK;\n    //创建ResponseEntity对象\n    ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);\n    //关闭输入流\n    is.close();\n    return responseEntity;\n}\n\n\n\n# 2、文件上传\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"\n\nSpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\na>添加依赖：\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.1</version>\n</dependency>\n\n\nb>在SpringMVC的配置文件中添加配置：\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--\x3e\n<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"></bean>\n\n\nc>控制器方法：\n\n@RequestMapping("/testUp")\npublic String testUp(MultipartFile photo, HttpSession session) throws IOException {\n    //获取上传的文件的文件名\n    String fileName = photo.getOriginalFilename();\n    //处理文件重名问题\n    // 获取后缀名\n    String hzName = fileName.substring(fileName.lastIndexOf("."));\n    // 将UUID和后缀名拼接真正的文件名\n    fileName = UUID.randomUUID().toString() + hzName;\n    //获取服务器中photo目录的路径\n    ServletContext servletContext = session.getServletContext();\n    String photoPath = servletContext.getRealPath("photo");\n    File file = new File(photoPath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    String finalPath = photoPath + File.separator + fileName;\n    //实现上传功能\n    photo.transferTo(new File(finalPath));\n    return "success";\n}\n\n\n\n# 十、拦截器\n\n\n# 1、拦截器的配置\n\nSpringMVC中的拦截器用于拦截控制器方法的执行\n\nSpringMVC中的拦截器需要实现HandlerInterceptor或者HandlerInterceptorAdapter(已过时)，重写下面的三个方法\n\n事实上是HandlerInterceptorAdapter继承了ASyncHandlerInterceptor, AsyncHandlerInterceptor又继承了HandlerInterceptor\n\nSpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：\n\n最简单的配置方法（第一种配置方法） 表示一个对象\n\n图片里面的设置也会被拦截，因为本质上这个也是控制器方法\n\n\n\n\n\n第二种配置方法\n<mvc:interceptor>\n\x3c!-- <bean class="com.atguigu.interceptor.FirstInterceptor"></bean> --\x3e\n<ref bean="firstInterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n\x3c!-- 拦截所有请求 --\x3e\n\x3c!-- 这里的/*表示访问该页面的上下一层目录 --\x3e\n<mvc:mapping path="/*"/>\n    <mvc:mapping path="/**"/>\n    \x3c!-- 排除不拦截的特殊情况 --\x3e\n    <mvc:exclude-mapping path="/testRequestEntity"/>\n    \x3c!-- 指定拦截 器 --\x3e\n    <ref bean="firstInterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n\t以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n\n# 2、拦截器的三个抽象方法\n\n过滤器的拦截器的区别是什么？？ SpringMVC中的拦截器有三个抽象方法：\n\npreHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\n\npostHandle：控制器方法执行之后执行postHandle()\n\nafterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()\n\n\n# 3、多个拦截器的执行顺序\n\na>若每个拦截器的preHandle()都返回true\n\n此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：\n\npreHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行\n\nb>若某个拦截器的preHandle()返回了false\n\npreHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行\n\n\n# 十一、异常处理器(出现异常跳转指定页面)\n\n\n# 1、基于配置的异常处理\n\nSpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver\n\nHandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver\n\nSpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：\n\n<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">\n    <property name="exceptionMappings">\n        <props>\n        \t\x3c!--\n        \t\tproperties的键表示处理器方法执行过程中出现的异常\n        \t\tproperties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面,themeleaf进行解析，和之前 的解析规则一致\n        \t--\x3e\n            <prop key="java.lang.ArithmeticException">error</prop>\n        </props>\n    </property>\n    \x3c!--\n    \texceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n\n\n    <property name="exceptionAttribute" value="ex"></property>\n</bean>\n\n\n\n# 2、基于注解的异常处理\n\n//@ControllerAdvice将当前类标识为异常处理的组件\n@ControllerAdvice\npublic class ExceptionController {\n\n    //@ExceptionHandler用于设置所标识方法处理的异常\n    @ExceptionHandler(value = ArithmeticException.class, NullPointerException.class)\n    //ex表示当前请求处理中出现的异常对象\n    public String handleArithmeticException(Exception ex, Model model){\n        model.addAttribute("ex", ex);\n        return "error";\n    }\n\n}\n\n\n\n# 十二、注解配置SpringMVC\n\n使用配置类和注解代替web.xml和SpringMVC配置文件的功能\n\n\n# 1、创建初始化类，代替web.xml\n\n在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。\n\nSpring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。\n\nSpring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。\n\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[]{SpringConfig.class};\n    }\n\n    /**\n     * 指定SpringMVC的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        // 返回class数组\n        return new Class[]{WebConfig.class};\n    }\n\n    /**\n     * 指定DispatcherServlet的映射规则(映射规则)，即url-pattern\n     * @return\n     */\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @Override\n    protected Filter[] getServletFilters() {\n        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();\n        encodingFilter.setEncoding("UTF-8");\n        encodingFilter.setForceRequestEncoding(true);\n        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};\n    }\n}\n\n\n\n# 2、创建SpringConfig配置类，代替spring的配置文件\n\n@Configuration\npublic class SpringConfig {\n\t//ssm整合之后，spring的配置信息写在此类中\n}\n\n\n\n# 3、创建WebConfig配置类，代替SpringMVC的配置文件\n\n\n// 扫描组件\n// 视图解析器\n// viewcontroller\n// default-servlet-handler\n// MVC注解驱动\n// 文件上传解析器\n// 异常处理\n// 拦截器\n\n@Configuration\n//扫描组件\n@ComponentScan("com.atguigu.mvc.controller")\n//开启MVC注解驱动\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    //使用默认的servlet处理静态资源\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @Bean\n    public CommonsMultipartResolver multipartResolver(){\n        return new CommonsMultipartResolver();\n    }\n\n    //配置拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        FirstInterceptor firstInterceptor = new FirstInterceptor();\n\n        //  addPathPatterns添加拦截规则\n        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");\n    }\n    \n    //配置视图控制\n    \n    /*@Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/").setViewName("index");\n    }*/\n    \n    //配置异常映射\n    /*@Override\n    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.setProperty("java.lang.ArithmeticException", "error");\n        //设置异常映射\n        exceptionResolver.setExceptionMappings(prop);\n        //设置共享异常信息的键\n        exceptionResolver.setExceptionAttribute("ex");\n        resolvers.add(exceptionResolver);\n    }*/\n\n    // 注意：xml视图解析器要从里到外配置\n    //配置生成模板解析器\n    @Bean\n    public ITemplateResolver templateResolver() {\n        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得\n        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(\n                webApplicationContext.getServletContext());\n\n        // 视图前缀\n        templateResolver.setPrefix("/WEB-INF/templates/");\n        // 视图后缀\n        templateResolver.setSuffix(".html");\n        templateResolver.setCharacterEncoding("UTF-8");\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        return templateResolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setCharacterEncoding("UTF-8");\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    }\n\n\n}\n\n\n\n# 4、测试功能\n\n@RequestMapping("/")\npublic String index(){\n    return "index";\n}\n\n\n\n# 十三、SpringMVC执行流程\n\n\n# 1、SpringMVC常用组件\n\n * DispatcherServlet：前端控制器，不需要工程师开发，由框架提供\n\n作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\n * HandlerMapping：处理器映射器，不需要工程师开发，由框架提供\n\n作用：根据请求的url、method等信息查找Handler，即控制器方法\n\n * Handler：处理器，需要工程师开发\n\n作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n\n * HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供\n\n作用：通过HandlerAdapter对处理器（控制器方法）进行执行\n\n * ViewResolver：视图解析器，不需要工程师开发，由框架提供（页面需要自己写）\n\n作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView\n\n * View：视图，不需要工程师开发，由框架或者视图技术提供\n\n作用：将模型数据通过页面展示给用户\n\n\n\n\n# 2、DispatcherServlet初始化过程\n\nDispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\n\n\n\n# a>初始化WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext initWebApplicationContext() {\n    WebApplicationContext rootContext =\n        WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n\n    if (this.webApplicationContext != null) {\n        // A context instance was injected at construction time -> use it\n        wac = this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) {\n                // The context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getParent() == null) {\n                    // The context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setParent(rootContext);\n                }\n                configureAndRefreshWebApplicationContext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // No context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. If one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findWebApplicationContext();\n    }\n    if (wac == null) {\n        // No context instance is defined for this servlet -> create a local one\n        // 创建WebApplicationContext\n        wac = createWebApplicationContext(rootContext);\n    }\n\n    if (!this.refreshEventReceived) {\n        // Either the context is not a ConfigurableApplicationContext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onRefresh manually here.\n        synchronized (this.onRefreshMonitor) {\n            // 刷新WebApplicationContext\n            onRefresh(wac);\n        }\n    }\n\n    if (this.publishContext) {\n        // Publish the context as a servlet context attribute.\n        // 将IOC容器在应用域共享\n        String attrName = getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    }\n\n    return wac;\n}\n\n\n# b>创建WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {\n    Class<?> contextClass = getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException(\n            "Fatal initialization error in servlet with name \'" + getServletName() +\n            "\': custom WebApplicationContext class [" + contextClass.getName() +\n            "] is not of type ConfigurableWebApplicationContext");\n    }\n    // 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac =\n        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n    wac.setEnvironment(getEnvironment());\n    // 设置父容器\n    wac.setParent(parent);\n    String configLocation = getContextConfigLocation();\n    if (configLocation != null) {\n        wac.setConfigLocation(configLocation);\n    }\n    configureAndRefreshWebApplicationContext(wac);\n\n    return wac;\n}\n\n\n# c>DispatcherServlet初始化策略\n\nFrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法（包含自己需要初始化的方法），初始化策略，即初始化DispatcherServlet的各个组件\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void initStrategies(ApplicationContext context) {\n   initMultipartResolver(context);\n   initLocaleResolver(context);\n   initThemeResolver(context);\n   initHandlerMappings(context);\n   initHandlerAdapters(context);\n   initHandlerExceptionResolvers(context);\n   initRequestToViewNameTranslator(context);\n   initViewResolvers(context);\n   initFlashMapManager(context);\n}\n\n\n\n# 3、DispatcherServlet调用组件处理请求\n\n# a>processRequest()\n\nFrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    long startTime = System.currentTimeMillis();\n    Throwable failureCause = null;\n\n    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext = buildLocaleContext(request);\n\n    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n    initContextHolders(request, localeContext, requestAttributes);\n\n    try {\n\t\t// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写\n        doService(request, response);\n    }\n    catch (ServletException | IOException ex) {\n        failureCause = ex;\n        throw ex;\n    }\n    catch (Throwable ex) {\n        failureCause = ex;\n        throw new NestedServletException("Request processing failed", ex);\n    }\n\n    finally {\n        resetContextHolders(request, previousLocaleContext, previousAttributes);\n        if (requestAttributes != null) {\n            requestAttributes.requestCompleted();\n        }\n        logResult(request, response, failureCause, asyncManager);\n        publishRequestHandledEvent(request, response, startTime, failureCause);\n    }\n}\n\n\n# b>doService()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    logRequest(request);\n\n    // Keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    Map<String, Object> attributesSnapshot = null;\n    if (WebUtils.isIncludeRequest(request)) {\n        attributesSnapshot = new HashMap<>();\n        Enumeration<?> attrNames = request.getAttributeNames();\n        while (attrNames.hasMoreElements()) {\n            String attrName = (String) attrNames.nextElement();\n            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n                attributesSnapshot.put(attrName, request.getAttribute(attrName));\n            }\n        }\n    }\n\n    // Make framework objects available to handlers and view objects.\n    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n    if (this.flashMapManager != null) {\n        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n        if (inputFlashMap != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n        }\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n    }\n\n    RequestPath requestPath = null;\n    if (this.parseRequestPath && !ServletRequestPathUtils.hasParsedRequestPath(request)) {\n        requestPath = ServletRequestPathUtils.parseAndCache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        doDispatch(request, response);\n    }\n    finally {\n        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n            // Restore the original attribute snapshot, in case of an include.\n            if (attributesSnapshot != null) {\n                restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n        }\n        if (requestPath != null) {\n            ServletRequestPathUtils.clearParsedRequestPath(request);\n        }\n    }\n}\n\n\n# c>doDispatch()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // Determine handler for the current request.\n            /*\n            \tmappedHandler：调用链\n                包含handler、interceptorList、interceptorIndex\n            \thandler：浏览器发送的请求所匹配的控制器方法\n            \tinterceptorList：处理控制器方法的所有拦截器集合\n            \tinterceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行\n            */\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n            // Determine handler adapter for the current request.\n           \t// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n            // Process last-modified header, if supported by the handler.\n            String method = request.getMethod();\n            boolean isGet = "GET".equals(method);\n            if (isGet || "HEAD".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n\t\t\t\n            // 调用拦截器的preHandle()\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // Actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            applyDefaultViewName(processedRequest, mv);\n            // 调用拦截器的postHandle()\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        }\n        catch (Exception ex) {\n            dispatchException = ex;\n        }\n        catch (Throwable err) {\n            // As of 4.3, we\'re processing Errors thrown from handler methods as well,\n            // making them available for @ExceptionHandler methods and other scenarios.\n            dispatchException = new NestedServletException("Handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    }\n    catch (Exception ex) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n    }\n    catch (Throwable err) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler,\n                               new NestedServletException("Handler processing failed", err));\n    }\n    finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            // Instead of postHandle and afterCompletion\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        }\n        else {\n            // Clean up any resources used by a multipart request.\n            if (multipartRequestParsed) {\n                cleanupMultipart(processedRequest);\n            }\n        }\n    }\n}\n\n\n# d>processDispatchResult()\n\nprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,\n                                   @Nullable Exception exception) throws Exception {\n\n    boolean errorView = false;\n\n    if (exception != null) {\n        if (exception instanceof ModelAndViewDefiningException) {\n            logger.debug("ModelAndViewDefiningException encountered", exception);\n            mv = ((ModelAndViewDefiningException) exception).getModelAndView();\n        }\n        else {\n            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n            mv = processHandlerException(request, response, handler, exception);\n            errorView = (mv != null);\n        }\n    }\n\n    // Did the handler return a view to render?\n    if (mv != null && !mv.wasCleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorView) {\n            WebUtils.clearErrorRequestAttributes(request);\n        }\n    }\n    else {\n        if (logger.isTraceEnabled()) {\n            logger.trace("No view rendering, null ModelAndView returned.");\n        }\n    }\n\n    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n        // Concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedHandler != null) {\n        // Exception (if any) is already handled..\n        // 调用拦截器的afterCompletion()\n        mappedHandler.triggerAfterCompletion(request, response, null);\n    }\n}\n\n\n\n# 4、SpringMVC的执行流程\n\n 1. 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\n\n 2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n\na) 不存在\n\ni. 再判断是否配置了mvc:default-servlet-handler\n\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\n\n\n\n\n\nb) 存在则执行下面的流程\n\n 3. 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\n\n 4. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\n\n 5. 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n\n 6. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n\na) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n\nb) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n\n 7.  Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\n\n 8.  此时将开始执行拦截器的postHandle(...)方法【逆向】。\n\n 9.  根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\n\n 10. 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\n\n 11. 将渲染结果返回给客户端。',normalizedContent:'# 八、restful案例\n\n\n# 1、准备工作\n\n和传统 crud 一样，实现对员工信息的增删改查。\n\n * 搭建环境\n\n * 准备实体类\n   \n   package com.atguigu.mvc.bean;\n   \n   public class employee {\n   \n      private integer id;\n      private string lastname;\n   \n      private string email;\n      //1 male, 0 female\n      private integer gender;\n      \n      public integer getid() {\n         return id;\n      }\n   \n      public void setid(integer id) {\n         this.id = id;\n      }\n   \n      public string getlastname() {\n         return lastname;\n      }\n   \n      public void setlastname(string lastname) {\n         this.lastname = lastname;\n      }\n   \n      public string getemail() {\n         return email;\n      }\n   \n      public void setemail(string email) {\n         this.email = email;\n      }\n   \n      public integer getgender() {\n         return gender;\n      }\n   \n      public void setgender(integer gender) {\n         this.gender = gender;\n      }\n   \n      public employee(integer id, string lastname, string email, integer gender) {\n         super();\n         this.id = id;\n         this.lastname = lastname;\n         this.email = email;\n         this.gender = gender;\n      }\n   \n      public employee() {\n      }\n   }\n   \n\n * 准备dao模拟数据\n   \n   package com.atguigu.mvc.dao;\n   \n   import java.util.collection;\n   import java.util.hashmap;\n   import java.util.map;\n   \n   import com.atguigu.mvc.bean.employee;\n   import org.springframework.stereotype.repository;\n   \n   \n   @repository\n   public class employeedao {\n   \n      private static map<integer, employee> employees = null;\n      \n      static{\n         employees = new hashmap<integer, employee>();\n   \n         employees.put(1001, new employee(1001, "e-aa", "aa@163.com", 1));\n         employees.put(1002, new employee(1002, "e-bb", "bb@163.com", 1));\n         employees.put(1003, new employee(1003, "e-cc", "cc@163.com", 0));\n         employees.put(1004, new employee(1004, "e-dd", "dd@163.com", 0));\n         employees.put(1005, new employee(1005, "e-ee", "ee@163.com", 1));\n      }\n      \n      private static integer initid = 1006;\n      \n      public void save(employee employee){\n         if(employee.getid() == null){\n            employee.setid(initid++);\n         }\n         employees.put(employee.getid(), employee);\n      }\n      \n      public collection<employee> getall(){\n         return employees.values();\n      }\n      \n      public employee get(integer id){\n         return employees.get(id);\n      }\n      \n      public void delete(integer id){\n         employees.remove(id);\n      }\n   }\n   \n\n\n# 2、功能清单\n\n功能           url 地址        请求方式\n访问首页√        /             get\n查询全部数据√      /employee     get\n删除√          /employee/2   delete\n跳转到添加数据页面√   /toadd        get\n执行保存√        /employee     post\n跳转到更新数据页面√   /employee/2   get\n执行更新√        /employee     put\n\n\n# 3、具体功能：访问首页\n\n# a>配置view-controller\n\n这里就不写控制器方法了\n\n<mvc:view-controller path="/" view-name="index"/>\n\n\n# b>创建页面\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8" >\n    <title>title</title>\n</head>\n<body>\n<h1>首页</h1>\n<a th:href="@{/employee}">访问员工信息</a>\n</body>\n</html>\n\n\n\n# 4、具体功能：查询所有员工数据\n\n# a>控制器方法\n\n@requestmapping(value = "/employee", method = requestmethod.get)\npublic string getemployeelist(model model){\n    collection<employee> employeelist = employeedao.getall();\n    model.addattribute("employeelist", employeelist);\n    return "employee_list";\n}\n\n\n# b>创建employee_list.html\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>employee info</title>\n    <script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n</head>\n<body>\n\n    <table border="1" cellpadding="0" cellspacing="0" style="text-align: center;" id="datatable">\n        <tr>\n            <th colspan="5">employee info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastname</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options(<a th:href="@{/toadd}">add</a>)</th>\n        </tr>\n\n        **th:each是什么意思**\n        <tr th:each="employee : ${employeelist}">\n            <td th:text="${employee.id}"></td>\n            <td th:text="${employee.lastname}"></td>\n            <td th:text="${employee.email}"></td>\n            <td th:text="${employee.gender}"></td>\n            <td>\n                \x3c!-- "@{/employee/${employee.id}}" 写法是错误的，因为$会被当成符号进行解析\n                \'/employee/\'表示请求地址 --\x3e\n                <a class="deletea" @click="deleteemployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n                \x3c!-- 或者 --\x3e\n                <a class="deletea" @click="deleteemployee" th:href="@{/employee/} + ${employee.id}">delete</a>\n                \x3c!-- 上述两种方法都是正确的  --\x3e\n\n                <a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n            </td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\nth:each是什么意思？？？复习前端知识\n\n\n# 5、具体功能：删除\n\n# a>创建处理delete请求方式的表单\n\n\x3c!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\x3e\n<form id="delete_form" method="post">\n    \x3c!-- hiddenhttpmethodfilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\x3e\n    <input type="hidden" name="_method" value="delete"/>\n</form>\n\n\n# b>删除超链接绑定点击事件\n\n引入vue.js\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n\n\n删除超链接\n\n<a class="deletea" @click="deleteemployee" th:href="@{\'/employee/\'+${employee.id}}">delete</a>\n\n\n通过vue处理点击事件\n\n<script type="text/javascript">\n    var vue = new vue({\n        el:"#datatable",\n        methods:{\n            //event表示当前事件\n            deleteemployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getelementbyid("delete_form");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventdefault();\n            }\n        }\n    });\n<\/script>\n\n\n# c> 开放静态资源访问\n\n<mvc:default-servlet-handler />\n\n\nspringmvc先处理请求，能处理就会被处理，不能处理就会交给今天的servelet处理，servelet能处理就处理，不能处理默认的servelet报错\n\n# d>控制器方法\n\n@requestmapping(value = "/employee/{id}", method = requestmethod.delete)\npublic string deleteemployee(@pathvariable("id") integer id){\n    employeedao.delete(id);\n    return "redirect:/employee";\n}\n\n\n\n# 6、具体功能：跳转到添加数据页面\n\n# a>配置view-controller\n\n<mvc:view-controller path="/toadd" view-name="employee_add"></mvc:view-controller>\n\n\n# b>创建employee_add.html\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>add employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    lastname:<input type="text" name="lastname"><br>\n    email:<input type="text" name="email"><br>\n    gender:<input type="radio" name="gender" value="1">male\n    <input type="radio" name="gender" value="0">female<br>\n    <input type="submit" value="add"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 7、具体功能：执行保存\n\n# a>控制器方法\n\n@requestmapping(value = "/employee", method = requestmethod.post)\npublic string addemployee(employee employee){\n    employeedao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 8、具体功能：跳转到更新数据页面\n\n# a>修改超链接\n\n<a th:href="@{\'/employee/\'+${employee.id}}">update</a>\n\n\n# b>控制器方法\n\n@requestmapping(value = "/employee/{id}", method = requestmethod.get)\npublic string getemployeebyid(@pathvariable("id") integer id, model model){\n    employee employee = employeedao.get(id);\n    model.addattribute("employee", employee);\n    return "employee_update";\n}\n\n\n# c>创建employee_update.html\n\n<!doctype html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="utf-8">\n    <title>update employee</title>\n</head>\n<body>\n\n<form th:action="@{/employee}" method="post">\n    <input type="hidden" name="_method" value="put">\n    <input type="hidden" name="id" th:value="${employee.id}">\n    lastname:<input type="text" name="lastname" th:value="${employee.lastname}"><br>\n    email:<input type="text" name="email" th:value="${employee.email}"><br>\n    \x3c!--\n        th:field="${employee.gender}"可用于单选框或复选框的回显\n        若单选框的value和employee.gender的值一致，则添加checked="checked"属性\n    --\x3e\n    gender:<input type="radio" name="gender" value="1" th:field="${employee.gender}">male\n    <input type="radio" name="gender" value="0" th:field="${employee.gender}">female<br>\n    <input type="submit" value="update"><br>\n</form>\n\n</body>\n</html>\n\n\n\n# 9、具体功能：执行更新\n\n# a>控制器方法\n\n@requestmapping(value = "/employee", method = requestmethod.put)\npublic string updateemployee(employee employee){\n    employeedao.save(employee);\n    return "redirect:/employee";\n}\n\n\n\n# 八、httpmessageconverter\n\nhttpmessageconverter，报文信息转换器，将请求报文转换为java对象（浏览器请求服务器），或将java对象转换为响应报文（服务器相应浏览器）\n\nhttpmessageconverter提供了两个注解和两个类型：@requestbody，@responsebody，requestentity，\n\nresponseentity\n\n\n# 1、@requestbody\n\n@requestbody可以获取请求体，需要在控制器方法设置一个形参，使用@requestbody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\n<form th:action="@{/testrequestbody}" method="post">\n    用户名：<input type="text" name="username"><br>\n    密码：<input type="password" name="password"><br>\n    <input type="submit">\n</form>\n\n\n@requestmapping("/testrequestbody")\npublic string testrequestbody(@requestbody string requestbody){\n    system.out.println("requestbody:"+requestbody);\n    return "success";\n}\n\n\n输出结果：\n\nrequestbody:username=admin&password=123456\n\n\n# 2、requestentity\n\nrequestentity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getheaders()获取请求头信息，通过getbody()获取请求体信息\n\n@requestmapping("/testrequestentity")\npublic string testrequestentity(requestentity<string> requestentity){\n    system.out.println("requestheader:"+requestentity.getheaders());\n    system.out.println("requestbody:"+requestentity.getbody());\n    return "success";\n}\n\n\n输出结果： requestheader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" not a;brand";v="99", "chromium";v="90", "google chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"http://localhost:8080", user-agent:"mozilla/5.0 (windows nt 10.0; win64; x64) applewebkit/537.36 (khtml, like gecko) chrome/90.0.4430.93 safari/537.36"] requestbody:username=admin&password=123\n\n\n# 3、@responsebody（用的最多）\n\n@responsebody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n\n@requestmapping("/testresponsebody")\n@responsebody\npublic string testresponsebody(){\n    return "success";\n}\n\n\n也就是加上responsebody直接返回字符串，不加则会拼接"前缀+返回字符串+后缀"并打开新页面进行展示信息\n\n结果：浏览器页面显示success\n\n这里要学习一下javaweb中的httpservletresponse对于浏览器数据的响应\n\n\n# 4、springmvc处理json\n\n@responsebody处理json的步骤：\n\na>导入jackson的依赖\n\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>2.12.1</version>\n</dependency>\n\n\nb>在springmvc的核心配置文件中开启mvc的注解驱动，此时在handleradaptor中会自动装配一个消息转换器：mappingjackson2httpmessageconverter，可以将响应到浏览器的java对象转换为json格式的字符串\n\n<mvc:annotation-driven />\n\n\nc>在处理器方法上使用@responsebody注解进行标识\n\nd>将java对象直接作为控制器方法的返回值返回，就会自动转换为json格式的字符串\n\n@requestmapping("/testresponseuser")\n@responsebody\npublic user testresponseuser(){\n    return new user(1001,"admin","123456",23,"男");\n}\n\n\n浏览器的页面中展示的结果：\n\n{"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}\n\n\n# 5、springmvc处理ajax\n\na>请求超链接：\n\n<div id="app">\n\t<a th:href="@{/testajax}" @click="testajax">testajax</a><br>\n</div>\n\n\nb>通过vue和axios处理点击事件：\n\n<script type="text/javascript" th:src="@{/static/js/vue.js}"><\/script>\n<script type="text/javascript" th:src="@{/static/js/axios.min.js}"><\/script>\n<script type="text/javascript">\n    var vue = new vue({\n        el:"#app",\n        methods:{\n            testajax:function (event) {\n                axios({\n                    method:"post",\n                    url:event.target.href,\n                    params:{\n                        username:"admin",\n                        password:"123456"\n                    }\n                }).then(function (response) {\n                    alert(response.data);\n                });\n                event.preventdefault();\n            }\n        }\n    });\n<\/script>\n\n\nc>控制器方法：\n\n@requestmapping("/testajax")\n@responsebody\npublic string testajax(string username, string password){\n    system.out.println("username:"+username+",password:"+password);\n    return "hello,ajax";\n}\n\n\n\n# 6、@restcontroller注解\n\n@restcontroller注解是springmvc提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@controller注解，并且为其中的每个方法添加了@responsebody注解\n\n\n# 7、responseentity\n\nresponseentity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n\n\n# 九、文件上传和下载\n\n\n# 1、文件下载\n\n使用responseentity实现下载文件的功能\n\n@requestmapping("/testdown")\npublic responseentity<byte[]> testresponseentity(httpsession session) throws ioexception {\n    //获取servletcontext对象\n    servletcontext servletcontext = session.getservletcontext();\n    //获取服务器中文件的真实路径\n    string realpath = servletcontext.getrealpath("/static/https://cdn.jsdelivr.net/gh/leejiayang/blogimages@main/springmvc/1.jpg");\n    //创建输入流\n    inputstream is = new fileinputstream(realpath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建httpheaders对象设置响应头信息\n    multivaluemap<string, string> headers = new httpheaders();\n    //设置要下载方式以及下载文件的名字\n    headers.add("content-disposition", "attachment;filename=1.jpg");\n    //设置响应状态码\n    httpstatus statuscode = httpstatus.ok;\n    //创建responseentity对象\n    responseentity<byte[]> responseentity = new responseentity<>(bytes, headers, statuscode);\n    //关闭输入流\n    is.close();\n    return responseentity;\n}\n\n\n\n# 2、文件上传\n\n文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"\n\nspringmvc中将上传的文件封装到multipartfile对象中，通过此对象可以获取文件相关信息\n\n上传步骤：\n\na>添加依赖：\n\n\x3c!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\x3e\n<dependency>\n    <groupid>commons-fileupload</groupid>\n    <artifactid>commons-fileupload</artifactid>\n    <version>1.3.1</version>\n</dependency>\n\n\nb>在springmvc的配置文件中添加配置：\n\n\x3c!--必须通过文件解析器的解析才能将文件转换为multipartfile对象--\x3e\n<bean id="multipartresolver" class="org.springframework.web.multipart.commons.commonsmultipartresolver"></bean>\n\n\nc>控制器方法：\n\n@requestmapping("/testup")\npublic string testup(multipartfile photo, httpsession session) throws ioexception {\n    //获取上传的文件的文件名\n    string filename = photo.getoriginalfilename();\n    //处理文件重名问题\n    // 获取后缀名\n    string hzname = filename.substring(filename.lastindexof("."));\n    // 将uuid和后缀名拼接真正的文件名\n    filename = uuid.randomuuid().tostring() + hzname;\n    //获取服务器中photo目录的路径\n    servletcontext servletcontext = session.getservletcontext();\n    string photopath = servletcontext.getrealpath("photo");\n    file file = new file(photopath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    string finalpath = photopath + file.separator + filename;\n    //实现上传功能\n    photo.transferto(new file(finalpath));\n    return "success";\n}\n\n\n\n# 十、拦截器\n\n\n# 1、拦截器的配置\n\nspringmvc中的拦截器用于拦截控制器方法的执行\n\nspringmvc中的拦截器需要实现handlerinterceptor或者handlerinterceptoradapter(已过时)，重写下面的三个方法\n\n事实上是handlerinterceptoradapter继承了asynchandlerinterceptor, asynchandlerinterceptor又继承了handlerinterceptor\n\nspringmvc的拦截器必须在springmvc的配置文件中进行配置：\n\n最简单的配置方法（第一种配置方法） 表示一个对象\n\n图片里面的设置也会被拦截，因为本质上这个也是控制器方法\n\n\n\n\n\n第二种配置方法\n<mvc:interceptor>\n\x3c!-- <bean class="com.atguigu.interceptor.firstinterceptor"></bean> --\x3e\n<ref bean="firstinterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- 以上两种配置方式都是对dispatcherservlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n\x3c!-- 拦截所有请求 --\x3e\n\x3c!-- 这里的/*表示访问该页面的上下一层目录 --\x3e\n<mvc:mapping path="/*"/>\n    <mvc:mapping path="/**"/>\n    \x3c!-- 排除不拦截的特殊情况 --\x3e\n    <mvc:exclude-mapping path="/testrequestentity"/>\n    \x3c!-- 指定拦截 器 --\x3e\n    <ref bean="firstinterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n\t以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n\n# 2、拦截器的三个抽象方法\n\n过滤器的拦截器的区别是什么？？ springmvc中的拦截器有三个抽象方法：\n\nprehandle：控制器方法执行之前执行prehandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\n\nposthandle：控制器方法执行之后执行posthandle()\n\naftercomplation：处理完视图和模型数据，渲染视图完毕之后执行aftercomplation()\n\n\n# 3、多个拦截器的执行顺序\n\na>若每个拦截器的prehandle()都返回true\n\n此时多个拦截器的执行顺序和拦截器在springmvc的配置文件的配置顺序有关：\n\nprehandle()会按照配置的顺序执行，而posthandle()和aftercomplation()会按照配置的反序执行\n\nb>若某个拦截器的prehandle()返回了false\n\nprehandle()返回false和它之前的拦截器的prehandle()都会执行，posthandle()都不执行，返回false的拦截器之前的拦截器的aftercomplation()会执行\n\n\n# 十一、异常处理器(出现异常跳转指定页面)\n\n\n# 1、基于配置的异常处理\n\nspringmvc提供了一个处理控制器方法执行过程中所出现的异常的接口：handlerexceptionresolver\n\nhandlerexceptionresolver接口的实现类有：defaulthandlerexceptionresolver和simplemappingexceptionresolver\n\nspringmvc提供了自定义的异常处理器simplemappingexceptionresolver，使用方式：\n\n<bean class="org.springframework.web.servlet.handler.simplemappingexceptionresolver">\n    <property name="exceptionmappings">\n        <props>\n        \t\x3c!--\n        \t\tproperties的键表示处理器方法执行过程中出现的异常\n        \t\tproperties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面,themeleaf进行解析，和之前 的解析规则一致\n        \t--\x3e\n            <prop key="java.lang.arithmeticexception">error</prop>\n        </props>\n    </property>\n    \x3c!--\n    \texceptionattribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n\n\n    <property name="exceptionattribute" value="ex"></property>\n</bean>\n\n\n\n# 2、基于注解的异常处理\n\n//@controlleradvice将当前类标识为异常处理的组件\n@controlleradvice\npublic class exceptioncontroller {\n\n    //@exceptionhandler用于设置所标识方法处理的异常\n    @exceptionhandler(value = arithmeticexception.class, nullpointerexception.class)\n    //ex表示当前请求处理中出现的异常对象\n    public string handlearithmeticexception(exception ex, model model){\n        model.addattribute("ex", ex);\n        return "error";\n    }\n\n}\n\n\n\n# 十二、注解配置springmvc\n\n使用配置类和注解代替web.xml和springmvc配置文件的功能\n\n\n# 1、创建初始化类，代替web.xml\n\n在servlet3.0环境中，容器会在类路径中查找实现javax.servlet.servletcontainerinitializer接口的类，如果找到的话就用它来配置servlet容器。\n\nspring提供了这个接口的实现，名为springservletcontainerinitializer，这个类反过来又会查找实现webapplicationinitializer的类并将配置的任务交给它们来完成。\n\nspring3.2引入了一个便利的webapplicationinitializer基础实现，名为abstractannotationconfigdispatcherservletinitializer，当我们的类扩展了abstractannotationconfigdispatcherservletinitializer并将其部署到servlet3.0容器的时候，容器会自动发现它，并用它来配置servlet上下文。\n\npublic class webinit extends abstractannotationconfigdispatcherservletinitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getrootconfigclasses() {\n        return new class[]{springconfig.class};\n    }\n\n    /**\n     * 指定springmvc的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getservletconfigclasses() {\n        // 返回class数组\n        return new class[]{webconfig.class};\n    }\n\n    /**\n     * 指定dispatcherservlet的映射规则(映射规则)，即url-pattern\n     * @return\n     */\n    @override\n    protected string[] getservletmappings() {\n        return new string[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @override\n    protected filter[] getservletfilters() {\n        characterencodingfilter encodingfilter = new characterencodingfilter();\n        encodingfilter.setencoding("utf-8");\n        encodingfilter.setforcerequestencoding(true);\n        hiddenhttpmethodfilter hiddenhttpmethodfilter = new hiddenhttpmethodfilter();\n        return new filter[]{encodingfilter, hiddenhttpmethodfilter};\n    }\n}\n\n\n\n# 2、创建springconfig配置类，代替spring的配置文件\n\n@configuration\npublic class springconfig {\n\t//ssm整合之后，spring的配置信息写在此类中\n}\n\n\n\n# 3、创建webconfig配置类，代替springmvc的配置文件\n\n\n// 扫描组件\n// 视图解析器\n// viewcontroller\n// default-servlet-handler\n// mvc注解驱动\n// 文件上传解析器\n// 异常处理\n// 拦截器\n\n@configuration\n//扫描组件\n@componentscan("com.atguigu.mvc.controller")\n//开启mvc注解驱动\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    //使用默认的servlet处理静态资源\n    @override\n    public void configuredefaultservlethandling(defaultservlethandlerconfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @bean\n    public commonsmultipartresolver multipartresolver(){\n        return new commonsmultipartresolver();\n    }\n\n    //配置拦截器\n    @override\n    public void addinterceptors(interceptorregistry registry) {\n        firstinterceptor firstinterceptor = new firstinterceptor();\n\n        //  addpathpatterns添加拦截规则\n        registry.addinterceptor(firstinterceptor).addpathpatterns("/**");\n    }\n    \n    //配置视图控制\n    \n    /*@override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        registry.addviewcontroller("/").setviewname("index");\n    }*/\n    \n    //配置异常映射\n    /*@override\n    public void configurehandlerexceptionresolvers(list<handlerexceptionresolver> resolvers) {\n        simplemappingexceptionresolver exceptionresolver = new simplemappingexceptionresolver();\n        properties prop = new properties();\n        prop.setproperty("java.lang.arithmeticexception", "error");\n        //设置异常映射\n        exceptionresolver.setexceptionmappings(prop);\n        //设置共享异常信息的键\n        exceptionresolver.setexceptionattribute("ex");\n        resolvers.add(exceptionresolver);\n    }*/\n\n    // 注意：xml视图解析器要从里到外配置\n    //配置生成模板解析器\n    @bean\n    public itemplateresolver templateresolver() {\n        webapplicationcontext webapplicationcontext = contextloader.getcurrentwebapplicationcontext();\n        // servletcontexttemplateresolver需要一个servletcontext作为构造参数，可通过webapplicationcontext 的方法获得\n        servletcontexttemplateresolver templateresolver = new servletcontexttemplateresolver(\n                webapplicationcontext.getservletcontext());\n\n        // 视图前缀\n        templateresolver.setprefix("/web-inf/templates/");\n        // 视图后缀\n        templateresolver.setsuffix(".html");\n        templateresolver.setcharacterencoding("utf-8");\n        templateresolver.settemplatemode(templatemode.html);\n        return templateresolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @bean\n    public springtemplateengine templateengine(itemplateresolver templateresolver) {\n        springtemplateengine templateengine = new springtemplateengine();\n        templateengine.settemplateresolver(templateresolver);\n        return templateengine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @bean\n    public viewresolver viewresolver(springtemplateengine templateengine) {\n        thymeleafviewresolver viewresolver = new thymeleafviewresolver();\n        viewresolver.setcharacterencoding("utf-8");\n        viewresolver.settemplateengine(templateengine);\n        return viewresolver;\n    }\n\n\n}\n\n\n\n# 4、测试功能\n\n@requestmapping("/")\npublic string index(){\n    return "index";\n}\n\n\n\n# 十三、springmvc执行流程\n\n\n# 1、springmvc常用组件\n\n * dispatcherservlet：前端控制器，不需要工程师开发，由框架提供\n\n作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\n * handlermapping：处理器映射器，不需要工程师开发，由框架提供\n\n作用：根据请求的url、method等信息查找handler，即控制器方法\n\n * handler：处理器，需要工程师开发\n\n作用：在dispatcherservlet的控制下handler对具体的用户请求进行处理\n\n * handleradapter：处理器适配器，不需要工程师开发，由框架提供\n\n作用：通过handleradapter对处理器（控制器方法）进行执行\n\n * viewresolver：视图解析器，不需要工程师开发，由框架提供（页面需要自己写）\n\n作用：进行视图解析，得到相应的视图，例如：thymeleafview、internalresourceview、redirectview\n\n * view：视图，不需要工程师开发，由框架或者视图技术提供\n\n作用：将模型数据通过页面展示给用户\n\n\n\n\n# 2、dispatcherservlet初始化过程\n\ndispatcherservlet 本质上是一个 servlet，所以天然的遵循 servlet 的生命周期。所以宏观上是 servlet 生命周期来进行调度。\n\n\n\n# a>初始化webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext initwebapplicationcontext() {\n    webapplicationcontext rootcontext =\n        webapplicationcontextutils.getwebapplicationcontext(getservletcontext());\n    webapplicationcontext wac = null;\n\n    if (this.webapplicationcontext != null) {\n        // a context instance was injected at construction time -> use it\n        wac = this.webapplicationcontext;\n        if (wac instanceof configurablewebapplicationcontext) {\n            configurablewebapplicationcontext cwac = (configurablewebapplicationcontext) wac;\n            if (!cwac.isactive()) {\n                // the context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getparent() == null) {\n                    // the context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setparent(rootcontext);\n                }\n                configureandrefreshwebapplicationcontext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // no context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. if one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findwebapplicationcontext();\n    }\n    if (wac == null) {\n        // no context instance is defined for this servlet -> create a local one\n        // 创建webapplicationcontext\n        wac = createwebapplicationcontext(rootcontext);\n    }\n\n    if (!this.refresheventreceived) {\n        // either the context is not a configurableapplicationcontext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onrefresh manually here.\n        synchronized (this.onrefreshmonitor) {\n            // 刷新webapplicationcontext\n            onrefresh(wac);\n        }\n    }\n\n    if (this.publishcontext) {\n        // publish the context as a servlet context attribute.\n        // 将ioc容器在应用域共享\n        string attrname = getservletcontextattributename();\n        getservletcontext().setattribute(attrname, wac);\n    }\n\n    return wac;\n}\n\n\n# b>创建webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext createwebapplicationcontext(@nullable applicationcontext parent) {\n    class<?> contextclass = getcontextclass();\n    if (!configurablewebapplicationcontext.class.isassignablefrom(contextclass)) {\n        throw new applicationcontextexception(\n            "fatal initialization error in servlet with name \'" + getservletname() +\n            "\': custom webapplicationcontext class [" + contextclass.getname() +\n            "] is not of type configurablewebapplicationcontext");\n    }\n    // 通过反射创建 ioc 容器对象\n    configurablewebapplicationcontext wac =\n        (configurablewebapplicationcontext) beanutils.instantiateclass(contextclass);\n\n    wac.setenvironment(getenvironment());\n    // 设置父容器\n    wac.setparent(parent);\n    string configlocation = getcontextconfiglocation();\n    if (configlocation != null) {\n        wac.setconfiglocation(configlocation);\n    }\n    configureandrefreshwebapplicationcontext(wac);\n\n    return wac;\n}\n\n\n# c>dispatcherservlet初始化策略\n\nframeworkservlet创建webapplicationcontext后，刷新容器，调用onrefresh(wac)，此方法在dispatcherservlet中进行了重写，调用了initstrategies(context)方法（包含自己需要初始化的方法），初始化策略，即初始化dispatcherservlet的各个组件\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void initstrategies(applicationcontext context) {\n   initmultipartresolver(context);\n   initlocaleresolver(context);\n   initthemeresolver(context);\n   inithandlermappings(context);\n   inithandleradapters(context);\n   inithandlerexceptionresolvers(context);\n   initrequesttoviewnametranslator(context);\n   initviewresolvers(context);\n   initflashmapmanager(context);\n}\n\n\n\n# 3、dispatcherservlet调用组件处理请求\n\n# a>processrequest()\n\nframeworkservlet重写httpservlet中的service()和doxxx()，这些方法中调用了processrequest(request, response)\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected final void processrequest(httpservletrequest request, httpservletresponse response)\n    throws servletexception, ioexception {\n\n    long starttime = system.currenttimemillis();\n    throwable failurecause = null;\n\n    localecontext previouslocalecontext = localecontextholder.getlocalecontext();\n    localecontext localecontext = buildlocalecontext(request);\n\n    requestattributes previousattributes = requestcontextholder.getrequestattributes();\n    servletrequestattributes requestattributes = buildrequestattributes(request, response, previousattributes);\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n    asyncmanager.registercallableinterceptor(frameworkservlet.class.getname(), new requestbindinginterceptor());\n\n    initcontextholders(request, localecontext, requestattributes);\n\n    try {\n\t\t// 执行服务，doservice()是一个抽象方法，在dispatcherservlet中进行了重写\n        doservice(request, response);\n    }\n    catch (servletexception | ioexception ex) {\n        failurecause = ex;\n        throw ex;\n    }\n    catch (throwable ex) {\n        failurecause = ex;\n        throw new nestedservletexception("request processing failed", ex);\n    }\n\n    finally {\n        resetcontextholders(request, previouslocalecontext, previousattributes);\n        if (requestattributes != null) {\n            requestattributes.requestcompleted();\n        }\n        logresult(request, response, failurecause, asyncmanager);\n        publishrequesthandledevent(request, response, starttime, failurecause);\n    }\n}\n\n\n# b>doservice()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\n@override\nprotected void doservice(httpservletrequest request, httpservletresponse response) throws exception {\n    logrequest(request);\n\n    // keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    map<string, object> attributessnapshot = null;\n    if (webutils.isincluderequest(request)) {\n        attributessnapshot = new hashmap<>();\n        enumeration<?> attrnames = request.getattributenames();\n        while (attrnames.hasmoreelements()) {\n            string attrname = (string) attrnames.nextelement();\n            if (this.cleanupafterinclude || attrname.startswith(default_strategies_prefix)) {\n                attributessnapshot.put(attrname, request.getattribute(attrname));\n            }\n        }\n    }\n\n    // make framework objects available to handlers and view objects.\n    request.setattribute(web_application_context_attribute, getwebapplicationcontext());\n    request.setattribute(locale_resolver_attribute, this.localeresolver);\n    request.setattribute(theme_resolver_attribute, this.themeresolver);\n    request.setattribute(theme_source_attribute, getthemesource());\n\n    if (this.flashmapmanager != null) {\n        flashmap inputflashmap = this.flashmapmanager.retrieveandupdate(request, response);\n        if (inputflashmap != null) {\n            request.setattribute(input_flash_map_attribute, collections.unmodifiablemap(inputflashmap));\n        }\n        request.setattribute(output_flash_map_attribute, new flashmap());\n        request.setattribute(flash_map_manager_attribute, this.flashmapmanager);\n    }\n\n    requestpath requestpath = null;\n    if (this.parserequestpath && !servletrequestpathutils.hasparsedrequestpath(request)) {\n        requestpath = servletrequestpathutils.parseandcache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        dodispatch(request, response);\n    }\n    finally {\n        if (!webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n            // restore the original attribute snapshot, in case of an include.\n            if (attributessnapshot != null) {\n                restoreattributesafterinclude(request, attributessnapshot);\n            }\n        }\n        if (requestpath != null) {\n            servletrequestpathutils.clearparsedrequestpath(request);\n        }\n    }\n}\n\n\n# c>dodispatch()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception {\n    httpservletrequest processedrequest = request;\n    handlerexecutionchain mappedhandler = null;\n    boolean multipartrequestparsed = false;\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n\n    try {\n        modelandview mv = null;\n        exception dispatchexception = null;\n\n        try {\n            processedrequest = checkmultipart(request);\n            multipartrequestparsed = (processedrequest != request);\n\n            // determine handler for the current request.\n            /*\n            \tmappedhandler：调用链\n                包含handler、interceptorlist、interceptorindex\n            \thandler：浏览器发送的请求所匹配的控制器方法\n            \tinterceptorlist：处理控制器方法的所有拦截器集合\n            \tinterceptorindex：拦截器索引，控制拦截器aftercompletion()的执行\n            */\n            mappedhandler = gethandler(processedrequest);\n            if (mappedhandler == null) {\n                nohandlerfound(processedrequest, response);\n                return;\n            }\n\n            // determine handler adapter for the current request.\n           \t// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            handleradapter ha = gethandleradapter(mappedhandler.gethandler());\n\n            // process last-modified header, if supported by the handler.\n            string method = request.getmethod();\n            boolean isget = "get".equals(method);\n            if (isget || "head".equals(method)) {\n                long lastmodified = ha.getlastmodified(request, mappedhandler.gethandler());\n                if (new servletwebrequest(request, response).checknotmodified(lastmodified) && isget) {\n                    return;\n                }\n            }\n\t\t\t\n            // 调用拦截器的prehandle()\n            if (!mappedhandler.applyprehandle(processedrequest, response)) {\n                return;\n            }\n\n            // actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得modelandview对象\n            mv = ha.handle(processedrequest, response, mappedhandler.gethandler());\n\n            if (asyncmanager.isconcurrenthandlingstarted()) {\n                return;\n            }\n\n            applydefaultviewname(processedrequest, mv);\n            // 调用拦截器的posthandle()\n            mappedhandler.applyposthandle(processedrequest, response, mv);\n        }\n        catch (exception ex) {\n            dispatchexception = ex;\n        }\n        catch (throwable err) {\n            // as of 4.3, we\'re processing errors thrown from handler methods as well,\n            // making them available for @exceptionhandler methods and other scenarios.\n            dispatchexception = new nestedservletexception("handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processdispatchresult(processedrequest, response, mappedhandler, mv, dispatchexception);\n    }\n    catch (exception ex) {\n        triggeraftercompletion(processedrequest, response, mappedhandler, ex);\n    }\n    catch (throwable err) {\n        triggeraftercompletion(processedrequest, response, mappedhandler,\n                               new nestedservletexception("handler processing failed", err));\n    }\n    finally {\n        if (asyncmanager.isconcurrenthandlingstarted()) {\n            // instead of posthandle and aftercompletion\n            if (mappedhandler != null) {\n                mappedhandler.applyafterconcurrenthandlingstarted(processedrequest, response);\n            }\n        }\n        else {\n            // clean up any resources used by a multipart request.\n            if (multipartrequestparsed) {\n                cleanupmultipart(processedrequest);\n            }\n        }\n    }\n}\n\n\n# d>processdispatchresult()\n\nprivate void processdispatchresult(httpservletrequest request, httpservletresponse response,\n                                   @nullable handlerexecutionchain mappedhandler, @nullable modelandview mv,\n                                   @nullable exception exception) throws exception {\n\n    boolean errorview = false;\n\n    if (exception != null) {\n        if (exception instanceof modelandviewdefiningexception) {\n            logger.debug("modelandviewdefiningexception encountered", exception);\n            mv = ((modelandviewdefiningexception) exception).getmodelandview();\n        }\n        else {\n            object handler = (mappedhandler != null ? mappedhandler.gethandler() : null);\n            mv = processhandlerexception(request, response, handler, exception);\n            errorview = (mv != null);\n        }\n    }\n\n    // did the handler return a view to render?\n    if (mv != null && !mv.wascleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorview) {\n            webutils.clearerrorrequestattributes(request);\n        }\n    }\n    else {\n        if (logger.istraceenabled()) {\n            logger.trace("no view rendering, null modelandview returned.");\n        }\n    }\n\n    if (webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n        // concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedhandler != null) {\n        // exception (if any) is already handled..\n        // 调用拦截器的aftercompletion()\n        mappedhandler.triggeraftercompletion(request, response, null);\n    }\n}\n\n\n\n# 4、springmvc的执行流程\n\n 1. 用户向服务器发送请求，请求被springmvc 前端控制器 dispatcherservlet捕获。\n\n 2. dispatcherservlet对请求url进行解析，得到请求资源标识符（uri），判断请求uri对应的映射：\n\na) 不存在\n\ni. 再判断是否配置了mvc:default-servlet-handler\n\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：js,css,html），找不到客户端也会展示404错误\n\n\n\n\n\nb) 存在则执行下面的流程\n\n 3. 根据该uri，调用handlermapping获得该handler配置的所有相关的对象（包括handler对象以及handler对象对应的拦截器），最后以handlerexecutionchain执行链对象的形式返回。\n\n 4. dispatcherservlet 根据获得的handler，选择一个合适的handleradapter。\n\n 5. 如果成功获得handleradapter，此时将开始执行拦截器的prehandler(…)方法【正向】\n\n 6. 提取request中的模型数据，填充handler入参，开始执行handler（controller)方法，处理请求。在填充handler的入参过程中，根据你的配置，spring将帮你做一些额外的工作：\n\na) httpmessageconveter： 将请求消息（如json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n\nb) 数据转换：对请求消息进行数据转换。如string转换成integer、double等\n\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中\n\n 7.  handler执行完成后，向dispatcherservlet 返回一个modelandview对象。\n\n 8.  此时将开始执行拦截器的posthandle(...)方法【逆向】。\n\n 9.  根据返回的modelandview（此时会判断是否存在异常：如果存在异常，则执行handlerexceptionresolver进行异常处理）选择一个适合的viewresolver进行视图解析，根据model和view，来渲染视图。\n\n 10. 渲染视图完毕执行拦截器的aftercompletion(…)方法【逆向】。\n\n 11. 将渲染结果返回给客户端。',charsets:{cjk:!0}},{title:"拦截器",frontmatter:{title:"拦截器",date:"2022-05-12T00:00:00.000Z",permalink:"/springmvc/010/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/10.%E6%8B%A6%E6%88%AA%E5%99%A8.html",relativePath:"07.框架/02.SpringMVC/10.拦截器.md",key:"v-1dace089",path:"/springmvc/010/",headers:[{level:3,title:"1、拦截器的配置",slug:"_1、拦截器的配置",normalizedTitle:"1、拦截器的配置",charIndex:12},{level:3,title:"2、拦截器的三个抽象方法",slug:"_2、拦截器的三个抽象方法",normalizedTitle:"2、拦截器的三个抽象方法",charIndex:915},{level:3,title:"3、多个拦截器的执行顺序",slug:"_3、多个拦截器的执行顺序",normalizedTitle:"3、多个拦截器的执行顺序",charIndex:1163}],headersStr:"1、拦截器的配置 2、拦截器的三个抽象方法 3、多个拦截器的执行顺序",content:'# 十、拦截器\n\n\n# 1、拦截器的配置\n\nSpringMVC中的拦截器用于拦截控制器方法的执行\n\nSpringMVC中的拦截器需要实现HandlerInterceptor或者HandlerInterceptorAdapter(已过时)，重写下面的三个方法\n\n事实上是HandlerInterceptorAdapter继承了ASyncHandlerInterceptor, AsyncHandlerInterceptor又继承了HandlerInterceptor\n\nSpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：\n\n最简单的配置方法（第一种配置方法） 表示一个对象\n\n图片里面的设置也会被拦截，因为本质上这个也是控制器方法\n\n\n\n\n\n第二种配置方法\n<mvc:interceptor>\n\x3c!-- <bean class="com.atguigu.interceptor.FirstInterceptor"></bean> --\x3e\n<ref bean="firstInterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n\x3c!-- 拦截所有请求 --\x3e\n\x3c!-- 这里的/*表示访问该页面的上下一层目录 --\x3e\n<mvc:mapping path="/*"/>\n    <mvc:mapping path="/**"/>\n    \x3c!-- 排除不拦截的特殊情况 --\x3e\n    <mvc:exclude-mapping path="/testRequestEntity"/>\n    \x3c!-- 指定拦截 器 --\x3e\n    <ref bean="firstInterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n\t以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n\n# 2、拦截器的三个抽象方法\n\n过滤器的拦截器的区别是什么？？ SpringMVC中的拦截器有三个抽象方法：\n\npreHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\n\npostHandle：控制器方法执行之后执行postHandle()\n\nafterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()\n\n\n# 3、多个拦截器的执行顺序\n\na>若每个拦截器的preHandle()都返回true\n\n此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：\n\npreHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行\n\nb>若某个拦截器的preHandle()返回了false\n\npreHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行',normalizedContent:'# 十、拦截器\n\n\n# 1、拦截器的配置\n\nspringmvc中的拦截器用于拦截控制器方法的执行\n\nspringmvc中的拦截器需要实现handlerinterceptor或者handlerinterceptoradapter(已过时)，重写下面的三个方法\n\n事实上是handlerinterceptoradapter继承了asynchandlerinterceptor, asynchandlerinterceptor又继承了handlerinterceptor\n\nspringmvc的拦截器必须在springmvc的配置文件中进行配置：\n\n最简单的配置方法（第一种配置方法） 表示一个对象\n\n图片里面的设置也会被拦截，因为本质上这个也是控制器方法\n\n\n\n\n\n第二种配置方法\n<mvc:interceptor>\n\x3c!-- <bean class="com.atguigu.interceptor.firstinterceptor"></bean> --\x3e\n<ref bean="firstinterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- 以上两种配置方式都是对dispatcherservlet所处理的所有的请求进行拦截 --\x3e\n<mvc:interceptor>\n\x3c!-- 拦截所有请求 --\x3e\n\x3c!-- 这里的/*表示访问该页面的上下一层目录 --\x3e\n<mvc:mapping path="/*"/>\n    <mvc:mapping path="/**"/>\n    \x3c!-- 排除不拦截的特殊情况 --\x3e\n    <mvc:exclude-mapping path="/testrequestentity"/>\n    \x3c!-- 指定拦截 器 --\x3e\n    <ref bean="firstinterceptor"></ref>\n</mvc:interceptor>\n\x3c!-- \n\t以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n--\x3e\n\n\n\n# 2、拦截器的三个抽象方法\n\n过滤器的拦截器的区别是什么？？ springmvc中的拦截器有三个抽象方法：\n\nprehandle：控制器方法执行之前执行prehandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\n\nposthandle：控制器方法执行之后执行posthandle()\n\naftercomplation：处理完视图和模型数据，渲染视图完毕之后执行aftercomplation()\n\n\n# 3、多个拦截器的执行顺序\n\na>若每个拦截器的prehandle()都返回true\n\n此时多个拦截器的执行顺序和拦截器在springmvc的配置文件的配置顺序有关：\n\nprehandle()会按照配置的顺序执行，而posthandle()和aftercomplation()会按照配置的反序执行\n\nb>若某个拦截器的prehandle()返回了false\n\nprehandle()返回false和它之前的拦截器的prehandle()都会执行，posthandle()都不执行，返回false的拦截器之前的拦截器的aftercomplation()会执行',charsets:{cjk:!0}},{title:"异常处理器",frontmatter:{title:"异常处理器",date:"2022-05-13T00:00:00.000Z",permalink:"/springmvc/011/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/11.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8.html",relativePath:"07.框架/02.SpringMVC/11.异常处理器.md",key:"v-53e6eb32",path:"/springmvc/011/",headers:[{level:3,title:"1、基于配置的异常处理",slug:"_1、基于配置的异常处理",normalizedTitle:"1、基于配置的异常处理",charIndex:27},{level:3,title:"2、基于注解的异常处理",slug:"_2、基于注解的异常处理",normalizedTitle:"2、基于注解的异常处理",charIndex:790}],headersStr:"1、基于配置的异常处理 2、基于注解的异常处理",content:'# 十一、异常处理器(出现异常跳转指定页面)\n\n\n# 1、基于配置的异常处理\n\nSpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver\n\nHandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver\n\nSpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：\n\n<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">\n    <property name="exceptionMappings">\n        <props>\n        \t\x3c!--\n        \t\tproperties的键表示处理器方法执行过程中出现的异常\n        \t\tproperties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面,themeleaf进行解析，和之前 的解析规则一致\n        \t--\x3e\n            <prop key="java.lang.ArithmeticException">error</prop>\n        </props>\n    </property>\n    \x3c!--\n    \texceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n\n\n    <property name="exceptionAttribute" value="ex"></property>\n</bean>\n\n\n\n# 2、基于注解的异常处理\n\n//@ControllerAdvice将当前类标识为异常处理的组件\n@ControllerAdvice\npublic class ExceptionController {\n\n    //@ExceptionHandler用于设置所标识方法处理的异常\n    @ExceptionHandler(value = ArithmeticException.class, NullPointerException.class)\n    //ex表示当前请求处理中出现的异常对象\n    public String handleArithmeticException(Exception ex, Model model){\n        model.addAttribute("ex", ex);\n        return "error";\n    }\n\n}\n',normalizedContent:'# 十一、异常处理器(出现异常跳转指定页面)\n\n\n# 1、基于配置的异常处理\n\nspringmvc提供了一个处理控制器方法执行过程中所出现的异常的接口：handlerexceptionresolver\n\nhandlerexceptionresolver接口的实现类有：defaulthandlerexceptionresolver和simplemappingexceptionresolver\n\nspringmvc提供了自定义的异常处理器simplemappingexceptionresolver，使用方式：\n\n<bean class="org.springframework.web.servlet.handler.simplemappingexceptionresolver">\n    <property name="exceptionmappings">\n        <props>\n        \t\x3c!--\n        \t\tproperties的键表示处理器方法执行过程中出现的异常\n        \t\tproperties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面,themeleaf进行解析，和之前 的解析规则一致\n        \t--\x3e\n            <prop key="java.lang.arithmeticexception">error</prop>\n        </props>\n    </property>\n    \x3c!--\n    \texceptionattribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --\x3e\n\n\n    <property name="exceptionattribute" value="ex"></property>\n</bean>\n\n\n\n# 2、基于注解的异常处理\n\n//@controlleradvice将当前类标识为异常处理的组件\n@controlleradvice\npublic class exceptioncontroller {\n\n    //@exceptionhandler用于设置所标识方法处理的异常\n    @exceptionhandler(value = arithmeticexception.class, nullpointerexception.class)\n    //ex表示当前请求处理中出现的异常对象\n    public string handlearithmeticexception(exception ex, model model){\n        model.addattribute("ex", ex);\n        return "error";\n    }\n\n}\n',charsets:{cjk:!0}},{title:"注解配置SpringMVC",frontmatter:{title:"注解配置SpringMVC",date:"2022-05-14T00:00:00.000Z",permalink:"/springmvc/012/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/12.%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AESpringMVC.html",relativePath:"07.框架/02.SpringMVC/12.注解配置SpringMVC.md",key:"v-23d15f89",path:"/springmvc/012/",headers:[{level:3,title:"1、创建初始化类，代替web.xml",slug:"_1、创建初始化类-代替web-xml",normalizedTitle:"1、创建初始化类，代替web.xml",charIndex:59},{level:3,title:"2、创建SpringConfig配置类，代替spring的配置文件",slug:"_2、创建springconfig配置类-代替spring的配置文件",normalizedTitle:"2、创建springconfig配置类，代替spring的配置文件",charIndex:1579},{level:3,title:"3、创建WebConfig配置类，代替SpringMVC的配置文件",slug:"_3、创建webconfig配置类-代替springmvc的配置文件",normalizedTitle:"3、创建webconfig配置类，代替springmvc的配置文件",charIndex:1692},{level:3,title:"4、测试功能",slug:"_4、测试功能",normalizedTitle:"4、测试功能",charIndex:4651}],headersStr:"1、创建初始化类，代替web.xml 2、创建SpringConfig配置类，代替spring的配置文件 3、创建WebConfig配置类，代替SpringMVC的配置文件 4、测试功能",content:'# 十二、注解配置SpringMVC\n\n使用配置类和注解代替web.xml和SpringMVC配置文件的功能\n\n\n# 1、创建初始化类，代替web.xml\n\n在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。\n\nSpring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。\n\nSpring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。\n\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[]{SpringConfig.class};\n    }\n\n    /**\n     * 指定SpringMVC的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        // 返回class数组\n        return new Class[]{WebConfig.class};\n    }\n\n    /**\n     * 指定DispatcherServlet的映射规则(映射规则)，即url-pattern\n     * @return\n     */\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @Override\n    protected Filter[] getServletFilters() {\n        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();\n        encodingFilter.setEncoding("UTF-8");\n        encodingFilter.setForceRequestEncoding(true);\n        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};\n    }\n}\n\n\n\n# 2、创建SpringConfig配置类，代替spring的配置文件\n\n@Configuration\npublic class SpringConfig {\n\t//ssm整合之后，spring的配置信息写在此类中\n}\n\n\n\n# 3、创建WebConfig配置类，代替SpringMVC的配置文件\n\n\n// 扫描组件\n// 视图解析器\n// viewcontroller\n// default-servlet-handler\n// MVC注解驱动\n// 文件上传解析器\n// 异常处理\n// 拦截器\n\n@Configuration\n//扫描组件\n@ComponentScan("com.atguigu.mvc.controller")\n//开启MVC注解驱动\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    //使用默认的servlet处理静态资源\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @Bean\n    public CommonsMultipartResolver multipartResolver(){\n        return new CommonsMultipartResolver();\n    }\n\n    //配置拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        FirstInterceptor firstInterceptor = new FirstInterceptor();\n\n        //  addPathPatterns添加拦截规则\n        registry.addInterceptor(firstInterceptor).addPathPatterns("/**");\n    }\n    \n    //配置视图控制\n    \n    /*@Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/").setViewName("index");\n    }*/\n    \n    //配置异常映射\n    /*@Override\n    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.setProperty("java.lang.ArithmeticException", "error");\n        //设置异常映射\n        exceptionResolver.setExceptionMappings(prop);\n        //设置共享异常信息的键\n        exceptionResolver.setExceptionAttribute("ex");\n        resolvers.add(exceptionResolver);\n    }*/\n\n    // 注意：xml视图解析器要从里到外配置\n    //配置生成模板解析器\n    @Bean\n    public ITemplateResolver templateResolver() {\n        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得\n        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(\n                webApplicationContext.getServletContext());\n\n        // 视图前缀\n        templateResolver.setPrefix("/WEB-INF/templates/");\n        // 视图后缀\n        templateResolver.setSuffix(".html");\n        templateResolver.setCharacterEncoding("UTF-8");\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        return templateResolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setCharacterEncoding("UTF-8");\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    }\n\n\n}\n\n\n\n# 4、测试功能\n\n@RequestMapping("/")\npublic String index(){\n    return "index";\n}\n',normalizedContent:'# 十二、注解配置springmvc\n\n使用配置类和注解代替web.xml和springmvc配置文件的功能\n\n\n# 1、创建初始化类，代替web.xml\n\n在servlet3.0环境中，容器会在类路径中查找实现javax.servlet.servletcontainerinitializer接口的类，如果找到的话就用它来配置servlet容器。\n\nspring提供了这个接口的实现，名为springservletcontainerinitializer，这个类反过来又会查找实现webapplicationinitializer的类并将配置的任务交给它们来完成。\n\nspring3.2引入了一个便利的webapplicationinitializer基础实现，名为abstractannotationconfigdispatcherservletinitializer，当我们的类扩展了abstractannotationconfigdispatcherservletinitializer并将其部署到servlet3.0容器的时候，容器会自动发现它，并用它来配置servlet上下文。\n\npublic class webinit extends abstractannotationconfigdispatcherservletinitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getrootconfigclasses() {\n        return new class[]{springconfig.class};\n    }\n\n    /**\n     * 指定springmvc的配置类\n     * @return\n     */\n    @override\n    protected class<?>[] getservletconfigclasses() {\n        // 返回class数组\n        return new class[]{webconfig.class};\n    }\n\n    /**\n     * 指定dispatcherservlet的映射规则(映射规则)，即url-pattern\n     * @return\n     */\n    @override\n    protected string[] getservletmappings() {\n        return new string[]{"/"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @override\n    protected filter[] getservletfilters() {\n        characterencodingfilter encodingfilter = new characterencodingfilter();\n        encodingfilter.setencoding("utf-8");\n        encodingfilter.setforcerequestencoding(true);\n        hiddenhttpmethodfilter hiddenhttpmethodfilter = new hiddenhttpmethodfilter();\n        return new filter[]{encodingfilter, hiddenhttpmethodfilter};\n    }\n}\n\n\n\n# 2、创建springconfig配置类，代替spring的配置文件\n\n@configuration\npublic class springconfig {\n\t//ssm整合之后，spring的配置信息写在此类中\n}\n\n\n\n# 3、创建webconfig配置类，代替springmvc的配置文件\n\n\n// 扫描组件\n// 视图解析器\n// viewcontroller\n// default-servlet-handler\n// mvc注解驱动\n// 文件上传解析器\n// 异常处理\n// 拦截器\n\n@configuration\n//扫描组件\n@componentscan("com.atguigu.mvc.controller")\n//开启mvc注解驱动\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    //使用默认的servlet处理静态资源\n    @override\n    public void configuredefaultservlethandling(defaultservlethandlerconfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @bean\n    public commonsmultipartresolver multipartresolver(){\n        return new commonsmultipartresolver();\n    }\n\n    //配置拦截器\n    @override\n    public void addinterceptors(interceptorregistry registry) {\n        firstinterceptor firstinterceptor = new firstinterceptor();\n\n        //  addpathpatterns添加拦截规则\n        registry.addinterceptor(firstinterceptor).addpathpatterns("/**");\n    }\n    \n    //配置视图控制\n    \n    /*@override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        registry.addviewcontroller("/").setviewname("index");\n    }*/\n    \n    //配置异常映射\n    /*@override\n    public void configurehandlerexceptionresolvers(list<handlerexceptionresolver> resolvers) {\n        simplemappingexceptionresolver exceptionresolver = new simplemappingexceptionresolver();\n        properties prop = new properties();\n        prop.setproperty("java.lang.arithmeticexception", "error");\n        //设置异常映射\n        exceptionresolver.setexceptionmappings(prop);\n        //设置共享异常信息的键\n        exceptionresolver.setexceptionattribute("ex");\n        resolvers.add(exceptionresolver);\n    }*/\n\n    // 注意：xml视图解析器要从里到外配置\n    //配置生成模板解析器\n    @bean\n    public itemplateresolver templateresolver() {\n        webapplicationcontext webapplicationcontext = contextloader.getcurrentwebapplicationcontext();\n        // servletcontexttemplateresolver需要一个servletcontext作为构造参数，可通过webapplicationcontext 的方法获得\n        servletcontexttemplateresolver templateresolver = new servletcontexttemplateresolver(\n                webapplicationcontext.getservletcontext());\n\n        // 视图前缀\n        templateresolver.setprefix("/web-inf/templates/");\n        // 视图后缀\n        templateresolver.setsuffix(".html");\n        templateresolver.setcharacterencoding("utf-8");\n        templateresolver.settemplatemode(templatemode.html);\n        return templateresolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @bean\n    public springtemplateengine templateengine(itemplateresolver templateresolver) {\n        springtemplateengine templateengine = new springtemplateengine();\n        templateengine.settemplateresolver(templateresolver);\n        return templateengine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @bean\n    public viewresolver viewresolver(springtemplateengine templateengine) {\n        thymeleafviewresolver viewresolver = new thymeleafviewresolver();\n        viewresolver.setcharacterencoding("utf-8");\n        viewresolver.settemplateengine(templateengine);\n        return viewresolver;\n    }\n\n\n}\n\n\n\n# 4、测试功能\n\n@requestmapping("/")\npublic string index(){\n    return "index";\n}\n',charsets:{cjk:!0}},{title:"SpringMVC执行流程",frontmatter:{title:"SpringMVC执行流程",date:"2022-05-16T00:00:00.000Z",permalink:"/springmvc/013/",categories:["框架","SpringMVC"],tags:["SpringMVC"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/02.SpringMVC/13.SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.html",relativePath:"07.框架/02.SpringMVC/13.SpringMVC执行流程.md",key:"v-3968b695",path:"/springmvc/013/",headers:[{level:3,title:"1、SpringMVC常用组件",slug:"_1、springmvc常用组件",normalizedTitle:"1、springmvc常用组件",charIndex:23},{level:3,title:"2、DispatcherServlet初始化过程",slug:"_2、dispatcherservlet初始化过程",normalizedTitle:"2、dispatcherservlet初始化过程",charIndex:524},{level:5,title:"a>初始化WebApplicationContext",slug:"a-初始化webapplicationcontext",normalizedTitle:"a&gt;初始化webapplicationcontext",charIndex:null},{level:5,title:"b>创建WebApplicationContext",slug:"b-创建webapplicationcontext",normalizedTitle:"b&gt;创建webapplicationcontext",charIndex:null},{level:5,title:"c>DispatcherServlet初始化策略",slug:"c-dispatcherservlet初始化策略",normalizedTitle:"c&gt;dispatcherservlet初始化策略",charIndex:null},{level:3,title:"3、DispatcherServlet调用组件处理请求",slug:"_3、dispatcherservlet调用组件处理请求",normalizedTitle:"3、dispatcherservlet调用组件处理请求",charIndex:4796},{level:5,title:"a>processRequest()",slug:"a-processrequest",normalizedTitle:"a&gt;processrequest()",charIndex:null},{level:5,title:"b>doService()",slug:"b-doservice",normalizedTitle:"b&gt;doservice()",charIndex:null},{level:5,title:"c>doDispatch()",slug:"c-dodispatch",normalizedTitle:"c&gt;dodispatch()",charIndex:null},{level:5,title:"d>processDispatchResult()",slug:"d-processdispatchresult",normalizedTitle:"d&gt;processdispatchresult()",charIndex:null},{level:3,title:"4、SpringMVC的执行流程",slug:"_4、springmvc的执行流程",normalizedTitle:"4、springmvc的执行流程",charIndex:14309}],headersStr:"1、SpringMVC常用组件 2、DispatcherServlet初始化过程 a>初始化WebApplicationContext b>创建WebApplicationContext c>DispatcherServlet初始化策略 3、DispatcherServlet调用组件处理请求 a>processRequest() b>doService() c>doDispatch() d>processDispatchResult() 4、SpringMVC的执行流程",content:'# 十三、SpringMVC执行流程\n\n\n# 1、SpringMVC常用组件\n\n * DispatcherServlet：前端控制器，不需要工程师开发，由框架提供\n\n作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\n * HandlerMapping：处理器映射器，不需要工程师开发，由框架提供\n\n作用：根据请求的url、method等信息查找Handler，即控制器方法\n\n * Handler：处理器，需要工程师开发\n\n作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n\n * HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供\n\n作用：通过HandlerAdapter对处理器（控制器方法）进行执行\n\n * ViewResolver：视图解析器，不需要工程师开发，由框架提供（页面需要自己写）\n\n作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView\n\n * View：视图，不需要工程师开发，由框架或者视图技术提供\n\n作用：将模型数据通过页面展示给用户\n\n\n\n\n# 2、DispatcherServlet初始化过程\n\nDispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\n\n\n\n# a>初始化WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext initWebApplicationContext() {\n    WebApplicationContext rootContext =\n        WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n\n    if (this.webApplicationContext != null) {\n        // A context instance was injected at construction time -> use it\n        wac = this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) {\n                // The context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getParent() == null) {\n                    // The context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setParent(rootContext);\n                }\n                configureAndRefreshWebApplicationContext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // No context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. If one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findWebApplicationContext();\n    }\n    if (wac == null) {\n        // No context instance is defined for this servlet -> create a local one\n        // 创建WebApplicationContext\n        wac = createWebApplicationContext(rootContext);\n    }\n\n    if (!this.refreshEventReceived) {\n        // Either the context is not a ConfigurableApplicationContext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onRefresh manually here.\n        synchronized (this.onRefreshMonitor) {\n            // 刷新WebApplicationContext\n            onRefresh(wac);\n        }\n    }\n\n    if (this.publishContext) {\n        // Publish the context as a servlet context attribute.\n        // 将IOC容器在应用域共享\n        String attrName = getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    }\n\n    return wac;\n}\n\n\n# b>创建WebApplicationContext\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {\n    Class<?> contextClass = getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException(\n            "Fatal initialization error in servlet with name \'" + getServletName() +\n            "\': custom WebApplicationContext class [" + contextClass.getName() +\n            "] is not of type ConfigurableWebApplicationContext");\n    }\n    // 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac =\n        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n    wac.setEnvironment(getEnvironment());\n    // 设置父容器\n    wac.setParent(parent);\n    String configLocation = getContextConfigLocation();\n    if (configLocation != null) {\n        wac.setConfigLocation(configLocation);\n    }\n    configureAndRefreshWebApplicationContext(wac);\n\n    return wac;\n}\n\n\n# c>DispatcherServlet初始化策略\n\nFrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法（包含自己需要初始化的方法），初始化策略，即初始化DispatcherServlet的各个组件\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void initStrategies(ApplicationContext context) {\n   initMultipartResolver(context);\n   initLocaleResolver(context);\n   initThemeResolver(context);\n   initHandlerMappings(context);\n   initHandlerAdapters(context);\n   initHandlerExceptionResolvers(context);\n   initRequestToViewNameTranslator(context);\n   initViewResolvers(context);\n   initFlashMapManager(context);\n}\n\n\n\n# 3、DispatcherServlet调用组件处理请求\n\n# a>processRequest()\n\nFrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)\n\n所在类：org.springframework.web.servlet.FrameworkServlet\n\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    long startTime = System.currentTimeMillis();\n    Throwable failureCause = null;\n\n    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext = buildLocaleContext(request);\n\n    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n    initContextHolders(request, localeContext, requestAttributes);\n\n    try {\n\t\t// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写\n        doService(request, response);\n    }\n    catch (ServletException | IOException ex) {\n        failureCause = ex;\n        throw ex;\n    }\n    catch (Throwable ex) {\n        failureCause = ex;\n        throw new NestedServletException("Request processing failed", ex);\n    }\n\n    finally {\n        resetContextHolders(request, previousLocaleContext, previousAttributes);\n        if (requestAttributes != null) {\n            requestAttributes.requestCompleted();\n        }\n        logResult(request, response, failureCause, asyncManager);\n        publishRequestHandledEvent(request, response, startTime, failureCause);\n    }\n}\n\n\n# b>doService()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    logRequest(request);\n\n    // Keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    Map<String, Object> attributesSnapshot = null;\n    if (WebUtils.isIncludeRequest(request)) {\n        attributesSnapshot = new HashMap<>();\n        Enumeration<?> attrNames = request.getAttributeNames();\n        while (attrNames.hasMoreElements()) {\n            String attrName = (String) attrNames.nextElement();\n            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n                attributesSnapshot.put(attrName, request.getAttribute(attrName));\n            }\n        }\n    }\n\n    // Make framework objects available to handlers and view objects.\n    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n    if (this.flashMapManager != null) {\n        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n        if (inputFlashMap != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n        }\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n    }\n\n    RequestPath requestPath = null;\n    if (this.parseRequestPath && !ServletRequestPathUtils.hasParsedRequestPath(request)) {\n        requestPath = ServletRequestPathUtils.parseAndCache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        doDispatch(request, response);\n    }\n    finally {\n        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n            // Restore the original attribute snapshot, in case of an include.\n            if (attributesSnapshot != null) {\n                restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n        }\n        if (requestPath != null) {\n            ServletRequestPathUtils.clearParsedRequestPath(request);\n        }\n    }\n}\n\n\n# c>doDispatch()\n\n所在类：org.springframework.web.servlet.DispatcherServlet\n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // Determine handler for the current request.\n            /*\n            \tmappedHandler：调用链\n                包含handler、interceptorList、interceptorIndex\n            \thandler：浏览器发送的请求所匹配的控制器方法\n            \tinterceptorList：处理控制器方法的所有拦截器集合\n            \tinterceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行\n            */\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n            // Determine handler adapter for the current request.\n           \t// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n            // Process last-modified header, if supported by the handler.\n            String method = request.getMethod();\n            boolean isGet = "GET".equals(method);\n            if (isGet || "HEAD".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n\t\t\t\n            // 调用拦截器的preHandle()\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // Actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            applyDefaultViewName(processedRequest, mv);\n            // 调用拦截器的postHandle()\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        }\n        catch (Exception ex) {\n            dispatchException = ex;\n        }\n        catch (Throwable err) {\n            // As of 4.3, we\'re processing Errors thrown from handler methods as well,\n            // making them available for @ExceptionHandler methods and other scenarios.\n            dispatchException = new NestedServletException("Handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    }\n    catch (Exception ex) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n    }\n    catch (Throwable err) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler,\n                               new NestedServletException("Handler processing failed", err));\n    }\n    finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            // Instead of postHandle and afterCompletion\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        }\n        else {\n            // Clean up any resources used by a multipart request.\n            if (multipartRequestParsed) {\n                cleanupMultipart(processedRequest);\n            }\n        }\n    }\n}\n\n\n# d>processDispatchResult()\n\nprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,\n                                   @Nullable Exception exception) throws Exception {\n\n    boolean errorView = false;\n\n    if (exception != null) {\n        if (exception instanceof ModelAndViewDefiningException) {\n            logger.debug("ModelAndViewDefiningException encountered", exception);\n            mv = ((ModelAndViewDefiningException) exception).getModelAndView();\n        }\n        else {\n            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n            mv = processHandlerException(request, response, handler, exception);\n            errorView = (mv != null);\n        }\n    }\n\n    // Did the handler return a view to render?\n    if (mv != null && !mv.wasCleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorView) {\n            WebUtils.clearErrorRequestAttributes(request);\n        }\n    }\n    else {\n        if (logger.isTraceEnabled()) {\n            logger.trace("No view rendering, null ModelAndView returned.");\n        }\n    }\n\n    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n        // Concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedHandler != null) {\n        // Exception (if any) is already handled..\n        // 调用拦截器的afterCompletion()\n        mappedHandler.triggerAfterCompletion(request, response, null);\n    }\n}\n\n\n\n# 4、SpringMVC的执行流程\n\n 1. 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\n\n 2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n\na) 不存在\n\ni. 再判断是否配置了mvc:default-servlet-handler\n\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\n\n\n\n\n\nb) 存在则执行下面的流程\n\n 3. 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\n\n 4. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\n\n 5. 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n\n 6. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n\na) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n\nb) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n\n 7.  Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\n\n 8.  此时将开始执行拦截器的postHandle(...)方法【逆向】。\n\n 9.  根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\n\n 10. 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\n\n 11. 将渲染结果返回给客户端。',normalizedContent:'# 十三、springmvc执行流程\n\n\n# 1、springmvc常用组件\n\n * dispatcherservlet：前端控制器，不需要工程师开发，由框架提供\n\n作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\n * handlermapping：处理器映射器，不需要工程师开发，由框架提供\n\n作用：根据请求的url、method等信息查找handler，即控制器方法\n\n * handler：处理器，需要工程师开发\n\n作用：在dispatcherservlet的控制下handler对具体的用户请求进行处理\n\n * handleradapter：处理器适配器，不需要工程师开发，由框架提供\n\n作用：通过handleradapter对处理器（控制器方法）进行执行\n\n * viewresolver：视图解析器，不需要工程师开发，由框架提供（页面需要自己写）\n\n作用：进行视图解析，得到相应的视图，例如：thymeleafview、internalresourceview、redirectview\n\n * view：视图，不需要工程师开发，由框架或者视图技术提供\n\n作用：将模型数据通过页面展示给用户\n\n\n\n\n# 2、dispatcherservlet初始化过程\n\ndispatcherservlet 本质上是一个 servlet，所以天然的遵循 servlet 的生命周期。所以宏观上是 servlet 生命周期来进行调度。\n\n\n\n# a>初始化webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext initwebapplicationcontext() {\n    webapplicationcontext rootcontext =\n        webapplicationcontextutils.getwebapplicationcontext(getservletcontext());\n    webapplicationcontext wac = null;\n\n    if (this.webapplicationcontext != null) {\n        // a context instance was injected at construction time -> use it\n        wac = this.webapplicationcontext;\n        if (wac instanceof configurablewebapplicationcontext) {\n            configurablewebapplicationcontext cwac = (configurablewebapplicationcontext) wac;\n            if (!cwac.isactive()) {\n                // the context has not yet been refreshed -> provide services such as\n                // setting the parent context, setting the application context id, etc\n                if (cwac.getparent() == null) {\n                    // the context instance was injected without an explicit parent -> set\n                    // the root application context (if any; may be null) as the parent\n                    cwac.setparent(rootcontext);\n                }\n                configureandrefreshwebapplicationcontext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // no context instance was injected at construction time -> see if one\n        // has been registered in the servlet context. if one exists, it is assumed\n        // that the parent context (if any) has already been set and that the\n        // user has performed any initialization such as setting the context id\n        wac = findwebapplicationcontext();\n    }\n    if (wac == null) {\n        // no context instance is defined for this servlet -> create a local one\n        // 创建webapplicationcontext\n        wac = createwebapplicationcontext(rootcontext);\n    }\n\n    if (!this.refresheventreceived) {\n        // either the context is not a configurableapplicationcontext with refresh\n        // support or the context injected at construction time had already been\n        // refreshed -> trigger initial onrefresh manually here.\n        synchronized (this.onrefreshmonitor) {\n            // 刷新webapplicationcontext\n            onrefresh(wac);\n        }\n    }\n\n    if (this.publishcontext) {\n        // publish the context as a servlet context attribute.\n        // 将ioc容器在应用域共享\n        string attrname = getservletcontextattributename();\n        getservletcontext().setattribute(attrname, wac);\n    }\n\n    return wac;\n}\n\n\n# b>创建webapplicationcontext\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected webapplicationcontext createwebapplicationcontext(@nullable applicationcontext parent) {\n    class<?> contextclass = getcontextclass();\n    if (!configurablewebapplicationcontext.class.isassignablefrom(contextclass)) {\n        throw new applicationcontextexception(\n            "fatal initialization error in servlet with name \'" + getservletname() +\n            "\': custom webapplicationcontext class [" + contextclass.getname() +\n            "] is not of type configurablewebapplicationcontext");\n    }\n    // 通过反射创建 ioc 容器对象\n    configurablewebapplicationcontext wac =\n        (configurablewebapplicationcontext) beanutils.instantiateclass(contextclass);\n\n    wac.setenvironment(getenvironment());\n    // 设置父容器\n    wac.setparent(parent);\n    string configlocation = getcontextconfiglocation();\n    if (configlocation != null) {\n        wac.setconfiglocation(configlocation);\n    }\n    configureandrefreshwebapplicationcontext(wac);\n\n    return wac;\n}\n\n\n# c>dispatcherservlet初始化策略\n\nframeworkservlet创建webapplicationcontext后，刷新容器，调用onrefresh(wac)，此方法在dispatcherservlet中进行了重写，调用了initstrategies(context)方法（包含自己需要初始化的方法），初始化策略，即初始化dispatcherservlet的各个组件\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void initstrategies(applicationcontext context) {\n   initmultipartresolver(context);\n   initlocaleresolver(context);\n   initthemeresolver(context);\n   inithandlermappings(context);\n   inithandleradapters(context);\n   inithandlerexceptionresolvers(context);\n   initrequesttoviewnametranslator(context);\n   initviewresolvers(context);\n   initflashmapmanager(context);\n}\n\n\n\n# 3、dispatcherservlet调用组件处理请求\n\n# a>processrequest()\n\nframeworkservlet重写httpservlet中的service()和doxxx()，这些方法中调用了processrequest(request, response)\n\n所在类：org.springframework.web.servlet.frameworkservlet\n\nprotected final void processrequest(httpservletrequest request, httpservletresponse response)\n    throws servletexception, ioexception {\n\n    long starttime = system.currenttimemillis();\n    throwable failurecause = null;\n\n    localecontext previouslocalecontext = localecontextholder.getlocalecontext();\n    localecontext localecontext = buildlocalecontext(request);\n\n    requestattributes previousattributes = requestcontextholder.getrequestattributes();\n    servletrequestattributes requestattributes = buildrequestattributes(request, response, previousattributes);\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n    asyncmanager.registercallableinterceptor(frameworkservlet.class.getname(), new requestbindinginterceptor());\n\n    initcontextholders(request, localecontext, requestattributes);\n\n    try {\n\t\t// 执行服务，doservice()是一个抽象方法，在dispatcherservlet中进行了重写\n        doservice(request, response);\n    }\n    catch (servletexception | ioexception ex) {\n        failurecause = ex;\n        throw ex;\n    }\n    catch (throwable ex) {\n        failurecause = ex;\n        throw new nestedservletexception("request processing failed", ex);\n    }\n\n    finally {\n        resetcontextholders(request, previouslocalecontext, previousattributes);\n        if (requestattributes != null) {\n            requestattributes.requestcompleted();\n        }\n        logresult(request, response, failurecause, asyncmanager);\n        publishrequesthandledevent(request, response, starttime, failurecause);\n    }\n}\n\n\n# b>doservice()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\n@override\nprotected void doservice(httpservletrequest request, httpservletresponse response) throws exception {\n    logrequest(request);\n\n    // keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    map<string, object> attributessnapshot = null;\n    if (webutils.isincluderequest(request)) {\n        attributessnapshot = new hashmap<>();\n        enumeration<?> attrnames = request.getattributenames();\n        while (attrnames.hasmoreelements()) {\n            string attrname = (string) attrnames.nextelement();\n            if (this.cleanupafterinclude || attrname.startswith(default_strategies_prefix)) {\n                attributessnapshot.put(attrname, request.getattribute(attrname));\n            }\n        }\n    }\n\n    // make framework objects available to handlers and view objects.\n    request.setattribute(web_application_context_attribute, getwebapplicationcontext());\n    request.setattribute(locale_resolver_attribute, this.localeresolver);\n    request.setattribute(theme_resolver_attribute, this.themeresolver);\n    request.setattribute(theme_source_attribute, getthemesource());\n\n    if (this.flashmapmanager != null) {\n        flashmap inputflashmap = this.flashmapmanager.retrieveandupdate(request, response);\n        if (inputflashmap != null) {\n            request.setattribute(input_flash_map_attribute, collections.unmodifiablemap(inputflashmap));\n        }\n        request.setattribute(output_flash_map_attribute, new flashmap());\n        request.setattribute(flash_map_manager_attribute, this.flashmapmanager);\n    }\n\n    requestpath requestpath = null;\n    if (this.parserequestpath && !servletrequestpathutils.hasparsedrequestpath(request)) {\n        requestpath = servletrequestpathutils.parseandcache(request);\n    }\n\n    try {\n        // 处理请求和响应\n        dodispatch(request, response);\n    }\n    finally {\n        if (!webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n            // restore the original attribute snapshot, in case of an include.\n            if (attributessnapshot != null) {\n                restoreattributesafterinclude(request, attributessnapshot);\n            }\n        }\n        if (requestpath != null) {\n            servletrequestpathutils.clearparsedrequestpath(request);\n        }\n    }\n}\n\n\n# c>dodispatch()\n\n所在类：org.springframework.web.servlet.dispatcherservlet\n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception {\n    httpservletrequest processedrequest = request;\n    handlerexecutionchain mappedhandler = null;\n    boolean multipartrequestparsed = false;\n\n    webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n\n    try {\n        modelandview mv = null;\n        exception dispatchexception = null;\n\n        try {\n            processedrequest = checkmultipart(request);\n            multipartrequestparsed = (processedrequest != request);\n\n            // determine handler for the current request.\n            /*\n            \tmappedhandler：调用链\n                包含handler、interceptorlist、interceptorindex\n            \thandler：浏览器发送的请求所匹配的控制器方法\n            \tinterceptorlist：处理控制器方法的所有拦截器集合\n            \tinterceptorindex：拦截器索引，控制拦截器aftercompletion()的执行\n            */\n            mappedhandler = gethandler(processedrequest);\n            if (mappedhandler == null) {\n                nohandlerfound(processedrequest, response);\n                return;\n            }\n\n            // determine handler adapter for the current request.\n           \t// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法\n            handleradapter ha = gethandleradapter(mappedhandler.gethandler());\n\n            // process last-modified header, if supported by the handler.\n            string method = request.getmethod();\n            boolean isget = "get".equals(method);\n            if (isget || "head".equals(method)) {\n                long lastmodified = ha.getlastmodified(request, mappedhandler.gethandler());\n                if (new servletwebrequest(request, response).checknotmodified(lastmodified) && isget) {\n                    return;\n                }\n            }\n\t\t\t\n            // 调用拦截器的prehandle()\n            if (!mappedhandler.applyprehandle(processedrequest, response)) {\n                return;\n            }\n\n            // actually invoke the handler.\n            // 由处理器适配器调用具体的控制器方法，最终获得modelandview对象\n            mv = ha.handle(processedrequest, response, mappedhandler.gethandler());\n\n            if (asyncmanager.isconcurrenthandlingstarted()) {\n                return;\n            }\n\n            applydefaultviewname(processedrequest, mv);\n            // 调用拦截器的posthandle()\n            mappedhandler.applyposthandle(processedrequest, response, mv);\n        }\n        catch (exception ex) {\n            dispatchexception = ex;\n        }\n        catch (throwable err) {\n            // as of 4.3, we\'re processing errors thrown from handler methods as well,\n            // making them available for @exceptionhandler methods and other scenarios.\n            dispatchexception = new nestedservletexception("handler dispatch failed", err);\n        }\n        // 后续处理：处理模型数据和渲染视图\n        processdispatchresult(processedrequest, response, mappedhandler, mv, dispatchexception);\n    }\n    catch (exception ex) {\n        triggeraftercompletion(processedrequest, response, mappedhandler, ex);\n    }\n    catch (throwable err) {\n        triggeraftercompletion(processedrequest, response, mappedhandler,\n                               new nestedservletexception("handler processing failed", err));\n    }\n    finally {\n        if (asyncmanager.isconcurrenthandlingstarted()) {\n            // instead of posthandle and aftercompletion\n            if (mappedhandler != null) {\n                mappedhandler.applyafterconcurrenthandlingstarted(processedrequest, response);\n            }\n        }\n        else {\n            // clean up any resources used by a multipart request.\n            if (multipartrequestparsed) {\n                cleanupmultipart(processedrequest);\n            }\n        }\n    }\n}\n\n\n# d>processdispatchresult()\n\nprivate void processdispatchresult(httpservletrequest request, httpservletresponse response,\n                                   @nullable handlerexecutionchain mappedhandler, @nullable modelandview mv,\n                                   @nullable exception exception) throws exception {\n\n    boolean errorview = false;\n\n    if (exception != null) {\n        if (exception instanceof modelandviewdefiningexception) {\n            logger.debug("modelandviewdefiningexception encountered", exception);\n            mv = ((modelandviewdefiningexception) exception).getmodelandview();\n        }\n        else {\n            object handler = (mappedhandler != null ? mappedhandler.gethandler() : null);\n            mv = processhandlerexception(request, response, handler, exception);\n            errorview = (mv != null);\n        }\n    }\n\n    // did the handler return a view to render?\n    if (mv != null && !mv.wascleared()) {\n        // 处理模型数据和渲染视图\n        render(mv, request, response);\n        if (errorview) {\n            webutils.clearerrorrequestattributes(request);\n        }\n    }\n    else {\n        if (logger.istraceenabled()) {\n            logger.trace("no view rendering, null modelandview returned.");\n        }\n    }\n\n    if (webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n        // concurrent handling started during a forward\n        return;\n    }\n\n    if (mappedhandler != null) {\n        // exception (if any) is already handled..\n        // 调用拦截器的aftercompletion()\n        mappedhandler.triggeraftercompletion(request, response, null);\n    }\n}\n\n\n\n# 4、springmvc的执行流程\n\n 1. 用户向服务器发送请求，请求被springmvc 前端控制器 dispatcherservlet捕获。\n\n 2. dispatcherservlet对请求url进行解析，得到请求资源标识符（uri），判断请求uri对应的映射：\n\na) 不存在\n\ni. 再判断是否配置了mvc:default-servlet-handler\n\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n\n\n\n\niii. 如果有配置，则访问目标资源（一般为静态资源，如：js,css,html），找不到客户端也会展示404错误\n\n\n\n\n\nb) 存在则执行下面的流程\n\n 3. 根据该uri，调用handlermapping获得该handler配置的所有相关的对象（包括handler对象以及handler对象对应的拦截器），最后以handlerexecutionchain执行链对象的形式返回。\n\n 4. dispatcherservlet 根据获得的handler，选择一个合适的handleradapter。\n\n 5. 如果成功获得handleradapter，此时将开始执行拦截器的prehandler(…)方法【正向】\n\n 6. 提取request中的模型数据，填充handler入参，开始执行handler（controller)方法，处理请求。在填充handler的入参过程中，根据你的配置，spring将帮你做一些额外的工作：\n\na) httpmessageconveter： 将请求消息（如json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n\nb) 数据转换：对请求消息进行数据转换。如string转换成integer、double等\n\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中\n\n 7.  handler执行完成后，向dispatcherservlet 返回一个modelandview对象。\n\n 8.  此时将开始执行拦截器的posthandle(...)方法【逆向】。\n\n 9.  根据返回的modelandview（此时会判断是否存在异常：如果存在异常，则执行handlerexceptionresolver进行异常处理）选择一个适合的viewresolver进行视图解析，根据model和view，来渲染视图。\n\n 10. 渲染视图完毕执行拦截器的aftercompletion(…)方法【逆向】。\n\n 11. 将渲染结果返回给客户端。',charsets:{cjk:!0}},{title:"运维",frontmatter:{title:"运维",date:"2022-03-22T00:00:00.000Z",permalink:"/springboot/002/",categories:["框架","SpringBoot"],tags:["SpringBoot"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/03.SpringBoot/02.%E8%BF%90%E7%BB%B4.html",relativePath:"07.框架/03.SpringBoot/02.运维.md",key:"v-70eda528",path:"/springboot/002/",headers:[{level:2,title:"YW-1.SpringBoot程序的打包与运行",slug:"yw-1-springboot程序的打包与运行",normalizedTitle:"yw-1.springboot程序的打包与运行",charIndex:98},{level:3,title:"程序打包",slug:"程序打包",normalizedTitle:"程序打包",charIndex:83},{level:3,title:"程序运行",slug:"程序运行",normalizedTitle:"程序运行",charIndex:782},{level:3,title:"SpringBoot程序打包失败处理",slug:"springboot程序打包失败处理",normalizedTitle:"springboot程序打包失败处理",charIndex:1324},{level:3,title:"命令行启动常见问题及解决方案",slug:"命令行启动常见问题及解决方案",normalizedTitle:"命令行启动常见问题及解决方案",charIndex:4274},{level:3,title:"SpringBoot项目快速启动（Linux版）",slug:"springboot项目快速启动-linux版",normalizedTitle:"springboot项目快速启动（linux版）",charIndex:4589},{level:2,title:"YW-2.配置高级",slug:"yw-2-配置高级",normalizedTitle:"yw-2.配置高级",charIndex:4765},{level:3,title:"YW-2-1.临时属性设置",slug:"yw-2-1-临时属性设置",normalizedTitle:"yw-2-1.临时属性设置",charIndex:4932},{level:4,title:"属性加载优先级",slug:"属性加载优先级",normalizedTitle:"属性加载优先级",charIndex:5487},{level:4,title:"开发环境中使用临时属性",slug:"开发环境中使用临时属性",normalizedTitle:"开发环境中使用临时属性",charIndex:6432},{level:3,title:"YW-2-2.配置文件分类",slug:"yw-2-2-配置文件分类",normalizedTitle:"yw-2-2.配置文件分类",charIndex:7610},{level:3,title:"YW-2-3.自定义配置文件",slug:"yw-2-3-自定义配置文件",normalizedTitle:"yw-2-3.自定义配置文件",charIndex:8851},{level:2,title:"YW-3.多环境开发",slug:"yw-3-多环境开发",normalizedTitle:"yw-3.多环境开发",charIndex:9468},{level:3,title:"YW-3-1.多环境开发（yaml单一文件版）",slug:"yw-3-1-多环境开发-yaml单一文件版",normalizedTitle:"yw-3-1.多环境开发（yaml单一文件版）",charIndex:9677},{level:3,title:"YW-3-2.多环境开发（yaml多文件版）",slug:"yw-3-2-多环境开发-yaml多文件版",normalizedTitle:"yw-3-2.多环境开发（yaml多文件版）",charIndex:10509},{level:3,title:"YW-3-3.多环境开发（properties多文件版）",slug:"yw-3-3-多环境开发-properties多文件版",normalizedTitle:"yw-3-3.多环境开发（properties多文件版）",charIndex:11059},{level:3,title:"YW-3-4.多环境开发独立配置文件书写技巧",slug:"yw-3-4-多环境开发独立配置文件书写技巧",normalizedTitle:"yw-3-4.多环境开发独立配置文件书写技巧",charIndex:11355},{level:3,title:"YW-3-5.多环境开发控制",slug:"yw-3-5-多环境开发控制",normalizedTitle:"yw-3-5.多环境开发控制",charIndex:12235},{level:2,title:"YW-4.日志",slug:"yw-4-日志",normalizedTitle:"yw-4.日志",charIndex:13319},{level:4,title:"YW-4-1.代码中使用日志工具记录日志",slug:"yw-4-1-代码中使用日志工具记录日志",normalizedTitle:"yw-4-1.代码中使用日志工具记录日志",charIndex:13547},{level:4,title:"教你一招：优化日志对象创建代码",slug:"教你一招-优化日志对象创建代码",normalizedTitle:"教你一招：优化日志对象创建代码",charIndex:15010},{level:4,title:"YW-4-2.日志输出格式控制",slug:"yw-4-2-日志输出格式控制",normalizedTitle:"yw-4-2.日志输出格式控制",charIndex:15560},{level:4,title:"YW-4-3.日志文件",slug:"yw-4-3-日志文件",normalizedTitle:"yw-4-3.日志文件",charIndex:15915}],headersStr:"YW-1.SpringBoot程序的打包与运行 程序打包 程序运行 SpringBoot程序打包失败处理 命令行启动常见问题及解决方案 SpringBoot项目快速启动（Linux版） YW-2.配置高级 YW-2-1.临时属性设置 属性加载优先级 开发环境中使用临时属性 YW-2-2.配置文件分类 YW-2-3.自定义配置文件 YW-3.多环境开发 YW-3-1.多环境开发（yaml单一文件版） YW-3-2.多环境开发（yaml多文件版） YW-3-3.多环境开发（properties多文件版） YW-3-4.多环境开发独立配置文件书写技巧 YW-3-5.多环境开发控制 YW-4.日志 YW-4-1.代码中使用日志工具记录日志 教你一招：优化日志对象创建代码 YW-4-2.日志输出格式控制 YW-4-3.日志文件",content:'# SpringBoot运维实用篇\n\n * SpringBoot程序的打包与运行\n * 配置高级\n * 多环境开发\n * 日志\n\n下面开启第一部分SpringBoot程序打包与运行的学习\n\n\n# YW-1.SpringBoot程序的打包与运行\n\n刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。\n\n但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。\n\n我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。\n\n那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。\n\n温馨提示\n\n企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。\n\n 1. 开发部门使用Git、SVN等版本控制工具上传工程到版本服务器\n 2. 服务器使用版本控制工具下载工程\n 3. 服务器上使用Maven工具在当前真机环境下重新构建项目\n 4. 启动服务\n\n继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。\n\n\n# 程序打包\n\nSpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。\n\nmvn package\n\n\n打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。打包的时候可以按照需求可以跳过test阶段（maven里面有讲）\n\n\n# 程序运行\n\n程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。\n\njava -jar 工程包名.jar\n\n\n执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。\n\n特别关注：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。\n\n特别关注：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n\n总结\n\n 1. SpringBoot工程可以基于java环境下独立运行jar文件启动服务\n 2. SpringBoot工程执行mvn命令package进行打包\n 3. 执行jar命令：java –jar 工程名.jar\n\n\n# SpringBoot程序打包失败处理\n\n有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象\n\n要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。\n\n搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。\n\n在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n\n我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征\n\n * 打包后文件的大小不同\n * 打包后所包含的内容不同\n * 打包程序中个别文件内容不同\n\n先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：\n\n不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。\n\n\n\n**我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。**打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。\n\n\n\n原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。\n\n\n\n仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。\n\n再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\\springframework\\boot\\loader，在里面可以找到一个JarLauncher.class的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。\n\n回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别\n\n * 小容量文件的MANIFEST.MF\n   \n   Manifest-Version: 1.0\n   Implementation-Title: springboot_08_ssmp\n   Implementation-Version: 0.0.1-SNAPSHOT\n   Build-Jdk-Spec: 1.8\n   Created-By: Maven Jar Plugin 3.2.0\n   \n\n * 大容量文件的MANIFEST.MF\n   \n   Manifest-Version: 1.0\n   Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx\n   Implementation-Title: springboot_08_ssmp\n   Implementation-Version: 0.0.1-SNAPSHOT\n   Spring-Boot-Layers-Index: BOOT-INF/layers.idx\n   Start-Class: com.itheima.SSMPApplication\n   Spring-Boot-Classes: BOOT-INF/classes/\n   Spring-Boot-Lib: BOOT-INF/lib/\n   Build-Jdk-Spec: 1.8\n   Spring-Boot-Version: 2.5.4\n   Created-By: Maven Jar Plugin 3.2.0\n   Main-Class: org.springframework.boot.loader.JarLauncher\n   \n\n大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.JarLauncher。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.JarLauncher类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。\n\n现在这组设定的作用就搞清楚了\n\n 1. SpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包\n 2. 首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类\n 3. JarLauncher类执行时会找到Start-Class属性，也就是启动类类名\n 4. 运行启动类时会运行当前工程的内容\n 5. 运行当前工程时会使用依赖的jar包，从lib目录中查找\n\n看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。\n\n再来看之前的报错信息：\n\n由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。\n\n上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚SpringBoot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。\n\n总结\n\n 1. spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包\n\n\n# 命令行启动常见问题及解决方案\n\n各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。\n\n# 查询端口\nnetstat -ano\n# 查询指定端口\nnetstat -ano |findstr "端口号"\n# 根据进程PID查询进程名称\ntasklist |findstr "进程PID号"\n# 根据PID杀死任务\ntaskkill /F /PID "进程PID号"\n# 根据进程名称杀死任务\ntaskkill -f -t -im "进程名称"\n\n\n关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。\n\n\n# SpringBoot项目快速启动（Linux版）\n\n其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。\n\n\n\n\n# YW-2.配置高级\n\n关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。\n\n\n# YW-2-1.临时属性设置\n\n目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。\n\n\n\nSpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。\n\njava –jar springboot.jar –-server.port=80\n\n\n上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。\n\n如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。\n\njava –jar springboot.jar –-server.port=80 --logging.level.root=debug\n\n\n# 属性加载优先级\n\n现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序（从上到下优先级越来越高）。地址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\n我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。\n\n比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。\n\n我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。\n\n总结\n\n 1. 使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性\n 2. 临时属性添加方式：java –jar 工程名.jar –-属性名=值\n 3. 多个临时属性之间使用空格分隔\n 4. 临时属性必须是当前boot工程支持的属性，否则设置无效\n\n# 开发环境中使用临时属性\n\n临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。\n\n打开SpringBoot引导类的运行界面Run/Debug Configurations，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。\n\n做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。\n\npublic static void main(String[] args) {\n}\n\n\n原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的\n\npublic static void main(String[] args) {\n    SpringApplication.run(SSMPApplication.class,args);\n}\n\n\n这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。\n\npublic static void main(String[] args) {\n    SpringApplication.run(SSMPApplication.class);\n}\n\n\n或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。\n\npublic static void main(String[] args) {\n    String[] arg = new String[1];\n    arg[0] = "--server.port=8082";\n    SpringApplication.run(SSMPApplication.class, arg);\n}\n\n\n总结\n\n 1. 启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性\n\n思考\n\n现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。\n\n\n# YW-2-2.配置文件分类\n\nSpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：\n\n * 类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）\n * 类路径下config目录下配置文件\n * 程序包所在目录中配置文件\n * 程序包所在目录中config目录下配置文件\n\n好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为\n\n 1. file ：config/application.yml 【最高】\n 2. file ：application.yml\n 3. classpath：config/application.yml\n 4. classpath：application.yml 【最低】\n\n那为什么设计这种多种呢？说一个最典型的应用吧。\n\n * 场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。\n * 场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。\n * 场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？\n\n解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？\n\n级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。\n\n\n\n总结\n\n 1. 配置文件分为4种\n    \n    * 项目类路径配置文件：服务于开发人员本机开发与测试**（最低）**\n    * 项目类路径config目录中配置文件：服务于项目经理整体调控\n    * 工程路径配置文件：服务于运维人员配置涉密线上环境\n    * 工程路径config目录中配置文件：服务于运维经理整体调控**（最高）**\n\n 2. 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序\n\n\n# YW-2-3.自定义配置文件\n\n之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。\n\n自定义配置文件方式有如下两种：\n\n方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名\n\n方式二：使用临时属性设置配置文件路径，这个是全路径名\n\n也可以设置加载多个配置文件（** 最后一个文件会使前面的失效**）\n\n使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。\n\n\n\n温馨提示\n\n我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。\n\n总结\n\n 1. 配置文件可以修改名称，通过启动参数设定\n 2. 配置文件可以修改路径，通过启动参数设定\n 3. 微服务开发中配置文件通过配置中心进行设置\n\n\n\n\n# YW-3.多环境开发\n\n讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。\n\n什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。\n\n\n# YW-3-1.多环境开发（yaml单一文件版）\n\n那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：\n\nserver:\n  port: 80\n\n\n如何想设计两组环境呢？中间使用三个减号分隔开\n\nserver:\n  port: 80\n---\nserver:\n  port: 81\n\n\n如何区分两种环境呢？起名字呗\n\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n\n\n那用哪一个呢？设置默认启动哪个就可以了\n\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 默认启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n\n\n就这么简单，再多来一组环境也OK\n\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 默认启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n---\nspring:\n\tprofiles: test\nserver:\n\tport: 82\n\n\n其中关于环境名称定义上述格式是过时格式，标准格式如下\n\nspring:\n\tconfig:\n    \tactivate:\n        \ton-profile: pro\n\n\n总结\n\n 1. 多环境开发需要设置若干种常用环境，例如开发、生产、测试环境\n 2. yaml格式中设置多环境使用---区分环境设置边界\n 3. 每种环境的区别在于加载的配置属性不同\n 4. 启用某种环境时需要指定启动时使用该环境\n\n\n# YW-3-2.多环境开发（yaml多文件版）\n\n将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。\n\n主配置文件\n\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n\n\n环境配置文件\n\nserver:\n\tport: 80\n\n\n环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。\n\napplication-pro.yaml\n\nserver:\n\tport: 80\n\n\napplication-dev.yaml\n\nserver:\n\tport: 81\n\n\n文件的命名规则为：application-环境名.yml。\n\n在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。\n\n * 主配置文件中设置公共配置（全局）\n * 环境分类配置文件中常用于设置冲突属性（局部）\n\n总结\n\n 1. 可以使用独立配置文件定义环境属性\n\n 2. 独立配置文件便于线上系统维护更新并保障系统安全性\n\n\n# YW-3-3.多环境开发（properties多文件版）\n\nSpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。\n\n主配置文件\n\nspring.profiles.active=pro\n\n\n环境配置文件\n\napplication-pro.properties\n\nserver.port=80\n\n\napplication-dev.properties\n\nserver.port=81\n\n\n文件的命名规则为：application-环境名.properties。\n\n总结\n\n 1. properties文件多环境配置仅支持多文件格式\n\n\n# YW-3-4.多环境开发独立配置文件书写技巧\n\n作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。\n\n准备工作\n\n将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下\n\n * application-devDB.yml\n * application-devRedis.yml\n * application-devMVC.yml\n\n使用\n\n使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔\n\nspring:\n\tprofiles:\n    \tactive: dev\n        include: devDB,devRedis,devMVC\n\n\n比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么\n\n注意\n\n当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效\n\n改良\n\n但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。\n\nspring:\n\tprofiles:\n    \tactive: dev\n        group:\n        \t"dev": devDB,devRedis,devMVC\n      \t\t"pro": proDB,proRedis,proMVC\n      \t\t"test": testDB,testRedis,testMVC\n\n\n现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！\n\n总结\n\n 1. 多环境开发使用group属性设置配置文件分组，便于线上维护管理\n\n\n# YW-3-5.多环境开发控制\n\n多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。\n\n要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。\n\nmaven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：\n\n * 先在maven环境中设置用什么具体的环境\n * 在SpringBoot中读取maven设置的环境即可\n\nmaven中设置多环境（使用属性方式区分环境）\n\n<profiles>\n    <profile>\n        <id>env_dev</id>  \x3c!--id用来确认环境变量--\x3e\n        <properties>\n            <profile.active>dev</profile.active>\n        </properties>\n        <activation>\n            <activeByDefault>true</activeByDefault>\t\t\x3c!--默认启动环境--\x3e\n        </activation>\n    </profile>\n    <profile>\n        <id>env_pro</id>\n        <properties>\n            <profile.active>pro</profile.active>\n        </properties>\n    </profile>\n</profiles>\n\n\nSpringBoot中读取maven设置值\n\nspring:\n\tprofiles:\n    \tactive: @profile.active@\n\n\n上面的@属性名@就是读取maven中配置的属性值的语法格式。\n\n总结\n\n 1. 当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值\n 2. 基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效，防止缓存使得新的环境属性不能立马生效\n\n\n# YW-4.日志\n\n运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：\n\n * 编程期调试代码\n * 运营期记录信息\n * 记录日常运营重要信息（峰值流量、平均响应时长……）\n * 记录应用报错信息（错误堆栈）\n * 记录运维过程数据（扩容、宕机、报警……）\n\n或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。\n\n# YW-4-1.代码中使用日志工具记录日志\n\n日志的使用格式非常固定，直接上操作步骤：\n\n步骤①：添加日志记录操作\n\n@RestController\n@RequestMapping("/books")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\n    @GetMapping\n    public String getById(){\n        log.trace("fatal...")  // 用的很少\n        log.debug("debug...");\n        log.info("info...");\n        log.warn("warn...");\n        log.error("error...");\n        log.fatal("fatal...")  // 错误级别太高了，一般不考虑\n        return "springboot is running...2";\n    }\n}\n\n\n上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。\n\n步骤②：设置日志输出级别\n\n日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：\n\n * TRACE：运行堆栈信息，使用率低\n * DEBUG：程序员调试代码使用\n * INFO：记录运维过程数据\n * WARN：记录运维过程报警数据\n * ERROR：记录错误堆栈信息\n * FATAL：灾难信息，合并计入ERROR\n\n一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：\n\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n\n这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制\n\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n# 设置日志级别，root表示根节点，即整体应用日志级别\nlogging:\n\tlevel:\n    \troot: debug\n\n\n还可以再设置更细粒度的控制\n\n步骤③：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别\n\nlogging:\n\t# 设置日志组\n    group:\n    \t# 自定义组名，设置当前组中所包含的包\n        ebank: com.itheima.controller\n    level:\n    \troot: warn\n        # 为对应组设置日志级别\n        ebank: debug\n    \t# 为对应 包设置日志级别\n        com.itheima.controller: debug\n\n\n说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。\n\n总结\n\n 1. 日志用于记录开发调试与运维过程消息\n 2. 日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR\n 3. 可以通过日志组或代码包的形式进行日志显示级别的控制\n\n# 教你一招：优化日志对象创建代码\n\n写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。\n\n\n\n\n\n\n@RestController\n@RequestMapping("/books")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\t//这一句可以不写了\n}\n\n\n导入lombok后使用注解搞定，日志对象名为log\n\n@Slf4j\t\t//这个注解替代了下面那一行\n@RestController\n@RequestMapping("/books")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\t//这一句可以不写了\n}\n\n\n总结\n\n 1. 基于lombok提供的@Slf4j注解为类快速添加日志对象\n\n# YW-4-2.日志输出格式控制\n\n日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。\n\n\n\n\n\n对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。\n\nlogging:\n\tpattern:\n    \tconsole: "%d %clr(%p) --- [%16t] %clr(%-40.40c){cyan} : %m %n"\n\n\n总结\n\n 1. 日志输出格式设置规则（很简单一部分）\n    \n    \n\n# YW-4-3.日志文件\n\n日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。\n\n对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。\n\n记录日志到文件中格式非常简单，设置日志文件名即可。\n\nlogging:\n\tfile:\n    \tname: server.log\n\n\n虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：\n\nlogging:\n\tlogback:\n    \trollingpolicy:\n        \tmax-file-size: 3KB\n            file-name-pattern: server.%d{yyyy-MM-dd}.%i.log\n\n\n以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。\n\n总结\n\n 1. 日志记录到文件\n 2. 日志文件格式设置',normalizedContent:'# springboot运维实用篇\n\n * springboot程序的打包与运行\n * 配置高级\n * 多环境开发\n * 日志\n\n下面开启第一部分springboot程序打包与运行的学习\n\n\n# yw-1.springboot程序的打包与运行\n\n刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在idea下写的，运行也是在idea下运行的。\n\n但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。\n\n我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。\n\n那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。\n\n温馨提示\n\n企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。\n\n 1. 开发部门使用git、svn等版本控制工具上传工程到版本服务器\n 2. 服务器使用版本控制工具下载工程\n 3. 服务器上使用maven工具在当前真机环境下重新构建项目\n 4. 启动服务\n\n继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。\n\n\n# 程序打包\n\nspringboot程序是基于maven创建的，在maven中提供有打包的指令，叫做package。本操作可以在idea环境下执行。\n\nmvn package\n\n\n打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。打包的时候可以按照需求可以跳过test阶段（maven里面有讲）\n\n\n# 程序运行\n\n程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。\n\njava -jar 工程包名.jar\n\n\n执行程序打包指令后，程序正常运行，与在idea下执行程序没有区别。\n\n特别关注：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。\n\n特别关注：在使用向导创建springboot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。\n\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n        </plugin>\n    </plugins>\n</build>\n\n\n总结\n\n 1. springboot工程可以基于java环境下独立运行jar文件启动服务\n 2. springboot工程执行mvn命令package进行打包\n 3. 执行jar命令：java –jar 工程名.jar\n\n\n# springboot程序打包失败处理\n\n有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象\n\n要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。\n\n搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的springboot项目为什么能执行呢？其实是因为打包方式不一样。\n\n在springboot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。\n\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n        </plugin>\n    </plugins>\n</build>\n\n\n我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征\n\n * 打包后文件的大小不同\n * 打包后所包含的内容不同\n * 打包程序中个别文件内容不同\n\n先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：\n\n不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。\n\n\n\n**我们发现内容也完全不一样，仅有一个目录是一样的，叫做meta-inf。**打开容量大的程序包中的boot-inf目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。\n\n\n\n原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到boot-inf目录下，打开lib目录，里面显示了很多个jar文件。\n\n\n\n仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，springboot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。\n\n再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\\springframework\\boot\\loader，在里面可以找到一个jarlauncher.class的文件，先记得这个文件。再看这套目录名，明显是一个spring的目录名，为什么要把spring框架的东西打包到这个程序包中呢？不清楚。\n\n回到两个程序包的最外层目录，查看名称相同的文件夹meta-inf下都有一个叫做manifest.mf的文件，但是大小不同，打开文件，比较内容区别\n\n * 小容量文件的manifest.mf\n   \n   manifest-version: 1.0\n   implementation-title: springboot_08_ssmp\n   implementation-version: 0.0.1-snapshot\n   build-jdk-spec: 1.8\n   created-by: maven jar plugin 3.2.0\n   \n\n * 大容量文件的manifest.mf\n   \n   manifest-version: 1.0\n   spring-boot-classpath-index: boot-inf/classpath.idx\n   implementation-title: springboot_08_ssmp\n   implementation-version: 0.0.1-snapshot\n   spring-boot-layers-index: boot-inf/layers.idx\n   start-class: com.itheima.ssmpapplication\n   spring-boot-classes: boot-inf/classes/\n   spring-boot-lib: boot-inf/lib/\n   build-jdk-spec: 1.8\n   spring-boot-version: 2.5.4\n   created-by: maven jar plugin 3.2.0\n   main-class: org.springframework.boot.loader.jarlauncher\n   \n\n大文件中明显比小文件中多了几行信息，其中最后一行信息是main-class: org.springframework.boot.loader.jarlauncher。这句话什么意思呢？如果使用java -jar执行此程序包，将执行main-class属性配置的类，这个类恰巧就是前面看到的那个文件。原来springboot打包程序中出现spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.jarlauncher类内部要查找start-class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。\n\n现在这组设定的作用就搞清楚了\n\n 1. springboot程序添加配置后会打出一个特殊的包，包含spring框架部分功能，原始工程内容，原始工程依赖的jar包\n 2. 首先读取manifest.mf文件中的main-class属性，用来标记执行java -jar命令后运行的类\n 3. jarlauncher类执行时会找到start-class属性，也就是启动类类名\n 4. 运行启动类时会运行当前工程的内容\n 5. 运行当前工程时会使用依赖的jar包，从lib目录中查找\n\n看来springboot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。\n\n再来看之前的报错信息：\n\n由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在manifest.mf文件中也就没有了main-class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。\n\n上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚springboot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。\n\n总结\n\n 1. spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包\n\n\n# 命令行启动常见问题及解决方案\n\n各位小伙伴在dos环境下启动springboot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。\n\n# 查询端口\nnetstat -ano\n# 查询指定端口\nnetstat -ano |findstr "端口号"\n# 根据进程pid查询进程名称\ntasklist |findstr "进程pid号"\n# 根据pid杀死任务\ntaskkill /f /pid "进程pid号"\n# 根据进程名称杀死任务\ntaskkill -f -t -im "进程名称"\n\n\n关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。\n\n\n# springboot项目快速启动（linux版）\n\n其实对于linux系统下的程序运行与windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，ip地址如何查询，jdk如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。\n\n\n\n\n# yw-2.配置高级\n\n关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。\n\n\n# yw-2-1.临时属性设置\n\n目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。\n\n\n\nspringboot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。\n\njava –jar springboot.jar –-server.port=80\n\n\n上面的命令是启动springboot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。\n\n如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。\n\njava –jar springboot.jar –-server.port=80 --logging.level.root=debug\n\n\n# 属性加载优先级\n\n现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序（从上到下优先级越来越高）。地址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\n我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条config data说的就是使用配置文件，第11条command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是springboot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。\n\n比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。\n\n我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以springboot最终会加载系统配置属性user.name。\n\n总结\n\n 1. 使用jar命令启动springboot工程时可以使用临时属性替换配置文件中的属性\n 2. 临时属性添加方式：java –jar 工程名.jar –-属性名=值\n 3. 多个临时属性之间使用空格分隔\n 4. 临时属性必须是当前boot工程支持的属性，否则设置无效\n\n# 开发环境中使用临时属性\n\n临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是idea界面下如何操作了。\n\n打开springboot引导类的运行界面run/debug configurations，在里面找到配置项。其中program arguments对应的位置就是添加临时属性的，可以加几个试试效果。\n\n做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。\n\npublic static void main(string[] args) {\n}\n\n\n原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的\n\npublic static void main(string[] args) {\n    springapplication.run(ssmpapplication.class,args);\n}\n\n\n这个args参数居然传递给了run方法，看来在idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到springboot程序中了。\n\npublic static void main(string[] args) {\n    springapplication.run(ssmpapplication.class);\n}\n\n\n或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。\n\npublic static void main(string[] args) {\n    string[] arg = new string[1];\n    arg[0] = "--server.port=8082";\n    springapplication.run(ssmpapplication.class, arg);\n}\n\n\n总结\n\n 1. 启动springboot程序时，可以选择是否使用命令行属性为springboot程序传递启动属性\n\n思考\n\n现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。\n\n\n# yw-2-2.配置文件分类\n\nspringboot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是springboot提供的4级配置文件中的其中一个级别。4个级别分别是：\n\n * 类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）\n * 类路径下config目录下配置文件\n * 程序包所在目录中配置文件\n * 程序包所在目录中config目录下配置文件\n\n好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为\n\n 1. file ：config/application.yml 【最高】\n 2. file ：application.yml\n 3. classpath：config/application.yml\n 4. classpath：application.yml 【最低】\n\n那为什么设计这种多种呢？说一个最典型的应用吧。\n\n * 场景a：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。\n * 场景b：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。\n * 场景c：测试完了，一切ok。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景b中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？\n\n解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？\n\n级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。\n\n\n\n总结\n\n 1. 配置文件分为4种\n    \n    * 项目类路径配置文件：服务于开发人员本机开发与测试**（最低）**\n    * 项目类路径config目录中配置文件：服务于项目经理整体调控\n    * 工程路径配置文件：服务于运维人员配置涉密线上环境\n    * 工程路径config目录中配置文件：服务于运维经理整体调控**（最高）**\n\n 2. 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序\n\n\n# yw-2-3.自定义配置文件\n\n之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。\n\n自定义配置文件方式有如下两种：\n\n方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名\n\n方式二：使用临时属性设置配置文件路径，这个是全路径名\n\n也可以设置加载多个配置文件（** 最后一个文件会使前面的失效**）\n\n使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。\n\n\n\n温馨提示\n\n我们现在研究的都是springboot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于springcloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。\n\n总结\n\n 1. 配置文件可以修改名称，通过启动参数设定\n 2. 配置文件可以修改路径，通过启动参数设定\n 3. 微服务开发中配置文件通过配置中心进行设置\n\n\n\n\n# yw-3.多环境开发\n\n讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。\n\n什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。\n\n\n# yw-3-1.多环境开发（yaml单一文件版）\n\n那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：\n\nserver:\n  port: 80\n\n\n如何想设计两组环境呢？中间使用三个减号分隔开\n\nserver:\n  port: 80\n---\nserver:\n  port: 81\n\n\n如何区分两种环境呢？起名字呗\n\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n\n\n那用哪一个呢？设置默认启动哪个就可以了\n\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 默认启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n\n\n就这么简单，再多来一组环境也ok\n\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 默认启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n---\nspring:\n\tprofiles: test\nserver:\n\tport: 82\n\n\n其中关于环境名称定义上述格式是过时格式，标准格式如下\n\nspring:\n\tconfig:\n    \tactivate:\n        \ton-profile: pro\n\n\n总结\n\n 1. 多环境开发需要设置若干种常用环境，例如开发、生产、测试环境\n 2. yaml格式中设置多环境使用---区分环境设置边界\n 3. 每种环境的区别在于加载的配置属性不同\n 4. 启用某种环境时需要指定启动时使用该环境\n\n\n# yw-3-2.多环境开发（yaml多文件版）\n\n将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。\n\n主配置文件\n\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n\n\n环境配置文件\n\nserver:\n\tport: 80\n\n\n环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。\n\napplication-pro.yaml\n\nserver:\n\tport: 80\n\n\napplication-dev.yaml\n\nserver:\n\tport: 81\n\n\n文件的命名规则为：application-环境名.yml。\n\n在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。\n\n * 主配置文件中设置公共配置（全局）\n * 环境分类配置文件中常用于设置冲突属性（局部）\n\n总结\n\n 1. 可以使用独立配置文件定义环境属性\n\n 2. 独立配置文件便于线上系统维护更新并保障系统安全性\n\n\n# yw-3-3.多环境开发（properties多文件版）\n\nspringboot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。\n\n主配置文件\n\nspring.profiles.active=pro\n\n\n环境配置文件\n\napplication-pro.properties\n\nserver.port=80\n\n\napplication-dev.properties\n\nserver.port=81\n\n\n文件的命名规则为：application-环境名.properties。\n\n总结\n\n 1. properties文件多环境配置仅支持多文件格式\n\n\n# yw-3-4.多环境开发独立配置文件书写技巧\n\n作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。\n\n准备工作\n\n将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下\n\n * application-devdb.yml\n * application-devredis.yml\n * application-devmvc.yml\n\n使用\n\n使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔\n\nspring:\n\tprofiles:\n    \tactive: dev\n        include: devdb,devredis,devmvc\n\n\n比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么\n\n注意\n\n当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效\n\n改良\n\n但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦。springboot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。\n\nspring:\n\tprofiles:\n    \tactive: dev\n        group:\n        \t"dev": devdb,devredis,devmvc\n      \t\t"pro": prodb,proredis,promvc\n      \t\t"test": testdb,testredis,testmvc\n\n\n现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！\n\n总结\n\n 1. 多环境开发使用group属性设置配置文件分组，便于线上维护管理\n\n\n# yw-3-5.多环境开发控制\n\n多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和springboot同时设置多环境的话怎么搞。\n\n要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。\n\nmaven是做什么的？项目构建管理的，最终生成代码包的，springboot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以springboot应该听maven的。整个确认后下面就好做了。大体思想如下：\n\n * 先在maven环境中设置用什么具体的环境\n * 在springboot中读取maven设置的环境即可\n\nmaven中设置多环境（使用属性方式区分环境）\n\n<profiles>\n    <profile>\n        <id>env_dev</id>  \x3c!--id用来确认环境变量--\x3e\n        <properties>\n            <profile.active>dev</profile.active>\n        </properties>\n        <activation>\n            <activebydefault>true</activebydefault>\t\t\x3c!--默认启动环境--\x3e\n        </activation>\n    </profile>\n    <profile>\n        <id>env_pro</id>\n        <properties>\n            <profile.active>pro</profile.active>\n        </properties>\n    </profile>\n</profiles>\n\n\nspringboot中读取maven设置值\n\nspring:\n\tprofiles:\n    \tactive: @profile.active@\n\n\n上面的@属性名@就是读取maven中配置的属性值的语法格式。\n\n总结\n\n 1. 当maven与springboot同时对多环境进行控制时，以mavn为主，springboot使用@..@占位符读取maven对应的配置属性值\n 2. 基于springboot读取maven配置属性的前提下，如果在idea下测试工程时pom.xml每次更新需要手动compile方可生效，防止缓存使得新的环境属性不能立马生效\n\n\n# yw-4.日志\n\n运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：\n\n * 编程期调试代码\n * 运营期记录信息\n * 记录日常运营重要信息（峰值流量、平均响应时长……）\n * 记录应用报错信息（错误堆栈）\n * 记录运维过程数据（扩容、宕机、报警……）\n\n或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。\n\n# yw-4-1.代码中使用日志工具记录日志\n\n日志的使用格式非常固定，直接上操作步骤：\n\n步骤①：添加日志记录操作\n\n@restcontroller\n@requestmapping("/books")\npublic class bookcontroller extends baseclass{\n    private static final logger log = loggerfactory.getlogger(bookcontroller.class);\n    @getmapping\n    public string getbyid(){\n        log.trace("fatal...")  // 用的很少\n        log.debug("debug...");\n        log.info("info...");\n        log.warn("warn...");\n        log.error("error...");\n        log.fatal("fatal...")  // 错误级别太高了，一般不考虑\n        return "springboot is running...2";\n    }\n}\n\n\n上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的api了。\n\n步骤②：设置日志输出级别\n\n日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：\n\n * trace：运行堆栈信息，使用率低\n * debug：程序员调试代码使用\n * info：记录运维过程数据\n * warn：记录运维过程报警数据\n * error：记录错误堆栈信息\n * fatal：灾难信息，合并计入error\n\n一般情况下，开发时候使用debug，上线后使用info，运维信息记录使用warn即可。下面就设置一下日志级别：\n\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n\n这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制\n\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n# 设置日志级别，root表示根节点，即整体应用日志级别\nlogging:\n\tlevel:\n    \troot: debug\n\n\n还可以再设置更细粒度的控制\n\n步骤③：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别\n\nlogging:\n\t# 设置日志组\n    group:\n    \t# 自定义组名，设置当前组中所包含的包\n        ebank: com.itheima.controller\n    level:\n    \troot: warn\n        # 为对应组设置日志级别\n        ebank: debug\n    \t# 为对应 包设置日志级别\n        com.itheima.controller: debug\n\n\n说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。\n\n总结\n\n 1. 日志用于记录开发调试与运维过程消息\n 2. 日志的级别共6种，通常使用4种即可，分别是debug，info,warn,error\n 3. 可以通过日志组或代码包的形式进行日志显示级别的控制\n\n# 教你一招：优化日志对象创建代码\n\n写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。\n\n\n\n\n\n\n@restcontroller\n@requestmapping("/books")\npublic class bookcontroller extends baseclass{\n    private static final logger log = loggerfactory.getlogger(bookcontroller.class);\t//这一句可以不写了\n}\n\n\n导入lombok后使用注解搞定，日志对象名为log\n\n@slf4j\t\t//这个注解替代了下面那一行\n@restcontroller\n@requestmapping("/books")\npublic class bookcontroller extends baseclass{\n    private static final logger log = loggerfactory.getlogger(bookcontroller.class);\t//这一句可以不写了\n}\n\n\n总结\n\n 1. 基于lombok提供的@slf4j注解为类快速添加日志对象\n\n# yw-4-2.日志输出格式控制\n\n日志已经能够记录了，但是目前记录的格式是springboot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。\n\n\n\n\n\n对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，pid与线程名用于做精准分析。了解这些信息后就可以diy日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。\n\nlogging:\n\tpattern:\n    \tconsole: "%d %clr(%p) --- [%16t] %clr(%-40.40c){cyan} : %m %n"\n\n\n总结\n\n 1. 日志输出格式设置规则（很简单一部分）\n    \n    \n\n# yw-4-3.日志文件\n\n日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。\n\n对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。\n\n记录日志到文件中格式非常简单，设置日志文件名即可。\n\nlogging:\n\tfile:\n    \tname: server.log\n\n\n虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：\n\nlogging:\n\tlogback:\n    \trollingpolicy:\n        \tmax-file-size: 3kb\n            file-name-pattern: server.%d{yyyy-mm-dd}.%i.log\n\n\n以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3kb以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。\n\n总结\n\n 1. 日志记录到文件\n 2. 日志文件格式设置',charsets:{cjk:!0}},{title:"快速入门",frontmatter:{title:"快速入门",date:"2022-03-20T00:00:00.000Z",permalink:"/springboot/001/",categories:["框架","SpringBoot"],tags:["SpringBoot"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/03.SpringBoot/01.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"07.框架/03.SpringBoot/01.快速入门.md",key:"v-5fd81377",path:"/springboot/001/",headers:[{level:2,title:"JC-1.快速上手SpringBoot",slug:"jc-1-快速上手springboot",normalizedTitle:"jc-1.快速上手springboot",charIndex:155},{level:3,title:"JC-1-1.SpringBoot入门程序制作（一）",slug:"jc-1-1-springboot入门程序制作-一",normalizedTitle:"jc-1-1.springboot入门程序制作（一）",charIndex:966},{level:3,title:"JC-1-2.SpringBoot入门程序制作（二）",slug:"jc-1-2-springboot入门程序制作-二",normalizedTitle:"jc-1-2.springboot入门程序制作（二）",charIndex:4694},{level:3,title:"JC-1-3.SpringBoot入门程序制作（三）",slug:"jc-1-3-springboot入门程序制作-三",normalizedTitle:"jc-1-3.springboot入门程序制作（三）",charIndex:5718},{level:3,title:"JC-1-4.SpringBoot入门程序制作（四）",slug:"jc-1-4-springboot入门程序制作-四",normalizedTitle:"jc-1-4.springboot入门程序制作（四）",charIndex:6497},{level:4,title:"教你一招：在Idea中隐藏指定文件/文件夹",slug:"教你一招-在idea中隐藏指定文件-文件夹",normalizedTitle:"教你一招：在idea中隐藏指定文件/文件夹",charIndex:8735},{level:3,title:"JC-1-5.SpringBoot简介",slug:"jc-1-5-springboot简介",normalizedTitle:"jc-1-5.springboot简介",charIndex:9398},{level:4,title:"parent",slug:"parent",normalizedTitle:"parent",charIndex:2764},{level:4,title:"starter",slug:"starter",normalizedTitle:"starter",charIndex:2862},{level:4,title:"引导类",slug:"引导类",normalizedTitle:"引导类",charIndex:8626},{level:4,title:"内嵌tomcat",slug:"内嵌tomcat",normalizedTitle:"内嵌tomcat",charIndex:10795},{level:2,title:"JC-2.SpringBoot基础配置",slug:"jc-2-springboot基础配置",normalizedTitle:"jc-2.springboot基础配置",charIndex:26833},{level:3,title:"JC-2-1.属性配置",slug:"jc-2-1-属性配置",normalizedTitle:"jc-2-1.属性配置",charIndex:27397},{level:3,title:"JC-2-2.配置文件分类",slug:"jc-2-2-配置文件分类",normalizedTitle:"jc-2-2.配置文件分类",charIndex:29310},{level:4,title:"配置文件优先级",slug:"配置文件优先级",normalizedTitle:"配置文件优先级",charIndex:30141},{level:4,title:"教你一招：自动提示功能消失解决方案",slug:"教你一招-自动提示功能消失解决方案",normalizedTitle:"教你一招：自动提示功能消失解决方案",charIndex:31147},{level:3,title:"JC-2-3.yaml文件",slug:"jc-2-3-yaml文件",normalizedTitle:"jc-2-3.yaml文件",charIndex:31894},{level:3,title:"JC-2-4.yaml数据读取",slug:"jc-2-4-yaml数据读取",normalizedTitle:"jc-2-4.yaml数据读取",charIndex:33591},{level:4,title:"读取单一数据",slug:"读取单一数据",normalizedTitle:"读取单一数据",charIndex:33703},{level:4,title:"读取全部数据",slug:"读取全部数据",normalizedTitle:"读取全部数据",charIndex:33909},{level:4,title:"读取对象数据",slug:"读取对象数据",normalizedTitle:"读取对象数据",charIndex:34208},{level:4,title:"yaml文件中的数据引用",slug:"yaml文件中的数据引用",normalizedTitle:"yaml文件中的数据引用",charIndex:34788},{level:2,title:"JC-3.基于SpringBoot实现SSMP整合",slug:"jc-3-基于springboot实现ssmp整合",normalizedTitle:"jc-3.基于springboot实现ssmp整合",charIndex:35522},{level:3,title:"JC-3-1.整合JUnit",slug:"jc-3-1-整合junit",normalizedTitle:"jc-3-1.整合junit",charIndex:35773},{level:3,title:"JC-3-2.整合MyBatis",slug:"jc-3-2-整合mybatis",normalizedTitle:"jc-3-2.整合mybatis",charIndex:38252},{level:3,title:"JC-3-3.整合MyBatis-Plus",slug:"jc-3-3-整合mybatis-plus",normalizedTitle:"jc-3-3.整合mybatis-plus",charIndex:43976},{level:3,title:"JC-3-4.整合Druid",slug:"jc-3-4-整合druid",normalizedTitle:"jc-3-4.整合druid",charIndex:45796},{level:3,title:"JC-3-5.SSMP整合综合案例",slug:"jc-3-5-ssmp整合综合案例",normalizedTitle:"jc-3-5.ssmp整合综合案例",charIndex:48407},{level:4,title:"0.模块创建",slug:"_0-模块创建",normalizedTitle:"0.模块创建",charIndex:49170},{level:4,title:"1.实体类开发",slug:"_1-实体类开发",normalizedTitle:"1.实体类开发",charIndex:49771},{level:4,title:"2.数据层开发——基础CRUD",slug:"_2-数据层开发-基础crud",normalizedTitle:"2.数据层开发——基础crud",charIndex:52613},{level:5,title:"查看MP运行日志",slug:"查看mp运行日志",normalizedTitle:"查看mp运行日志",charIndex:55389},{level:4,title:"3.数据层开发——分页功能制作",slug:"_3-数据层开发-分页功能制作",normalizedTitle:"3.数据层开发——分页功能制作",charIndex:57565},{level:4,title:"4.数据层开发——条件查询功能制作",slug:"_4-数据层开发-条件查询功能制作",normalizedTitle:"4.数据层开发——条件查询功能制作",charIndex:59654},{level:4,title:"5.业务层开发",slug:"_5-业务层开发",normalizedTitle:"5.业务层开发",charIndex:61043},{level:5,title:"业务层快速开发",slug:"业务层快速开发",normalizedTitle:"业务层快速开发",charIndex:64159},{level:4,title:"6.表现层开发",slug:"_6-表现层开发",normalizedTitle:"6.表现层开发",charIndex:64797},{level:4,title:"7.表现层消息一致性处理",slug:"_7-表现层消息一致性处理",normalizedTitle:"7.表现层消息一致性处理",charIndex:66106},{level:4,title:"8.前后端联通性测试",slug:"_8-前后端联通性测试",normalizedTitle:"8.前后端联通性测试",charIndex:67158},{level:4,title:"9.页面基础功能开发",slug:"_9-页面基础功能开发",normalizedTitle:"9.页面基础功能开发",charIndex:67572},{level:5,title:"F-1.列表功能（非分页版）",slug:"f-1-列表功能-非分页版",normalizedTitle:"f-1.列表功能（非分页版）",charIndex:67586},{level:5,title:"F-2.添加功能",slug:"f-2-添加功能",normalizedTitle:"f-2.添加功能",charIndex:67912},{level:5,title:"F-3.删除功能",slug:"f-3-删除功能",normalizedTitle:"f-3.删除功能",charIndex:69124},{level:5,title:"F-4.修改功能",slug:"f-4-修改功能",normalizedTitle:"f-4.修改功能",charIndex:70072},{level:4,title:"10.业务消息一致性处理",slug:"_10-业务消息一致性处理",normalizedTitle:"10.业务消息一致性处理",charIndex:71221},{level:4,title:"11.页面功能开发",slug:"_11-页面功能开发",normalizedTitle:"11.页面功能开发",charIndex:72991},{level:5,title:"F-5.分页功能",slug:"f-5-分页功能",normalizedTitle:"f-5.分页功能",charIndex:73004},{level:5,title:"F-6.删除功能维护",slug:"f-6-删除功能维护",normalizedTitle:"f-6.删除功能维护",charIndex:74473},{level:5,title:"F-7.条件查询功能",slug:"f-7-条件查询功能",normalizedTitle:"f-7.条件查询功能",charIndex:74982},{level:2,title:"基础篇完结",slug:"基础篇完结",normalizedTitle:"基础篇完结",charIndex:78444}],headersStr:"JC-1.快速上手SpringBoot JC-1-1.SpringBoot入门程序制作（一） JC-1-2.SpringBoot入门程序制作（二） JC-1-3.SpringBoot入门程序制作（三） JC-1-4.SpringBoot入门程序制作（四） 教你一招：在Idea中隐藏指定文件/文件夹 JC-1-5.SpringBoot简介 parent starter 引导类 内嵌tomcat JC-2.SpringBoot基础配置 JC-2-1.属性配置 JC-2-2.配置文件分类 配置文件优先级 教你一招：自动提示功能消失解决方案 JC-2-3.yaml文件 JC-2-4.yaml数据读取 读取单一数据 读取全部数据 读取对象数据 yaml文件中的数据引用 JC-3.基于SpringBoot实现SSMP整合 JC-3-1.整合JUnit JC-3-2.整合MyBatis JC-3-3.整合MyBatis-Plus JC-3-4.整合Druid JC-3-5.SSMP整合综合案例 0.模块创建 1.实体类开发 2.数据层开发——基础CRUD 查看MP运行日志 3.数据层开发——分页功能制作 4.数据层开发——条件查询功能制作 5.业务层开发 业务层快速开发 6.表现层开发 7.表现层消息一致性处理 8.前后端联通性测试 9.页面基础功能开发 F-1.列表功能（非分页版） F-2.添加功能 F-3.删除功能 F-4.修改功能 10.业务消息一致性处理 11.页面功能开发 F-5.分页功能 F-6.删除功能维护 F-7.条件查询功能 基础篇完结",content:'# SpringBoot基础篇\n\n在基础篇中，我给学习者的定位是先上手，能够使用SpringBoot搭建基于SpringBoot的web项目开发，所以内容设置较少，主要包含如下内容：\n\n * SpringBoot快速入门\n * SpringBoot基础配置\n * 基于SpringBoot整合SSMP\n\n\n# JC-1.快速上手SpringBoot\n\n学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot技术由Pivotal团队研发制作，功能的话简单概括就是加速Spring程序的开发，这个加速要从如下两个方面来说\n\n * Spring程序初始搭建过程\n * Spring程序的开发过程\n\n通过上面两个方面的定位，我们可以产生两个模糊的概念：\n\n 1. SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子\n 2. SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？\n\n带着上面这些疑问我们就着手第一个SpringBoot程序的开发了，看看到底使用SpringBoot技术能简化开发到什么程度。\n\n温馨提示\n\n如果对Spring程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备Spring技术的知识，硬着头皮学不下去的。\n\n\n# JC-1-1.SpringBoot入门程序制作（一）\n\n下面让我们开始做第一个SpringBoot程序吧，本课程基于Idea2020.3版本制作，使用的Maven版本为3.6.1，JDK版本为1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个Idea和Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。\n\n下面使用SpringBoot技术快速构建一个SpringMVC的程序，通过这个过程体会简化二字的含义\n\n步骤①：创建新模块，选择Spring Initializr，并配置模块相关基础信息\n\n\n\n特别关注：第3步点击Next时，Idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直联网转转转\n\n特别关注：第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11\n\n步骤②：选择当前模块需要使用的技术集\n\n\n\n按照要求，左侧选择web，然后在中间选择Spring Web即可，选完右侧就出现了新的内容项，这就表示勾选成功了\n\n关注：此处选择的SpringBoot的版本使用默认的就可以了，需要说一点，SpringBoot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，回头可以到配置文件中修改对应的版本\n\n步骤③：开发控制器类\n\n//Rest模式\n@RestController\n@RequestMapping("/books")\npublic class BookController {\n    @GetMapping\n    public String getById(){\n        System.out.println("springboot is running...");\n        return "springboot is running...";\n    }\n}\n\n\n入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作SpringMVC的程序也是没有问题的，上例中的@RestController与@GetMapping注解是基于Restful开发的典型注解\n\n关注：做到这里SpringBoot程序的最基础的开发已经做完了，现在就可以正常的运行Spring程序了。可能有些小伙伴会有疑惑，Tomcat服务器没有配置，=-Spring也没有配置，什么都没有配置这就能用吗？这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程\n\n步骤④：运行自动生成的Application类\n\n\n\n使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。\n\n不难看出，运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了\n\n访问路径：\thttp://localhost:8080/books\n\n\n是不是感觉很神奇？目前的效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前\n\n * pom.xml\n   \n   这是maven的配置文件，描述了当前工程构建时相应的配置信息\n   \n   <?xml version="1.0" encoding="UTF-8"?>\n   <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n       <modelVersion>4.0.0</modelVersion>\n   \n       <parent>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-parent</artifactId>\n           <version>2.5.4</version>\n       </parent>\n   \n       <groupId>com.itheima</groupId>\n       <artifactId>springboot_01_01_quickstart</artifactId>\n       <version>0.0.1-SNAPSHOT</version>\n   \n       <dependencies>\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n   \n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-test</artifactId>\n               <scope>test</scope>\n           </dependency>\n       </dependencies>\n   </project>\n   \n   \n   配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说\n\n * Application类\n   \n   @SpringBootApplication\n   public class Application {\n       public static void main(String[] args) {\n           SpringApplication.run(Application.class, args);\n       }\n   }\n   \n   \n   这个类功能很简单，就一句代码，前面运行程序就是运行的这个类\n\n到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot肯定没法玩，看来核心就是这两个文件了。由于是制作第一个SpringBoot程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。\n\n通过上面的制作，我们不难发现，SpringBoot程序简直太好写了，几乎什么都没写，功能就有了，这也是SpringBoot技术为什么现在这么火的原因，和Spirng程序相比，SpringBoot程序在开发的过程中各个层面均具有优势\n\n类配置文件                 SPRING   SPRINGBOOT\npom文件中的坐标             手工添加     勾选添加\nweb3.0配置类             手工制作     无\nSpring/SpringMVC配置类   手工制作     无\n控制器                   手工制作     手工制作\n\n一句话总结一下就是能少写就少写，能不写就不写，这就是SpringBoot技术给我们带来的好处，行了，现在你就可以动手做一做SpringBoot程序了，看看效果如何，是否真的帮助你简化开发了\n\n总结\n\n 1. 开发SpringBoot程序可以根据向导进行联网快速制作\n 2. SpringBoot程序需要基于JDK8以上版本进行制作\n 3. SpringBoot程序中需要使用何种功能通过勾选选择技术，也可以手工添加对应的要使用的技术（后期讲解）\n 4. 运行SpringBoot程序通过运行Application程序入口进行\n\n思考\n\n前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于Idea开发时，你会发现你配置了一些坐标，然后Maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这和Idea这款IDE工具有关，万一Idea不能正常访问网络的话，我们是不是就无法制作SpringBoot程序了呢？咱们下一节再说\n\n\n# JC-1-2.SpringBoot入门程序制作（二）\n\n如果Idea不能正常联网，这个SpringBoot程序就无法制作了吗？开什么玩笑，世上IDE工具千千万，难道SpringBoot技术还必须基于Idea来做了？这是不可能的。开发SpringBoot程序，可以不基于任意的IDE工具进行，其实在SpringBoot的官网里面就可以直接创建SpringBoot程序\n\nSpringBoot官网和Spring的官网是在一起的，都是 spring.io 。你可以通过项目一级一级的找到SpringBoot技术的介绍页，然后在页面中间部位找到如下内容\n\n步骤①：点击Spring Initializr后进入到创建SpringBoot程序的界面上，下面是输入信息的过程，和前面的一样，只是界面变了而已，根据自己的要求，在左侧选择对应信息和输入对应的信息即可\n\n步骤②：右侧的ADD DEPENDENCIES用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面\n\n步骤③：所有信息设置完毕后，点击下面左侧按钮，生成一个文件包\n\n\n\n步骤④：保存后得到一个压缩文件，这个文件打开后就是创建的SpringBoot工程文件夹了\n\n\n\n步骤⑤：解压缩此文件后，得到工程目录，在Idea中导入即可使用，和之前创建的东西完全一样。下面就可以自己创建一个Controller测试一下是否能用了。\n\n温馨提示\n\n做到这里其实可以透漏一个小秘密，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，走的就是这个过程，只不过Idea把界面给整合了一下，读取到了Spring官网给的信息，然后展示到了Idea的界面中而已，不信你可以看看下面这个步骤\n\n上面描述了连接的网址，再看看SpringBoot官网创建工程的URL地址，是不是一样？\n\n总结\n\n 1. 打开SpringBoot官网，选择Quickstart Your Project\n\n 2. 创建工程\n    \n    并保存项目\n    \n    \n\n 3. 解压项目，通过IDE导入项目\n\n思考\n\n现在创建工程靠的是访问国外的Spring主站，但是互联网访问是可以控制的，如果一天这个网站你在国内都无法访问了，那前面这两种方式都无法创建SpringBoot工程了，这时候又该怎么解决这个问题呢？咱们下一节再说\n\n\n# JC-1-3.SpringBoot入门程序制作（三）\n\n前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实都是走的同一个地方，也就是SpringBoot的官网创建的SpringBoot工程，那如果我们国内有这么一个网站能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，这个国内的网站有吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就OK了，没错，就是这样\n\n创建工程时，切换选择starter服务路径，然后手工收入阿里云提供给我们的使用地址即可。地址：http://start.aliyun.com或https://start.aliyun.com\n\n\n\n阿里为了便于自己开发使用，因此在依赖坐标中添加了一些阿里相关的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。不过有一点需要说清楚，阿里云地址默认创建的SpringBoot工程版本是2.4.1，所以如果你想更换其他的版本，创建项目后手工修改即可，别忘了刷新一下，加载新版本信息\n\n\n\n阿里云提供的地址更符合国内开发者的使用习惯，里面有一些SpringBoot官网上没有给出的坐标，大家可以好好看一看。\n\n注意：阿里云提供的工程创建地址初始化完毕后和实用SpringBoot官网创建出来的工程略有区别。主要是在配置文件的形式上有区别。这个信息在后面讲解Boot程序的执行流程时给大家揭晓\n\n总结\n\n 1. 选择start来源为自定义URL\n 2. 输入阿里云start地址\n 3. 创建项目\n\n思考\n\n做到这里我们已经有了三种方式创建SpringBoot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，整个事情是不是就不能做了呢？咱们下一节再说\n\n\n# JC-1-4.SpringBoot入门程序制作（四）\n\n不能上网，还想创建SpringBoot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个信息找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。\n\n联网做什么呢？首先SpringBoot工程也是基于Maven构建的，而Maven工程当使用了一些自己需要使用又不存在的东西时，就要去下载。其实SpringBoot工程创建的时候就是去下载一些必要的组件的。你把这些东西给提前准备好就可以了吗？是的，就是这样。\n\n下面咱们就一起手工创建一个SpringBoot工程\n\n步骤①：创建工程时，选择手工创建Maven工程\n\n步骤②：参照标准SpringBoot工程的pom文件，书写自己的pom文件即可\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.4</version>\n    </parent>\n\n    <groupId>com.itheima</groupId>\n    <artifactId>springboot_01_04_quickstart</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用\n\n步骤③：之前运行SpringBoot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称一切修改即可\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class);\n    }\n}\n\n\n关注：类上面的注解@SpringBootApplication千万别丢了，这个是核心，后面再介绍\n\n关注：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称\n\n步骤④：下面就可以自己创建一个Controller测试一下是否能用了，和之前没有差别了\n\n看到这里其实应该能够想明白了，通过向导或者网站创建的SpringBoot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。\n\n温馨提示\n\n如果你的计算机上从来没有创建成功过SpringBoot工程，自然也就没有下载过SpringBoot对应的坐标，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的\n\n总结\n\n 1. 创建普通Maven工程\n 2. 继承spring-boot-starter-parent\n 3. 添加依赖spring-boot-starter-web\n 4. 制作引导类Application\n\n到这里其实学习了4种创建SpringBoot工程的方式，其实本质是一样的，就是根据SpringBoot工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。\n\n# 教你一招：在Idea中隐藏指定文件/文件夹\n\n创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的SpringBoot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。\n\n处理方案无外乎两种，如果你对每一个文件/目录足够了解，没有用的完全可以删除掉，或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。\n\n既然是在Idea下做隐藏功能，肯定隶属于Idea的设置，设置方式如下。\n\n步骤①：打开设置，【Files】→【Settings】\n\n步骤②：打开文件类型设置界面，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示\n\n步骤③：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可(这里就把.mvn文件夹点击Apply之后就被隐藏了)\n\n\n\n到这里就做完了，其实就是Idea的一个小功能\n\n总结\n\n 1. Idea中隐藏指定文件或指定类型文件\n    1. 【Files】→【Settings】\n    2. 【Editor】→【File Types】→【Ignored Files and Folders】\n    3. 输入要隐藏的名称，支持*号通配符\n    4. 回车确认添加\n\n\n# JC-1-5.SpringBoot简介\n\n入门案例做完了，这个时候回忆一下咱们之前说的SpringBoot的功能是什么还记得吗？加速Spring程序的开发，现在是否深有体会？再来看SpringBoot技术的设计初衷就很容易理解了。\n\nSpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。\n\n都简化了了哪些东西呢？其实就是针对原始的Spring程序制作的两个方面进行了简化：\n\n * Spring程序缺点\n   * 依赖设置繁琐\n     * 以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标时必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定面\n   * 配置繁琐\n     * 以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用\n\n> 回顾\n> \n> 通过上面两个方面的定位，我们可以产生两个模糊的概念：\n> \n>  1. SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子\n>  2. SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？\n\n再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是SpringBoot给我们带来的好处。这些简化操作在SpringBoot中有专业的用语，也是SpringBoot程序的核心功能及优点：\n\n * 起步依赖（简化依赖配置）\n   * 依赖配置的书写简化就是靠这个起步依赖达成的\n * 自动配置（简化常用工程相关配置）\n   * 配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的，后面具体展开说\n * 辅助功能（内置服务器，……）\n   * 除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot程序的一个可以感知到的功能，也是SpringBoot的辅助功能之一。一个辅助功能都能做的这么6，太牛了\n\n下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面\n\n * parent\n * starter\n * 引导类\n * 内嵌tomcat\n\n# parent\n\nSpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版与B技术的3.5版可以合作在一起，但是和B技术的3.7版合并使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。\n\nSpringBoot一看这种情况so easy啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于SpringBoot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做parent。\n\nparent自身具有很多个版本，每个parent版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用SpringBoot提供的parent就行了，由parent帮助开发者统一的进行各种技术的版本管理\n\n比如你现在要使用Spring配合MyBatis开发，没有parent之前怎么做呢？选个Spring的版本，再选个MyBatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你Spring的版本发生变化需要切换时，你的MyBatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由parent负责处理。\n\n有人可能会提出来，万一parent给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，parent仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，使用parent可以帮助开发者进行版本的统一管理\n\n关注：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚\n\n那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义\n\n * 项目中的pom.xml中继承了一个坐标\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.5.4</version>\n</parent>\n\n\n * 打开后可以查阅到其中又继承了一个坐标\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.5.4</version>\n</parent>\n\n\n * 这个坐标中定义了两组信息，第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号\n\n<properties>\n    <activemq.version>5.16.3</activemq.version>\n    <aspectj.version>1.9.7</aspectj.version>\n    <assertj.version>3.19.0</assertj.version>\n    <commons-codec.version>1.15</commons-codec.version>\n    <commons-dbcp2.version>2.8.0</commons-dbcp2.version>\n    <commons-lang3.version>3.12.0</commons-lang3.version>\n    <commons-pool.version>1.6</commons-pool.version>\n    <commons-pool2.version>2.9.0</commons-pool2.version>\n    <h2.version>1.4.200</h2.version>\n    <hibernate.version>5.4.32.Final</hibernate.version>\n    <hibernate-validator.version>6.2.0.Final</hibernate-validator.version>\n    <httpclient.version>4.5.13</httpclient.version>\n    <jackson-bom.version>2.12.4</jackson-bom.version>\n    <javax-jms.version>2.0.1</javax-jms.version>\n    <javax-json.version>1.1.4</javax-json.version>\n    <javax-websocket.version>1.1</javax-websocket.version>\n    <jetty-el.version>9.0.48</jetty-el.version>\n    <junit.version>4.13.2</junit.version>\n</properties>\n\n\n第二组是各式各样的的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值\n\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.hibernate</groupId>\n            <artifactId>hibernate-core</artifactId>\n            <version>${hibernate.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>${junit.version}</version>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n\n关注：上面的依赖坐标定义是出现在<dependencyManagement>标签中的，其实是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的\n\n关注：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式\n\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>${spring-boot.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n\n总结\n\n 1. 开发SpringBoot程序要继承spring-boot-starter-parent\n 2. spring-boot-starter-parent中定义了若干个依赖管理\n 3. 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突\n 4. 继承parent的形式也可以采用引入依赖的形式实现效果\n 5. 如果不指定版本，SpringBoot里面也会默认根据parent调用最合适的版本（这个是我自己添加的）\n\n思考\n\nparent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？\n\n# starter\n\nSpringBoot关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。\n\nSpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做starter。\n\nstarter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，使用starter可以帮助开发者减少依赖配置\n\n这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅SpringBoot的配置源码，看到这些定义\n\n * 项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n * 在spring-boot-starter-web中又定义了若干个具体依赖的坐标\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-json</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-tomcat</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n之前提到过开发SpringMVC程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。\n\n但是我们发现除了这两个还有其他的，比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.datatype</groupId>\n        <artifactId>jackson-datatype-jdk8</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.datatype</groupId>\n        <artifactId>jackson-datatype-jsr310</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.module</groupId>\n        <artifactId>jackson-module-parameter-names</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。\n\n到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。\n\nstarter与parent的区别\n\n朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。\n\nstarter是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的\n\nparent是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的\n\n实际开发应用方式\n\n * 实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter\n   \n   * 如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供\n   * 如果没有对应的starter，手写坐标即可\n\n * 实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理\n   \n   * 方式一：直接写坐标\n   * 方式二：覆盖<properties>中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了\n   \n   <properties>\n       <activemq.version>5.16.3</activemq.version>\n       <aspectj.version>1.9.7</aspectj.version>\n       <assertj.version>3.19.0</assertj.version>\n       <commons-codec.version>1.15</commons-codec.version>\n       <commons-dbcp2.version>2.8.0</commons-dbcp2.version>\n       <commons-lang3.version>3.12.0</commons-lang3.version>\n       <commons-pool.version>1.6</commons-pool.version>\n       <commons-pool2.version>2.9.0</commons-pool2.version>\n       <h2.version>1.4.200</h2.version>\n       <hibernate.version>5.4.32.Final</hibernate.version>\n       <hibernate-validator.version>6.2.0.Final</hibernate-validator.version>\n       <httpclient.version>4.5.13</httpclient.version>\n       <jackson-bom.version>2.12.4</jackson-bom.version>\n       <javax-jms.version>2.0.1</javax-jms.version>\n       <javax-json.version>1.1.4</javax-json.version>\n       <javax-websocket.version>1.1</javax-websocket.version>\n       <jetty-el.version>9.0.48</jetty-el.version>\n       <junit.version>4.13.2</junit.version>\n   </properties>\n   \n\n温馨提示\n\nSpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式\n\n命名规则：spring-boot-starter-技术名称\n\n\n所以以后见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合章节再说\n\n总结\n\n 1. 开发SpringBoot程序需要导入坐标时通常导入对应的starter\n 2. 每个不同的starter根据功能不同，通常包含多个依赖坐标\n 3. 使用starter可以实现快速配置的效果，达到简化配置的目的\n\n# 引导类\n\n配置说完了，我们发现SpringBoot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类了，带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行\n\n@SpringBootApplication\npublic class Springboot0101QuickstartApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot0101QuickstartApplication.class, args);\n    }\n}\n\n\nSpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建自己的Spring容器对象（IoC容器）并将所有的对象交给Spring的容器管理，也就是一个一个的Bean。那还了SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。\n\n@SpringBootApplication\npublic class Springboot0101QuickstartApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext ctx = SpringApplication.run(Springboot0101QuickstartApplication.class, args);\n        BookController bean = ctx.getBean(BookController.class);\n        System.out.println("bean======>" + bean);\n    }\n}\n\n\n\n\n通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。这个类在SpringBoot程序中是所有功能的入口，称这个类为引导类。\n\n作为一个引导类最典型的特征就是当前类上方声明了一个注解@SpringBootApplication\n\n总结\n\n 1. SpringBoot工程提供引导类用来启动程序\n 2. SpringBoot工程启动后创建并初始化Spring容器\n\n思考\n\n程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？\n\n# 内嵌tomcat\n\n当前我们做的SpringBoot入门案例勾选了Spirng-web的功能，并且导入了对应的starter。\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\nSpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西。我帮你搞一个web服务器，你要愿意用的，直接使用就好了，干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。\n\n由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。\n\n下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题\n\n 1. 这个服务器在什么位置定义的\n 2. 这个服务器是怎么运行的\n 3. 这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾\n\n内嵌Tomcat定义位置\n\n说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n打开查看web的starter导入了哪些东西\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-json</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-tomcat</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n第三个依赖就是这个tomcat对应的东西了，居然也是一个starter，再打开看看\n\n<dependencies>\n    <dependency>\n        <groupId>jakarta.annotation</groupId>\n        <artifactId>jakarta.annotation-api</artifactId>\n        <version>1.3.5</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-core</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactId>tomcat-annotations-api</artifactId>\n                <groupId>org.apache.tomcat</groupId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-el</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-websocket</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactId>tomcat-annotations-api</artifactId>\n                <groupId>org.apache.tomcat</groupId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n\n这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能，再来说第二个问题，这个服务器是怎么运行的\n\n内嵌Tomcat运行原理\n\nTomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉的小伙伴可能有印象，tomcat安装目录中保存有jar，好多个jar。\n\n下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象。\n\n如果是对象，那Spring容器是用来管理对象的，这个对象能不能交给Spring容器管理呢？把吗去掉，是个对象都可以交给Spring容器管理，行了，这下通了。tomcat服务器运行其实是以对象的形式在Spring容器中运行的，怪不得我们没有安装这个tomcat，而且还能用。闹了半天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心\n\n<dependencies>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-core</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n\n上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后会等着用户发请求，而是直接停掉了，就是这个原因了。\n\n更换内嵌Tomcat\n\n那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器\n\n * tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件\n\n * jetty：更轻量级，负载性能远不及tomcat\n\n * undertow：负载性能勉强跑赢tomcat\n   \n   想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jetty</artifactId>\n    </dependency>\n</dependencies>\n\n\n现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。\n\n总结\n\n 1. 内嵌Tomcat服务器是SpringBoot辅助功能之一\n 2. 内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理\n 3. 变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n到这里第一章快速上手SpringBoot就结束了，这一章我们学习了两大块知识\n\n 1. 使用了4种方式制作了SpringBoot的入门程序，不管是哪一种，其实内部都是一模一样的\n 2. 学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等\n\n第一章到这里就结束了，再往下学习就要去基于会创建SpringBoot工程的基础上，研究SpringBoot工程的具体细节了。\n\n\n# JC-2.SpringBoot基础配置\n\n入门案例做完了，下面就要研究SpringBoot的用法了。通过入门案例，各位小伙伴能够感知到一个信息，SpringBoot没有具体的功能，它在辅助加快Spring程序的开发效率。我们发现现在几乎不用做任何的配置，功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。\n\n如果我们想修改默认的配置i，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖的，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行SpringBoot程序的入口，也不像是做配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么干预SpringBoot的默认配置，修改成自己的配置。\n\n.iml文件是idea的配置文件，idea导入一个工程就会自动生成，因此复制的工程可以删除\n\n复制的工程中的name和discibtion可以删除\n\n\n\n\n\n\n# JC-2-1.属性配置\n\nSpringBoot通过配置文件resources/application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的\n\n\n\n那该如何写呢？properties格式的文件书写规范是key=value\n\nname=itheima\n\n\n这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。当你输入port后，神奇的事情就发生了，这玩意儿带提示，太好了\n\n根据提示敲回车，输入80端口，搞定\n\nserver.port=80\n\n\n下面就可以直接运行程序，测试效果了。\n\n我们惊奇的发现SpringBoot这玩意儿狠啊，以前修改端口在哪里改？tomcat服务器的配置文件中改，现在呢？SpringBoot专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。\n\n其实到这里我们应该得到如下三个信息\n\n 1. SpringBoot程序可以在application.properties文件中进行属性配置\n 2. application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置\n 3. SpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面\n\n总结\n\n 1. SpringBoot默认配置文件是application.properties\n\n做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。\n\n关闭运行日志图表（banner)\n\nspring.main.banner-mode=off\n\n\n设置运行日志的显示级别\n\nlogging.level.root=debug\n\n\n你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。SpringBoot比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。\n\n我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。\n\n打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties\n\n能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然配置的东西都没有使用对应技术，配了也是白配。\n\n温馨提示\n\n所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n    <version>2.5.4</version>\n    <scope>compile</scope>\n</dependency>\n\n\n总结\n\n 1. SpringBoot中导入对应starter后，提供对应配置属性\n 2. 书写SpringBoot配置采用关键字+提示形式书写\n\n\n# JC-2-2.配置文件分类\n\n现在已经能够进行SpringBoot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。分别如下:\n\n * properties格式\n\n * yml格式\n\n * yaml格式\n   \n   一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为SpringBoot的配置在Idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下\n\n * application.properties（properties格式）\n\nserver.port=80\n\n\n * application.yml（yml格式）\n\nserver:\n  port: 81\n\n\n * application.yaml（yaml格式）\n\nserver:\n  port: 82\n\n\n仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。\n\n总结\n\n 1. SpringBoot提供了3种配置文件的格式\n    * properties（传统格式/默认格式）\n    * yml（主流格式）\n    * yaml\n\n思考\n\n现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？\n\n# 配置文件优先级\n\n其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。\n\n * application.properties（properties格式）\n\nserver.port=80\n\n\n * application.yml（yml格式）\n\nserver:\n  port: 81\n\n\n * application.yaml（yaml格式）\n\nserver:\n  port: 82\n\n\n启动后发现目前的启动端口为80，把80对应的文件删除掉，然后再启动，现在端口又改成了81。现在我们就已经知道了3个文件的加载优先顺序是什么\n\napplication.properties  >  application.yml  >  application.yaml\n\n\n虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。\n\n最后我们把配置文件内容给修改一下\n\n * application.properties（properties格式）\n\nserver.port=80\nspring.main.banner-mode=off\n\n\n * application.yml（yml格式）\n\nserver:\n  port: 81\nlogging: \n  level: \n    root: debug\n\n\n * application.yaml（yaml格式）\n\nserver:\n  port: 82\n\n\n我们发现不仅端口生效了，最终显示80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，那所有的配置项都会生效。\n\n总结\n\n 1. 配置文件间的加载优先级 properties（最高）> yml > yaml（最低）\n 2. 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\n# 教你一招：自动提示功能消失解决方案\n\n可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。\n\n先要明确一个核心，就是自动提示功能不是SpringBoot技术给我们提供的，是我们在Idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下3种：\n\n 1. Idea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能\n\n 2. Idea认定你是合理的配置文件，但是Idea加载不到对应的提示信息\n    \n    这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：\n\n步骤①：打开设置，【Files】→【Project Structure...】\n\n\n\n步骤②：在弹出窗口中左侧选择【Facets】，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块\n\n\n\n步骤③：点击Customize Spring Boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示\n\n\n\n步骤④：选择添加配置文件，然后选中要作为配置文件的具体文件就OK了\n\n\n\n到这里就做完了，其实就是Idea的一个小功能\n\n\n\n总结\n\n 1. 指定SpringBoot配置文件\n    \n    * Setting → Project Structure → Facets\n    * 选中对应项目/工程\n    * Customize Spring Boot\n    * 选择配置文件\n\n\n# JC-2-3.yaml文件\n\nSpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。\n\nYAML（YAML Ain\'t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：\n\n * .yml格式（主流）\n\n * .yaml格式\n   \n   对于文件自身在书写时，具有严格的语法格式要求，具体如下：\n\n 1. 大小写敏感\n 2. 属性层级关系使用多行描述，每行结尾使用冒号结束\n 3. 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n 4. 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n 5. #号 表示注释\n\n上述规则不要死记硬背，按照书写习惯慢慢适应，并且在Idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，数据前面要加空格与冒号隔开\n\n下面列出常见的数据书写格式，熟悉一下\n\nboolean: TRUE  \t\t\t\t\t\t#TRUE,true,True,FALSE,false，False均可\nfloat: 3.14    \t\t\t\t\t\t#6.8523015e+5  #支持科学计数法\nint: 123       \t\t\t\t\t\t#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制\nnull: ~        \t\t\t\t\t\t#使用~表示null\nstring: HelloWorld      \t\t\t#字符串可以直接书写\nstring2: "Hello World"  \t\t\t#可以使用双引号包裹特殊字符\ndate: 2018-02-17        \t\t\t#日期必须使用yyyy-MM-dd格式\ndatetime: 2018-02-17T15:02:31+08:00  #时间和日期之间使用T连接，最后使用+代表时区\n\n\n此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔\n\nsubject:\n\t- Java\n\t- 前端\n\t- 大数据\nenterprise:\n\tname: itcast\n    age: 16\n    subject:\n    \t- Java\n        - 前端\n        - 大数据\nlikes: [王者荣耀,刺激战场]\t\t\t#数组书写缩略格式\nusers:\t\t\t\t\t\t\t #对象数组格式一\n  - name: Tom\n   \tage: 4\n  - name: Jerry\n    age: 5\n\n\nusers:\t\t\t\t\t\t\t #对象数组格式二\n  -  \n    name: Tom\n    age: 4\n  -   \n    name: Jerry\n    age: 5\t\t\t    \nusers2: [ { name:Tom , age:4 } , { name:Jerry , age:5 } ]\t#对象数组缩略格式\n\n\n总结\n\n 1. yaml语法规则\n    * 大小写敏感\n    * 属性层级关系使用多行描述，每行结尾使用冒号结束\n    * 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n    * 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n    * #号 表示注释\n 2. 注意属性名冒号后面与数据之间有一个空格\n 3. 字面值、对象数据格式、数组数据格式\n\n思考\n\n现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据时给谁用的呢？大部分是SpringBoot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？咱们下一节再说。\n\n\n# JC-2-4.yaml数据读取\n\n对于yaml文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式\n\n# 读取单一数据\n\nyaml中保存的单个数据，可以使用Spring中的注解直接读取，使用@Value可以读取单个数据，属性名引用方式：${一级属性名.二级属性名……}\n\n记得使用@Value注解时，要将该注入写在某一个指定的Spring管控的bean的属性名上方。现在就可以读取到对应的单一数据行了\n\n总结\n\n 1. 使用@Value配合SpEL读取单个数据\n 2. 如果数据存在多层级，依次书写层级名称即可\n\n# 读取全部数据\n\n读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中\n\n数据封装到了Environment对象中，获取属性时，通过Environment的接口操作进行，具体方法时getProperties（String），参数填写属性名即可\n\n总结\n\n 1. 使用Environment对象封装全部配置信息\n 2. 使用@Autowired自动装配数据到Environment对象中\n\n# 读取对象数据\n\n单一数据读取书写比较繁琐，全数据封装又封装的太厉害了，每次拿数据还要一个一个的getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作\n\n首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。\n\n这个@ConfigurationProperties必须告诉他加载的数据前缀是什么，这样当前前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可，然后重写tostring和get、set方法。\n\n\n\n温馨提示\n\n细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，是这样的，咱们到原理篇再揭秘如何弹出提示。\n\n总结\n\n 1. 使用@ConfigurationProperties注解绑定配置信息到封装类中\n 2. 封装类需要定义为Spring管理的bean，否则无法进行属性注入\n\n# yaml文件中的数据引用\n\n如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀\n\ncenter:\n\tdataDir: /usr/local/fire/data\n    tmpDir: /usr/local/fire/tmp\n    logDir: /usr/local/fire/log\n    msgDir: /usr/local/fire/msgDir\n\n\n或者\n\ncenter:\n\tdataDir: D:/usr/local/fire/data\n    tmpDir: D:/usr/local/fire/tmp\n    logDir: D:/usr/local/fire/log\n    msgDir: D:/usr/local/fire/msgDir\n\n\n这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：\n\nbaseDir: /usr/local/fire\n\tcenter:\n    dataDir: ${baseDir}/data\n    tmpDir: ${baseDir}/tmp\n    logDir: ${baseDir}/log\n    msgDir: ${baseDir}/msgDir\n\n\n还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来\n\nlesson: "Spring\\tboot\\nlesson"\n\n\n总结\n\n 1. 在配置文件中可以使用${属性名}方式引用属性值\n 2. 如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析\n\n到这里有关yaml文件的基础使用就先告一段落，在实用篇中再继续研究更深入的内容。\n\n\n# JC-3.基于SpringBoot实现SSMP整合\n\n重头戏来了，SpringBoot之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到SpringBoot到底有多酷炫。这一章咱们学习如下技术的整合方式\n\n * 整合JUnit\n\n * 整合MyBatis\n\n * 整合MyBatis-Plus\n\n * 整合Druid\n   \n   上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。\n\n\n# JC-3-1.整合JUnit\n\nSpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非SpringBoot技术时对应的整合是如何做的，然后再看基于SpringBoot的整合是如何做的，才能比对出来简化在了哪里。\n\n我们先来看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式\n\n//加载spring整合junit专用的类运行器\n@RunWith(SpringJUnit4ClassRunner.class)\n//指定对应的配置信息，这个注解也可以在SpringBoot中使用，但是SpringBoot默认用SpringBootTest就行可以\n@ContextConfiguration(classes = SpringConfig.class)\npublic class AccountServiceTestCase {\n    //注入你要测试的对象\n    @Autowired\n    private AccountService accountService;\n    @Test\n    public void testGetById(){\n        //执行要测试的对象对应的方法\n        System.out.println(accountService.findById(2));\n    }\n}\n\n\n\n其中核心代码是前两个注解，第一个注解@RunWith是设置Spring专用于测试的类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，每次都指定一样的东西，这个东西写起来没有技术含量啊，第二个注解@ContextConfiguration是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。似然有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写\n\nSpringBoot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下\n\n@SpringBootTest\nclass Springboot04JunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println("two...");\n    }\n}\n\n\n看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会SpringBoot整合其他技术的优势在哪里，就两个字——简化。使用一个注解@SpringBootTest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。\n\n这个时候有人就问了，你加载的配置类或者配置文件是哪一个**（如果和引导类不在同一个包下，就不能引入默认的配置类或者引导类，故必须要显式的引入配置类或者引导类）**？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类\n\n@SpringBootTest(classes = Springboot04JunitApplication.class)\nclass Springboot04JunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println("two...");\n    }\n}\n\n\n第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的\n\n@SpringBootTest \n@ContextConfiguration(classes = Springboot04JunitApplication.class)\nclass Springboot04JunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println("two...");\n    }\n}\n\n\n温馨提示\n\n使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。\n\n总结\n\n 1. 导入测试对应的starter\n 2. 测试类使用@SpringBootTest修饰\n 3. 使用自动装配的形式添加要测试的对象\n 4. 测试类如果存在于引导类所在包或子包中无需指定引导类\n 5. 测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n\n# JC-3-2.整合MyBatis\n\n整合完JUnit下面再来说一下整合MyBatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对Spring整合MyBatis不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行\n\n * 导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要\n   \n   <dependencies>\n       <dependency>\n           <groupId>com.alibaba</groupId>\n           <artifactId>druid</artifactId>\n           <version>1.1.16</version>\n       </dependency>\n       <dependency>\n           <groupId>org.mybatis</groupId>\n           <artifactId>mybatis</artifactId>\n           <version>3.5.6</version>\n       </dependency>\n       <dependency>\n           <groupId>mysql</groupId>\n           <artifactId>mysql-connector-java</artifactId>\n           <version>5.1.47</version>\n       </dependency>\n       \x3c!--1.导入mybatis与spring整合的jar包--\x3e\n       <dependency>\n           <groupId>org.mybatis</groupId>\n           <artifactId>mybatis-spring</artifactId>\n           <version>1.3.0</version>\n       </dependency>\n       \x3c!--导入spring操作数据库必选的包--\x3e\n       <dependency>\n           <groupId>org.springframework</groupId>\n           <artifactId>spring-jdbc</artifactId>\n           <version>5.2.10.RELEASE</version>\n       </dependency>\n   </dependencies>\n   \n\n * Spring核心配置\n   \n   @Configuration\n   @ComponentScan("com.itheima")\n   @PropertySource("jdbc.properties")\n   public class SpringConfig {\n   }\n   \n\n * MyBatis要交给Spring接管的bean\n   \n   //定义mybatis专用的配置类\n   @Configuration\n   public class MyBatisConfig {\n   //    定义创建SqlSessionFactory对应的bean\n       @Bean\n       public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){\n           //SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象\n           SqlSessionFactoryBean sfb = new SqlSessionFactoryBean();\n           //设置数据源替代原始配置中的environments的配置\n           sfb.setDataSource(dataSource);\n           //设置类型别名替代原始配置中的typeAliases的配置\n           sfb.setTypeAliasesPackage("com.itheima.domain");\n           return sfb;\n       }\n   //    定义加载所有的映射配置\n       @Bean\n       public MapperScannerConfigurer mapperScannerConfigurer(){\n           MapperScannerConfigurer msc = new MapperScannerConfigurer();\n           msc.setBasePackage("com.itheima.dao");\n           return msc;\n       }\n   \n   }\n   \n\n * 数据源对应的bean，此处使用Druid数据源\n   \n   @Configuration\n   public class JdbcConfig {\n       @Value("${jdbc.driver}")\n       private String driver;\n       @Value("${jdbc.url}")\n       private String url;\n       @Value("${jdbc.username}")\n       private String userName;\n       @Value("${jdbc.password}")\n       private String password;\n   \n       @Bean("dataSource")\n       public DataSource dataSource(){\n           DruidDataSource ds = new DruidDataSource();\n           ds.setDriverClassName(driver);\n           ds.setUrl(url);\n           ds.setUsername(userName);\n           ds.setPassword(password);\n           return ds;\n       }\n   }\n   \n\n * 数据库连接信息（properties格式）\n   \n   jdbc.driver=com.mysql.jdbc.Driver\n   jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false\n   jdbc.username=root\n   jdbc.password=root\n   \n   \n   上述格式基本上是简格式了，要写的东西还真不少。下面看看SpringBoot整合MyBaits格式\n\n步骤①：创建模块时勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库\n\n\n\n\n\n或者手工导入对应技术的starter，和对应数据库的坐标\n\n<dependencies>\n    \x3c!--1.导入对应的starter--\x3e\n    <dependency>\n        <groupId>org.mybatis.spring.boot</groupId>\n        <artifactId>mybatis-spring-boot-starter</artifactId>\n        <version>2.2.0</version>\n    </dependency>\n\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n\n\n步骤②：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n\n\n完了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot把配置中所有可能出现的通用配置都简化了。下面就可以写一下MyBatis程序运行需要的Dao（或者Mapper）就可以运行了\n\n实体类（还要有set和get方法、tostring方法）\n\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n\n\n映射接口（Dao）\n\n@Mapper\npublic interface BookDao {\n    @Select("select * from tbl_book where id = #{id}")\n    public Book getById(Integer id);\n}\n\n\n测试类\n\n@SpringBootTest\nclass Springboot05MybatisApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        System.out.println(bookDao.getById(1));\n    }\n}\n\n\n完美，开发从此变的就这么简单。再体会一下SpringBoot如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解\n\n注意：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。当SpringBoot2.4.3（不含）版本之前会出现一个小BUG，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    username: root\n    password: root\n\n\n这里设置的UTC是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置不写UTC，写Asia/Shanghai也可以解决这个问题。\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai\n    username: root\n    password: root\n\n\n如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone=+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。\n\n此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用com.mysql.jdbc.Driver，换用com.mysql.cj.jdbc.Driver。前面的例子中已经更换了驱动了，在此说明一下。\n\nLoading class `com.mysql.jdbc.Driver\'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver\'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.\n\n\n总结\n\n 1. 整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter\n\n 2. 数据库连接相关信息转换成配置\n\n 3. 数据库SQL映射需要添加@Mapper被容器识别到\n\n 4. MySQL 8.X驱动强制要求设置时区\n    \n    * 修改url，添加serverTimezone设定\n    * 修改MySQL数据库配置\n\n 5. 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\n\n# JC-3-3.整合MyBatis-Plus\n\n做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话\n\n * 导入对应技术的starter坐标\n * 根据对应技术的要求做配置\n\n虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。\n\n接下来在MyBatis的基础上再升级一下，整合MyBaitsPlus（简称MP），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合\n\n步骤①：手工导入对应的starter （去www.mvnrepository.com查询插件对应的版本及其他信息，官网会给出引用格式）\n\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.3</version>\n</dependency>\n\n\n关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式\n\nSpring-boot-start-***\n\n\n而这个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范，后期原理篇会再详细讲解\n\nSTARTER所属   命名规则                                   示例\n官方提供        spring-boot-starter-技术名称               spring-boot-starter-web\n                                                   spring-boot-starter-test\n第三方提供       第三方技术名称-spring-boot-starter            druid-spring-boot-starter\n第三方提供       第三方技术名称-boot-starter（第三方技术名称过长，简化命名）   mybatis-plus-boot-starter\n\n温馨提示\n\n有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot官网还未收录此坐标，而我们Idea创建模块时读取的是SpringBoot官网的Spring Initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应Mybatis-Plus的坐标\n\n步骤②：配置数据源相关信息\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n\n\n没了，就这么多，剩下的就是写MyBaitsPlus的程序了\n\n映射接口（Dao）\n\n@Mapper\npublic interface BookDao extends BaseMapper<Book> {\n}\n\n\n核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。\n\n下面就可以写一个测试类进行测试了，此处省略。\n\n温馨提示\n\n目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到MyBatisPlus课程中去学习，此处仅给出解决方案。配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置所有表的通用前缀名称为tbl_\n\n\n总结\n\n 1. 手工添加MyBatis-Plus对应的starter\n 2. 数据层接口使用BaseMapper简化开发\n 3. 需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标\n\n\n# JC-3-4.整合Druid\n\n使用SpringBoot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。\n\n前面整合MyBatis和MP的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。\n\n在没有指定数据源时，我们的配置如下：\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai\n    username: root\n    password: root\n\n\n此时虽然没有指定数据源，但是根据SpringBoot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是HiKari。通过启动日志可以查看到对应的身影。\n\n2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.\n2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n\n\n上述信息中每一行都有HiKari的身影，如果需要更换数据源，其实只需要两步即可。\n\n 1. 导入对应的技术坐标\n 2. 配置使用指定的数据源类型\n\n下面就切换一下数据源对象\n\n步骤①：导入对应的坐标（注意，是坐标，此处不是starter）\n\n<dependencies>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.16</version>\n    </dependency>\n</dependencies>\n\n\n步骤②：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    username: root\n    password: root\n    type: com.alibaba.druid.pool.DruidDataSource\n\n\n这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照SpringBoot整合其他技术的通用规则来套啊，导入对应的starter，进行相应的配置即可。\n\n步骤①：导入对应的starter\n\n<dependencies>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.6</version>\n    </dependency>\n</dependencies>\n\n\n步骤②：修改配置\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n\n\n注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西**（Diuid专用特定的专用配置方法）**。言外之意，url这个属性时druid下面的属性，那你能想到吗？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅\n\n与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。\n\n这是我们做的第4个技术的整合方案，还是那两句话：导入对应starter，使用对应配置。没了，SpringBoot整合其他技术就这么简单粗暴。\n\n总结\n\n 1. 整合Druid需要导入Druid对应的starter\n 2. 根据Druid提供的配置方式进行配置\n 3. 整合第三方技术通用方式\n    * 导入对应的starter\n    * 根据提供的配置格式，配置非默认值对应的配置项\n\n\n# JC-3-5.SSMP整合综合案例\n\nSpringBoot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的SpringBoot整合其他技术的案例，为什么感觉SpringBoot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。\n\n先看一下这个案例的最终效果\n\n主页面\n\n\n\n添加\n\n\n\n删除\n\n\n\n修改\n\n\n\n分页\n\n\n\n条件查询\n\n\n\n整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个\n\n 1. 实体类开发————使用Lombok快速制作实体类\n 2. Dao开发————整合MyBatisPlus，制作数据层测试\n 3. Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类\n 4. Controller开发————基于Restful开发，使用PostMan测试接口功能\n 5. Controller开发————前后端开发协议制作\n 6. 页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理\n    * 列表\n    * 新增\n    * 修改\n    * 删除\n    * 分页\n    * 查询\n 7. 项目异常处理\n 8. 按条件查询————页面功能调整、Controller修正功能、Service修正功能\n\n可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟进进度，完成这个小案例的制作。\n\n# 0.模块创建\n\n对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。\n\n我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。\n\n一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。\n\n下面我们就可以创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。\n\npom.xml\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n\napplication.yml\n\nserver:\n  port: 80\n\n\n# 1.实体类开发\n\n本案例对应的模块表结构如下：\n\n-- ----------------------------\n-- Table structure for tbl_book\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_book`;\nCREATE TABLE `tbl_book`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of tbl_book\n-- ----------------------------\nINSERT INTO `tbl_book` VALUES (1, \'计算机理论\', \'Spring实战 第5版\', \'Spring入门经典教程，深入理解Spring原理技术内幕\');\nINSERT INTO `tbl_book` VALUES (2, \'计算机理论\', \'Spring 5核心原理与30个类手写实战\', \'十年沉淀之作，手写Spring精华思想\');\nINSERT INTO `tbl_book` VALUES (3, \'计算机理论\', \'Spring 5 设计模式\', \'深入Spring源码剖析Spring源码中蕴含的10大设计模式\');\nINSERT INTO `tbl_book` VALUES (4, \'计算机理论\', \'Spring MVC+MyBatis开发从入门到项目实战\', \'全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手\');\nINSERT INTO `tbl_book` VALUES (5, \'计算机理论\', \'轻量级Java Web企业应用实战\', \'源码级剖析Spring框架，适合已掌握Java基础的读者\');\nINSERT INTO `tbl_book` VALUES (6, \'计算机理论\', \'Java核心技术 卷I 基础知识（原书第11版）\', \'Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新\');\nINSERT INTO `tbl_book` VALUES (7, \'计算机理论\', \'深入理解Java虚拟机\', \'5个维度全面剖析JVM，大厂面试知识点全覆盖\');\nINSERT INTO `tbl_book` VALUES (8, \'计算机理论\', \'Java编程思想（第4版）\', \'Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉\');\nINSERT INTO `tbl_book` VALUES (9, \'计算机理论\', \'零基础学Java（全彩版）\', \'零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术\');\nINSERT INTO `tbl_book` VALUES (10, \'市场营销\', \'直播就该这么做：主播高效沟通实战指南\', \'李子柒、李佳琦、薇娅成长为网红的秘密都在书中\');\nINSERT INTO `tbl_book` VALUES (11, \'市场营销\', \'直播销讲实战一本通\', \'和秋叶一起学系列网络营销书籍\');\nINSERT INTO `tbl_book` VALUES (12, \'市场营销\', \'直播带货：淘宝、天猫直播从新手到高手\', \'一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+\');\n\n\n根据上述表结构，制作对应的实体类\n\n实体类\n\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n\n\n实体类的开发可以自动通过工具手工生成get/set方法，然后覆盖toString()、equals()，hashCode()等方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。\n\nLombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。\n\n<dependencies>\n    \x3c!--lombok--\x3e\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n</dependencies>\n\n\n使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加\n\nimport lombok.Data;\n@Data\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n\n\n到这里实体类就做好了，是不是比不使用lombok简化好多，这种工具在Java开发中还有N多，后面课程中遇到了能用的东西时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些\n\n总结\n\n 1. 实体类制作\n 2. 使用lombok简化开发\n    * 导入lombok无需指定版本，由SpringBoot提供版本\n    * @Data注解\n\n# 2.数据层开发——基础CRUD\n\n数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid，学都学了都用上\n\n步骤①：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少\n\n<dependencies>\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-boot-starter</artifactId>\n        <version>3.4.3</version>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.6</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n\n\n步骤②：配置数据库连接相关的数据源配置\n\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n\n\n步骤③：使用MP的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定\n\n@Mapper\npublic interface BookDao extends BaseMapper<Book> {\n}\n\n\n步骤④：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧\n\npackage com.itheima.dao;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.metadata.IPage;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\nimport com.itheima.domain.Book;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\npublic class BookDaoTestCase {\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Test\n    void testGetById(){\n        System.out.println(bookDao.selectById(1));\n    }\n\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setType("测试数据123");\n        book.setName("测试数据123");\n        book.setDescription("测试数据123");\n        bookDao.insert(book);\n    }\n\n    @Test\n    void testUpdate(){\n        Book book = new Book();\n        book.setId(17);\n        book.setType("测试数据abcdefg");\n        book.setName("测试数据123");\n        book.setDescription("测试数据123");\n        bookDao.updateById(book);\n    }\n\n    @Test\n    void testDelete(){\n        bookDao.deleteById(16);\n    }\n\n    @Test\n    void testGetAll(){\n        bookDao.selectList(null);\n    }\n}\n\n\n温馨提示\n\nMP技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MP使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下\n\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置表名通用前缀\n      id-type: auto\t\t\t\t#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增\n\n\n# 查看MP运行日志\n\n在进行数据层测试的时候，因为基础的CRUD操作均由MP给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你干预开发出来的，所以查看执行期运行的SQL语句就成为当务之急。\n\nSpringBoot整合MP的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\n      id-type: auto\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n\n再来看运行结果，此时就显示了运行期执行SQL的情况。\n\nCreating a new SqlSession\nSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not active\nJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring\n==>  Preparing: SELECT id,type,name,description FROM tbl_book\n==> Parameters: \n<==    Columns: id, type, name, description\n<==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕\n<==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想\n<==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式\n<==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手\n<==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者\n<==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新\n<==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖\n<==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉\n<==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术\n<==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中\n<==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍\n<==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+\n<==        Row: 13, 测试类型, 测试数据, 测试描述数据\n<==        Row: 14, 测试数据update, 测试数据update, 测试数据update\n<==        Row: 15, -----------------, 测试数据123, 测试数据123\n<==      Total: 15\n\n\n其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。\n\n此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可\n\n总结\n\n 1. 手工导入starter坐标（2个），mysql驱动（1个）\n\n 2. 配置数据源与MyBatisPlus对应的配置\n\n 3. 开发Dao接口（Dao用于操作数据库）（继承BaseMapper）\n\n 4. 制作测试类测试Dao功能是否有效\n\n 5. 使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志\n\n# 3.数据层开发——分页功能制作\n\n前面仅仅是使用了MP提供的基础CRUD功能，实际上MP给我们提供了几乎所有的基础操作，这一节说一下如果实现数据库端的分页操作\n\nMP提供的分页操作API如下\n\n@Test\nvoid testGetPage(){\n    IPage page = new Page(2,5);\n    bookDao.selectPage(page, null);\n    System.out.println(page.getCurrent());\n    System.out.println(page.getSize());\n    System.out.println(page.getTotal());\n    System.out.println(page.getPages());\n    System.out.println(page.getRecords());\n}\n\n\n其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MP提供的，别选错包了。创建此对象时就需要指定分页的两个基本数据\n\n * 当前显示第几页\n * 每页显示几条数据\n\n可以通过创建Page对象时利用构造方法初始化这两个数据\n\nIPage page = new Page(2,5);\n\n\n将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？\n\nIPage page = bookDao.selectPage(page, null);\n\n\n原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了\n\n@Test\nvoid testGetPage(){\n    IPage page = new Page(2,5);  //IPage对象\n    bookDao.selectPage(page, null);\n    System.out.println(page.getCurrent());\t\t//当前页码值\n    System.out.println(page.getSize());\t\t\t//每页显示数\n    System.out.println(page.getTotal());\t\t//数据总量\n    System.out.println(page.getPages());\t\t//总页数\n    System.out.println(page.getRecords());\t\t//详细数据\n}\n\n\n到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页当前是无效的。为什么这样呢？这个要源于MP的内部机制。\n\n对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MP为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。\n\n基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MP将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MP的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习MyBatisPlus这门课程进行详细解读。具体设置方式如下\n\n定义MP拦截器并将其设置为Spring管控的bean\n\n@Configuration\npublic class MPConfig {\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor(){\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n        return interceptor;\n    }\n}\n\n\n上述代码第一行是创建MP的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。\n\n总结\n\n 1. 使用IPage封装分页数据\n 2. 分页操作依赖MyBatisPlus分页拦截器实现功能\n 3. 借助MyBatisPlus日志查阅执行SQL语句\n\n# 4.数据层开发——条件查询功能制作\n\n除了分页功能，MP还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MP将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种套件的拼装。这里给大家普及一下基本格式，详细的操作还是到MP的课程中查阅吧\n\n下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用\n\n@Test\nvoid testGetBy(){\n    QueryWrapper<Book> qw = new QueryWrapper<>();\n    qw.like("name","Spring");\n    bookDao.selectList(qw);\n}\n\n\n其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。\n\n这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。\n\nMP针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就变了上述问题的出现\n\n@Test\nvoid testGetBy2(){\n    String name = "1";\n    LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n    lqw.like(Book::getName,name);\n    bookDao.selectList(lqw);\n}\n\n\n为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MP还提供了动态拼装SQL的快捷书写方式\n\n@Test\nvoid testGetBy2(){\n    String name = "1";\n    LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n    //if(name != null) lqw.like(Book::getName,name);\t\t//方式一：JAVA代码控制\n    lqw.like(name != null,Book::getName,name);\t\t\t\t//方式二：API接口提供控制开关\n    bookDao.selectList(lqw);\n}\n\n\n其实就是个格式，没有区别。关于MP的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴还是去完整的学习一下MP的知识吧，这里只是蜻蜓点水的用了几个操作而已。\n\n总结\n\n 1. 使用QueryWrapper对象封装查询条件\n\n 2. 推荐使用LambdaQueryWrapper对象\n\n 3. 所有查询操作封装成方法调用\n\n 4. 查询条件支持动态条件拼装\n\n# 5.业务层开发\n\n数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是组织业务逻辑功能，并根据业务需求，对数据持久层发起调用。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。\n\n一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作\n\nlogin(String username,String password);\n\n\n而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询\n\nselectByUserNameAndPassword(String username,String password);\n\n\n我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的\n\n接口：传入用户名与密码字段，查询出对应结果，结果是单条数据\n接口：传入ID字段，查询出对应结果，结果是单条数据\n接口：传入离职字段，查询出对应结果，结果是多条数据\n\n\n但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大\n\n接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对喵喵喵字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR\n\n\n你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。\n\n多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：\n\npublic interface BookService {\n    Boolean save(Book book);\n    Boolean update(Book book);\n    Boolean delete(Integer id);\n    Book getById(Integer id);\n    List<Book> getAll();\n    IPage<Book> getPage(int currentPage,int pageSize);\n}\n\n\n业务层实现类如下，转调数据层即可\n\n@Service\npublic class BookServiceImpl implements BookService {\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Override\n    public Boolean save(Book book) {\n        return bookDao.insert(book) > 0;\n    }\n\n    @Override\n    public Boolean update(Book book) {\n        return bookDao.updateById(book) > 0;\n    }\n\n    @Override\n    public Boolean delete(Integer id) {\n        return bookDao.deleteById(id) > 0;\n    }\n\n    @Override\n    public Book getById(Integer id) {\n        return bookDao.selectById(id);\n    }\n\n    @Override\n    public List<Book> getAll() {\n        return bookDao.selectList(null);\n    }\n\n    @Override\n    public IPage<Book> getPage(int currentPage, int pageSize) {\n        IPage page = new Page(currentPage,pageSize);\n        bookDao.selectPage(page,null);\n        return page;\n    }\n}\n\n\n别忘了对业务层接口进行测试，测试类如下\n\n@SpringBootTest\npublic class BookServiceTest {\n    @Autowired\n    private IBookService bookService;\n\n    @Test\n    void testGetById(){\n        System.out.println(bookService.getById(4));\n    }\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setType("测试数据123");\n        book.setName("测试数据123");\n        book.setDescription("测试数据123");\n        bookService.save(book);\n    }\n    @Test\n    void testUpdate(){\n        Book book = new Book();\n        book.setId(17);\n        book.setType("-----------------");\n        book.setName("测试数据123");\n        book.setDescription("测试数据123");\n        bookService.updateById(book);\n    }\n    @Test\n    void testDelete(){\n        bookService.removeById(18);\n    }\n\n    @Test\n    void testGetAll(){\n        bookService.list();\n    }\n\n    @Test\n    void testGetPage(){\n        IPage<Book> page = new Page<Book>(2,5);\n        bookService.page(page);\n        System.out.println(page.getCurrent());\n        System.out.println(page.getSize());\n        System.out.println(page.getTotal());\n        System.out.println(page.getPages());\n        System.out.println(page.getRecords());\n    }\n\n}\n\n\n总结\n\n 1. Service接口名称定义成业务名称，并与Dao接口名称进行区分\n 2. 制作测试类测试Service功能是否有效\n\n# 业务层快速开发\n\n其实MP技术不仅提供了数据层快速开发方案，业务层MP也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用\n\n业务层接口快速开发\n\npublic interface IBookService extends IService<Book> {\n    //添加非通用操作API接口\n}\n\n\n业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类\n\n@Service\npublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService {\n    @Autowired\n    private BookDao bookDao;\n\t//添加非通用操作API\n}\n\n\n如果感觉MP提供的功能不足以支撑你的使用需要，其实是一定不能支撑的，因为需求不可能是通用的，在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。\n\n总结\n\n 1. 使用通用接口（ISerivce<T>）快速开发Service\n 2. 使用通用实现类（ServiceImpl<M,T>）快速开发ServiceImpl\n 3. 可以在通用接口基础上做功能重载或功能追加\n 4. 注意重载时不要覆盖原始操作，避免原始提供的功能丢失\n\n# 6.表现层开发\n\n终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么SpringBoot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行\n\n表现层接口如下:\n\n@RestController\n@RequestMapping("/books")\npublic class BookController2 {\n\n    @Autowired\n    private IBookService bookService;\n\n    @GetMapping\n    public List<Book> getAll(){\n        return bookService.list();\n    }\n\n    @PostMapping\n    public Boolean save(@RequestBody Book book){\n        return bookService.save(book);\n    }\n\n    @PutMapping\n    public Boolean update(@RequestBody Book book){\n        return bookService.modify(book);\n    }\n\n    @DeleteMapping("{id}")\n    public Boolean delete(@PathVariable Integer id){\n        return bookService.delete(id);\n    }\n\n    @GetMapping("{id}")\n    public Book getById(@PathVariable Integer id){\n        return bookService.getById(id);\n    }\n\n    @GetMapping("{currentPage}/{pageSize}")\n    public IPage<Book> getPage(@PathVariable int currentPage,@PathVariable int pageSize){\n        return bookService.getPage(currentPage,pageSize, null);\n    }\n}\n\n\n在实用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了\n\n普通GET请求\n\n\n\nPUT请求传递json数据，后台实用@RequestBody接收数据\n\n\n\nGET请求传递路径变量，后台实用@PathVariable接收数据\n\n\n\n总结\n\n 1. 基于Restful制作表现层接口\n    * 新增：POST\n    * 删除：DELETE\n    * 修改：PUT\n    * 查询：GET\n 2. 接收参数\n    * 实体数据：@RequestBody\n    * 路径变量：@PathVariable\n\n# 7.表现层消息一致性处理\n\n目前我们通过Postman测试后业务层接口功能时通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重\n\n增删改操作结果\n\ntrue\n\n\n查询单个数据操作结果\n\n{\n    "id": 1,\n    "type": "计算机理论",\n    "name": "Spring实战 第5版",\n    "description": "Spring入门经典教程"\n}\n\n\n查询全部数据操作结果\n\n[\n    {\n        "id": 1,\n        "type": "计算机理论",\n        "name": "Spring实战 第5版",\n        "description": "Spring入门经典教程"\n    },\n    {\n        "id": 2,\n        "type": "计算机理论",\n        "name": "Spring 5核心原理与30个类手写实战",\n        "description": "十年沉淀之作"\n    }\n]\n\n\n每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n@Data\npublic class R {\n    private Boolean flag;\n    private Object data;\n}\n\n\n其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了\n\n{\n    "flag": true,\n    "data":{\n        "id": 1,\n        "type": "计算机理论",\n        "name": "Spring实战 第5版",\n        "description": "Spring入门经典教程"\n    }\n}\n\n\n表现层开发格式也需要转换一下\n\n结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的麻烦。\n\n总结\n\n 1. 设计统一的返回值结果类型便于前端开发读取数据\n\n 2. 返回值结果类型可以根据需求自行设定，没有固定格式\n\n 3. 返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n# 8.前后端联通性测试\n\n后端的表现层接口开发完毕，就可以进行前端的开发了。\n\n将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。\n\n\n\n在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发\n\n//列表\ngetAll() {\n\taxios.get("/books").then((res)=>{\n\t\tconsole.log(res.data);\n\t});\n},\n\n\n只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了\n\n总结\n\n 1. 单体项目中页面放置在resources/static目录下\n 2. created钩子函数用于初始化页面时发起调用\n 3. 页面使用axios发送异步请求获取数据后确认前后端是否联通\n\n# 9.页面基础功能开发\n\n# F-1.列表功能（非分页版）\n\n列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可\n\n页面数据模型定义\n\ndata:{\n\tdataList: [],//当前页要展示的列表数据\n\t...\n},\n\n\n异步请求获取数据\n\n//列表\ngetAll() {\n    axios.get("/books").then((res)=>{\n        this.dataList = res.data.data;\n    });\n},\n\n\n这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了\n\n总结：\n\n 1. 将查询数据返回到页面，利用前端数据绑定进行数据展示\n\n# F-2.添加功能\n\n添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可\n\n默认状态\n\ndata:{\n\tdialogFormVisible: false,//添加表单是否可见\n\t...\n},\n\n\n切换为显示状态\n\n//弹出添加窗口\nhandleCreate() {\n\tthis.dialogFormVisible = true;\n},\n\n\n由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹\n\n定义清理数据操作\n\n//重置表单\nresetForm() {\n    this.formData = {};\n},\n\n\n切换弹窗状态时清理数据\n\n//弹出添加窗口\nhandleCreate() {\n    this.dialogFormVisible = true;\n    this.resetForm();\n},\n\n\n至此准备工作完成，下面就要调用后台完成添加操作了\n\n添加操作\n\n//添加\nhandleAdd () {\n    //发送异步请求\n    axios.post("/books",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.flag){\n            this.dialogFormVisible = false;\n            this.$message.success("添加成功");\n        }else {\n            this.$message.error("添加失败");\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n\n\n 1. 将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台\n 2. 根据返回的操作结果决定下一步操作\n    * 如何是true就关闭添加窗口，显示添加成功的消息\n    * 如果是false保留添加窗口，显示添加失败的消息\n 3. 无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）\n\n取消添加操作\n\n//取消\ncancel(){\n    this.dialogFormVisible = false;\n    this.$message.info("操作取消");\n},\n\n\n总结\n\n 1. 请求方式使用POST调用后台对应操作\n 2. 添加操作结束后动态刷新页面加载数据\n 3. 根据操作结果不同，显示对应的提示信息\n 4. 弹出添加Div时清除表单数据\n\n# F-3.删除功能\n\n模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可\n\n删除操作\n\n// 删除\nhandleDelete(row) {\n    axios.delete("/books/"+row.id).then((res)=>{\n        if(res.data.flag){\n            this.$message.success("删除成功");\n        }else{\n            this.$message.error("删除失败");\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n\n\n删除操作提示信息\n\n// 删除\nhandleDelete(row) {\n    //1.弹出提示框\n    this.$confirm("此操作永久删除当前数据，是否继续？","提示",{\n        type:\'info\'\n    }).then(()=>{\n        //2.做删除业务\n        axios.delete("/books/"+row.id).then((res)=>{\n       \t\tif(res.data.flag){\n            \tthis.$message.success("删除成功");\n        \t}else{\n            \tthis.$message.error("删除失败");\n        \t}\n        }).finally(()=>{\n            this.getAll();\n        });\n    }).catch(()=>{\n        //3.取消删除\n        this.$message.info("取消删除操作");\n    });\n}，\t\n\n\n总结\n\n 1. 请求方式使用Delete调用后台对应操作\n 2. 删除操作需要传递当前行数据对应的id值到后台\n 3. 删除操作结束后动态刷新页面加载数据\n 4. 根据操作结果不同，显示对应的提示信息\n 5. 删除操作前弹出提示框避免误操作\n\n# F-4.修改功能\n\n修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：\n\n 1. 页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗\n\n 2. 弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据\n\n 3. 查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台\n\n 4. 查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据\n\n 5. 修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据\n    \n    所以整体上来看，修改功能就是前面几个功能的大合体\n    \n    查询并展示数据\n\n//弹出编辑窗口\nhandleUpdate(row) {\n    axios.get("/books/"+row.id).then((res)=>{\n        if(res.data.flag){\n            //展示弹层，加载数据\n            this.formData = res.data.data;\n            this.dialogFormVisible4Edit = true;\n        }else{\n            this.$message.error("数据同步失败，自动刷新");\n        }\n    });\n},\n\n\n修改操作\n\n//修改\nhandleEdit() {\n    axios.put("/books",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层并刷新页面\n        if(res.data.flag){\n            this.dialogFormVisible4Edit = false;\n            this.$message.success("修改成功");\n        }else {\n            this.$message.error("修改失败，请重试");\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n\n\n总结\n\n 1. 加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）\n 2. 利用前端双向数据绑定将查询到的数据进行回显（同查询全部）\n 3. 请求方式使用PUT调用后台对应操作（同新增传递数据）\n 4. 修改操作结束后动态刷新页面加载数据（同新增）\n 5. 根据操作结果不同，显示对应的提示信息（同新增）\n\n\n\n# 10.业务消息一致性处理\n\n目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子\n\n{\n    "timestamp": "2021-09-15T03:27:31.038+00:00",\n    "status": 500,\n    "error": "Internal Server Error",\n    "path": "/books"\n}\n\n\n面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？\n\n{\n    "flag": true,\n    "data":{\n        "id": 1,\n        "type": "计算机理论",\n        "name": "Spring实战 第5版",\n        "description": "Spring入门经典教程"\n    }\n}\n\n\n看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理\n\n首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息\n\n@Data\npublic class R{\n    private Boolean flag;\n    private Object data;\n    private String msg;\t\t//用于封装消息\n}\n\n\n后台代码也要根据情况做处理，当前是模拟的错误\n\n@PostMapping\npublic R save(@RequestBody Book book) throws IOException {\n    Boolean flag = bookService.insert(book);\n    return new R(flag , flag ? "添加成功^_^" : "添加失败-_-!");\n}\n\n\n然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理\n\n@RestControllerAdvice\npublic class ProjectExceptionAdvice {\n    // ExceptionHandler用来拦截所有或者指定的异常信息\n    @ExceptionHandler(Exception.class)\n    public R doOtherException(Exception ex){\n        //记录日志\n        //发送消息给运维\n        //发送邮件给开发人员,ex对象发送给开发人员\n        ex.printStackTrace();\n        return new R(false,null,"系统错误，请稍后再试！");\n    }\n}\n\n\n页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息\n\n//添加\nhandleAdd () {\n\t//发送ajax请求\n    axios.post("/books",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.flag){\n            this.dialogFormVisible = false;\n            this.$message.success("添加成功");\n        }else {\n            this.$message.error(res.data.msg);\t\t\t//消息来自于后台传递过来，而非固定内容\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n\n\n总结\n\n 1. 使用注解**@RestControllerAdvice**定义SpringMVC异常处理器用来处理异常的\n 2. 异常处理器必须被扫描加载，否则无法生效\n 3. 表现层返回结果的模型类中添加消息属性用来传递消息到页面\n\n\n\n# 11.页面功能开发\n\n# F-5.分页功能\n\n分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件\n\n\x3c!--分页组件--\x3e\n<div class="pagination-container">\n    <el-pagination\n\t\tclass="pagiantion"\n\t\t@current-change="handleCurrentChange"\n\t\t:current-page="pagination.currentPage"\n\t\t:page-size="pagination.pageSize"\n\t\tlayout="total, prev, pager, next, jumper"\n\t\t:total="pagination.total">\n    </el-pagination>\n</div>\n\n\n为了配合分页组件，封装分页对应的数据模型\n\ndata:{\n\tpagination: {\t\n\t\t//分页相关模型数据\n\t\tcurrentPage: 1,\t//当前页码\n\t\tpageSize:10,\t//每页显示的记录数\n\t\ttotal:0,\t\t//总记录数\n\t}\n},\n\n\n修改查询全部功能为分页查询，通过路径变量传递页码信息参数\n\ngetAll() {\n    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize).then((res) => {\n    });\n},\n\n\n后台提供对应的分页功能\n\n@GetMapping("/{currentPage}/{pageSize}")\npublic R getAll(@PathVariable Integer currentPage,@PathVariable Integer pageSize){\n    IPage<Book> pageBook = bookService.getPage(currentPage, pageSize);\n    return new R(null != pageBook ,pageBook);\n}\n\n\n页面根据分页操作结果读取对应数据，并进行数据模型绑定\n\ngetAll() {\n    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize).then((res) => {\n        this.pagination.total = res.data.data.total;\n        this.pagination.currentPage = res.data.data.current;\n        this.pagination.pagesize = res.data.data.size;\n        this.dataList = res.data.data.records;\n    });\n},\n\n\n对切换页码操作设置调用当前分页操作\n\n//切换页码\nhandleCurrentChange(currentPage) {\n    this.pagination.currentPage = currentPage;\n    this.getAll();\n},\n\n\n总结\n\n 1. 使用el分页组件\n 2. 定义分页组件绑定的数据模型\n 3. 异步调用获取分页数据\n 4. 分页数据页面回显\n\n# F-6.删除功能维护\n\n由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案\n\n@GetMapping("{currentPage}/{pageSize}")\npublic R getPage(@PathVariable int currentPage,@PathVariable int pageSize){\n    IPage<Book> page = bookService.getPage(currentPage, pageSize);\n    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值\n    if( currentPage > page.getPages()){\n        page = bookService.getPage((int)page.getPages(), pageSize);\n    }\n    return new R(true, page);\n}\n\n\n# F-7.条件查询功能\n\n最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了\n\n * 页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关的数据转换成2个分页数据加若干个条件\n\n * 后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大\n\n * 查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略\n   \n   经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别\n   \n   页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递\n   \n   页面封装查询条件字段\n   \n   pagination: {\t\t\n   //分页相关模型数据\n   \tcurrentPage: 1,\t\t//当前页码\n   \tpageSize:10,\t\t//每页显示的记录数\n   \ttotal:0,\t\t\t//总记录数\n   \tname: "",\n   \ttype: "",\n   \tdescription: ""\n   },\n   \n   \n   页面添加查询条件字段对应的数据模型绑定名称\n   \n   <div class="filter-container">\n       <el-input placeholder="图书类别" v-model="pagination.type" class="filter-item"/>\n       <el-input placeholder="图书名称" v-model="pagination.name" class="filter-item"/>\n       <el-input placeholder="图书描述" v-model="pagination.description" class="filter-item"/>\n       <el-button @click="getAll()" class="dalfBut">查询</el-button>\n       <el-button type="primary" class="butT" @click="handleCreate()">新建</el-button>\n   </div>\n   \n   \n   将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求\n   \n   getAll() {\n       //1.获取查询条件,拼接查询条件\n       param = "?name="+this.pagination.name;\n       param += "&type="+this.pagination.type;\n       param += "&description="+this.pagination.description;\n       console.log("-----------------"+ param);\n       axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize+param).then((res) => {\n           this.dataList = res.data.data.records;\n       });\n   },\n   \n   \n   后台代码中定义实体类封查询条件\n   \n   @GetMapping("{currentPage}/{pageSize}")\n   public R getAll(@PathVariable int currentPage,@PathVariable int pageSize,Book book) {\n       System.out.println("参数=====>"+book);\n       IPage<Book> pageBook = bookService.getPage(currentPage,pageSize);\n       return new R(null != pageBook ,pageBook);\n   }\n   \n   \n   对应业务层接口与实现类进行修正\n   \n   public interface IBookService extends IService<Book> {\n       IPage<Book> getPage(Integer currentPage,Integer pageSize,Book queryBook);\n   }\n   \n   \n   @Service\n   public class BookServiceImpl2 extends ServiceImpl<BookDao,Book> implements IBookService {\n       public IPage<Book> getPage(Integer currentPage,Integer pageSize,Book queryBook){\n           IPage page = new Page(currentPage,pageSize);\n           LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n           lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());\n           lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());\n           lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());\n           return bookDao.selectPage(page,lqw);\n       }\n   }\n   \n   \n   页面回显数据\n   \n   getAll() {\n       //1.获取查询条件,拼接查询条件\n       param = "?name="+this.pagination.name;\n       param += "&type="+this.pagination.type;\n       param += "&description="+this.pagination.description;\n       console.log("-----------------"+ param);\n       axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize+param).then((res) => {\n           this.pagination.total = res.data.data.total;\n           this.pagination.currentPage = res.data.data.current;\n           this.pagination.pagesize = res.data.data.size;\n           this.dataList = res.data.data.records;\n       });\n   },\n   \n\n总结\n\n 1. 定义查询条件数据模型（当前封装到分页数据模型中）\n 2. 异步调用分页功能并通过请求参数传递数据到后台\n\n\n# 基础篇完结\n\n基础篇到这里就全部结束了，在基础篇中带着大家学习了如果创建一个SpringBoot工程，然后学习了SpringBoot的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于SpringBoot的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。',normalizedContent:'# springboot基础篇\n\n在基础篇中，我给学习者的定位是先上手，能够使用springboot搭建基于springboot的web项目开发，所以内容设置较少，主要包含如下内容：\n\n * springboot快速入门\n * springboot基础配置\n * 基于springboot整合ssmp\n\n\n# jc-1.快速上手springboot\n\n学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。springboot技术由pivotal团队研发制作，功能的话简单概括就是加速spring程序的开发，这个加速要从如下两个方面来说\n\n * spring程序初始搭建过程\n * spring程序的开发过程\n\n通过上面两个方面的定位，我们可以产生两个模糊的概念：\n\n 1. springboot开发团队认为原始的spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的spring程序至少有一个配置文件或配置类，用来描述spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了springboot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子\n 2. springboot开发团队认为原始的spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给spring容器管理，也就是配置成spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西springboot也能帮我们简化？\n\n带着上面这些疑问我们就着手第一个springboot程序的开发了，看看到底使用springboot技术能简化开发到什么程度。\n\n温馨提示\n\n如果对spring程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备spring技术的知识，硬着头皮学不下去的。\n\n\n# jc-1-1.springboot入门程序制作（一）\n\n下面让我们开始做第一个springboot程序吧，本课程基于idea2020.3版本制作，使用的maven版本为3.6.1，jdk版本为1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个idea和maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。\n\n下面使用springboot技术快速构建一个springmvc的程序，通过这个过程体会简化二字的含义\n\n步骤①：创建新模块，选择spring initializr，并配置模块相关基础信息\n\n\n\n特别关注：第3步点击next时，idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直联网转转转\n\n特别关注：第5步选择java版本和你计算机上安装的jdk版本匹配即可，但是最低要求为jdk8或以上版本，推荐使用8或11\n\n步骤②：选择当前模块需要使用的技术集\n\n\n\n按照要求，左侧选择web，然后在中间选择spring web即可，选完右侧就出现了新的内容项，这就表示勾选成功了\n\n关注：此处选择的springboot的版本使用默认的就可以了，需要说一点，springboot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，回头可以到配置文件中修改对应的版本\n\n步骤③：开发控制器类\n\n//rest模式\n@restcontroller\n@requestmapping("/books")\npublic class bookcontroller {\n    @getmapping\n    public string getbyid(){\n        system.out.println("springboot is running...");\n        return "springboot is running...";\n    }\n}\n\n\n入门案例制作的springmvc的控制器基于rest风格开发，当然此处使用原始格式制作springmvc的程序也是没有问题的，上例中的@restcontroller与@getmapping注解是基于restful开发的典型注解\n\n关注：做到这里springboot程序的最基础的开发已经做完了，现在就可以正常的运行spring程序了。可能有些小伙伴会有疑惑，tomcat服务器没有配置，=-spring也没有配置，什么都没有配置这就能用吗？这就是springboot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程\n\n步骤④：运行自动生成的application类\n\n\n\n使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。\n\n不难看出，运行的信息中包含了8080的端口，tomcat这种熟悉的字样，难道这里启动了tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了\n\n访问路径：\thttp://localhost:8080/books\n\n\n是不是感觉很神奇？目前的效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前\n\n * pom.xml\n   \n   这是maven的配置文件，描述了当前工程构建时相应的配置信息\n   \n   <?xml version="1.0" encoding="utf-8"?>\n   <project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n            xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n       <modelversion>4.0.0</modelversion>\n   \n       <parent>\n           <groupid>org.springframework.boot</groupid>\n           <artifactid>spring-boot-starter-parent</artifactid>\n           <version>2.5.4</version>\n       </parent>\n   \n       <groupid>com.itheima</groupid>\n       <artifactid>springboot_01_01_quickstart</artifactid>\n       <version>0.0.1-snapshot</version>\n   \n       <dependencies>\n           <dependency>\n               <groupid>org.springframework.boot</groupid>\n               <artifactid>spring-boot-starter-web</artifactid>\n           </dependency>\n   \n           <dependency>\n               <groupid>org.springframework.boot</groupid>\n               <artifactid>spring-boot-starter-test</artifactid>\n               <scope>test</scope>\n           </dependency>\n       </dependencies>\n   </project>\n   \n   \n   配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说\n\n * application类\n   \n   @springbootapplication\n   public class application {\n       public static void main(string[] args) {\n           springapplication.run(application.class, args);\n       }\n   }\n   \n   \n   这个类功能很简单，就一句代码，前面运行程序就是运行的这个类\n\n到这里我们可以大胆推测一下，如果上面这两个文件没有的话，springboot肯定没法玩，看来核心就是这两个文件了。由于是制作第一个springboot程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。\n\n通过上面的制作，我们不难发现，springboot程序简直太好写了，几乎什么都没写，功能就有了，这也是springboot技术为什么现在这么火的原因，和spirng程序相比，springboot程序在开发的过程中各个层面均具有优势\n\n类配置文件                 spring   springboot\npom文件中的坐标             手工添加     勾选添加\nweb3.0配置类             手工制作     无\nspring/springmvc配置类   手工制作     无\n控制器                   手工制作     手工制作\n\n一句话总结一下就是能少写就少写，能不写就不写，这就是springboot技术给我们带来的好处，行了，现在你就可以动手做一做springboot程序了，看看效果如何，是否真的帮助你简化开发了\n\n总结\n\n 1. 开发springboot程序可以根据向导进行联网快速制作\n 2. springboot程序需要基于jdk8以上版本进行制作\n 3. springboot程序中需要使用何种功能通过勾选选择技术，也可以手工添加对应的要使用的技术（后期讲解）\n 4. 运行springboot程序通过运行application程序入口进行\n\n思考\n\n前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于idea开发时，你会发现你配置了一些坐标，然后maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这和idea这款ide工具有关，万一idea不能正常访问网络的话，我们是不是就无法制作springboot程序了呢？咱们下一节再说\n\n\n# jc-1-2.springboot入门程序制作（二）\n\n如果idea不能正常联网，这个springboot程序就无法制作了吗？开什么玩笑，世上ide工具千千万，难道springboot技术还必须基于idea来做了？这是不可能的。开发springboot程序，可以不基于任意的ide工具进行，其实在springboot的官网里面就可以直接创建springboot程序\n\nspringboot官网和spring的官网是在一起的，都是 spring.io 。你可以通过项目一级一级的找到springboot技术的介绍页，然后在页面中间部位找到如下内容\n\n步骤①：点击spring initializr后进入到创建springboot程序的界面上，下面是输入信息的过程，和前面的一样，只是界面变了而已，根据自己的要求，在左侧选择对应信息和输入对应的信息即可\n\n步骤②：右侧的add dependencies用于选择使用何种技术，和之前勾选的spring web是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面\n\n步骤③：所有信息设置完毕后，点击下面左侧按钮，生成一个文件包\n\n\n\n步骤④：保存后得到一个压缩文件，这个文件打开后就是创建的springboot工程文件夹了\n\n\n\n步骤⑤：解压缩此文件后，得到工程目录，在idea中导入即可使用，和之前创建的东西完全一样。下面就可以自己创建一个controller测试一下是否能用了。\n\n温馨提示\n\n做到这里其实可以透漏一个小秘密，idea工具中创建springboot工程其实连接的就是springboot的官网，走的就是这个过程，只不过idea把界面给整合了一下，读取到了spring官网给的信息，然后展示到了idea的界面中而已，不信你可以看看下面这个步骤\n\n上面描述了连接的网址，再看看springboot官网创建工程的url地址，是不是一样？\n\n总结\n\n 1. 打开springboot官网，选择quickstart your project\n\n 2. 创建工程\n    \n    并保存项目\n    \n    \n\n 3. 解压项目，通过ide导入项目\n\n思考\n\n现在创建工程靠的是访问国外的spring主站，但是互联网访问是可以控制的，如果一天这个网站你在国内都无法访问了，那前面这两种方式都无法创建springboot工程了，这时候又该怎么解决这个问题呢？咱们下一节再说\n\n\n# jc-1-3.springboot入门程序制作（三）\n\n前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实都是走的同一个地方，也就是springboot的官网创建的springboot工程，那如果我们国内有这么一个网站能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，这个国内的网站有吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就ok了，没错，就是这样\n\n创建工程时，切换选择starter服务路径，然后手工收入阿里云提供给我们的使用地址即可。地址：http://start.aliyun.com或https://start.aliyun.com\n\n\n\n阿里为了便于自己开发使用，因此在依赖坐标中添加了一些阿里相关的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。不过有一点需要说清楚，阿里云地址默认创建的springboot工程版本是2.4.1，所以如果你想更换其他的版本，创建项目后手工修改即可，别忘了刷新一下，加载新版本信息\n\n\n\n阿里云提供的地址更符合国内开发者的使用习惯，里面有一些springboot官网上没有给出的坐标，大家可以好好看一看。\n\n注意：阿里云提供的工程创建地址初始化完毕后和实用springboot官网创建出来的工程略有区别。主要是在配置文件的形式上有区别。这个信息在后面讲解boot程序的执行流程时给大家揭晓\n\n总结\n\n 1. 选择start来源为自定义url\n 2. 输入阿里云start地址\n 3. 创建项目\n\n思考\n\n做到这里我们已经有了三种方式创建springboot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，整个事情是不是就不能做了呢？咱们下一节再说\n\n\n# jc-1-4.springboot入门程序制作（四）\n\n不能上网，还想创建springboot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个信息找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。\n\n联网做什么呢？首先springboot工程也是基于maven构建的，而maven工程当使用了一些自己需要使用又不存在的东西时，就要去下载。其实springboot工程创建的时候就是去下载一些必要的组件的。你把这些东西给提前准备好就可以了吗？是的，就是这样。\n\n下面咱们就一起手工创建一个springboot工程\n\n步骤①：创建工程时，选择手工创建maven工程\n\n步骤②：参照标准springboot工程的pom文件，书写自己的pom文件即可\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelversion>4.0.0</modelversion>\n\n    <parent>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-parent</artifactid>\n        <version>2.5.4</version>\n    </parent>\n\n    <groupid>com.itheima</groupid>\n    <artifactid>springboot_01_04_quickstart</artifactid>\n    <version>1.0-snapshot</version>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用\n\n步骤③：之前运行springboot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称一切修改即可\n\n@springbootapplication\npublic class application {\n    public static void main(string[] args) {\n        springapplication.run(application.class);\n    }\n}\n\n\n关注：类上面的注解@springbootapplication千万别丢了，这个是核心，后面再介绍\n\n关注：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称\n\n步骤④：下面就可以自己创建一个controller测试一下是否能用了，和之前没有差别了\n\n看到这里其实应该能够想明白了，通过向导或者网站创建的springboot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。\n\n温馨提示\n\n如果你的计算机上从来没有创建成功过springboot工程，自然也就没有下载过springboot对应的坐标，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的\n\n总结\n\n 1. 创建普通maven工程\n 2. 继承spring-boot-starter-parent\n 3. 添加依赖spring-boot-starter-web\n 4. 制作引导类application\n\n到这里其实学习了4种创建springboot工程的方式，其实本质是一样的，就是根据springboot工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。\n\n# 教你一招：在idea中隐藏指定文件/文件夹\n\n创建springboot工程时，使用springboot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的springboot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。\n\n处理方案无外乎两种，如果你对每一个文件/目录足够了解，没有用的完全可以删除掉，或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，直接delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。\n\n既然是在idea下做隐藏功能，肯定隶属于idea的设置，设置方式如下。\n\n步骤①：打开设置，【files】→【settings】\n\n步骤②：打开文件类型设置界面，【editor】→【file types】→【ignored files and folders】，忽略文件或文件夹显示\n\n步骤③：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可(这里就把.mvn文件夹点击apply之后就被隐藏了)\n\n\n\n到这里就做完了，其实就是idea的一个小功能\n\n总结\n\n 1. idea中隐藏指定文件或指定类型文件\n    1. 【files】→【settings】\n    2. 【editor】→【file types】→【ignored files and folders】\n    3. 输入要隐藏的名称，支持*号通配符\n    4. 回车确认添加\n\n\n# jc-1-5.springboot简介\n\n入门案例做完了，这个时候回忆一下咱们之前说的springboot的功能是什么还记得吗？加速spring程序的开发，现在是否深有体会？再来看springboot技术的设计初衷就很容易理解了。\n\nspringboot是由pivotal团队提供的全新框架，其设计目的是用来简化spring应用的初始搭建以及开发过程。\n\n都简化了了哪些东西呢？其实就是针对原始的spring程序制作的两个方面进行了简化：\n\n * spring程序缺点\n   * 依赖设置繁琐\n     * 以前写spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始springmvc程序的小伙伴应该知道，写springmvc程序，最基础的spring-web和spring-webmvc这两个坐标时必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定面\n   * 配置繁琐\n     * 以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用\n\n> 回顾\n> \n> 通过上面两个方面的定位，我们可以产生两个模糊的概念：\n> \n>  1. springboot开发团队认为原始的spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的spring程序至少有一个配置文件或配置类，用来描述spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了springboot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子\n>  2. springboot开发团队认为原始的spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给spring容器管理，也就是配置成spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西springboot也能帮我们简化？\n\n再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是springboot给我们带来的好处。这些简化操作在springboot中有专业的用语，也是springboot程序的核心功能及优点：\n\n * 起步依赖（简化依赖配置）\n   * 依赖配置的书写简化就是靠这个起步依赖达成的\n * 自动配置（简化常用工程相关配置）\n   * 配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的，后面具体展开说\n * 辅助功能（内置服务器，……）\n   * 除了上面的功能，其实springboot程序还有其他的一些优势，比如我们没有配置tomcat服务器，但是能正常运行，这是springboot程序的一个可以感知到的功能，也是springboot的辅助功能之一。一个辅助功能都能做的这么6，太牛了\n\n下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面\n\n * parent\n * starter\n * 引导类\n * 内嵌tomcat\n\n# parent\n\nspringboot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如a技术的2.0版与b技术的3.5版可以合作在一起，但是和b技术的3.7版合并使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。\n\nspringboot一看这种情况so easy啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于springboot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做parent。\n\nparent自身具有很多个版本，每个parent版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用springboot提供的parent就行了，由parent帮助开发者统一的进行各种技术的版本管理\n\n比如你现在要使用spring配合mybatis开发，没有parent之前怎么做呢？选个spring的版本，再选个mybatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你spring的版本发生变化需要切换时，你的mybatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由parent负责处理。\n\n有人可能会提出来，万一parent给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，parent仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，使用parent可以帮助开发者进行版本的统一管理\n\n关注：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚\n\n那springboot又是如何做到这一点的呢？可以查阅springboot的配置源码，看到这些定义\n\n * 项目中的pom.xml中继承了一个坐标\n\n<parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <version>2.5.4</version>\n</parent>\n\n\n * 打开后可以查阅到其中又继承了一个坐标\n\n<parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-dependencies</artifactid>\n    <version>2.5.4</version>\n</parent>\n\n\n * 这个坐标中定义了两组信息，第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号\n\n<properties>\n    <activemq.version>5.16.3</activemq.version>\n    <aspectj.version>1.9.7</aspectj.version>\n    <assertj.version>3.19.0</assertj.version>\n    <commons-codec.version>1.15</commons-codec.version>\n    <commons-dbcp2.version>2.8.0</commons-dbcp2.version>\n    <commons-lang3.version>3.12.0</commons-lang3.version>\n    <commons-pool.version>1.6</commons-pool.version>\n    <commons-pool2.version>2.9.0</commons-pool2.version>\n    <h2.version>1.4.200</h2.version>\n    <hibernate.version>5.4.32.final</hibernate.version>\n    <hibernate-validator.version>6.2.0.final</hibernate-validator.version>\n    <httpclient.version>4.5.13</httpclient.version>\n    <jackson-bom.version>2.12.4</jackson-bom.version>\n    <javax-jms.version>2.0.1</javax-jms.version>\n    <javax-json.version>1.1.4</javax-json.version>\n    <javax-websocket.version>1.1</javax-websocket.version>\n    <jetty-el.version>9.0.48</jetty-el.version>\n    <junit.version>4.13.2</junit.version>\n</properties>\n\n\n第二组是各式各样的的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值\n\n<dependencymanagement>\n    <dependencies>\n        <dependency>\n            <groupid>org.hibernate</groupid>\n            <artifactid>hibernate-core</artifactid>\n            <version>${hibernate.version}</version>\n        </dependency>\n        <dependency>\n            <groupid>junit</groupid>\n            <artifactid>junit</artifactid>\n            <version>${junit.version}</version>\n        </dependency>\n    </dependencies>\n</dependencymanagement>\n\n\n关注：上面的依赖坐标定义是出现在<dependencymanagement>标签中的，其实是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的\n\n关注：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式\n\n<dependencymanagement>\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-dependencies</artifactid>\n            <version>${spring-boot.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencymanagement>\n\n\n总结\n\n 1. 开发springboot程序要继承spring-boot-starter-parent\n 2. spring-boot-starter-parent中定义了若干个依赖管理\n 3. 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突\n 4. 继承parent的形式也可以采用引入依赖的形式实现效果\n 5. 如果不指定版本，springboot里面也会默认根据parent调用最合适的版本（这个是我自己添加的）\n\n思考\n\nparent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？\n\n# starter\n\nspringboot关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。\n\nspringboot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，springboot给它起了个名字叫做starter。\n\nstarter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，使用starter可以帮助开发者减少依赖配置\n\n这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅springboot的配置源码，看到这些定义\n\n * 项目中的pom.xml定义了使用springmvc技术，但是并没有写springmvc的坐标，而是添加了一个名字中包含starter的依赖\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n * 在spring-boot-starter-web中又定义了若干个具体依赖的坐标\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter</artifactid>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-json</artifactid>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-tomcat</artifactid>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-web</artifactid>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-webmvc</artifactid>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n之前提到过开发springmvc程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。\n\n但是我们发现除了这两个还有其他的，比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter</artifactid>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-web</artifactid>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>com.fasterxml.jackson.core</groupid>\n        <artifactid>jackson-databind</artifactid>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>com.fasterxml.jackson.datatype</groupid>\n        <artifactid>jackson-datatype-jdk8</artifactid>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>com.fasterxml.jackson.datatype</groupid>\n        <artifactid>jackson-datatype-jsr310</artifactid>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>com.fasterxml.jackson.module</groupid>\n        <artifactid>jackson-module-parameter-names</artifactid>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n我们可以发现，这个starter中又包含了若干个坐标，其实就是使用springmvc开发通常都会使用到json，使用json又离不开这里面定义的这些坐标，看来还真是方便，springboot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。\n\n到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。\n\nstarter与parent的区别\n\n朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。\n\nstarter是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的\n\nparent是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由springboot统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的\n\n实际开发应用方式\n\n * 实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter\n   \n   * 如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供\n   * 如果没有对应的starter，手写坐标即可\n\n * 实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖springboot提供给我们的配置管理\n   \n   * 方式一：直接写坐标\n   * 方式二：覆盖<properties>中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就ok了\n   \n   <properties>\n       <activemq.version>5.16.3</activemq.version>\n       <aspectj.version>1.9.7</aspectj.version>\n       <assertj.version>3.19.0</assertj.version>\n       <commons-codec.version>1.15</commons-codec.version>\n       <commons-dbcp2.version>2.8.0</commons-dbcp2.version>\n       <commons-lang3.version>3.12.0</commons-lang3.version>\n       <commons-pool.version>1.6</commons-pool.version>\n       <commons-pool2.version>2.9.0</commons-pool2.version>\n       <h2.version>1.4.200</h2.version>\n       <hibernate.version>5.4.32.final</hibernate.version>\n       <hibernate-validator.version>6.2.0.final</hibernate-validator.version>\n       <httpclient.version>4.5.13</httpclient.version>\n       <jackson-bom.version>2.12.4</jackson-bom.version>\n       <javax-jms.version>2.0.1</javax-jms.version>\n       <javax-json.version>1.1.4</javax-json.version>\n       <javax-websocket.version>1.1</javax-websocket.version>\n       <jetty-el.version>9.0.48</jetty-el.version>\n       <junit.version>4.13.2</junit.version>\n   </properties>\n   \n\n温馨提示\n\nspringboot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式\n\n命名规则：spring-boot-starter-技术名称\n\n\n所以以后见了spring-boot-starter-aaa这样的名字，这就是springboot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合章节再说\n\n总结\n\n 1. 开发springboot程序需要导入坐标时通常导入对应的starter\n 2. 每个不同的starter根据功能不同，通常包含多个依赖坐标\n 3. 使用starter可以实现快速配置的效果，达到简化配置的目的\n\n# 引导类\n\n配置说完了，我们发现springboot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是springboot工程创建时自带的那个类了，带有main方法的那个类，运行这个类就可以启动springboot工程的运行\n\n@springbootapplication\npublic class springboot0101quickstartapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot0101quickstartapplication.class, args);\n    }\n}\n\n\nspringboot本身是为了加速spring程序的开发的，而spring程序运行的基础是需要创建自己的spring容器对象（ioc容器）并将所有的对象交给spring的容器管理，也就是一个一个的bean。那还了springboot加速开发spring程序，这个容器还在吗？这个疑问不用说，一定在。当前这个类运行后就会产生一个spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作bean。\n\n@springbootapplication\npublic class springboot0101quickstartapplication {\n    public static void main(string[] args) {\n        configurableapplicationcontext ctx = springapplication.run(springboot0101quickstartapplication.class, args);\n        bookcontroller bean = ctx.getbean(bookcontroller.class);\n        system.out.println("bean======>" + bean);\n    }\n}\n\n\n\n\n通过上述操作不难看出，其实springboot程序启动还是创建了一个spring容器对象。这个类在springboot程序中是所有功能的入口，称这个类为引导类。\n\n作为一个引导类最典型的特征就是当前类上方声明了一个注解@springbootapplication\n\n总结\n\n 1. springboot工程提供引导类用来启动程序\n 2. springboot工程启动后创建并初始化spring容器\n\n思考\n\n程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？\n\n# 内嵌tomcat\n\n当前我们做的springboot入门案例勾选了spirng-web的功能，并且导入了对应的starter。\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\nspringboot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西。我帮你搞一个web服务器，你要愿意用的，直接使用就好了，干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。\n\n由于这个功能不属于程序的主体功能，可用可不用，于是乎springboot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。\n\n下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题\n\n 1. 这个服务器在什么位置定义的\n 2. 这个服务器是怎么运行的\n 3. 这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾\n\n内嵌tomcat定义位置\n\n说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n打开查看web的starter导入了哪些东西\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter</artifactid>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-json</artifactid>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-tomcat</artifactid>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-web</artifactid>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-webmvc</artifactid>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n第三个依赖就是这个tomcat对应的东西了，居然也是一个starter，再打开看看\n\n<dependencies>\n    <dependency>\n        <groupid>jakarta.annotation</groupid>\n        <artifactid>jakarta.annotation-api</artifactid>\n        <version>1.3.5</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.apache.tomcat.embed</groupid>\n        <artifactid>tomcat-embed-core</artifactid>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactid>tomcat-annotations-api</artifactid>\n                <groupid>org.apache.tomcat</groupid>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupid>org.apache.tomcat.embed</groupid>\n        <artifactid>tomcat-embed-el</artifactid>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupid>org.apache.tomcat.embed</groupid>\n        <artifactid>tomcat-embed-websocket</artifactid>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactid>tomcat-annotations-api</artifactid>\n                <groupid>org.apache.tomcat</groupid>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n\n这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能，再来说第二个问题，这个服务器是怎么运行的\n\n内嵌tomcat运行原理\n\ntomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉的小伙伴可能有印象，tomcat安装目录中保存有jar，好多个jar。\n\n下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象。\n\n如果是对象，那spring容器是用来管理对象的，这个对象能不能交给spring容器管理呢？把吗去掉，是个对象都可以交给spring容器管理，行了，这下通了。tomcat服务器运行其实是以对象的形式在spring容器中运行的，怪不得我们没有安装这个tomcat，而且还能用。闹了半天这东西最后是以一个对象的形式存在，保存在spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心\n\n<dependencies>\n    <dependency>\n        <groupid>org.apache.tomcat.embed</groupid>\n        <artifactid>tomcat-embed-core</artifactid>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n\n\n那既然是个对象，如果把这个对象从spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n        <exclusions>\n            <exclusion>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-tomcat</artifactid>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n\n上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后会等着用户发请求，而是直接停掉了，就是这个原因了。\n\n更换内嵌tomcat\n\n那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据springboot的工作机制，用什么技术，加入什么依赖就行了。springboot提供了3款内置的服务器\n\n * tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件\n\n * jetty：更轻量级，负载性能远不及tomcat\n\n * undertow：负载性能勉强跑赢tomcat\n   \n   想用哪个，加个坐标就ok。前提是把tomcat排除掉，因为tomcat是默认加载的。\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n        <exclusions>\n            <exclusion>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-tomcat</artifactid>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-jetty</artifactid>\n    </dependency>\n</dependencies>\n\n\n现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。\n\n总结\n\n 1. 内嵌tomcat服务器是springboot辅助功能之一\n 2. 内嵌tomcat工作原理是将tomcat服务器作为对象运行，并将该对象交给spring容器管理\n 3. 变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n到这里第一章快速上手springboot就结束了，这一章我们学习了两大块知识\n\n 1. 使用了4种方式制作了springboot的入门程序，不管是哪一种，其实内部都是一模一样的\n 2. 学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等\n\n第一章到这里就结束了，再往下学习就要去基于会创建springboot工程的基础上，研究springboot工程的具体细节了。\n\n\n# jc-2.springboot基础配置\n\n入门案例做完了，下面就要研究springboot的用法了。通过入门案例，各位小伙伴能够感知到一个信息，springboot没有具体的功能，它在辅助加快spring程序的开发效率。我们发现现在几乎不用做任何的配置，功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。\n\n如果我们想修改默认的配置i，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖的，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行springboot程序的入口，也不像是做配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么干预springboot的默认配置，修改成自己的配置。\n\n.iml文件是idea的配置文件，idea导入一个工程就会自动生成，因此复制的工程可以删除\n\n复制的工程中的name和discibtion可以删除\n\n\n\n\n\n\n# jc-2-1.属性配置\n\nspringboot通过配置文件resources/application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下springboot的配置格式是什么样的\n\n\n\n那该如何写呢？properties格式的文件书写规范是key=value\n\nname=itheima\n\n\n这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。当你输入port后，神奇的事情就发生了，这玩意儿带提示，太好了\n\n根据提示敲回车，输入80端口，搞定\n\nserver.port=80\n\n\n下面就可以直接运行程序，测试效果了。\n\n我们惊奇的发现springboot这玩意儿狠啊，以前修改端口在哪里改？tomcat服务器的配置文件中改，现在呢？springboot专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。\n\n其实到这里我们应该得到如下三个信息\n\n 1. springboot程序可以在application.properties文件中进行属性配置\n 2. application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置\n 3. springboot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面\n\n总结\n\n 1. springboot默认配置文件是application.properties\n\n做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。\n\n关闭运行日志图表（banner)\n\nspring.main.banner-mode=off\n\n\n设置运行日志的显示级别\n\nlogging.level.root=debug\n\n\n你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。springboot比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。\n\n我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。\n\n打开springboot的官网，找到springboot官方文档，打开查看附录中的application properties就可以获取到对应的配置项了，网址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties\n\n能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然配置的东西都没有使用对应技术，配了也是白配。\n\n温馨提示\n\n所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的springboot的starter的基础依赖，里面定义了springboot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter</artifactid>\n    <version>2.5.4</version>\n    <scope>compile</scope>\n</dependency>\n\n\n总结\n\n 1. springboot中导入对应starter后，提供对应配置属性\n 2. 书写springboot配置采用关键字+提示形式书写\n\n\n# jc-2-2.配置文件分类\n\n现在已经能够进行springboot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，springboot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。分别如下:\n\n * properties格式\n\n * yml格式\n\n * yaml格式\n   \n   一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为springboot的配置在idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下\n\n * application.properties（properties格式）\n\nserver.port=80\n\n\n * application.yml（yml格式）\n\nserver:\n  port: 81\n\n\n * application.yaml（yaml格式）\n\nserver:\n  port: 82\n\n\n仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。\n\n总结\n\n 1. springboot提供了3种配置文件的格式\n    * properties（传统格式/默认格式）\n    * yml（主流格式）\n    * yaml\n\n思考\n\n现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？\n\n# 配置文件优先级\n\n其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。\n\n * application.properties（properties格式）\n\nserver.port=80\n\n\n * application.yml（yml格式）\n\nserver:\n  port: 81\n\n\n * application.yaml（yaml格式）\n\nserver:\n  port: 82\n\n\n启动后发现目前的启动端口为80，把80对应的文件删除掉，然后再启动，现在端口又改成了81。现在我们就已经知道了3个文件的加载优先顺序是什么\n\napplication.properties  >  application.yml  >  application.yaml\n\n\n虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。\n\n最后我们把配置文件内容给修改一下\n\n * application.properties（properties格式）\n\nserver.port=80\nspring.main.banner-mode=off\n\n\n * application.yml（yml格式）\n\nserver:\n  port: 81\nlogging: \n  level: \n    root: debug\n\n\n * application.yaml（yaml格式）\n\nserver:\n  port: 82\n\n\n我们发现不仅端口生效了，最终显示80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，那所有的配置项都会生效。\n\n总结\n\n 1. 配置文件间的加载优先级 properties（最高）> yml > yaml（最低）\n 2. 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\n# 教你一招：自动提示功能消失解决方案\n\n可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。\n\n先要明确一个核心，就是自动提示功能不是springboot技术给我们提供的，是我们在idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下3种：\n\n 1. idea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能\n\n 2. idea认定你是合理的配置文件，但是idea加载不到对应的提示信息\n    \n    这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：\n\n步骤①：打开设置，【files】→【project structure...】\n\n\n\n步骤②：在弹出窗口中左侧选择【facets】，右侧选中spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块\n\n\n\n步骤③：点击customize spring boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示\n\n\n\n步骤④：选择添加配置文件，然后选中要作为配置文件的具体文件就ok了\n\n\n\n到这里就做完了，其实就是idea的一个小功能\n\n\n\n总结\n\n 1. 指定springboot配置文件\n    \n    * setting → project structure → facets\n    * 选中对应项目/工程\n    * customize spring boot\n    * 选择配置文件\n\n\n# jc-2-3.yaml文件\n\nspringboot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。\n\nyaml（yaml ain\'t markup language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：\n\n * .yml格式（主流）\n\n * .yaml格式\n   \n   对于文件自身在书写时，具有严格的语法格式要求，具体如下：\n\n 1. 大小写敏感\n 2. 属性层级关系使用多行描述，每行结尾使用冒号结束\n 3. 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用tab键）\n 4. 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n 5. #号 表示注释\n\n上述规则不要死记硬背，按照书写习惯慢慢适应，并且在idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，数据前面要加空格与冒号隔开\n\n下面列出常见的数据书写格式，熟悉一下\n\nboolean: true  \t\t\t\t\t\t#true,true,true,false,false，false均可\nfloat: 3.14    \t\t\t\t\t\t#6.8523015e+5  #支持科学计数法\nint: 123       \t\t\t\t\t\t#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制\nnull: ~        \t\t\t\t\t\t#使用~表示null\nstring: helloworld      \t\t\t#字符串可以直接书写\nstring2: "hello world"  \t\t\t#可以使用双引号包裹特殊字符\ndate: 2018-02-17        \t\t\t#日期必须使用yyyy-mm-dd格式\ndatetime: 2018-02-17t15:02:31+08:00  #时间和日期之间使用t连接，最后使用+代表时区\n\n\n此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔\n\nsubject:\n\t- java\n\t- 前端\n\t- 大数据\nenterprise:\n\tname: itcast\n    age: 16\n    subject:\n    \t- java\n        - 前端\n        - 大数据\nlikes: [王者荣耀,刺激战场]\t\t\t#数组书写缩略格式\nusers:\t\t\t\t\t\t\t #对象数组格式一\n  - name: tom\n   \tage: 4\n  - name: jerry\n    age: 5\n\n\nusers:\t\t\t\t\t\t\t #对象数组格式二\n  -  \n    name: tom\n    age: 4\n  -   \n    name: jerry\n    age: 5\t\t\t    \nusers2: [ { name:tom , age:4 } , { name:jerry , age:5 } ]\t#对象数组缩略格式\n\n\n总结\n\n 1. yaml语法规则\n    * 大小写敏感\n    * 属性层级关系使用多行描述，每行结尾使用冒号结束\n    * 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用tab键）\n    * 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n    * #号 表示注释\n 2. 注意属性名冒号后面与数据之间有一个空格\n 3. 字面值、对象数据格式、数组数据格式\n\n思考\n\n现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据时给谁用的呢？大部分是springboot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？咱们下一节再说。\n\n\n# jc-2-4.yaml数据读取\n\n对于yaml文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式\n\n# 读取单一数据\n\nyaml中保存的单个数据，可以使用spring中的注解直接读取，使用@value可以读取单个数据，属性名引用方式：${一级属性名.二级属性名……}\n\n记得使用@value注解时，要将该注入写在某一个指定的spring管控的bean的属性名上方。现在就可以读取到对应的单一数据行了\n\n总结\n\n 1. 使用@value配合spel读取单个数据\n 2. 如果数据存在多层级，依次书写层级名称即可\n\n# 读取全部数据\n\n读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，springboot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中\n\n数据封装到了environment对象中，获取属性时，通过environment的接口操作进行，具体方法时getproperties（string），参数填写属性名即可\n\n总结\n\n 1. 使用environment对象封装全部配置信息\n 2. 使用@autowired自动装配数据到environment对象中\n\n# 读取对象数据\n\n单一数据读取书写比较繁琐，全数据封装又封装的太厉害了，每次拿数据还要一个一个的getproperties（）,总之用起来都不是很舒服。由于java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。springboot也提供了可以将一组yaml对象数据封装一个java对象的操作\n\n首先定义一个对象，并将该对象纳入spring管控的范围，也就是定义成一个bean，然后使用注解@configurationproperties指定该对象加载哪一组yaml中配置的信息。\n\n这个@configurationproperties必须告诉他加载的数据前缀是什么，这样当前前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可，然后重写tostring和get、set方法。\n\n\n\n温馨提示\n\n细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，是这样的，咱们到原理篇再揭秘如何弹出提示。\n\n总结\n\n 1. 使用@configurationproperties注解绑定配置信息到封装类中\n 2. 封装类需要定义为spring管理的bean，否则无法进行属性注入\n\n# yaml文件中的数据引用\n\n如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀\n\ncenter:\n\tdatadir: /usr/local/fire/data\n    tmpdir: /usr/local/fire/tmp\n    logdir: /usr/local/fire/log\n    msgdir: /usr/local/fire/msgdir\n\n\n或者\n\ncenter:\n\tdatadir: d:/usr/local/fire/data\n    tmpdir: d:/usr/local/fire/tmp\n    logdir: d:/usr/local/fire/log\n    msgdir: d:/usr/local/fire/msgdir\n\n\n这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：\n\nbasedir: /usr/local/fire\n\tcenter:\n    datadir: ${basedir}/data\n    tmpdir: ${basedir}/tmp\n    logdir: ${basedir}/log\n    msgdir: ${basedir}/msgdir\n\n\n还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来\n\nlesson: "spring\\tboot\\nlesson"\n\n\n总结\n\n 1. 在配置文件中可以使用${属性名}方式引用属性值\n 2. 如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析\n\n到这里有关yaml文件的基础使用就先告一段落，在实用篇中再继续研究更深入的内容。\n\n\n# jc-3.基于springboot实现ssmp整合\n\n重头戏来了，springboot之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到springboot到底有多酷炫。这一章咱们学习如下技术的整合方式\n\n * 整合junit\n\n * 整合mybatis\n\n * 整合mybatis-plus\n\n * 整合druid\n   \n   上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。\n\n\n# jc-3-1.整合junit\n\nspringboot技术的定位用于简化开发，再具体点是简化spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非springboot技术时对应的整合是如何做的，然后再看基于springboot的整合是如何做的，才能比对出来简化在了哪里。\n\n我们先来看一下不使用springboot技术时，spring整合junit的制作方式\n\n//加载spring整合junit专用的类运行器\n@runwith(springjunit4classrunner.class)\n//指定对应的配置信息，这个注解也可以在springboot中使用，但是springboot默认用springboottest就行可以\n@contextconfiguration(classes = springconfig.class)\npublic class accountservicetestcase {\n    //注入你要测试的对象\n    @autowired\n    private accountservice accountservice;\n    @test\n    public void testgetbyid(){\n        //执行要测试的对象对应的方法\n        system.out.println(accountservice.findbyid(2));\n    }\n}\n\n\n\n其中核心代码是前两个注解，第一个注解@runwith是设置spring专用于测试的类运行器，简单说就是spring程序执行程序有自己的一套独立的运行程序的方式，不能使用junit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，每次都指定一样的东西，这个东西写起来没有技术含量啊，第二个注解@contextconfiguration是用来设置spring核心配置文件或配置类的，简单说就是加载spring的环境你要告诉spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。似然有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写\n\nspringboot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下\n\n@springboottest\nclass springboot04junitapplicationtests {\n    //注入你要测试的对象\n    @autowired\n    private bookdao bookdao;\n    @test\n    void contextloads() {\n        //执行要测试的对象对应的方法\n        bookdao.save();\n        system.out.println("two...");\n    }\n}\n\n\n看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会springboot整合其他技术的优势在哪里，就两个字——简化。使用一个注解@springboottest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。\n\n这个时候有人就问了，你加载的配置类或者配置文件是哪一个**（如果和引导类不在同一个包下，就不能引入默认的配置类或者引导类，故必须要显式的引入配置类或者引导类）**？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@springboottest中添加classes属性指定配置类\n\n@springboottest(classes = springboot04junitapplication.class)\nclass springboot04junitapplicationtests {\n    //注入你要测试的对象\n    @autowired\n    private bookdao bookdao;\n    @test\n    void contextloads() {\n        //执行要测试的对象对应的方法\n        bookdao.save();\n        system.out.println("two...");\n    }\n}\n\n\n第二种方式回归原始配置方式，仍然使用@contextconfiguration注解进行，效果是一样的\n\n@springboottest \n@contextconfiguration(classes = springboot04junitapplication.class)\nclass springboot04junitapplicationtests {\n    //注入你要测试的对象\n    @autowired\n    private bookdao bookdao;\n    @test\n    void contextloads() {\n        //执行要测试的对象对应的方法\n        bookdao.save();\n        system.out.println("two...");\n    }\n}\n\n\n温馨提示\n\n使用springboot整合junit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。\n\n总结\n\n 1. 导入测试对应的starter\n 2. 测试类使用@springboottest修饰\n 3. 使用自动装配的形式添加要测试的对象\n 4. 测试类如果存在于引导类所在包或子包中无需指定引导类\n 5. 测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n\n# jc-3-2.整合mybatis\n\n整合完junit下面再来说一下整合mybatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对spring整合mybatis不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行\n\n * 导入坐标，mybatis坐标不能少，spring整合mybatis还有自己专用的坐标，此外spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了druid数据源，这个倒是可以不要\n   \n   <dependencies>\n       <dependency>\n           <groupid>com.alibaba</groupid>\n           <artifactid>druid</artifactid>\n           <version>1.1.16</version>\n       </dependency>\n       <dependency>\n           <groupid>org.mybatis</groupid>\n           <artifactid>mybatis</artifactid>\n           <version>3.5.6</version>\n       </dependency>\n       <dependency>\n           <groupid>mysql</groupid>\n           <artifactid>mysql-connector-java</artifactid>\n           <version>5.1.47</version>\n       </dependency>\n       \x3c!--1.导入mybatis与spring整合的jar包--\x3e\n       <dependency>\n           <groupid>org.mybatis</groupid>\n           <artifactid>mybatis-spring</artifactid>\n           <version>1.3.0</version>\n       </dependency>\n       \x3c!--导入spring操作数据库必选的包--\x3e\n       <dependency>\n           <groupid>org.springframework</groupid>\n           <artifactid>spring-jdbc</artifactid>\n           <version>5.2.10.release</version>\n       </dependency>\n   </dependencies>\n   \n\n * spring核心配置\n   \n   @configuration\n   @componentscan("com.itheima")\n   @propertysource("jdbc.properties")\n   public class springconfig {\n   }\n   \n\n * mybatis要交给spring接管的bean\n   \n   //定义mybatis专用的配置类\n   @configuration\n   public class mybatisconfig {\n   //    定义创建sqlsessionfactory对应的bean\n       @bean\n       public sqlsessionfactorybean sqlsessionfactory(datasource datasource){\n           //sqlsessionfactorybean是由mybatis-spring包提供的，专用于整合用的对象\n           sqlsessionfactorybean sfb = new sqlsessionfactorybean();\n           //设置数据源替代原始配置中的environments的配置\n           sfb.setdatasource(datasource);\n           //设置类型别名替代原始配置中的typealiases的配置\n           sfb.settypealiasespackage("com.itheima.domain");\n           return sfb;\n       }\n   //    定义加载所有的映射配置\n       @bean\n       public mapperscannerconfigurer mapperscannerconfigurer(){\n           mapperscannerconfigurer msc = new mapperscannerconfigurer();\n           msc.setbasepackage("com.itheima.dao");\n           return msc;\n       }\n   \n   }\n   \n\n * 数据源对应的bean，此处使用druid数据源\n   \n   @configuration\n   public class jdbcconfig {\n       @value("${jdbc.driver}")\n       private string driver;\n       @value("${jdbc.url}")\n       private string url;\n       @value("${jdbc.username}")\n       private string username;\n       @value("${jdbc.password}")\n       private string password;\n   \n       @bean("datasource")\n       public datasource datasource(){\n           druiddatasource ds = new druiddatasource();\n           ds.setdriverclassname(driver);\n           ds.seturl(url);\n           ds.setusername(username);\n           ds.setpassword(password);\n           return ds;\n       }\n   }\n   \n\n * 数据库连接信息（properties格式）\n   \n   jdbc.driver=com.mysql.jdbc.driver\n   jdbc.url=jdbc:mysql://localhost:3306/spring_db?usessl=false\n   jdbc.username=root\n   jdbc.password=root\n   \n   \n   上述格式基本上是简格式了，要写的东西还真不少。下面看看springboot整合mybaits格式\n\n步骤①：创建模块时勾选要使用的技术，mybatis，由于要操作数据库，还要勾选对应数据库\n\n\n\n\n\n或者手工导入对应技术的starter，和对应数据库的坐标\n\n<dependencies>\n    \x3c!--1.导入对应的starter--\x3e\n    <dependency>\n        <groupid>org.mybatis.spring.boot</groupid>\n        <artifactid>mybatis-spring-boot-starter</artifactid>\n        <version>2.2.0</version>\n    </dependency>\n\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n\n\n步骤②：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n\n\n完了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，springboot把配置中所有可能出现的通用配置都简化了。下面就可以写一下mybatis程序运行需要的dao（或者mapper）就可以运行了\n\n实体类（还要有set和get方法、tostring方法）\n\npublic class book {\n    private integer id;\n    private string type;\n    private string name;\n    private string description;\n}\n\n\n映射接口（dao）\n\n@mapper\npublic interface bookdao {\n    @select("select * from tbl_book where id = #{id}")\n    public book getbyid(integer id);\n}\n\n\n测试类\n\n@springboottest\nclass springboot05mybatisapplicationtests {\n    @autowired\n    private bookdao bookdao;\n    @test\n    void contextloads() {\n        system.out.println(bookdao.getbyid(1));\n    }\n}\n\n\n完美，开发从此变的就这么简单。再体会一下springboot如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解\n\n注意：当前使用的springboot版本是2.5.4，对应的坐标设置中mysql驱动使用的是8x版本。当springboot2.4.3（不含）版本之前会出现一个小bug，就是mysql驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n    username: root\n    password: root\n\n\n这里设置的utc是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置不写utc，写asia/shanghai也可以解决这个问题。\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=asia/shanghai\n    username: root\n    password: root\n\n\n如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone=+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。\n\n此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用com.mysql.jdbc.driver，换用com.mysql.cj.jdbc.driver。前面的例子中已经更换了驱动了，在此说明一下。\n\nloading class `com.mysql.jdbc.driver\'. this is deprecated. the new driver class is `com.mysql.cj.jdbc.driver\'. the driver is automatically registered via the spi and manual loading of the driver class is generally unnecessary.\n\n\n总结\n\n 1. 整合操作需要勾选mybatis技术，也就是导入mybatis对应的starter\n\n 2. 数据库连接相关信息转换成配置\n\n 3. 数据库sql映射需要添加@mapper被容器识别到\n\n 4. mysql 8.x驱动强制要求设置时区\n    \n    * 修改url，添加servertimezone设定\n    * 修改mysql数据库配置\n\n 5. 驱动类过时，提醒更换为com.mysql.cj.jdbc.driver\n\n\n# jc-3-3.整合mybatis-plus\n\n做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话\n\n * 导入对应技术的starter坐标\n * 根据对应技术的要求做配置\n\n虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。\n\n接下来在mybatis的基础上再升级一下，整合mybaitsplus（简称mp），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合\n\n步骤①：手工导入对应的starter （去www.mvnrepository.com查询插件对应的版本及其他信息，官网会给出引用格式）\n\n<dependency>\n    <groupid>com.baomidou</groupid>\n    <artifactid>mybatis-plus-boot-starter</artifactid>\n    <version>3.4.3</version>\n</dependency>\n\n\n关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式\n\nspring-boot-start-***\n\n\n而这个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范，后期原理篇会再详细讲解\n\nstarter所属   命名规则                                   示例\n官方提供        spring-boot-starter-技术名称               spring-boot-starter-web\n                                                   spring-boot-starter-test\n第三方提供       第三方技术名称-spring-boot-starter            druid-spring-boot-starter\n第三方提供       第三方技术名称-boot-starter（第三方技术名称过长，简化命名）   mybatis-plus-boot-starter\n\n温馨提示\n\n有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，springboot官网还未收录此坐标，而我们idea创建模块时读取的是springboot官网的spring initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应mybatis-plus的坐标\n\n步骤②：配置数据源相关信息\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n\n\n没了，就这么多，剩下的就是写mybaitsplus的程序了\n\n映射接口（dao）\n\n@mapper\npublic interface bookdao extends basemapper<book> {\n}\n\n\n核心在于dao接口继承了一个basemapper的接口，这个接口中帮助开发者预定了若干个常用的api接口，简化了通用api接口的开发工作。\n\n下面就可以写一个测试类进行测试了，此处省略。\n\n温馨提示\n\n目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到mybatisplus课程中去学习，此处仅给出解决方案。配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置所有表的通用前缀名称为tbl_\n\n\n总结\n\n 1. 手工添加mybatis-plus对应的starter\n 2. 数据层接口使用basemapper简化开发\n 3. 需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标\n\n\n# jc-3-4.整合druid\n\n使用springboot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。\n\n前面整合mybatis和mp的时候，使用的数据源对象都是springboot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，druid。\n\n在没有指定数据源时，我们的配置如下：\n\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=asia/shanghai\n    username: root\n    password: root\n\n\n此时虽然没有指定数据源，但是根据springboot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是hikari。通过启动日志可以查看到对应的身影。\n\n2021-11-29 09:39:15.202  info 12260 --- [           main] com.zaxxer.hikari.hikaridatasource       : hikaripool-1 - starting...\n2021-11-29 09:39:15.208  warn 12260 --- [           main] com.zaxxer.hikari.util.driverdatasource  : registered driver with driverclassname=com.mysql.jdbc.driver was not found, trying direct instantiation.\n2021-11-29 09:39:15.551  info 12260 --- [           main] com.zaxxer.hikari.hikaridatasource       : hikaripool-1 - start completed.\n\n\n上述信息中每一行都有hikari的身影，如果需要更换数据源，其实只需要两步即可。\n\n 1. 导入对应的技术坐标\n 2. 配置使用指定的数据源类型\n\n下面就切换一下数据源对象\n\n步骤①：导入对应的坐标（注意，是坐标，此处不是starter）\n\n<dependencies>\n    <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>druid</artifactid>\n        <version>1.1.16</version>\n    </dependency>\n</dependencies>\n\n\n步骤②：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n    username: root\n    password: root\n    type: com.alibaba.druid.pool.druiddatasource\n\n\n这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照springboot整合其他技术的通用规则来套啊，导入对应的starter，进行相应的配置即可。\n\n步骤①：导入对应的starter\n\n<dependencies>\n    <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>druid-spring-boot-starter</artifactid>\n        <version>1.2.6</version>\n    </dependency>\n</dependencies>\n\n\n步骤②：修改配置\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.driver\n      url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n      username: root\n      password: root\n\n\n注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西**（diuid专用特定的专用配置方法）**。言外之意，url这个属性时druid下面的属性，那你能想到吗？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅\n\n与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。\n\n这是我们做的第4个技术的整合方案，还是那两句话：导入对应starter，使用对应配置。没了，springboot整合其他技术就这么简单粗暴。\n\n总结\n\n 1. 整合druid需要导入druid对应的starter\n 2. 根据druid提供的配置方式进行配置\n 3. 整合第三方技术通用方式\n    * 导入对应的starter\n    * 根据提供的配置格式，配置非默认值对应的配置项\n\n\n# jc-3-5.ssmp整合综合案例\n\nspringboot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的springboot整合其他技术的案例，为什么感觉springboot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。\n\n先看一下这个案例的最终效果\n\n主页面\n\n\n\n添加\n\n\n\n删除\n\n\n\n修改\n\n\n\n分页\n\n\n\n条件查询\n\n\n\n整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个\n\n 1. 实体类开发————使用lombok快速制作实体类\n 2. dao开发————整合mybatisplus，制作数据层测试\n 3. service开发————基于mybatisplus进行增量开发，制作业务层测试类\n 4. controller开发————基于restful开发，使用postman测试接口功能\n 5. controller开发————前后端开发协议制作\n 6. 页面开发————基于vue+elementui制作，前后端联调，页面数据处理，页面消息处理\n    * 列表\n    * 新增\n    * 修改\n    * 删除\n    * 分页\n    * 查询\n 7. 项目异常处理\n 8. 按条件查询————页面功能调整、controller修正功能、service修正功能\n\n可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟进进度，完成这个小案例的制作。\n\n# 0.模块创建\n\n对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。\n\n我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。\n\n一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。\n\n下面我们就可以创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。\n\npom.xml\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-test</artifactid>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n\napplication.yml\n\nserver:\n  port: 80\n\n\n# 1.实体类开发\n\n本案例对应的模块表结构如下：\n\n-- ----------------------------\n-- table structure for tbl_book\n-- ----------------------------\ndrop table if exists `tbl_book`;\ncreate table `tbl_book`  (\n  `id` int(11) not null auto_increment,\n  `type` varchar(20) character set utf8 collate utf8_general_ci null default null,\n  `name` varchar(50) character set utf8 collate utf8_general_ci null default null,\n  `description` varchar(255) character set utf8 collate utf8_general_ci null default null,\n  primary key (`id`) using btree\n) engine = innodb auto_increment = 51 character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of tbl_book\n-- ----------------------------\ninsert into `tbl_book` values (1, \'计算机理论\', \'spring实战 第5版\', \'spring入门经典教程，深入理解spring原理技术内幕\');\ninsert into `tbl_book` values (2, \'计算机理论\', \'spring 5核心原理与30个类手写实战\', \'十年沉淀之作，手写spring精华思想\');\ninsert into `tbl_book` values (3, \'计算机理论\', \'spring 5 设计模式\', \'深入spring源码剖析spring源码中蕴含的10大设计模式\');\ninsert into `tbl_book` values (4, \'计算机理论\', \'spring mvc+mybatis开发从入门到项目实战\', \'全方位解析面向web应用的轻量级框架，带你成为spring mvc开发高手\');\ninsert into `tbl_book` values (5, \'计算机理论\', \'轻量级java web企业应用实战\', \'源码级剖析spring框架，适合已掌握java基础的读者\');\ninsert into `tbl_book` values (6, \'计算机理论\', \'java核心技术 卷i 基础知识（原书第11版）\', \'core java 第11版，jolt大奖获奖作品，针对java se9、10、11全面更新\');\ninsert into `tbl_book` values (7, \'计算机理论\', \'深入理解java虚拟机\', \'5个维度全面剖析jvm，大厂面试知识点全覆盖\');\ninsert into `tbl_book` values (8, \'计算机理论\', \'java编程思想（第4版）\', \'java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉\');\ninsert into `tbl_book` values (9, \'计算机理论\', \'零基础学java（全彩版）\', \'零基础自学编程的入门图书，由浅入深，详解java语言的编程思想和核心技术\');\ninsert into `tbl_book` values (10, \'市场营销\', \'直播就该这么做：主播高效沟通实战指南\', \'李子柒、李佳琦、薇娅成长为网红的秘密都在书中\');\ninsert into `tbl_book` values (11, \'市场营销\', \'直播销讲实战一本通\', \'和秋叶一起学系列网络营销书籍\');\ninsert into `tbl_book` values (12, \'市场营销\', \'直播带货：淘宝、天猫直播从新手到高手\', \'一本教你如何玩转直播的书，10堂课轻松实现带货月入3w+\');\n\n\n根据上述表结构，制作对应的实体类\n\n实体类\n\npublic class book {\n    private integer id;\n    private string type;\n    private string name;\n    private string description;\n}\n\n\n实体类的开发可以自动通过工具手工生成get/set方法，然后覆盖tostring()、equals()，hashcode()等方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。\n\nlombok，一个java类库，提供了一组注解，简化pojo实体类开发，springboot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。\n\n<dependencies>\n    \x3c!--lombok--\x3e\n    <dependency>\n        <groupid>org.projectlombok</groupid>\n        <artifactid>lombok</artifactid>\n    </dependency>\n</dependencies>\n\n\n使用lombok可以通过一个注解@data完成一个实体类对应的getter，setter，tostring，equals，hashcode等操作的快速添加\n\nimport lombok.data;\n@data\npublic class book {\n    private integer id;\n    private string type;\n    private string name;\n    private string description;\n}\n\n\n到这里实体类就做好了，是不是比不使用lombok简化好多，这种工具在java开发中还有n多，后面课程中遇到了能用的东西时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些\n\n总结\n\n 1. 实体类制作\n 2. 使用lombok简化开发\n    * 导入lombok无需指定版本，由springboot提供版本\n    * @data注解\n\n# 2.数据层开发——基础crud\n\n数据层开发本次使用mybatisplus技术，数据源使用前面学习的druid，学都学了都用上\n\n步骤①：导入mybatisplus与druid对应的starter，当然mysql的驱动不能少\n\n<dependencies>\n    <dependency>\n        <groupid>com.baomidou</groupid>\n        <artifactid>mybatis-plus-boot-starter</artifactid>\n        <version>3.4.3</version>\n    </dependency>\n    <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>druid-spring-boot-starter</artifactid>\n        <version>1.2.6</version>\n    </dependency>\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n\n\n步骤②：配置数据库连接相关的数据源配置\n\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.driver\n      url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n      username: root\n      password: root\n\n\n步骤③：使用mp的标准通用接口basemapper加速开发，别忘了@mapper和泛型的指定\n\n@mapper\npublic interface bookdao extends basemapper<book> {\n}\n\n\n步骤④：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧\n\npackage com.itheima.dao;\n\nimport com.baomidou.mybatisplus.core.conditions.query.lambdaquerywrapper;\nimport com.baomidou.mybatisplus.core.conditions.query.querywrapper;\nimport com.baomidou.mybatisplus.core.metadata.ipage;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.page;\nimport com.itheima.domain.book;\nimport org.junit.jupiter.api.test;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.test.context.springboottest;\n\n@springboottest\npublic class bookdaotestcase {\n\n    @autowired\n    private bookdao bookdao;\n\n    @test\n    void testgetbyid(){\n        system.out.println(bookdao.selectbyid(1));\n    }\n\n    @test\n    void testsave(){\n        book book = new book();\n        book.settype("测试数据123");\n        book.setname("测试数据123");\n        book.setdescription("测试数据123");\n        bookdao.insert(book);\n    }\n\n    @test\n    void testupdate(){\n        book book = new book();\n        book.setid(17);\n        book.settype("测试数据abcdefg");\n        book.setname("测试数据123");\n        book.setdescription("测试数据123");\n        bookdao.updatebyid(book);\n    }\n\n    @test\n    void testdelete(){\n        bookdao.deletebyid(16);\n    }\n\n    @test\n    void testgetall(){\n        bookdao.selectlist(null);\n    }\n}\n\n\n温馨提示\n\nmp技术默认的主键生成策略为雪花算法，生成的主键id长度较大，和目前的数据库设定规则不相符，需要配置一下使mp使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下\n\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.driver\n      url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n      username: root\n      password: root\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置表名通用前缀\n      id-type: auto\t\t\t\t#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增\n\n\n# 查看mp运行日志\n\n在进行数据层测试的时候，因为基础的crud操作均由mp给我们提供了，所以就出现了一个局面，开发者不需要书写sql语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装sql语句这些操作完全不是你干预开发出来的，所以查看执行期运行的sql语句就成为当务之急。\n\nspringboot整合mp的时候充分考虑到了这点，通过配置的形式就可以查阅执行期sql语句，配置如下\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\n      id-type: auto\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.stdoutimpl\n\n\n再来看运行结果，此时就显示了运行期执行sql的情况。\n\ncreating a new sqlsession\nsqlsession [org.apache.ibatis.session.defaults.defaultsqlsession@2c9a6717] was not registered for synchronization because synchronization is not active\njdbc connection [com.mysql.cj.jdbc.connectionimpl@6ca30b8a] will not be managed by spring\n==>  preparing: select id,type,name,description from tbl_book\n==> parameters: \n<==    columns: id, type, name, description\n<==        row: 1, 计算机理论, spring实战 第5版, spring入门经典教程，深入理解spring原理技术内幕\n<==        row: 2, 计算机理论, spring 5核心原理与30个类手写实战, 十年沉淀之作，手写spring精华思想\n<==        row: 3, 计算机理论, spring 5 设计模式, 深入spring源码剖析spring源码中蕴含的10大设计模式\n<==        row: 4, 计算机理论, spring mvc+mybatis开发从入门到项目实战, 全方位解析面向web应用的轻量级框架，带你成为spring mvc开发高手\n<==        row: 5, 计算机理论, 轻量级java web企业应用实战, 源码级剖析spring框架，适合已掌握java基础的读者\n<==        row: 6, 计算机理论, java核心技术 卷i 基础知识（原书第11版）, core java 第11版，jolt大奖获奖作品，针对java se9、10、11全面更新\n<==        row: 7, 计算机理论, 深入理解java虚拟机, 5个维度全面剖析jvm，大厂面试知识点全覆盖\n<==        row: 8, 计算机理论, java编程思想（第4版）, java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉\n<==        row: 9, 计算机理论, 零基础学java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解java语言的编程思想和核心技术\n<==        row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中\n<==        row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍\n<==        row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3w+\n<==        row: 13, 测试类型, 测试数据, 测试描述数据\n<==        row: 14, 测试数据update, 测试数据update, 测试数据update\n<==        row: 15, -----------------, 测试数据123, 测试数据123\n<==      total: 15\n\n\n其中清晰的标注了当前执行的sql语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。\n\n此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可\n\n总结\n\n 1. 手工导入starter坐标（2个），mysql驱动（1个）\n\n 2. 配置数据源与mybatisplus对应的配置\n\n 3. 开发dao接口（dao用于操作数据库）（继承basemapper）\n\n 4. 制作测试类测试dao功能是否有效\n\n 5. 使用配置方式开启日志，设置日志输出方式为标准输出即可查阅sql执行日志\n\n# 3.数据层开发——分页功能制作\n\n前面仅仅是使用了mp提供的基础crud功能，实际上mp给我们提供了几乎所有的基础操作，这一节说一下如果实现数据库端的分页操作\n\nmp提供的分页操作api如下\n\n@test\nvoid testgetpage(){\n    ipage page = new page(2,5);\n    bookdao.selectpage(page, null);\n    system.out.println(page.getcurrent());\n    system.out.println(page.getsize());\n    system.out.println(page.gettotal());\n    system.out.println(page.getpages());\n    system.out.println(page.getrecords());\n}\n\n\n其中selectpage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是mp提供的，别选错包了。创建此对象时就需要指定分页的两个基本数据\n\n * 当前显示第几页\n * 每页显示几条数据\n\n可以通过创建page对象时利用构造方法初始化这两个数据\n\nipage page = new page(2,5);\n\n\n将该对象传入到查询方法selectpage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个ipage对象，这又是怎么回事？\n\nipage page = bookdao.selectpage(page, null);\n\n\n原来这个ipage对象中封装了若干个数据，而查询的结果作为ipage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个ipage对象中，其实还是为了高度的封装，一个ipage描述了分页所有的信息。下面5个操作就是ipage对象中封装的所有信息了\n\n@test\nvoid testgetpage(){\n    ipage page = new page(2,5);  //ipage对象\n    bookdao.selectpage(page, null);\n    system.out.println(page.getcurrent());\t\t//当前页码值\n    system.out.println(page.getsize());\t\t\t//每页显示数\n    system.out.println(page.gettotal());\t\t//数据总量\n    system.out.println(page.getpages());\t\t//总页数\n    system.out.println(page.getrecords());\t\t//详细数据\n}\n\n\n到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页当前是无效的。为什么这样呢？这个要源于mp的内部机制。\n\n对于mysql的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候mp为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为iphone6与iphone6s-plus的关系。\n\n基础操作中有查询全部的功能，而在这个基础上只需要升级一下（plus）就可以得到分页操作。所以mp将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过mp的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习mybatisplus这门课程进行详细解读。具体设置方式如下\n\n定义mp拦截器并将其设置为spring管控的bean\n\n@configuration\npublic class mpconfig {\n    @bean\n    public mybatisplusinterceptor mybatisplusinterceptor(){\n        mybatisplusinterceptor interceptor = new mybatisplusinterceptor();\n        interceptor.addinnerinterceptor(new paginationinnerinterceptor());\n        return interceptor;\n    }\n}\n\n\n上述代码第一行是创建mp的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。\n\n总结\n\n 1. 使用ipage封装分页数据\n 2. 分页操作依赖mybatisplus分页拦截器实现功能\n 3. 借助mybatisplus日志查阅执行sql语句\n\n# 4.数据层开发——条件查询功能制作\n\n除了分页功能，mp还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的sql语句，现在简单了，mp将这些操作都制作成api接口，调用一个又一个的方法就可以实现各种套件的拼装。这里给大家普及一下基本格式，详细的操作还是到mp的课程中查阅吧\n\n下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用\n\n@test\nvoid testgetby(){\n    querywrapper<book> qw = new querywrapper<>();\n    qw.like("name","spring");\n    bookdao.selectlist(qw);\n}\n\n\n其中第一句querywrapper对象是一个用于封装查询条件的对象，该对象可以动态使用api调用的方法添加条件，最终转化成对应的sql语句。第二句就是一个条件了，需要什么条件，使用querywapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。\n\n这组api使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。\n\nmp针对字段检查进行了功能升级，全面支持lambda表达式，就有了下面这组api。由querywrapper对象升级为lambdaquerywrapper对象，这下就变了上述问题的出现\n\n@test\nvoid testgetby2(){\n    string name = "1";\n    lambdaquerywrapper<book> lqw = new lambdaquerywrapper<book>();\n    lqw.like(book::getname,name);\n    bookdao.selectlist(lqw);\n}\n\n\n为了便于开发者动态拼写sql，防止将null数据作为条件使用，mp还提供了动态拼装sql的快捷书写方式\n\n@test\nvoid testgetby2(){\n    string name = "1";\n    lambdaquerywrapper<book> lqw = new lambdaquerywrapper<book>();\n    //if(name != null) lqw.like(book::getname,name);\t\t//方式一：java代码控制\n    lqw.like(name != null,book::getname,name);\t\t\t\t//方式二：api接口提供控制开关\n    bookdao.selectlist(lqw);\n}\n\n\n其实就是个格式，没有区别。关于mp的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴还是去完整的学习一下mp的知识吧，这里只是蜻蜓点水的用了几个操作而已。\n\n总结\n\n 1. 使用querywrapper对象封装查询条件\n\n 2. 推荐使用lambdaquerywrapper对象\n\n 3. 所有查询操作封装成方法调用\n\n 4. 查询条件支持动态条件拼装\n\n# 5.业务层开发\n\n数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是组织业务逻辑功能，并根据业务需求，对数据持久层发起调用。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。\n\n一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作\n\nlogin(string username,string password);\n\n\n而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询\n\nselectbyusernameandpassword(string username,string password);\n\n\n我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的\n\n接口：传入用户名与密码字段，查询出对应结果，结果是单条数据\n接口：传入id字段，查询出对应结果，结果是单条数据\n接口：传入离职字段，查询出对应结果，结果是多条数据\n\n\n但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大\n\n接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对喵喵喵字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回businessexception，封装消息码info_logon_username_password_error\n\n\n你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的iso标准化文档而已。\n\n多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：\n\npublic interface bookservice {\n    boolean save(book book);\n    boolean update(book book);\n    boolean delete(integer id);\n    book getbyid(integer id);\n    list<book> getall();\n    ipage<book> getpage(int currentpage,int pagesize);\n}\n\n\n业务层实现类如下，转调数据层即可\n\n@service\npublic class bookserviceimpl implements bookservice {\n\n    @autowired\n    private bookdao bookdao;\n\n    @override\n    public boolean save(book book) {\n        return bookdao.insert(book) > 0;\n    }\n\n    @override\n    public boolean update(book book) {\n        return bookdao.updatebyid(book) > 0;\n    }\n\n    @override\n    public boolean delete(integer id) {\n        return bookdao.deletebyid(id) > 0;\n    }\n\n    @override\n    public book getbyid(integer id) {\n        return bookdao.selectbyid(id);\n    }\n\n    @override\n    public list<book> getall() {\n        return bookdao.selectlist(null);\n    }\n\n    @override\n    public ipage<book> getpage(int currentpage, int pagesize) {\n        ipage page = new page(currentpage,pagesize);\n        bookdao.selectpage(page,null);\n        return page;\n    }\n}\n\n\n别忘了对业务层接口进行测试，测试类如下\n\n@springboottest\npublic class bookservicetest {\n    @autowired\n    private ibookservice bookservice;\n\n    @test\n    void testgetbyid(){\n        system.out.println(bookservice.getbyid(4));\n    }\n    @test\n    void testsave(){\n        book book = new book();\n        book.settype("测试数据123");\n        book.setname("测试数据123");\n        book.setdescription("测试数据123");\n        bookservice.save(book);\n    }\n    @test\n    void testupdate(){\n        book book = new book();\n        book.setid(17);\n        book.settype("-----------------");\n        book.setname("测试数据123");\n        book.setdescription("测试数据123");\n        bookservice.updatebyid(book);\n    }\n    @test\n    void testdelete(){\n        bookservice.removebyid(18);\n    }\n\n    @test\n    void testgetall(){\n        bookservice.list();\n    }\n\n    @test\n    void testgetpage(){\n        ipage<book> page = new page<book>(2,5);\n        bookservice.page(page);\n        system.out.println(page.getcurrent());\n        system.out.println(page.getsize());\n        system.out.println(page.gettotal());\n        system.out.println(page.getpages());\n        system.out.println(page.getrecords());\n    }\n\n}\n\n\n总结\n\n 1. service接口名称定义成业务名称，并与dao接口名称进行区分\n 2. 制作测试类测试service功能是否有效\n\n# 业务层快速开发\n\n其实mp技术不仅提供了数据层快速开发方案，业务层mp也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用\n\n业务层接口快速开发\n\npublic interface ibookservice extends iservice<book> {\n    //添加非通用操作api接口\n}\n\n\n业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类\n\n@service\npublic class bookserviceimpl extends serviceimpl<bookdao, book> implements ibookservice {\n    @autowired\n    private bookdao bookdao;\n\t//添加非通用操作api\n}\n\n\n如果感觉mp提供的功能不足以支撑你的使用需要，其实是一定不能支撑的，因为需求不可能是通用的，在原始接口基础上接着定义新的api接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的api接口名冲突即可。\n\n总结\n\n 1. 使用通用接口（iserivce<t>）快速开发service\n 2. 使用通用实现类（serviceimpl<m,t>）快速开发serviceimpl\n 3. 可以在通用接口基础上做功能重载或功能追加\n 4. 注意重载时不要覆盖原始操作，避免原始提供的功能丢失\n\n# 6.表现层开发\n\n终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么springboot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于restful的表现层接口开发，功能测试通过postman工具进行\n\n表现层接口如下:\n\n@restcontroller\n@requestmapping("/books")\npublic class bookcontroller2 {\n\n    @autowired\n    private ibookservice bookservice;\n\n    @getmapping\n    public list<book> getall(){\n        return bookservice.list();\n    }\n\n    @postmapping\n    public boolean save(@requestbody book book){\n        return bookservice.save(book);\n    }\n\n    @putmapping\n    public boolean update(@requestbody book book){\n        return bookservice.modify(book);\n    }\n\n    @deletemapping("{id}")\n    public boolean delete(@pathvariable integer id){\n        return bookservice.delete(id);\n    }\n\n    @getmapping("{id}")\n    public book getbyid(@pathvariable integer id){\n        return bookservice.getbyid(id);\n    }\n\n    @getmapping("{currentpage}/{pagesize}")\n    public ipage<book> getpage(@pathvariable int currentpage,@pathvariable int pagesize){\n        return bookservice.getpage(currentpage,pagesize, null);\n    }\n}\n\n\n在实用postman测试时关注提交类型，对应上即可，不然就会报405的错误码了\n\n普通get请求\n\n\n\nput请求传递json数据，后台实用@requestbody接收数据\n\n\n\nget请求传递路径变量，后台实用@pathvariable接收数据\n\n\n\n总结\n\n 1. 基于restful制作表现层接口\n    * 新增：post\n    * 删除：delete\n    * 修改：put\n    * 查询：get\n 2. 接收参数\n    * 实体数据：@requestbody\n    * 路径变量：@pathvariable\n\n# 7.表现层消息一致性处理\n\n目前我们通过postman测试后业务层接口功能时通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重\n\n增删改操作结果\n\ntrue\n\n\n查询单个数据操作结果\n\n{\n    "id": 1,\n    "type": "计算机理论",\n    "name": "spring实战 第5版",\n    "description": "spring入门经典教程"\n}\n\n\n查询全部数据操作结果\n\n[\n    {\n        "id": 1,\n        "type": "计算机理论",\n        "name": "spring实战 第5版",\n        "description": "spring入门经典教程"\n    },\n    {\n        "id": 2,\n        "type": "计算机理论",\n        "name": "spring 5核心原理与30个类手写实战",\n        "description": "十年沉淀之作"\n    }\n]\n\n\n每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n@data\npublic class r {\n    private boolean flag;\n    private object data;\n}\n\n\n其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了\n\n{\n    "flag": true,\n    "data":{\n        "id": 1,\n        "type": "计算机理论",\n        "name": "spring实战 第5版",\n        "description": "spring入门经典教程"\n    }\n}\n\n\n表现层开发格式也需要转换一下\n\n结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的麻烦。\n\n总结\n\n 1. 设计统一的返回值结果类型便于前端开发读取数据\n\n 2. 返回值结果类型可以根据需求自行设定，没有固定格式\n\n 3. 返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n# 8.前后端联通性测试\n\n后端的表现层接口开发完毕，就可以进行前端的开发了。\n\n将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。\n\n\n\n在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发\n\n//列表\ngetall() {\n\taxios.get("/books").then((res)=>{\n\t\tconsole.log(res.data);\n\t});\n},\n\n\n只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了\n\n总结\n\n 1. 单体项目中页面放置在resources/static目录下\n 2. created钩子函数用于初始化页面时发起调用\n 3. 页面使用axios发送异步请求获取数据后确认前后端是否联通\n\n# 9.页面基础功能开发\n\n# f-1.列表功能（非分页版）\n\n列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用vue的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可\n\n页面数据模型定义\n\ndata:{\n\tdatalist: [],//当前页要展示的列表数据\n\t...\n},\n\n\n异步请求获取数据\n\n//列表\ngetall() {\n    axios.get("/books").then((res)=>{\n        this.datalist = res.data.data;\n    });\n},\n\n\n这样在页面加载时就可以获取到数据，并且由vue将数据展示到页面上了\n\n总结：\n\n 1. 将查询数据返回到页面，利用前端数据绑定进行数据展示\n\n# f-2.添加功能\n\n添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可\n\n默认状态\n\ndata:{\n\tdialogformvisible: false,//添加表单是否可见\n\t...\n},\n\n\n切换为显示状态\n\n//弹出添加窗口\nhandlecreate() {\n\tthis.dialogformvisible = true;\n},\n\n\n由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹\n\n定义清理数据操作\n\n//重置表单\nresetform() {\n    this.formdata = {};\n},\n\n\n切换弹窗状态时清理数据\n\n//弹出添加窗口\nhandlecreate() {\n    this.dialogformvisible = true;\n    this.resetform();\n},\n\n\n至此准备工作完成，下面就要调用后台完成添加操作了\n\n添加操作\n\n//添加\nhandleadd () {\n    //发送异步请求\n    axios.post("/books",this.formdata).then((res)=>{\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.flag){\n            this.dialogformvisible = false;\n            this.$message.success("添加成功");\n        }else {\n            this.$message.error("添加失败");\n        }\n    }).finally(()=>{\n        this.getall();\n    });\n},\n\n\n 1. 将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台\n 2. 根据返回的操作结果决定下一步操作\n    * 如何是true就关闭添加窗口，显示添加成功的消息\n    * 如果是false保留添加窗口，显示添加失败的消息\n 3. 无论添加是否成功，页面均进行刷新，动态加载数据（对getall操作发起调用）\n\n取消添加操作\n\n//取消\ncancel(){\n    this.dialogformvisible = false;\n    this.$message.info("操作取消");\n},\n\n\n总结\n\n 1. 请求方式使用post调用后台对应操作\n 2. 添加操作结束后动态刷新页面加载数据\n 3. 根据操作结果不同，显示对应的提示信息\n 4. 弹出添加div时清除表单数据\n\n# f-3.删除功能\n\n模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可\n\n删除操作\n\n// 删除\nhandledelete(row) {\n    axios.delete("/books/"+row.id).then((res)=>{\n        if(res.data.flag){\n            this.$message.success("删除成功");\n        }else{\n            this.$message.error("删除失败");\n        }\n    }).finally(()=>{\n        this.getall();\n    });\n},\n\n\n删除操作提示信息\n\n// 删除\nhandledelete(row) {\n    //1.弹出提示框\n    this.$confirm("此操作永久删除当前数据，是否继续？","提示",{\n        type:\'info\'\n    }).then(()=>{\n        //2.做删除业务\n        axios.delete("/books/"+row.id).then((res)=>{\n       \t\tif(res.data.flag){\n            \tthis.$message.success("删除成功");\n        \t}else{\n            \tthis.$message.error("删除失败");\n        \t}\n        }).finally(()=>{\n            this.getall();\n        });\n    }).catch(()=>{\n        //3.取消删除\n        this.$message.info("取消删除操作");\n    });\n}，\t\n\n\n总结\n\n 1. 请求方式使用delete调用后台对应操作\n 2. 删除操作需要传递当前行数据对应的id值到后台\n 3. 删除操作结束后动态刷新页面加载数据\n 4. 根据操作结果不同，显示对应的提示信息\n 5. 删除操作前弹出提示框避免误操作\n\n# f-4.修改功能\n\n修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：\n\n 1. 页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗\n\n 2. 弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据\n\n 3. 查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台\n\n 4. 查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据\n\n 5. 修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据\n    \n    所以整体上来看，修改功能就是前面几个功能的大合体\n    \n    查询并展示数据\n\n//弹出编辑窗口\nhandleupdate(row) {\n    axios.get("/books/"+row.id).then((res)=>{\n        if(res.data.flag){\n            //展示弹层，加载数据\n            this.formdata = res.data.data;\n            this.dialogformvisible4edit = true;\n        }else{\n            this.$message.error("数据同步失败，自动刷新");\n        }\n    });\n},\n\n\n修改操作\n\n//修改\nhandleedit() {\n    axios.put("/books",this.formdata).then((res)=>{\n        //如果操作成功，关闭弹层并刷新页面\n        if(res.data.flag){\n            this.dialogformvisible4edit = false;\n            this.$message.success("修改成功");\n        }else {\n            this.$message.error("修改失败，请重试");\n        }\n    }).finally(()=>{\n        this.getall();\n    });\n},\n\n\n总结\n\n 1. 加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）\n 2. 利用前端双向数据绑定将查询到的数据进行回显（同查询全部）\n 3. 请求方式使用put调用后台对应操作（同新增传递数据）\n 4. 修改操作结束后动态刷新页面加载数据（同新增）\n 5. 根据操作结果不同，显示对应的提示信息（同新增）\n\n\n\n# 10.业务消息一致性处理\n\n目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出bug，如果我们搞一个bug出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子\n\n{\n    "timestamp": "2021-09-15t03:27:31.038+00:00",\n    "status": 500,\n    "error": "internal server error",\n    "path": "/books"\n}\n\n\n面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？\n\n{\n    "flag": true,\n    "data":{\n        "id": 1,\n        "type": "计算机理论",\n        "name": "spring实战 第5版",\n        "description": "spring入门经典教程"\n    }\n}\n\n\n看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理\n\n首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息\n\n@data\npublic class r{\n    private boolean flag;\n    private object data;\n    private string msg;\t\t//用于封装消息\n}\n\n\n后台代码也要根据情况做处理，当前是模拟的错误\n\n@postmapping\npublic r save(@requestbody book book) throws ioexception {\n    boolean flag = bookservice.insert(book);\n    return new r(flag , flag ? "添加成功^_^" : "添加失败-_-!");\n}\n\n\n然后在表现层做统一的异常处理，使用springmvc提供的异常处理器做统一的异常处理\n\n@restcontrolleradvice\npublic class projectexceptionadvice {\n    // exceptionhandler用来拦截所有或者指定的异常信息\n    @exceptionhandler(exception.class)\n    public r dootherexception(exception ex){\n        //记录日志\n        //发送消息给运维\n        //发送邮件给开发人员,ex对象发送给开发人员\n        ex.printstacktrace();\n        return new r(false,null,"系统错误，请稍后再试！");\n    }\n}\n\n\n页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息\n\n//添加\nhandleadd () {\n\t//发送ajax请求\n    axios.post("/books",this.formdata).then((res)=>{\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.flag){\n            this.dialogformvisible = false;\n            this.$message.success("添加成功");\n        }else {\n            this.$message.error(res.data.msg);\t\t\t//消息来自于后台传递过来，而非固定内容\n        }\n    }).finally(()=>{\n        this.getall();\n    });\n},\n\n\n总结\n\n 1. 使用注解**@restcontrolleradvice**定义springmvc异常处理器用来处理异常的\n 2. 异常处理器必须被扫描加载，否则无法生效\n 3. 表现层返回结果的模型类中添加消息属性用来传递消息到页面\n\n\n\n# 11.页面功能开发\n\n# f-5.分页功能\n\n分页功能的制作用于替换前面的查询全部，其中要使用到elementui提供的分页组件\n\n\x3c!--分页组件--\x3e\n<div class="pagination-container">\n    <el-pagination\n\t\tclass="pagiantion"\n\t\t@current-change="handlecurrentchange"\n\t\t:current-page="pagination.currentpage"\n\t\t:page-size="pagination.pagesize"\n\t\tlayout="total, prev, pager, next, jumper"\n\t\t:total="pagination.total">\n    </el-pagination>\n</div>\n\n\n为了配合分页组件，封装分页对应的数据模型\n\ndata:{\n\tpagination: {\t\n\t\t//分页相关模型数据\n\t\tcurrentpage: 1,\t//当前页码\n\t\tpagesize:10,\t//每页显示的记录数\n\t\ttotal:0,\t\t//总记录数\n\t}\n},\n\n\n修改查询全部功能为分页查询，通过路径变量传递页码信息参数\n\ngetall() {\n    axios.get("/books/"+this.pagination.currentpage+"/"+this.pagination.pagesize).then((res) => {\n    });\n},\n\n\n后台提供对应的分页功能\n\n@getmapping("/{currentpage}/{pagesize}")\npublic r getall(@pathvariable integer currentpage,@pathvariable integer pagesize){\n    ipage<book> pagebook = bookservice.getpage(currentpage, pagesize);\n    return new r(null != pagebook ,pagebook);\n}\n\n\n页面根据分页操作结果读取对应数据，并进行数据模型绑定\n\ngetall() {\n    axios.get("/books/"+this.pagination.currentpage+"/"+this.pagination.pagesize).then((res) => {\n        this.pagination.total = res.data.data.total;\n        this.pagination.currentpage = res.data.data.current;\n        this.pagination.pagesize = res.data.data.size;\n        this.datalist = res.data.data.records;\n    });\n},\n\n\n对切换页码操作设置调用当前分页操作\n\n//切换页码\nhandlecurrentchange(currentpage) {\n    this.pagination.currentpage = currentpage;\n    this.getall();\n},\n\n\n总结\n\n 1. 使用el分页组件\n 2. 定义分页组件绑定的数据模型\n 3. 异步调用获取分页数据\n 4. 分页数据页面回显\n\n# f-6.删除功能维护\n\n由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现bug，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案\n\n@getmapping("{currentpage}/{pagesize}")\npublic r getpage(@pathvariable int currentpage,@pathvariable int pagesize){\n    ipage<book> page = bookservice.getpage(currentpage, pagesize);\n    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值\n    if( currentpage > page.getpages()){\n        page = bookservice.getpage((int)page.getpages(), pagesize);\n    }\n    return new r(true, page);\n}\n\n\n# f-7.条件查询功能\n\n最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了\n\n * 页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关的数据转换成2个分页数据加若干个条件\n\n * 后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大\n\n * 查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略\n   \n   经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别\n   \n   页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递\n   \n   页面封装查询条件字段\n   \n   pagination: {\t\t\n   //分页相关模型数据\n   \tcurrentpage: 1,\t\t//当前页码\n   \tpagesize:10,\t\t//每页显示的记录数\n   \ttotal:0,\t\t\t//总记录数\n   \tname: "",\n   \ttype: "",\n   \tdescription: ""\n   },\n   \n   \n   页面添加查询条件字段对应的数据模型绑定名称\n   \n   <div class="filter-container">\n       <el-input placeholder="图书类别" v-model="pagination.type" class="filter-item"/>\n       <el-input placeholder="图书名称" v-model="pagination.name" class="filter-item"/>\n       <el-input placeholder="图书描述" v-model="pagination.description" class="filter-item"/>\n       <el-button @click="getall()" class="dalfbut">查询</el-button>\n       <el-button type="primary" class="butt" @click="handlecreate()">新建</el-button>\n   </div>\n   \n   \n   将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求\n   \n   getall() {\n       //1.获取查询条件,拼接查询条件\n       param = "?name="+this.pagination.name;\n       param += "&type="+this.pagination.type;\n       param += "&description="+this.pagination.description;\n       console.log("-----------------"+ param);\n       axios.get("/books/"+this.pagination.currentpage+"/"+this.pagination.pagesize+param).then((res) => {\n           this.datalist = res.data.data.records;\n       });\n   },\n   \n   \n   后台代码中定义实体类封查询条件\n   \n   @getmapping("{currentpage}/{pagesize}")\n   public r getall(@pathvariable int currentpage,@pathvariable int pagesize,book book) {\n       system.out.println("参数=====>"+book);\n       ipage<book> pagebook = bookservice.getpage(currentpage,pagesize);\n       return new r(null != pagebook ,pagebook);\n   }\n   \n   \n   对应业务层接口与实现类进行修正\n   \n   public interface ibookservice extends iservice<book> {\n       ipage<book> getpage(integer currentpage,integer pagesize,book querybook);\n   }\n   \n   \n   @service\n   public class bookserviceimpl2 extends serviceimpl<bookdao,book> implements ibookservice {\n       public ipage<book> getpage(integer currentpage,integer pagesize,book querybook){\n           ipage page = new page(currentpage,pagesize);\n           lambdaquerywrapper<book> lqw = new lambdaquerywrapper<book>();\n           lqw.like(strings.isnotempty(querybook.getname()),book::getname,querybook.getname());\n           lqw.like(strings.isnotempty(querybook.gettype()),book::gettype,querybook.gettype());\n           lqw.like(strings.isnotempty(querybook.getdescription()),book::getdescription,querybook.getdescription());\n           return bookdao.selectpage(page,lqw);\n       }\n   }\n   \n   \n   页面回显数据\n   \n   getall() {\n       //1.获取查询条件,拼接查询条件\n       param = "?name="+this.pagination.name;\n       param += "&type="+this.pagination.type;\n       param += "&description="+this.pagination.description;\n       console.log("-----------------"+ param);\n       axios.get("/books/"+this.pagination.currentpage+"/"+this.pagination.pagesize+param).then((res) => {\n           this.pagination.total = res.data.data.total;\n           this.pagination.currentpage = res.data.data.current;\n           this.pagination.pagesize = res.data.data.size;\n           this.datalist = res.data.data.records;\n       });\n   },\n   \n\n总结\n\n 1. 定义查询条件数据模型（当前封装到分页数据模型中）\n 2. 异步调用分页功能并通过请求参数传递数据到后台\n\n\n# 基础篇完结\n\n基础篇到这里就全部结束了，在基础篇中带着大家学习了如果创建一个springboot工程，然后学习了springboot的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于springboot的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。',charsets:{cjk:!0}},{title:"简介及配置",frontmatter:{title:"简介及配置",date:"2022-03-04T00:00:00.000Z",permalink:"/mybatis/001/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/01.%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%85%8D%E7%BD%AE.html",relativePath:"07.框架/04.MyBatis/01.简介及配置.md",key:"v-df9543e4",path:"/mybatis/001/",headers:[{level:2,title:"MyBatis历史",slug:"mybatis历史",normalizedTitle:"mybatis历史",charIndex:16},{level:2,title:"MyBatis特性",slug:"mybatis特性",normalizedTitle:"mybatis特性",charIndex:287},{level:2,title:"MyBatis下载",slug:"mybatis下载",normalizedTitle:"mybatis下载",charIndex:532},{level:2,title:"和其它持久化层技术对比",slug:"和其它持久化层技术对比",normalizedTitle:"和其它持久化层技术对比",charIndex:566},{level:2,title:"开发环境",slug:"开发环境",normalizedTitle:"开发环境",charIndex:943},{level:2,title:"创建maven工程",slug:"创建maven工程",normalizedTitle:"创建maven工程",charIndex:1040},{level:2,title:"创建MyBatis的核心配置文件",slug:"创建mybatis的核心配置文件",normalizedTitle:"创建mybatis的核心配置文件",charIndex:1627},{level:2,title:"创建mapper接口",slug:"创建mapper接口",normalizedTitle:"创建mapper接口",charIndex:2558},{level:2,title:"创建MyBatis的映射文件",slug:"创建mybatis的映射文件",normalizedTitle:"创建mybatis的映射文件",charIndex:2756},{level:2,title:"通过junit测试功能",slug:"通过junit测试功能",normalizedTitle:"通过junit测试功能",charIndex:3612},{level:2,title:"加入log4j日志功能",slug:"加入log4j日志功能",normalizedTitle:"加入log4j日志功能",charIndex:5026}],headersStr:"MyBatis历史 MyBatis特性 MyBatis下载 和其它持久化层技术对比 开发环境 创建maven工程 创建MyBatis的核心配置文件 创建mapper接口 创建MyBatis的映射文件 通过junit测试功能 加入log4j日志功能",content:'# Mybatis简介\n\n\n# MyBatis历史\n\n * MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github\n * iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）\n\n\n# MyBatis特性\n\n 1. MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架\n 2. MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集\n 3. MyBatis可以使用简F单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录\n 4. MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架\n\n\n# MyBatis下载\n\n * MyBatis下载地址\n * \n\n\n# 和其它持久化层技术对比\n\n * JDBC\n   * SQL 夹杂在Java代码中耦合度高，导致硬编码内伤\n   * 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见\n   * 代码冗长，开发效率低\n * Hibernate 和 JPA\n   * 操作简便，开发效率高\n   * 程序中的长难复杂 SQL 需要绕过框架\n   * 内部自动生产的 SQL，不容易做特殊优化\n   * 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。\n   * 反射操作太多，导致数据库性能下降\n * MyBatis\n   * 轻量级，性能出色\n   * SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据\n   * 开发效率稍逊于HIbernate，但是完全能够接受\n\n\n# 搭建MyBatis\n\n\n# 开发环境\n\n * IDE：idea 2019.2\n * 构建工具：maven 3.5.4\n * MySQL版本：MySQL 5.7\n * MyBatis版本：MyBatis 3.5.7\n\n\n# 创建maven工程\n\n * 打包方式：jar\n\n * 引入依赖\n   \n   <dependencies>\n   \t\x3c!-- Mybatis核心 --\x3e\n   \t<dependency>\n   \t\t<groupId>org.mybatis</groupId>\n   \t\t<artifactId>mybatis</artifactId>\n   \t\t<version>3.5.7</version>\n   \t</dependency>\n   \t\x3c!-- junit测试 --\x3e\n   \t<dependency>\n   \t\t<groupId>junit</groupId>\n   \t\t<artifactId>junit</artifactId>\n   \t\t<version>4.12</version>\n   \t\t<scope>test</scope>\n   \t</dependency>\n   \t\x3c!-- MySQL驱动 --\x3e\n   \t<dependency>\n   \t\t<groupId>mysql</groupId>\n   \t\t<artifactId>mysql-connector-java</artifactId>\n   \t\t<version>5.1.3</version>\n   \t\t</dependency>\n   </dependencies>\n   \n\n\n# 创建MyBatis的核心配置文件\n\n> 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息 核心配置文件存放的位置是src/main/resources目录下\n\n<?xml version="1.0" encoding="UTF-8" ?>  \n<!DOCTYPE configuration  \nPUBLIC "-//mybatis.org//DTD Config 3.0//EN"  \n"http://mybatis.org/dtd/mybatis-3-config.dtd">  \n<configuration>  \n\t\x3c!--设置连接数据库的环境--\x3e  \n\t<environments default="development">  \n\t\t<environment id="development">  \n\t\t\t<transactionManager type="JDBC"/>  \n\t\t\t<dataSource type="POOLED">  \n\t\t\t\t<property name="driver" value="com.mysql.cj.jdbc.Driver"/>  \n\t\t\t\t<property name="url" value="jdbc:mysql://localhost:3306/MyBatis"/>  \n\t\t\t\t<property name="username" value="root"/>  \n\t\t\t\t<property name="password" value="123456"/>  \n\t\t\t</dataSource>  \n\t\t</environment>  \n\t</environments>  \n\t\x3c!--引入映射文件--\x3e  \n\t<mappers>  \n\t\t<mapper resource="mappers/UserMapper.xml"/>  \n\t</mappers>  \n</configuration>\n\n\n\n# 创建mapper接口\n\n> MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类\n\npackage com.atguigu.mybatis.mapper;  \n  \npublic interface UserMapper {  \n\t/**  \n\t* 添加用户信息  \n\t*/  \n\tint insertUser();  \n}\n\n\n\n# 创建MyBatis的映射文件\n\n * 相关概念：ORM（Object Relationship Mapping）对象关系映射。\n   * 对象：Java的实体类对象\n   * 关系：关系型数据库\n   * 映射：二者之间的对应关系\n\nJAVA概念   数据库概念\n类        表\n属性       字段/列\n对象       记录/行\n\n * 映射文件的命名规则\n   * 表所对应的实体类的类名+Mapper.xml\n   * 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml\n   * 因此一个映射文件对应一个实体类，对应一张表的操作\n   * MyBatis映射文件用于编写SQL，访问以及操作表中的数据\n   * MyBatis映射文件存放的位置是src/main/resources/mappers目录下\n * MyBatis中可以面向接口操作数据，要保证两个一致\n   * mapper接口的全类名和映射文件的命名空间（namespace）保持一致\n   * mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致\n\n<?xml version="1.0" encoding="UTF-8" ?>  \n<!DOCTYPE mapper  \nPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  \n"http://mybatis.org/dtd/mybatis-3-mapper.dtd">  \n<mapper namespace="com.atguigu.mybatis.mapper.UserMapper">  \n\t\x3c!--int insertUser();--\x3e  \n\t<insert id="insertUser">  \n\t\tinsert into t_user values(null,\'张三\',\'123\',23,\'女\')  \n\t</insert>  \n</mapper>\n\n\n\n# 通过junit测试功能\n\n * SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）\n * SqlSessionFactory：是“生产”SqlSession的“工厂”\n * 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象\n\npublic class UserMapperTest {\n    @Test\n    public void testInsertUser() throws IOException {\n        //读取MyBatis的核心配置文件\n        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");\n        //获取SqlSessionFactoryBuilder对象\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象\n        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n        //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务\n        //SqlSession sqlSession = sqlSessionFactory.openSession();\n\t    //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  \n\t\tSqlSession sqlSession = sqlSessionFactory.openSession(true);\n        //通过代理模式创建UserMapper接口的代理实现类对象\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句\n        int result = userMapper.insertUser();\n        //提交事务\n        //sqlSession.commit();\n        System.out.println("result:" + result);\n    }\n}\n\n\n * 此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用SqlSession sqlSession = sqlSessionFactory.openSession(true);，传入一个Boolean类型的参数，值为true，这样就可以自动提交\n\n\n# 加入log4j日志功能\n\n 1. 加入依赖\n    \n    \x3c!-- log4j日志 --\x3e\n    <dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n    </dependency>\n    \n\n 2. 加入log4j的配置文件\n    * log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下\n    * 日志的级别：FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试) 从左到右打印的内容越来越详细\n    \n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">\n    <log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">\n        <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender">\n            <param name="Encoding" value="UTF-8" />\n            <layout class="org.apache.log4j.PatternLayout">\n    \t\t\t<param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n" />\n            </layout>\n        </appender>\n        <logger name="java.sql">\n            <level value="debug" />\n        </logger>\n        <logger name="org.apache.ibatis">\n            <level value="info" />\n        </logger>\n        <root>\n            <level value="debug" />\n            <appender-ref ref="STDOUT" />\n        </root>\n    </log4j:configuration>\n    ',normalizedContent:'# mybatis简介\n\n\n# mybatis历史\n\n * mybatis最初是apache的一个开源项目ibatis, 2010年6月这个项目由apache software foundation迁移到了google code。随着开发团队转投google code旗下，ibatis3.x正式更名为mybatis。代码于2013年11月迁移到github\n * ibatis一词来源于“internet”和“abatis”的组合，是一个基于java的持久层框架。ibatis提供的持久层框架包括sql maps和data access objects（dao）\n\n\n# mybatis特性\n\n 1. mybatis 是支持定制化 sql、存储过程以及高级映射的优秀的持久层框架\n 2. mybatis 避免了几乎所有的 jdbc 代码和手动设置参数以及获取结果集\n 3. mybatis可以使用简f单的xml或注解用于配置和原始映射，将接口和java的pojo（plain old java objects，普通的java对象）映射成数据库中的记录\n 4. mybatis 是一个 半自动的orm（object relation mapping）框架\n\n\n# mybatis下载\n\n * mybatis下载地址\n * \n\n\n# 和其它持久化层技术对比\n\n * jdbc\n   * sql 夹杂在java代码中耦合度高，导致硬编码内伤\n   * 维护不易且实际开发需求中 sql 有变化，频繁修改的情况多见\n   * 代码冗长，开发效率低\n * hibernate 和 jpa\n   * 操作简便，开发效率高\n   * 程序中的长难复杂 sql 需要绕过框架\n   * 内部自动生产的 sql，不容易做特殊优化\n   * 基于全映射的全自动框架，大量字段的 pojo 进行部分映射时比较困难。\n   * 反射操作太多，导致数据库性能下降\n * mybatis\n   * 轻量级，性能出色\n   * sql 和 java 编码分开，功能边界清晰。java代码专注业务、sql语句专注数据\n   * 开发效率稍逊于hibernate，但是完全能够接受\n\n\n# 搭建mybatis\n\n\n# 开发环境\n\n * ide：idea 2019.2\n * 构建工具：maven 3.5.4\n * mysql版本：mysql 5.7\n * mybatis版本：mybatis 3.5.7\n\n\n# 创建maven工程\n\n * 打包方式：jar\n\n * 引入依赖\n   \n   <dependencies>\n   \t\x3c!-- mybatis核心 --\x3e\n   \t<dependency>\n   \t\t<groupid>org.mybatis</groupid>\n   \t\t<artifactid>mybatis</artifactid>\n   \t\t<version>3.5.7</version>\n   \t</dependency>\n   \t\x3c!-- junit测试 --\x3e\n   \t<dependency>\n   \t\t<groupid>junit</groupid>\n   \t\t<artifactid>junit</artifactid>\n   \t\t<version>4.12</version>\n   \t\t<scope>test</scope>\n   \t</dependency>\n   \t\x3c!-- mysql驱动 --\x3e\n   \t<dependency>\n   \t\t<groupid>mysql</groupid>\n   \t\t<artifactid>mysql-connector-java</artifactid>\n   \t\t<version>5.1.3</version>\n   \t\t</dependency>\n   </dependencies>\n   \n\n\n# 创建mybatis的核心配置文件\n\n> 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及mybatis的全局配置信息 核心配置文件存放的位置是src/main/resources目录下\n\n<?xml version="1.0" encoding="utf-8" ?>  \n<!doctype configuration  \npublic "-//mybatis.org//dtd config 3.0//en"  \n"http://mybatis.org/dtd/mybatis-3-config.dtd">  \n<configuration>  \n\t\x3c!--设置连接数据库的环境--\x3e  \n\t<environments default="development">  \n\t\t<environment id="development">  \n\t\t\t<transactionmanager type="jdbc"/>  \n\t\t\t<datasource type="pooled">  \n\t\t\t\t<property name="driver" value="com.mysql.cj.jdbc.driver"/>  \n\t\t\t\t<property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>  \n\t\t\t\t<property name="username" value="root"/>  \n\t\t\t\t<property name="password" value="123456"/>  \n\t\t\t</datasource>  \n\t\t</environment>  \n\t</environments>  \n\t\x3c!--引入映射文件--\x3e  \n\t<mappers>  \n\t\t<mapper resource="mappers/usermapper.xml"/>  \n\t</mappers>  \n</configuration>\n\n\n\n# 创建mapper接口\n\n> mybatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类\n\npackage com.atguigu.mybatis.mapper;  \n  \npublic interface usermapper {  \n\t/**  \n\t* 添加用户信息  \n\t*/  \n\tint insertuser();  \n}\n\n\n\n# 创建mybatis的映射文件\n\n * 相关概念：orm（object relationship mapping）对象关系映射。\n   * 对象：java的实体类对象\n   * 关系：关系型数据库\n   * 映射：二者之间的对应关系\n\njava概念   数据库概念\n类        表\n属性       字段/列\n对象       记录/行\n\n * 映射文件的命名规则\n   * 表所对应的实体类的类名+mapper.xml\n   * 例如：表t_user，映射的实体类为user，所对应的映射文件为usermapper.xml\n   * 因此一个映射文件对应一个实体类，对应一张表的操作\n   * mybatis映射文件用于编写sql，访问以及操作表中的数据\n   * mybatis映射文件存放的位置是src/main/resources/mappers目录下\n * mybatis中可以面向接口操作数据，要保证两个一致\n   * mapper接口的全类名和映射文件的命名空间（namespace）保持一致\n   * mapper接口中方法的方法名和映射文件中编写sql的标签的id属性保持一致\n\n<?xml version="1.0" encoding="utf-8" ?>  \n<!doctype mapper  \npublic "-//mybatis.org//dtd mapper 3.0//en"  \n"http://mybatis.org/dtd/mybatis-3-mapper.dtd">  \n<mapper namespace="com.atguigu.mybatis.mapper.usermapper">  \n\t\x3c!--int insertuser();--\x3e  \n\t<insert id="insertuser">  \n\t\tinsert into t_user values(null,\'张三\',\'123\',23,\'女\')  \n\t</insert>  \n</mapper>\n\n\n\n# 通过junit测试功能\n\n * sqlsession：代表java程序和数据库之间的会话。（httpsession是java程序和浏览器之间的会话）\n * sqlsessionfactory：是“生产”sqlsession的“工厂”\n * 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象\n\npublic class usermappertest {\n    @test\n    public void testinsertuser() throws ioexception {\n        //读取mybatis的核心配置文件\n        inputstream is = resources.getresourceasstream("mybatis-config.xml");\n        //获取sqlsessionfactorybuilder对象\n        sqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder();\n        //通过核心配置文件所对应的字节输入流创建工厂类sqlsessionfactory，生产sqlsession对象\n        sqlsessionfactory sqlsessionfactory = sqlsessionfactorybuilder.build(is);\n        //获取sqlsession，此时通过sqlsession对象所操作的sql都必须手动提交或回滚事务\n        //sqlsession sqlsession = sqlsessionfactory.opensession();\n\t    //创建sqlsession对象，此时通过sqlsession对象所操作的sql都会自动提交  \n\t\tsqlsession sqlsession = sqlsessionfactory.opensession(true);\n        //通过代理模式创建usermapper接口的代理实现类对象\n        usermapper usermapper = sqlsession.getmapper(usermapper.class);\n        //调用usermapper接口中的方法，就可以根据usermapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的sql标签，并执行标签中的sql语句\n        int result = usermapper.insertuser();\n        //提交事务\n        //sqlsession.commit();\n        system.out.println("result:" + result);\n    }\n}\n\n\n * 此时需要手动提交事务，如果要自动提交事务，则在获取sqlsession对象时，使用sqlsession sqlsession = sqlsessionfactory.opensession(true);，传入一个boolean类型的参数，值为true，这样就可以自动提交\n\n\n# 加入log4j日志功能\n\n 1. 加入依赖\n    \n    \x3c!-- log4j日志 --\x3e\n    <dependency>\n    <groupid>log4j</groupid>\n    <artifactid>log4j</artifactid>\n    <version>1.2.17</version>\n    </dependency>\n    \n\n 2. 加入log4j的配置文件\n    * log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下\n    * 日志的级别：fatal(致命)>error(错误)>warn(警告)>info(信息)>debug(调试) 从左到右打印的内容越来越详细\n    \n    <?xml version="1.0" encoding="utf-8" ?>\n    <!doctype log4j:configuration system "log4j.dtd">\n    <log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">\n        <appender name="stdout" class="org.apache.log4j.consoleappender">\n            <param name="encoding" value="utf-8" />\n            <layout class="org.apache.log4j.patternlayout">\n    \t\t\t<param name="conversionpattern" value="%-5p %d{mm-dd hh:mm:ss,sss} %m (%f:%l) \\n" />\n            </layout>\n        </appender>\n        <logger name="java.sql">\n            <level value="debug" />\n        </logger>\n        <logger name="org.apache.ibatis">\n            <level value="info" />\n        </logger>\n        <root>\n            <level value="debug" />\n            <appender-ref ref="stdout" />\n        </root>\n    </log4j:configuration>\n    ',charsets:{cjk:!0}},{title:"原理",frontmatter:{title:"原理",date:"2022-03-30T00:00:00.000Z",permalink:"/springboot/004/",categories:["框架","SpringBoot"],tags:["SpringBoot"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/03.SpringBoot/04.%E5%8E%9F%E7%90%86.html",relativePath:"07.框架/03.SpringBoot/04.原理.md",key:"v-0b01fcc0",path:"/springboot/004/",headers:[{level:2,title:"YL-1.自动配置工作流程",slug:"yl-1-自动配置工作流程",normalizedTitle:"yl-1.自动配置工作流程",charIndex:140},{level:3,title:"YL-1-1.bean的加载方式",slug:"yl-1-1-bean的加载方式",normalizedTitle:"yl-1-1.bean的加载方式",charIndex:424},{level:4,title:"方式一：配置文件+`<bean/>`标签",slug:"方式一-配置文件-bean-标签",normalizedTitle:"方式一：配置文件+<code>&lt;bean/&gt;</code>标签",charIndex:null},{level:4,title:"方式二：配置文件扫描+注解定义bean",slug:"方式二-配置文件扫描-注解定义bean",normalizedTitle:"方式二：配置文件扫描+注解定义bean",charIndex:1600},{level:4,title:"方式三：注解方式声明配置类",slug:"方式三-注解方式声明配置类",normalizedTitle:"方式三：注解方式声明配置类",charIndex:3187},{level:5,title:"使用FactroyBean接口",slug:"使用factroybean接口",normalizedTitle:"使用factroybean接口",charIndex:3660},{level:5,title:"注解格式导入XML格式配置的bean",slug:"注解格式导入xml格式配置的bean",normalizedTitle:"注解格式导入xml格式配置的bean",charIndex:4735},{level:5,title:"proxyBeanMethods属性",slug:"proxybeanmethods属性",normalizedTitle:"proxybeanmethods属性",charIndex:5073},{level:4,title:"方式四：使用@Import注解注入bean",slug:"方式四-使用-import注解注入bean",normalizedTitle:"方式四：使用@import注解注入bean",charIndex:6178},{level:5,title:"使用@Import注解注入配置类",slug:"使用-import注解注入配置类",normalizedTitle:"使用@import注解注入配置类",charIndex:6785},{level:4,title:"方式五：编程形式注册bean",slug:"方式五-编程形式注册bean",normalizedTitle:"方式五：编程形式注册bean",charIndex:6916},{level:4,title:"方式六：导入实现了ImportSelector接口的类",slug:"方式六-导入实现了importselector接口的类",normalizedTitle:"方式六：导入实现了importselector接口的类",charIndex:7750},{level:4,title:"方式七：导入实现了ImportBeanDefinitionRegistrar接口的类",slug:"方式七-导入实现了importbeandefinitionregistrar接口的类",normalizedTitle:"方式七：导入实现了importbeandefinitionregistrar接口的类",charIndex:8450},{level:4,title:"方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类",slug:"方式八-导入实现了beandefinitionregistrypostprocessor接口的类",normalizedTitle:"方式八：导入实现了beandefinitionregistrypostprocessor接口的类",charIndex:9288},{level:3,title:"YL-1-2.bean的加载控制",slug:"yl-1-2-bean的加载控制",normalizedTitle:"yl-1-2.bean的加载控制",charIndex:10453},{level:3,title:"YL-1-3.bean的依赖属性配置管理",slug:"yl-1-3-bean的依赖属性配置管理",normalizedTitle:"yl-1-3.bean的依赖属性配置管理",charIndex:13016},{level:3,title:"YL-1-4.自动配置原理（工作流程）",slug:"yl-1-4-自动配置原理-工作流程",normalizedTitle:"yl-1-4.自动配置原理（工作流程）",charIndex:13926},{level:3,title:"YL-1-5.变更自动配置",slug:"yl-1-5-变更自动配置",normalizedTitle:"yl-1-5.变更自动配置",charIndex:17450},{level:2,title:"YL-2.自定义starter开发",slug:"yl-2-自定义starter开发",normalizedTitle:"yl-2.自定义starter开发",charIndex:18645},{level:3,title:"YL-2-1.案例：记录系统访客独立IP访问次数",slug:"yl-2-1-案例-记录系统访客独立ip访问次数",normalizedTitle:"yl-2-1.案例：记录系统访客独立ip访问次数",charIndex:18856},{level:3,title:"YL-2-2.IP计数业务功能开发（自定义starter）",slug:"yl-2-2-ip计数业务功能开发-自定义starter",normalizedTitle:"yl-2-2.ip计数业务功能开发（自定义starter）",charIndex:19738},{level:3,title:"YL-2-3.定时任务报表开发",slug:"yl-2-3-定时任务报表开发",normalizedTitle:"yl-2-3.定时任务报表开发",charIndex:22690},{level:3,title:"YL-2-4.使用属性配置设置功能参数",slug:"yl-2-4-使用属性配置设置功能参数",normalizedTitle:"yl-2-4.使用属性配置设置功能参数",charIndex:23893},{level:3,title:"YL-2-5.使用属性配置设置定时器参数",slug:"yl-2-5-使用属性配置设置定时器参数",normalizedTitle:"yl-2-5.使用属性配置设置定时器参数",charIndex:26500},{level:3,title:"YL-2-6.拦截器开发",slug:"yl-2-6-拦截器开发",normalizedTitle:"yl-2-6.拦截器开发",charIndex:27368},{level:3,title:"YL-2-7.功能性完善——开启yml提示功能",slug:"yl-2-7-功能性完善-开启yml提示功能",normalizedTitle:"yl-2-7.功能性完善——开启yml提示功能",charIndex:28548},{level:2,title:"YL-3.SpringBoot程序启动流程解析",slug:"yl-3-springboot程序启动流程解析",normalizedTitle:"yl-3.springboot程序启动流程解析",charIndex:30425}],headersStr:"YL-1.自动配置工作流程 YL-1-1.bean的加载方式 方式一：配置文件+`<bean/>`标签 方式二：配置文件扫描+注解定义bean 方式三：注解方式声明配置类 使用FactroyBean接口 注解格式导入XML格式配置的bean proxyBeanMethods属性 方式四：使用@Import注解注入bean 使用@Import注解注入配置类 方式五：编程形式注册bean 方式六：导入实现了ImportSelector接口的类 方式七：导入实现了ImportBeanDefinitionRegistrar接口的类 方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类 YL-1-2.bean的加载控制 YL-1-3.bean的依赖属性配置管理 YL-1-4.自动配置原理（工作流程） YL-1-5.变更自动配置 YL-2.自定义starter开发 YL-2-1.案例：记录系统访客独立IP访问次数 YL-2-2.IP计数业务功能开发（自定义starter） YL-2-3.定时任务报表开发 YL-2-4.使用属性配置设置功能参数 YL-2-5.使用属性配置设置定时器参数 YL-2-6.拦截器开发 YL-2-7.功能性完善——开启yml提示功能 YL-3.SpringBoot程序启动流程解析",content:'# SpringBoot原理篇\n\n下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：\n\n * 自动配置工作流程\n * 自定义starter开发\n * springboot程序启动流程\n\n下面开启第一部分自动配置工作流程的学习\n\n\n# YL-1.自动配置工作流程\n\n自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的bean的加载方式仅仅应用于后面课程的学习，并不是所有的spring加载bean的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。\n\n\n# YL-1-1.bean的加载方式\n\n关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。如果前面这句话看起来有障碍，可以去复习一下spring的相关知识。B站中有我尊敬的满一航老师录制的spring高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。\n\nhttps://www.bilibili.com/video/BV1P44y1N7QG\n\n\n# 方式一：配置文件+<bean/>标签\n\n最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战java基础高级部分复习一下反射相关知识。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!--xml方式声明自己开发的bean--\x3e\n    <bean id="cat" class="Cat"/>\n    <bean class="Dog"/>\n\n    \x3c!--xml方式声明第三方开发的bean--\x3e\n    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/>\n    <bean class="com.alibaba.druid.pool.DruidDataSource"/>\n    <bean class="com.alibaba.druid.pool.DruidDataSource"/>\n</beans>\n\n\n# 方式二：配置文件扫描+注解定义bean\n\n由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository。\n\n@Component("tom")\npublic class Cat {\n}\n\n\n@Service\npublic class Mouse {\n}\n\n\n当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中，有人会说不是@Configuration吗？建议把spring注解开发相关课程学习一下，就不会有这个疑问了。\n\n@Component\npublic class DbConfig {\n    @Bean\n    public DruidDataSource dataSource(){\n        DruidDataSource ds = new DruidDataSource();\n        return ds;\n    }\n}\n\n\n上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n    ">\n    \x3c!--指定扫描加载bean的位置--\x3e\n    <context:component-scan base-package="com.itheima.bean,com.itheima.config"/>\n</beans>\n\n\n方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。\n\n# 方式三：注解方式声明配置类\n\n方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。\n\n定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同 。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。\n\n@ComponentScan({"com.itheima.bean","com.itheima.config"})\npublic class SpringConfig3 {\n    @Bean\n    public DogFactoryBean dog(){\n        return new DogFactoryBean();\n    }\n}\n\n\n# 使用FactroyBean接口\n\n补充一个小知识，spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。\n\npublic class DogFactoryBean implements FactoryBean<Dog> {\n    @Override\n    public Dog getObject() throws Exception {\n        Dog d = new Dog();\n        //.........\n        return d;\n    }\n    @Override\n    public Class<?> getObjectType() {\n        return Dog.class;\n    }\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n\n有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。\n\n通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。\n\n@ComponentScan({"com.itheima.bean","com.itheima.config"})\npublic class SpringConfig3 {\n    @Bean\n    public DogFactoryBean dog(){\n        return new DogFactoryBean();\n    }\n}\n\n\n# 注解格式导入XML格式配置的bean\n\n再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。\n\n@Configuration\n@ImportResource("applicationContext1.xml")\npublic class SpringConfig32 {\n}\n\n\n# proxyBeanMethods属性\n\n前面的例子中用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。\n\n@Configuration(proxyBeanMethods = true)\npublic class SpringConfig33 {\n    @Bean\n    public Cat cat(){\n        return new Cat();\n    }\n}\n\n\n下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用，前面讲MQ时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。\n\npublic class App33 {\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig33.class);\n        String[] names = ctx.getBeanDefinitionNames();\n        for (String name : names) {\n            System.out.println(name);\n        }\n        System.out.println("-------------------------");\n        SpringConfig33 springConfig33 = ctx.getBean("springConfig33", SpringConfig33.class);\n        System.out.println(springConfig33.cat());\n        System.out.println(springConfig33.cat());\n        System.out.println(springConfig33.cat());\n    }\n}\n\n\n# 方式四：使用@Import注解注入bean\n\n使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。\n\n有人就会奇怪，会有什么问题呢？比如你扫描了com.itheima.service包，后来因为业务需要，又扫描了com.itheima.dao包，你发现com.itheima包下面只有service和dao这两个包，这就简单了，直接扫描com.itheima就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.itheima包，这下就热闹了，该来的不该来的全来了。\n\n所以我们需要一种精准制导的加载方式，使用@Import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@Component修饰呢？这下就无解了，而@Import就无需考虑这个问题。\n\n@Import({Dog.class,DbConfig.class})\npublic class SpringConfig4 {\n}\n\n\n# 使用@Import注解注入配置类\n\n除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的，不解释太多了。\n\n@Import(DogFactoryBean.class)\npublic class SpringConfig4 {\n}\n\n\n# 方式五：编程形式注册bean\n\n前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。\n\npublic class App5 {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.register(Mouse.class);\n    }\n}\n\n\n其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。\n\npublic class App5 {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.registerBean("tom", Cat.class,0);\n        ctx.registerBean("tom", Cat.class,1);\n        ctx.registerBean("tom", Cat.class,2);\n        System.out.println(ctx.getBean(Cat.class));\n    }\n}\n\n\n# 方式六：导入实现了ImportSelector接口的类\n\n在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。\n\n现在又多了一种控制bean加载的方式，或者说是选择bean的方式。\n\npublic class MyImportSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata metadata) {\n        //各种条件的判定，判定完毕后，决定是否装载指定的bean\n        // Metadata表示源数据\n        boolean flag = metadata.hasAnnotation("org.springframework.context.annotation.Configuration");\n        if(flag){\n            return new String[]{"com.itheima.bean.Dog"};\n        }\n        return new String[]{"com.itheima.bean.Cat"};\n    }\n}\n\n\n\n# 方式七：导入实现了ImportBeanDefinitionRegistrar接口的类\n\n方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。\n\npublic class MyRegistrar implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        BeanDefinition beanDefinition = \t\n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();\n        registry.registerBeanDefinition("bookService",beanDefinition);\n    }\n}\n\n\n# 方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类\n\n上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。\n\nspring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。\n\npublic class MyPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        BeanDefinition beanDefinition = \n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();\n        registry.registerBeanDefinition("bookService",beanDefinition);\n    }\n}\n\n\n\n总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。复习的内容就先说到这里。\n\n总结\n\n 1. bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean\n 2. @Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载\n 3. spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean\n\n\n\n\n# YL-1-2.bean的加载控制\n\n前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，ImportSelector接口，ImportBeanDefinitionRegistrar接口，BeanDefinitionRegistryPostProcessor接口都可以控制bean的加载，这一节就来说说这些加载控制。\n\n企业级开发中不可能在spring容器中进行bean的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，通过判定是否加载了某个类来控制某些bean的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。\n\npublic class MyImportSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        try {\n            Class<?> clazz = Class.forName("com.itheima.bean.Mouse");\n            if(clazz != null) {\n                return new String[]{"com.itheima.bean.Cat"};\n            }\n        } catch (ClassNotFoundException e) {\n//            e.printStackTrace();\n            return new String[0];\n        }\n        return null;\n    }\n}\n\n\n通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我springboot信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。\n\n下例使用@ConditionalOnClass注解实现了当虚拟机中加载了com.itheima.bean.Wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。\n\n@Bean\n@ConditionalOnClass(name = "com.itheima.bean.Wolf")\npublic Cat tom(){\n    return new Cat();\n}\n\n\n@ConditionalOnMissingClass注解控制虚拟机中没有加载指定的类才加载对应的bean。\n\n@Bean\n@ConditionalOnMissingClass("com.itheima.bean.Dog")\npublic Cat tom(){\n    return new Cat();\n}\n\n\n这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。\n\n\n@Bean\n@ConditionalOnClass(name = "com.itheima.bean.Wolf")\n@ConditionalOnMissingClass("com.itheima.bean.Mouse")\npublic Cat tom(){\n    return new Cat();\n}\n\n\n除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。\n\n@Bean\n@ConditionalOnWebApplication\npublic Cat tom(){\n    return new Cat();\n}\n\n\n下面是判定容器环境是否是非web环境。\n\n@Bean\n@ConditionalOnNotWebApplication\npublic Cat tom(){\n    return new Cat();\n}\n\n\n当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbcTemplate对应的bean，你还需要再加载一个全新的jdbcTemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？\n\n@Bean\n@ConditionalOnBean(name="jerry")\npublic Cat tom(){\n    return new Cat();\n}\n\n\n以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个Druid的数据源对象出来，完美！\n\npublic class SpringConfig {\n    @Bean\n    @ConditionalOnClass(name="com.mysql.jdbc.Driver")\n    public DruidDataSource dataSource(){\n        return new DruidDataSource();\n    }\n}\n\n\n其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。\n\n总结\n\n 1. springboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean\n\n\n# YL-1-3.bean的依赖属性配置管理\n\nbean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。\n\ncartoon:\n  cat:\n    name: "图多盖洛"\n    age: 5\n  mouse:\n    name: "泰菲"\n    age: 1\n\n\n然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。\n\n@ConfigurationProperties(prefix = "cartoon")\n@Data\npublic class CartoonProperties {\n    private Cat cat;\n    private Mouse mouse;\n}\n\n\n最后在使用的位置注入对应的配置即可。\n\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse{\n    @Autowired\n    private CartoonProperties cartoonProperties;\n}\n\n\n建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。\n\n总结\n\n 1. bean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * Properties\n 2. 设置属性类加载指定前缀的配置信息\n 3. 在需要使用属性类的位置通过注解@EnableConfigurationProperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。\n\n\n# YL-1-4.自动配置原理（工作流程）\n\n经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。\n\n啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。\n\n自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么IP地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。\n\n而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：\n\n阶段一：准备阶段\n\n 1. springboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个技术集A\n\n 2. 收集常用技术(技术集A)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的设置集B\n    \n    阶段二：加载阶段\n\n 3. springboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成初始化环境\n\n 4. springboot将技术集A包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的\n\n 5. springboot会对技术集A中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与初始化环境，这个时候就可以根据这个初始化环境与springboot的技术集A进行比对了，哪个匹配上加载哪个\n\n 6. 因为有些技术不做配置就无法工作，所以springboot开始对设置集B下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量\n\n 7. 但是默认配置不一定能解决问题，于是springboot开放修改设置集B的接口，可以由开发者根据需要决定是否覆盖默认配置\n\n以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？\n\n * 首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的技术集A\n\npublic class CartoonCatAndMouse{\n}\n\n\n * 然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的设置集B\n\ncartoon:\n  cat:\n    name: "图多盖洛"\n    age: 5\n  mouse:\n    name: "泰菲"\n    age: 1\n\n\n * 将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样\n\n@ConfigurationProperties(prefix = "cartoon")\n@Data\npublic class CartoonProperties {\n    private Cat cat;\n    private Mouse mouse;\n}\n\n\n * 最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置\n\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware {\n    private CartoonProperties cartoonProperties;\n}\n\n\n * 当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn* * * * 为其设置加载条件\n\n@ConditionalOnClass(name="org.springframework.data.redis.core.RedisOperations")\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware {\n    private CartoonProperties cartoonProperties;\n}\n\n\n做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建META-INF目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。\n\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.itheima.bean.CartoonCatAndMouse\n\n\n其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：\n\n 1. 自动配置从根本上来说就是一个bean的加载\n 2. 通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱\n 3. 使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱\n 4. springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱\n\n你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。\n\n以上内容是自动配置的工作流程。\n\n总结\n\n 1. springboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中配置的所有的类都加载成bean\n 2. 在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean\n 3. 对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的配置属性类并加载对应的配置\n 4. 配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了\n\n\n\n\n# YL-1-5.变更自动配置\n\n知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：\n\n方式一：通过yaml配置设置排除指定的自动配置类\n\nspring:\n  autoconfigure:\n    exclude:\n      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration\n\n\n方式二：通过注解参数排除自动配置类\n\n@EnableAutoConfiguration(excludeName = "",exclude = {})\n\n\n方式三：排除坐标（应用面较窄）\n\n如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        \x3c!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--\x3e\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    \x3c!--添加Jetty起步依赖，匹配自动配置条件--\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jetty</artifactId>\n    </dependency>\n</dependencies>\n\n\n总结\n\n 1. springboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能\n\n\n# YL-2.自定义starter开发\n\n自动配置学习完后，我们就可以基于自动配置的特性，开发springboot技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的starter，然后就实现了springboot整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义starter来实现自定义功能的快捷添加。\n\n\n# YL-2-1.案例：记录系统访客独立IP访问次数\n\n本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。\n\n例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。\n\n         IP访问监控\n+-----ip-address-----+--num--+\n|     192.168.0.135  |   15  |\n|     61.129.65.248  |   20  |\n+--------------------+-------+\n\n\n在进行具体制作之前，先对功能做具体的分析\n\n 1. 数据记录在什么位置\n    \n    最终记录的数据是一个字符串（IP地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案，有兴趣的小伙伴可以使用redis作为解决方案。\n\n 2. 统计功能运行位置，因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。\n\n 3. 为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。\n    \n    * 输出频度，默认10秒\n    * 数据特征：累计数据 / 阶段数据，默认累计数据\n    * 输出格式：详细模式 / 极简模式\n\n在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。\n\n\n# YL-2-2.IP计数业务功能开发（自定义starter）\n\n本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。\n\n步骤一：创建全新的模块，定义业务功能类\n\n功能类的制作并不复杂，定义一个业务类，声明一个Map对象，用于记录ip访问次数，key是ip地址，value是访问次数\n\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n}\n\n\n有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。\n\n步骤二：制作统计功能\n\n制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可\n\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    public void count(){\n        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        //1.获取当前操作的IP地址\n        String ip = null;\n        //2.根据IP地址从Map取值，并递增\n        Integer count = ipCountMap.get(ip);\n        if(count == null){\n            ipCountMap.put(ip,1);\n        }else{\n            ipCountMap.put(ip,count + 1);\n        }\n    }\n}\n\n\n因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，可以从容器中直接获取请求对象，因此获取IP地址的操作可以通过自动装配得到请求对象，然后获取对应的访问IP地址。\n\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Autowired\n    //当前的request对象的注入工作由使用当前starter的工程提供自动装配\n    private HttpServletRequest httpServletRequest;\n    public void count(){\n        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        //1.获取当前操作的IP地址\n        String ip = httpServletRequest.getRemoteAddr();\n        //2.根据IP地址从Map取值，并递增\n        Integer count = ipCountMap.get(ip);\n        if(count == null){\n            ipCountMap.put(ip,1);\n        }else{\n            ipCountMap.put(ip,count + 1);\n        }\n    }\n}\n\n\n步骤三：定义自动配置类\n\n我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。\n\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n\n\n自动配置类需要在spring.factories文件中做配置方可自动运行。\n\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.itcast.autoconfig.IpAutoConfiguration\n\n\n步骤四：在原始项目中模拟调用，测试功能\n\n原始调用项目中导入当前开发的starter\n\n<dependency>\n    <groupId>cn.itcast</groupId>\n    <artifactId>ip_spring_boot_starter</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n</dependency>\n\n\n推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。\n\n@RestController\n@RequestMapping("/books")\npublic class BookController {\n    @Autowired\n    private IpCountService ipCountService;\n    @GetMapping("{currentPage}/{pageSize}")\n    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book){\n        ipCountService.count();\n        IPage<Book> page = bookService.getPage(currentPage, pageSize,book);\n        if( currentPage > page.getPages()){\n            page = bookService.getPage((int)page.getPages(), pageSize,book);\n        }\n        return new R(true, page);\n    }\n}\n\n\n温馨提示\n\n由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先clean然后install，保障资源进行了更新。切记切记！！\n\n当前效果\n\n每次调用分页操作后，可以在控制台输出当前访问的IP地址，此功能可以在count操作中添加日志或者输出语句进行测试。\n\n\n# YL-2-3.定时任务报表开发\n\n当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术Quartz实现，也可以选择Spring内置的task来完成此功能，此处选用Spring的task作为实现方案。\n\n步骤一：开启定时任务功能\n\n定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。\n\n@EnableScheduling\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n\n\n步骤二：制作显示统计数据功能\n\n定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。\n\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Scheduled(cron = "0/5 * * * * ?")\n    public void print(){\n        System.out.println("         IP访问监控");\n        System.out.println("+-----ip-address-----+--num--+");\n        for (Map.Entry<String, Integer> entry : ipCountMap.entrySet()) {\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            System.out.println(String.format("|%18s  |%5d  |",key,value));\n        }\n        System.out.println("+--------------------+-------+");\n      }\n}\n\n\n其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用String类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。\n\n\n# YL-2-4.使用属性配置设置功能参数\n\n由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。\n\n步骤一：定义参数格式\n\n设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）\n\ntools:\n  ip:\n    cycle: 10\n    cycleReset: false\n    model: "detail"\n\n\n步骤二：定义封装参数的属性类，读取配置参数\n\n为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。\n\n日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。\n\n@ConfigurationProperties(prefix = "tools.ip")\npublic class IpProperties {\n    /**\n     * 日志显示周期\n     */\n    private Long cycle = 5L;\n    /**\n     * 是否周期内重置数据\n     */\n    private Boolean cycleReset = false;\n    /**\n     * 日志输出模式  detail：详细模式  simple：极简模式\n     */\n    private String model = LogModel.DETAIL.value;\n    public enum LogModel{\n        DETAIL("detail"),\n        SIMPLE("simple");\n        private String value;\n        LogModel(String value) {\n            this.value = value;\n        }\n        public String getValue() {\n            return value;\n        }\n    }\n}\n\n\n步骤三：加载属性类\n\n@EnableScheduling\n@EnableConfigurationProperties(IpProperties.class)\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n\n\n步骤四：应用配置属性\n\n在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。\n\n注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。\n\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Autowired\n    private IpProperties ipProperties;\n    @Scheduled(cron = "0/5 * * * * ?")\n    public void print(){\n        if(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue())){\n            System.out.println("         IP访问监控");\n            System.out.println("+-----ip-address-----+--num--+");\n            for (Map.Entry<String, Integer> entry : ipCountMap.entrySet()) {\n                String key = entry.getKey();\n                Integer value = entry.getValue();\n                System.out.println(String.format("|%18s  |%5d  |",key,value));\n            }\n            System.out.println("+--------------------+-------+");\n        }else if(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue())){\n            System.out.println("     IP访问监控");\n            System.out.println("+-----ip-address-----+");\n            for (String key: ipCountMap.keySet()) {\n                System.out.println(String.format("|%18s  |",key));\n            }\n            System.out.println("+--------------------+");\n        }\n        //阶段内统计数据归零\n        if(ipProperties.getCycleReset()){\n            ipCountMap.clear();\n        }\n    }\n}\n\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。\n\n\n# YL-2-5.使用属性配置设置定时器参数\n\n在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@Scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@EnableConfigurationProperties注解对应的功能，改成最原始的bean定义格式。\n\n步骤一：@Scheduled注解使用#{}读取bean属性值\n\n此处读取bean名称为ipProperties的bean的cycle属性值\n\n@Scheduled(cron = "0/#{ipProperties.cycle} * * * * ?")\npublic void print(){\n}\n\n\n步骤二：属性类定义bean并指定bean的访问名称\n\n如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取\n\n@Component("ipProperties")\n@ConfigurationProperties(prefix = "tools.ip")\npublic class IpProperties {\n}\n\n\n步骤三：弃用@EnableConfigurationProperties注解对应的功能，改为导入bean的形式加载配置属性类\n\n@EnableScheduling\n//@EnableConfigurationProperties(IpProperties.class)\n@Import(IpProperties.class)\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制\n\n\n# YL-2-6.拦截器开发\n\n基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在web工程中制作，然后将所有功能挪入starter模块中\n\n步骤一：开发拦截器\n\n使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能\n\npublic class IpCountInterceptor implements HandlerInterceptor {\n    @Autowired\n    private IpCountService ipCountService;\n    @Override\n    public boolean preHandle(HttpServletRequest request, \n                             HttpServletResponse response, Object handler) throws Exception {\n        ipCountService.count();\n        return true;\n    }\n}\n\n\n步骤二：配置拦截器\n\n配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载IpCountProperties中的属性，通过配置设置拦截器拦截的请求。\n\n@Configuration\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(ipCountInterceptor()).addPathPatterns("/**");\n    }\n    @Bean\n    public IpCountInterceptor ipCountInterceptor(){\n        return new IpCountInterceptor();\n    }\n}\n\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。\n\n到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人就无法使用了。\n\n\n# YL-2-7.功能性完善——开启yml提示功能\n\n我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。\n\nspringboot提供有专用的工具实现此功能，仅需要导入下列坐标。\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n\n\n程序编译后，在META-INF目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的META-INF目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。\n\n{\n  "groups": [\n    {\n      "name": "tools.ip",\n      "type": "cn.itcast.properties.IpProperties",\n      "sourceType": "cn.itcast.properties.IpProperties"\n    }\n  ],\n  "properties": [\n    {\n      "name": "tools.ip.cycle",\n      "type": "java.lang.Long",\n      "description": "日志显示周期",\n      "sourceType": "cn.itcast.properties.IpProperties",\n      "defaultValue": 5\n    },\n    {\n      "name": "tools.ip.cycle-reset",\n      "type": "java.lang.Boolean",\n      "description": "是否周期内重置数据",\n      "sourceType": "cn.itcast.properties.IpProperties",\n      "defaultValue": false\n    },\n    {\n      "name": "tools.ip.model",\n      "type": "java.lang.String",\n      "description": "日志输出模式  detail：详细模式  simple：极简模式",\n      "sourceType": "cn.itcast.properties.IpProperties"\n    }\n  ],\n  "hints": [\n    {\n      "name": "tools.ip.model",\n      "values": [\n        {\n          "value": "detail",\n          "description": "详细模式."\n        },\n        {\n          "value": "simple",\n          "description": "极简模式."\n        }\n      ]\n    }\n  ]\n}\n\n\n总结\n\n 1. 自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能\n 2. 通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果\n 3. 本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter\n 4. 对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写\n\n\n# YL-3.SpringBoot程序启动流程解析\n\n原理篇学习到这里即将结束，最后一章说一下springboot程序的启动流程。对于springboot技术来说，它用于加速spring程序的开发，核心本质还是spring程序的运行，所以于其说是springboot程序的启动流程，不如说是springboot对spring程序的启动流程做了哪些更改。\n\n\n\n其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。\n\nspringboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：\n\n * 环境属性（Environment）\n * 系统配置（spring.factories）\n * 参数（Arguments、application.properties）\n\n以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。\n\nSpringboot30StartupApplication【10】->SpringApplication.run(Springboot30StartupApplication.class, args);\n    SpringApplication【1332】->return run(new Class<?>[] { primarySource }, args);\n        SpringApplication【1343】->return new SpringApplication(primarySources).run(args);\n            SpringApplication【1343】->SpringApplication(primarySources)\n            # 加载各种配置信息，初始化各种配置对象\n                SpringApplication【266】->this(null, primarySources);\n                    SpringApplication【280】->public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources)\n                        SpringApplication【281】->this.resourceLoader = resourceLoader;\n                        # 初始化资源加载器\n                        SpringApplication【283】->this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n                        # 初始化配置类的类名信息（格式转换）\n                        SpringApplication【284】->this.webApplicationType = WebApplicationType.deduceFromClasspath();\n                        # 确认当前容器加载的类型\n                        SpringApplication【285】->this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();\n                        # 获取系统配置引导信息\n                        SpringApplication【286】->setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n                        # 获取ApplicationContextInitializer.class对应的实例\n                        SpringApplication【287】->setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n                        # 初始化监听器，对初始化过程及运行过程进行干预\n                        SpringApplication【288】->this.mainApplicationClass = deduceMainApplicationClass();\n                        # 初始化了引导类类名信息，备用\n            SpringApplication【1343】->new SpringApplication(primarySources).run(args)\n            # 初始化容器，得到ApplicationContext对象\n                SpringApplication【323】->StopWatch stopWatch = new StopWatch();\n                # 设置计时器\n                SpringApplication【324】->stopWatch.start();\n                # 计时开始\n                SpringApplication【325】->DefaultBootstrapContext bootstrapContext = createBootstrapContext();\n                # 系统引导信息对应的上下文对象\n                SpringApplication【327】->configureHeadlessProperty();\n                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）\n                    java.awt.headless=true\n                SpringApplication【328】->SpringApplicationRunListeners listeners = getRunListeners(args);\n                # 获取当前注册的所有监听器\n                SpringApplication【329】->listeners.starting(bootstrapContext, this.mainApplicationClass);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【331】->ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n                # 获取参数\n                SpringApplication【333】->ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n                # 将前期读取的数据加载成了一个环境对象，用来描述信息\n                SpringApplication【333】->configureIgnoreBeanInfo(environment);\n                # 做了一个配置，备用\n                SpringApplication【334】->Banner printedBanner = printBanner(environment);\n                # 初始化logo\n                SpringApplication【335】->context = createApplicationContext();\n                # 创建容器对象，根据前期配置的容器类型进行判定并创建\n                SpringApplication【363】->context.setApplicationStartup(this.applicationStartup);\n                # 设置启动模式\n                SpringApplication【337】->prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n                # 对容器进行设置，参数来源于前期的设定\n                SpringApplication【338】->refreshContext(context);\n                # 刷新容器环境\n                SpringApplication【339】->afterRefresh(context, applicationArguments);\n                # 刷新完毕后做后处理\n                SpringApplication【340】->stopWatch.stop();\n                # 计时结束\n                SpringApplication【341】->if (this.logStartupInfo) {\n                # 判定是否记录启动时间的日志\n                SpringApplication【342】->    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n                # 创建日志对应的对象，输出日志信息，包含启动时间\n                SpringApplication【344】->listeners.started(context);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【345】->callRunners(context, applicationArguments);\n                # 调用运行器\n                SpringApplication【353】->listeners.running(context);\n                # 监听器执行了对应的操作步骤\n\n\n上述过程描述了springboot程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？\n\n遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。\n\npublic class Abc implements InitializingBean, DisposableBean {\n    public void destroy() throws Exception {\n        //销毁操作\n    }\n    public void afterPropertiesSet() throws Exception {\n        //初始化操作\n    }\n}\n\n\nspringboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。\n\nspringboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：\n\n * org.springframework.boot.context.event.ApplicationStartingEvent\n   * 应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent\n * org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent\n   * 环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent\n * org.springframework.boot.context.event.ApplicationContextInitializedEvent\n   * 上下文初始化事件\n * org.springframework.boot.context.event.ApplicationPreparedEvent\n   * 应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent\n * org.springframework.context.event.ContextRefreshedEvent\n   * 上下文刷新事件\n * org.springframework.boot.context.event.ApplicationStartedEvent\n   * 应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent\n * org.springframework.boot.context.event.ApplicationReadyEvent\n   * 应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求\n * org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）\n\n上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。\n\n//设定监听器，在应用启动开始事件时进行功能追加\npublic class MyListener implements ApplicationListener<ApplicationStartingEvent> {\n    public void onApplicationEvent(ApplicationStartingEvent event) {\n\t\t//自定义事件处理逻辑\n    }\n}\n\n\n按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。\n\n总结\n\n 1. springboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器\n 2. 整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码',normalizedContent:'# springboot原理篇\n\n下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：\n\n * 自动配置工作流程\n * 自定义starter开发\n * springboot程序启动流程\n\n下面开启第一部分自动配置工作流程的学习\n\n\n# yl-1.自动配置工作流程\n\n自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的bean的加载方式仅仅应用于后面课程的学习，并不是所有的spring加载bean的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。\n\n\n# yl-1-1.bean的加载方式\n\n关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的beandefinition对象初始化spring的bean。如果前面这句话看起来有障碍，可以去复习一下spring的相关知识。b站中有我尊敬的满一航老师录制的spring高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。\n\nhttps://www.bilibili.com/video/bv1p44y1n7qg\n\n\n# 方式一：配置文件+<bean/>标签\n\n最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战java基础高级部分复习一下反射相关知识。\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!--xml方式声明自己开发的bean--\x3e\n    <bean id="cat" class="cat"/>\n    <bean class="dog"/>\n\n    \x3c!--xml方式声明第三方开发的bean--\x3e\n    <bean id="datasource" class="com.alibaba.druid.pool.druiddatasource"/>\n    <bean class="com.alibaba.druid.pool.druiddatasource"/>\n    <bean class="com.alibaba.druid.pool.druiddatasource"/>\n</beans>\n\n\n# 方式二：配置文件扫描+注解定义bean\n\n由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@component以及三个衍生注解@service、@controller、@repository。\n\n@component("tom")\npublic class cat {\n}\n\n\n@service\npublic class mouse {\n}\n\n\n当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@component修饰的类中，有人会说不是@configuration吗？建议把spring注解开发相关课程学习一下，就不会有这个疑问了。\n\n@component\npublic class dbconfig {\n    @bean\n    public druiddatasource datasource(){\n        druiddatasource ds = new druiddatasource();\n        return ds;\n    }\n}\n\n\n上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n    ">\n    \x3c!--指定扫描加载bean的位置--\x3e\n    <context:component-scan base-package="com.itheima.bean,com.itheima.config"/>\n</beans>\n\n\n方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。\n\n# 方式三：注解方式声明配置类\n\n方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。\n\n定义一个类并使用@componentscan替代原始xml配置中的包扫描这个动作，其实功能基本相同 。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。\n\n@componentscan({"com.itheima.bean","com.itheima.config"})\npublic class springconfig3 {\n    @bean\n    public dogfactorybean dog(){\n        return new dogfactorybean();\n    }\n}\n\n\n# 使用factroybean接口\n\n补充一个小知识，spring提供了一个接口factorybean，也可以用于声明bean，只不过实现了factorybean接口的类造出来的对象不是当前类的对象，而是factorybean接口泛型指定类型的对象。如下列，造出来的bean并不是dogfactorybean，而是dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。\n\npublic class dogfactorybean implements factorybean<dog> {\n    @override\n    public dog getobject() throws exception {\n        dog d = new dog();\n        //.........\n        return d;\n    }\n    @override\n    public class<?> getobjecttype() {\n        return dog.class;\n    }\n    @override\n    public boolean issingleton() {\n        return true;\n    }\n}\n\n\n有人说，注释中的代码写入dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入dog，或许初始化动作a当前并不能满足你的需要，这个时候你就要做一个dogb的方案了。然后，就没有然后了，你就要做两个dog类。当时使用factorybean接口就可以完美解决这个问题。\n\n通常实现了factorybean接口的类使用@bean的形式进行加载，当然你也可以使用@component去声明dogfactorybean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。\n\n@componentscan({"com.itheima.bean","com.itheima.config"})\npublic class springconfig3 {\n    @bean\n    public dogfactorybean dog(){\n        return new dogfactorybean();\n    }\n}\n\n\n# 注解格式导入xml格式配置的bean\n\n再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@importresource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。\n\n@configuration\n@importresource("applicationcontext1.xml")\npublic class springconfig32 {\n}\n\n\n# proxybeanmethods属性\n\n前面的例子中用到了@configuration这个注解，当我们使用annotationconfigapplicationcontext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@configuration注解设置proxybeanmethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。\n\n@configuration(proxybeanmethods = true)\npublic class springconfig33 {\n    @bean\n    public cat cat(){\n        return new cat();\n    }\n}\n\n\n下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用，前面讲mq时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。\n\npublic class app33 {\n    public static void main(string[] args) {\n        applicationcontext ctx = new annotationconfigapplicationcontext(springconfig33.class);\n        string[] names = ctx.getbeandefinitionnames();\n        for (string name : names) {\n            system.out.println(name);\n        }\n        system.out.println("-------------------------");\n        springconfig33 springconfig33 = ctx.getbean("springconfig33", springconfig33.class);\n        system.out.println(springconfig33.cat());\n        system.out.println(springconfig33.cat());\n        system.out.println(springconfig33.cat());\n    }\n}\n\n\n# 方式四：使用@import注解注入bean\n\n使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。\n\n有人就会奇怪，会有什么问题呢？比如你扫描了com.itheima.service包，后来因为业务需要，又扫描了com.itheima.dao包，你发现com.itheima包下面只有service和dao这两个包，这就简单了，直接扫描com.itheima就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.itheima包，这下就热闹了，该来的不该来的全来了。\n\n所以我们需要一种精准制导的加载方式，使用@import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@componentscan可以解决很多问题，但是@import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@component修饰呢？这下就无解了，而@import就无需考虑这个问题。\n\n@import({dog.class,dbconfig.class})\npublic class springconfig4 {\n}\n\n\n# 使用@import注解注入配置类\n\n除了加载bean，还可以使用@import注解加载配置类。其实本质上是一样的，不解释太多了。\n\n@import(dogfactorybean.class)\npublic class springconfig4 {\n}\n\n\n# 方式五：编程形式注册bean\n\n前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。\n\npublic class app5 {\n    public static void main(string[] args) {\n        annotationconfigapplicationcontext ctx = new annotationconfigapplicationcontext(springconfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.register(mouse.class);\n    }\n}\n\n\n其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。\n\npublic class app5 {\n    public static void main(string[] args) {\n        annotationconfigapplicationcontext ctx = new annotationconfigapplicationcontext(springconfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.registerbean("tom", cat.class,0);\n        ctx.registerbean("tom", cat.class,1);\n        ctx.registerbean("tom", cat.class,2);\n        system.out.println(ctx.getbean(cat.class));\n    }\n}\n\n\n# 方式六：导入实现了importselector接口的类\n\n在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现importselector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。\n\n现在又多了一种控制bean加载的方式，或者说是选择bean的方式。\n\npublic class myimportselector implements importselector {\n    @override\n    public string[] selectimports(annotationmetadata metadata) {\n        //各种条件的判定，判定完毕后，决定是否装载指定的bean\n        // metadata表示源数据\n        boolean flag = metadata.hasannotation("org.springframework.context.annotation.configuration");\n        if(flag){\n            return new string[]{"com.itheima.bean.dog"};\n        }\n        return new string[]{"com.itheima.bean.cat"};\n    }\n}\n\n\n\n# 方式七：导入实现了importbeandefinitionregistrar接口的类\n\n方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做beandefinition的东西，它才是控制bean初始化加载的核心。beandefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在beandefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现importbeandefinitionregistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。\n\npublic class myregistrar implements importbeandefinitionregistrar {\n    @override\n    public void registerbeandefinitions(annotationmetadata metadata, beandefinitionregistry registry) {\n        beandefinition beandefinition = \t\n            beandefinitionbuilder.rootbeandefinition(bookserviceimpl2.class).getbeandefinition();\n        registry.registerbeandefinition("bookservice",beandefinition);\n    }\n}\n\n\n# 方式八：导入实现了beandefinitionregistrypostprocessor接口的类\n\n上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。\n\nspring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，beandefinitionregistrypostprocessor，看名字知道，beandefinition意思是bean定义，registry注册的意思，post后置，processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。\n\npublic class mypostprocessor implements beandefinitionregistrypostprocessor {\n    @override\n    public void postprocessbeandefinitionregistry(beandefinitionregistry registry) throws beansexception {\n        beandefinition beandefinition = \n            beandefinitionbuilder.rootbeandefinition(bookserviceimpl4.class).getbeandefinition();\n        registry.registerbeandefinition("bookservice",beandefinition);\n    }\n}\n\n\n\n总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。复习的内容就先说到这里。\n\n总结\n\n 1. bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean\n 2. @import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@bean相关的定义，会被一同加载\n 3. spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean\n\n\n\n\n# yl-1-2.bean的加载控制\n\n前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，importselector接口，importbeandefinitionregistrar接口，beandefinitionregistrypostprocessor接口都可以控制bean的加载，这一节就来说说这些加载控制。\n\n企业级开发中不可能在spring容器中进行bean的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，通过判定是否加载了某个类来控制某些bean的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。\n\npublic class myimportselector implements importselector {\n    @override\n    public string[] selectimports(annotationmetadata importingclassmetadata) {\n        try {\n            class<?> clazz = class.forname("com.itheima.bean.mouse");\n            if(clazz != null) {\n                return new string[]{"com.itheima.bean.cat"};\n            }\n        } catch (classnotfoundexception e) {\n//            e.printstacktrace();\n            return new string[0];\n        }\n        return null;\n    }\n}\n\n\n通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我springboot信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。\n\n下例使用@conditionalonclass注解实现了当虚拟机中加载了com.itheima.bean.wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。\n\n@bean\n@conditionalonclass(name = "com.itheima.bean.wolf")\npublic cat tom(){\n    return new cat();\n}\n\n\n@conditionalonmissingclass注解控制虚拟机中没有加载指定的类才加载对应的bean。\n\n@bean\n@conditionalonmissingclass("com.itheima.bean.dog")\npublic cat tom(){\n    return new cat();\n}\n\n\n这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。\n\n\n@bean\n@conditionalonclass(name = "com.itheima.bean.wolf")\n@conditionalonmissingclass("com.itheima.bean.mouse")\npublic cat tom(){\n    return new cat();\n}\n\n\n除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。\n\n@bean\n@conditionalonwebapplication\npublic cat tom(){\n    return new cat();\n}\n\n\n下面是判定容器环境是否是非web环境。\n\n@bean\n@conditionalonnotwebapplication\npublic cat tom(){\n    return new cat();\n}\n\n\n当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbctemplate对应的bean，你还需要再加载一个全新的jdbctemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？\n\n@bean\n@conditionalonbean(name="jerry")\npublic cat tom(){\n    return new cat();\n}\n\n\n以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个druid的数据源对象出来，完美！\n\npublic class springconfig {\n    @bean\n    @conditionalonclass(name="com.mysql.jdbc.driver")\n    public druiddatasource datasource(){\n        return new druiddatasource();\n    }\n}\n\n\n其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。\n\n总结\n\n 1. springboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean\n\n\n# yl-1-3.bean的依赖属性配置管理\n\nbean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。\n\ncartoon:\n  cat:\n    name: "图多盖洛"\n    age: 5\n  mouse:\n    name: "泰菲"\n    age: 1\n\n\n然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。\n\n@configurationproperties(prefix = "cartoon")\n@data\npublic class cartoonproperties {\n    private cat cat;\n    private mouse mouse;\n}\n\n\n最后在使用的位置注入对应的配置即可。\n\n@enableconfigurationproperties(cartoonproperties.class)\npublic class cartooncatandmouse{\n    @autowired\n    private cartoonproperties cartoonproperties;\n}\n\n\n建议在业务类上使用@enableconfigurationproperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类cartoonproperties，减少spring管控的资源数量。\n\n总结\n\n 1. bean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * properties\n 2. 设置属性类加载指定前缀的配置信息\n 3. 在需要使用属性类的位置通过注解@enableconfigurationproperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。\n\n\n# yl-1-4.自动配置原理（工作流程）\n\n经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。\n\n啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。\n\n自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么ip地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。\n\n而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：\n\n阶段一：准备阶段\n\n 1. springboot的开发人员先大量收集spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个技术集a\n\n 2. 收集常用技术(技术集a)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的设置集b\n    \n    阶段二：加载阶段\n\n 3. springboot初始化spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成初始化环境\n\n 4. springboot将技术集a包含的所有技术在springboot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的\n\n 5. springboot会对技术集a中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与初始化环境，这个时候就可以根据这个初始化环境与springboot的技术集a进行比对了，哪个匹配上加载哪个\n\n 6. 因为有些技术不做配置就无法工作，所以springboot开始对设置集b下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量\n\n 7. 但是默认配置不一定能解决问题，于是springboot开放修改设置集b的接口，可以由开发者根据需要决定是否覆盖默认配置\n\n以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？\n\n * 首先指定一个技术x，我们打算让技术x具备自动配置的功能，这个技术x可以是任意功能，这个技术隶属于上面描述的技术集a\n\npublic class cartooncatandmouse{\n}\n\n\n * 然后找出技术x使用过程中的常用配置y，这个配置隶属于上面表述的设置集b\n\ncartoon:\n  cat:\n    name: "图多盖洛"\n    age: 5\n  mouse:\n    name: "泰菲"\n    age: 1\n\n\n * 将常用配置y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样\n\n@configurationproperties(prefix = "cartoon")\n@data\npublic class cartoonproperties {\n    private cat cat;\n    private mouse mouse;\n}\n\n\n * 最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置\n\n@enableconfigurationproperties(cartoonproperties.class)\npublic class cartooncatandmouse implements applicationcontextaware {\n    private cartoonproperties cartoonproperties;\n}\n\n\n * 当然，你也可以为当前自动配置类设置上激活条件，例如使用@condtionon* * * * 为其设置加载条件\n\n@conditionalonclass(name="org.springframework.data.redis.core.redisoperations")\n@enableconfigurationproperties(cartoonproperties.class)\npublic class cartooncatandmouse implements applicationcontextaware {\n    private cartoonproperties cartoonproperties;\n}\n\n\n做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建meta-inf目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。\n\n# auto configure\norg.springframework.boot.autoconfigure.enableautoconfiguration=\\\ncom.itheima.bean.cartooncatandmouse\n\n\n其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：\n\n 1. 自动配置从根本上来说就是一个bean的加载\n 2. 通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱\n 3. 使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱\n 4. springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱\n\n你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。\n\n以上内容是自动配置的工作流程。\n\n总结\n\n 1. springboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.enableautoconfiguration配置项，将其中配置的所有的类都加载成bean\n 2. 在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean\n 3. 对于可以正常加载成bean的类，通常会通过@enableconfigurationproperties注解初始化对应的配置属性类并加载对应的配置\n 4. 配置属性类上通常会通过@configurationproperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了\n\n\n\n\n# yl-1-5.变更自动配置\n\n知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：\n\n方式一：通过yaml配置设置排除指定的自动配置类\n\nspring:\n  autoconfigure:\n    exclude:\n      - org.springframework.boot.autoconfigure.task.taskexecutionautoconfiguration\n\n\n方式二：通过注解参数排除自动配置类\n\n@enableautoconfiguration(excludename = "",exclude = {})\n\n\n方式三：排除坐标（应用面较窄）\n\n如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n        \x3c!--web起步依赖环境中，排除tomcat起步依赖，匹配自动配置条件--\x3e\n        <exclusions>\n            <exclusion>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-tomcat</artifactid>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    \x3c!--添加jetty起步依赖，匹配自动配置条件--\x3e\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-jetty</artifactid>\n    </dependency>\n</dependencies>\n\n\n总结\n\n 1. springboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能\n\n\n# yl-2.自定义starter开发\n\n自动配置学习完后，我们就可以基于自动配置的特性，开发springboot技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的starter，然后就实现了springboot整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义starter来实现自定义功能的快捷添加。\n\n\n# yl-2-1.案例：记录系统访客独立ip访问次数\n\n本案例的功能是统计网站独立ip访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：ip+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。\n\n例如：张三访问网站功能15次，ip地址：192.168.0.135，李四访问网站功能20次，ip地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。\n\n         ip访问监控\n+-----ip-address-----+--num--+\n|     192.168.0.135  |   15  |\n|     61.129.65.248  |   20  |\n+--------------------+-------+\n\n\n在进行具体制作之前，先对功能做具体的分析\n\n 1. 数据记录在什么位置\n    \n    最终记录的数据是一个字符串（ip地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案，有兴趣的小伙伴可以使用redis作为解决方案。\n\n 2. 统计功能运行位置，因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。\n\n 3. 为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。\n    \n    * 输出频度，默认10秒\n    * 数据特征：累计数据 / 阶段数据，默认累计数据\n    * 输出格式：详细模式 / 极简模式\n\n在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。\n\n\n# yl-2-2.ip计数业务功能开发（自定义starter）\n\n本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。\n\n步骤一：创建全新的模块，定义业务功能类\n\n功能类的制作并不复杂，定义一个业务类，声明一个map对象，用于记录ip访问次数，key是ip地址，value是访问次数\n\npublic class ipcountservice {\n    private map<string,integer> ipcountmap = new hashmap<string,integer>();\n}\n\n\n有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。\n\n步骤二：制作统计功能\n\n制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可\n\npublic class ipcountservice {\n    private map<string,integer> ipcountmap = new hashmap<string,integer>();\n    public void count(){\n        //每次调用当前操作，就记录当前访问的ip，然后累加访问次数\n        //1.获取当前操作的ip地址\n        string ip = null;\n        //2.根据ip地址从map取值，并递增\n        integer count = ipcountmap.get(ip);\n        if(count == null){\n            ipcountmap.put(ip,1);\n        }else{\n            ipcountmap.put(ip,count + 1);\n        }\n    }\n}\n\n\n因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，可以从容器中直接获取请求对象，因此获取ip地址的操作可以通过自动装配得到请求对象，然后获取对应的访问ip地址。\n\npublic class ipcountservice {\n    private map<string,integer> ipcountmap = new hashmap<string,integer>();\n    @autowired\n    //当前的request对象的注入工作由使用当前starter的工程提供自动装配\n    private httpservletrequest httpservletrequest;\n    public void count(){\n        //每次调用当前操作，就记录当前访问的ip，然后累加访问次数\n        //1.获取当前操作的ip地址\n        string ip = httpservletrequest.getremoteaddr();\n        //2.根据ip地址从map取值，并递增\n        integer count = ipcountmap.get(ip);\n        if(count == null){\n            ipcountmap.put(ip,1);\n        }else{\n            ipcountmap.put(ip,count + 1);\n        }\n    }\n}\n\n\n步骤三：定义自动配置类\n\n我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。\n\npublic class ipautoconfiguration {\n    @bean\n    public ipcountservice ipcountservice(){\n        return new ipcountservice();\n    }\n}\n\n\n自动配置类需要在spring.factories文件中做配置方可自动运行。\n\n# auto configure\norg.springframework.boot.autoconfigure.enableautoconfiguration=cn.itcast.autoconfig.ipautoconfiguration\n\n\n步骤四：在原始项目中模拟调用，测试功能\n\n原始调用项目中导入当前开发的starter\n\n<dependency>\n    <groupid>cn.itcast</groupid>\n    <artifactid>ip_spring_boot_starter</artifactid>\n    <version>0.0.1-snapshot</version>\n</dependency>\n\n\n推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。\n\n@restcontroller\n@requestmapping("/books")\npublic class bookcontroller {\n    @autowired\n    private ipcountservice ipcountservice;\n    @getmapping("{currentpage}/{pagesize}")\n    public r getpage(@pathvariable int currentpage,@pathvariable int pagesize,book book){\n        ipcountservice.count();\n        ipage<book> page = bookservice.getpage(currentpage, pagesize,book);\n        if( currentpage > page.getpages()){\n            page = bookservice.getpage((int)page.getpages(), pagesize,book);\n        }\n        return new r(true, page);\n    }\n}\n\n\n温馨提示\n\n由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先clean然后install，保障资源进行了更新。切记切记！！\n\n当前效果\n\n每次调用分页操作后，可以在控制台输出当前访问的ip地址，此功能可以在count操作中添加日志或者输出语句进行测试。\n\n\n# yl-2-3.定时任务报表开发\n\n当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术quartz实现，也可以选择spring内置的task来完成此功能，此处选用spring的task作为实现方案。\n\n步骤一：开启定时任务功能\n\n定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。\n\n@enablescheduling\npublic class ipautoconfiguration {\n    @bean\n    public ipcountservice ipcountservice(){\n        return new ipcountservice();\n    }\n}\n\n\n步骤二：制作显示统计数据功能\n\n定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。\n\npublic class ipcountservice {\n    private map<string,integer> ipcountmap = new hashmap<string,integer>();\n    @scheduled(cron = "0/5 * * * * ?")\n    public void print(){\n        system.out.println("         ip访问监控");\n        system.out.println("+-----ip-address-----+--num--+");\n        for (map.entry<string, integer> entry : ipcountmap.entryset()) {\n            string key = entry.getkey();\n            integer value = entry.getvalue();\n            system.out.println(string.format("|%18s  |%5d  |",key,value));\n        }\n        system.out.println("+--------------------+-------+");\n      }\n}\n\n\n其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用string类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。\n\n\n# yl-2-4.使用属性配置设置功能参数\n\n由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。\n\n步骤一：定义参数格式\n\n设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cyclereset），数据显示格式（model）\n\ntools:\n  ip:\n    cycle: 10\n    cyclereset: false\n    model: "detail"\n\n\n步骤二：定义封装参数的属性类，读取配置参数\n\n为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。\n\n日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。\n\n@configurationproperties(prefix = "tools.ip")\npublic class ipproperties {\n    /**\n     * 日志显示周期\n     */\n    private long cycle = 5l;\n    /**\n     * 是否周期内重置数据\n     */\n    private boolean cyclereset = false;\n    /**\n     * 日志输出模式  detail：详细模式  simple：极简模式\n     */\n    private string model = logmodel.detail.value;\n    public enum logmodel{\n        detail("detail"),\n        simple("simple");\n        private string value;\n        logmodel(string value) {\n            this.value = value;\n        }\n        public string getvalue() {\n            return value;\n        }\n    }\n}\n\n\n步骤三：加载属性类\n\n@enablescheduling\n@enableconfigurationproperties(ipproperties.class)\npublic class ipautoconfiguration {\n    @bean\n    public ipcountservice ipcountservice(){\n        return new ipcountservice();\n    }\n}\n\n\n步骤四：应用配置属性\n\n在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。\n\n注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。\n\npublic class ipcountservice {\n    private map<string,integer> ipcountmap = new hashmap<string,integer>();\n    @autowired\n    private ipproperties ipproperties;\n    @scheduled(cron = "0/5 * * * * ?")\n    public void print(){\n        if(ipproperties.getmodel().equals(ipproperties.logmodel.detail.getvalue())){\n            system.out.println("         ip访问监控");\n            system.out.println("+-----ip-address-----+--num--+");\n            for (map.entry<string, integer> entry : ipcountmap.entryset()) {\n                string key = entry.getkey();\n                integer value = entry.getvalue();\n                system.out.println(string.format("|%18s  |%5d  |",key,value));\n            }\n            system.out.println("+--------------------+-------+");\n        }else if(ipproperties.getmodel().equals(ipproperties.logmodel.simple.getvalue())){\n            system.out.println("     ip访问监控");\n            system.out.println("+-----ip-address-----+");\n            for (string key: ipcountmap.keyset()) {\n                system.out.println(string.format("|%18s  |",key));\n            }\n            system.out.println("+--------------------+");\n        }\n        //阶段内统计数据归零\n        if(ipproperties.getcyclereset()){\n            ipcountmap.clear();\n        }\n    }\n}\n\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。\n\n\n# yl-2-5.使用属性配置设置定时器参数\n\n在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@enableconfigurationproperties注解对应的功能，改成最原始的bean定义格式。\n\n步骤一：@scheduled注解使用#{}读取bean属性值\n\n此处读取bean名称为ipproperties的bean的cycle属性值\n\n@scheduled(cron = "0/#{ipproperties.cycle} * * * * ?")\npublic void print(){\n}\n\n\n步骤二：属性类定义bean并指定bean的访问名称\n\n如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取\n\n@component("ipproperties")\n@configurationproperties(prefix = "tools.ip")\npublic class ipproperties {\n}\n\n\n步骤三：弃用@enableconfigurationproperties注解对应的功能，改为导入bean的形式加载配置属性类\n\n@enablescheduling\n//@enableconfigurationproperties(ipproperties.class)\n@import(ipproperties.class)\npublic class ipautoconfiguration {\n    @bean\n    public ipcountservice ipcountservice(){\n        return new ipcountservice();\n    }\n}\n\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制\n\n\n# yl-2-6.拦截器开发\n\n基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在web工程中制作，然后将所有功能挪入starter模块中\n\n步骤一：开发拦截器\n\n使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能\n\npublic class ipcountinterceptor implements handlerinterceptor {\n    @autowired\n    private ipcountservice ipcountservice;\n    @override\n    public boolean prehandle(httpservletrequest request, \n                             httpservletresponse response, object handler) throws exception {\n        ipcountservice.count();\n        return true;\n    }\n}\n\n\n步骤二：配置拦截器\n\n配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载ipcountproperties中的属性，通过配置设置拦截器拦截的请求。\n\n@configuration\npublic class springmvcconfig implements webmvcconfigurer {\n    @override\n    public void addinterceptors(interceptorregistry registry) {\n        registry.addinterceptor(ipcountinterceptor()).addpathpatterns("/**");\n    }\n    @bean\n    public ipcountinterceptor ipcountinterceptor(){\n        return new ipcountinterceptor();\n    }\n}\n\n\n温馨提示\n\n每次运行效果之前先clean然后install，切记切记！！\n\n当前效果\n\n在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。\n\n到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人就无法使用了。\n\n\n# yl-2-7.功能性完善——开启yml提示功能\n\n我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。\n\nspringboot提供有专用的工具实现此功能，仅需要导入下列坐标。\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-configuration-processor</artifactid>\n    <optional>true</optional>\n</dependency>\n\n\n程序编译后，在meta-inf目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的meta-inf目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。\n\n{\n  "groups": [\n    {\n      "name": "tools.ip",\n      "type": "cn.itcast.properties.ipproperties",\n      "sourcetype": "cn.itcast.properties.ipproperties"\n    }\n  ],\n  "properties": [\n    {\n      "name": "tools.ip.cycle",\n      "type": "java.lang.long",\n      "description": "日志显示周期",\n      "sourcetype": "cn.itcast.properties.ipproperties",\n      "defaultvalue": 5\n    },\n    {\n      "name": "tools.ip.cycle-reset",\n      "type": "java.lang.boolean",\n      "description": "是否周期内重置数据",\n      "sourcetype": "cn.itcast.properties.ipproperties",\n      "defaultvalue": false\n    },\n    {\n      "name": "tools.ip.model",\n      "type": "java.lang.string",\n      "description": "日志输出模式  detail：详细模式  simple：极简模式",\n      "sourcetype": "cn.itcast.properties.ipproperties"\n    }\n  ],\n  "hints": [\n    {\n      "name": "tools.ip.model",\n      "values": [\n        {\n          "value": "detail",\n          "description": "详细模式."\n        },\n        {\n          "value": "simple",\n          "description": "极简模式."\n        }\n      ]\n    }\n  ]\n}\n\n\n总结\n\n 1. 自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能\n 2. 通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果\n 3. 本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter\n 4. 对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写\n\n\n# yl-3.springboot程序启动流程解析\n\n原理篇学习到这里即将结束，最后一章说一下springboot程序的启动流程。对于springboot技术来说，它用于加速spring程序的开发，核心本质还是spring程序的运行，所以于其说是springboot程序的启动流程，不如说是springboot对spring程序的启动流程做了哪些更改。\n\n\n\n其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。\n\nspringboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：\n\n * 环境属性（environment）\n * 系统配置（spring.factories）\n * 参数（arguments、application.properties）\n\n以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。\n\nspringboot30startupapplication【10】->springapplication.run(springboot30startupapplication.class, args);\n    springapplication【1332】->return run(new class<?>[] { primarysource }, args);\n        springapplication【1343】->return new springapplication(primarysources).run(args);\n            springapplication【1343】->springapplication(primarysources)\n            # 加载各种配置信息，初始化各种配置对象\n                springapplication【266】->this(null, primarysources);\n                    springapplication【280】->public springapplication(resourceloader resourceloader, class<?>... primarysources)\n                        springapplication【281】->this.resourceloader = resourceloader;\n                        # 初始化资源加载器\n                        springapplication【283】->this.primarysources = new linkedhashset<>(arrays.aslist(primarysources));\n                        # 初始化配置类的类名信息（格式转换）\n                        springapplication【284】->this.webapplicationtype = webapplicationtype.deducefromclasspath();\n                        # 确认当前容器加载的类型\n                        springapplication【285】->this.bootstrapregistryinitializers = getbootstrapregistryinitializersfromspringfactories();\n                        # 获取系统配置引导信息\n                        springapplication【286】->setinitializers((collection) getspringfactoriesinstances(applicationcontextinitializer.class));\n                        # 获取applicationcontextinitializer.class对应的实例\n                        springapplication【287】->setlisteners((collection) getspringfactoriesinstances(applicationlistener.class));\n                        # 初始化监听器，对初始化过程及运行过程进行干预\n                        springapplication【288】->this.mainapplicationclass = deducemainapplicationclass();\n                        # 初始化了引导类类名信息，备用\n            springapplication【1343】->new springapplication(primarysources).run(args)\n            # 初始化容器，得到applicationcontext对象\n                springapplication【323】->stopwatch stopwatch = new stopwatch();\n                # 设置计时器\n                springapplication【324】->stopwatch.start();\n                # 计时开始\n                springapplication【325】->defaultbootstrapcontext bootstrapcontext = createbootstrapcontext();\n                # 系统引导信息对应的上下文对象\n                springapplication【327】->configureheadlessproperty();\n                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）\n                    java.awt.headless=true\n                springapplication【328】->springapplicationrunlisteners listeners = getrunlisteners(args);\n                # 获取当前注册的所有监听器\n                springapplication【329】->listeners.starting(bootstrapcontext, this.mainapplicationclass);\n                # 监听器执行了对应的操作步骤\n                springapplication【331】->applicationarguments applicationarguments = new defaultapplicationarguments(args);\n                # 获取参数\n                springapplication【333】->configurableenvironment environment = prepareenvironment(listeners, bootstrapcontext, applicationarguments);\n                # 将前期读取的数据加载成了一个环境对象，用来描述信息\n                springapplication【333】->configureignorebeaninfo(environment);\n                # 做了一个配置，备用\n                springapplication【334】->banner printedbanner = printbanner(environment);\n                # 初始化logo\n                springapplication【335】->context = createapplicationcontext();\n                # 创建容器对象，根据前期配置的容器类型进行判定并创建\n                springapplication【363】->context.setapplicationstartup(this.applicationstartup);\n                # 设置启动模式\n                springapplication【337】->preparecontext(bootstrapcontext, context, environment, listeners, applicationarguments, printedbanner);\n                # 对容器进行设置，参数来源于前期的设定\n                springapplication【338】->refreshcontext(context);\n                # 刷新容器环境\n                springapplication【339】->afterrefresh(context, applicationarguments);\n                # 刷新完毕后做后处理\n                springapplication【340】->stopwatch.stop();\n                # 计时结束\n                springapplication【341】->if (this.logstartupinfo) {\n                # 判定是否记录启动时间的日志\n                springapplication【342】->    new startupinfologger(this.mainapplicationclass).logstarted(getapplicationlog(), stopwatch);\n                # 创建日志对应的对象，输出日志信息，包含启动时间\n                springapplication【344】->listeners.started(context);\n                # 监听器执行了对应的操作步骤\n                springapplication【345】->callrunners(context, applicationarguments);\n                # 调用运行器\n                springapplication【353】->listeners.running(context);\n                # 监听器执行了对应的操作步骤\n\n\n上述过程描述了springboot程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？\n\n遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。\n\npublic class abc implements initializingbean, disposablebean {\n    public void destroy() throws exception {\n        //销毁操作\n    }\n    public void afterpropertiesset() throws exception {\n        //初始化操作\n    }\n}\n\n\nspringboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。\n\nspringboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：\n\n * org.springframework.boot.context.event.applicationstartingevent\n   * 应用启动事件，在应用运行但未进行任何处理时，将发送 applicationstartingevent\n * org.springframework.boot.context.event.applicationenvironmentpreparedevent\n   * 环境准备事件，当environment被使用，且上下文创建之前，将发送 applicationenvironmentpreparedevent\n * org.springframework.boot.context.event.applicationcontextinitializedevent\n   * 上下文初始化事件\n * org.springframework.boot.context.event.applicationpreparedevent\n   * 应用准备事件，在开始刷新之前，bean定义被加载之后发送 applicationpreparedevent\n * org.springframework.context.event.contextrefreshedevent\n   * 上下文刷新事件\n * org.springframework.boot.context.event.applicationstartedevent\n   * 应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 applicationstartedevent\n * org.springframework.boot.context.event.applicationreadyevent\n   * 应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 applicationreadyevent，用于通知应用已经准备处理请求\n * org.springframework.context.event.contextclosedevent（上下文关闭事件，对应容器关闭）\n\n上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。\n\n//设定监听器，在应用启动开始事件时进行功能追加\npublic class mylistener implements applicationlistener<applicationstartingevent> {\n    public void onapplicationevent(applicationstartingevent event) {\n\t\t//自定义事件处理逻辑\n    }\n}\n\n\n按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。\n\n总结\n\n 1. springboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器\n 2. 整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码',charsets:{cjk:!0}},{title:"核心配置文件详解",frontmatter:{title:"核心配置文件详解",date:"2022-03-05T00:00:00.000Z",permalink:"/mybatis/002/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/02.%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3.html",relativePath:"07.框架/04.MyBatis/02.核心配置文件详解.md",key:"v-78cb83ac",path:"/mybatis/002/",headers:[{level:2,title:"单个字面量类型的参数",slug:"单个字面量类型的参数",normalizedTitle:"单个字面量类型的参数",charIndex:4192},{level:2,title:"多个字面量类型的参数",slug:"多个字面量类型的参数",normalizedTitle:"多个字面量类型的参数",charIndex:4637},{level:2,title:"map集合类型的参数（第二种情况的演变）",slug:"map集合类型的参数-第二种情况的演变",normalizedTitle:"map集合类型的参数（第二种情况的演变）",charIndex:5303},{level:2,title:"实体类类型的参数",slug:"实体类类型的参数",normalizedTitle:"实体类类型的参数",charIndex:5965},{level:2,title:"使用@Param标识参数",slug:"使用-param标识参数",normalizedTitle:"使用@param标识参数",charIndex:6460},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:7186}],headersStr:"单个字面量类型的参数 多个字面量类型的参数 map集合类型的参数（第二种情况的演变） 实体类类型的参数 使用@Param标识参数 总结",content:'# 核心配置文件详解\n\n> 核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)： properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//MyBatis.org//DTD Config 3.0//EN"\n        "http://MyBatis.org/dtd/MyBatis-3-config.dtd">\n<configuration>\n    \x3c!--引入properties文件，此时就可以${属性名}的方式访问属性值--\x3e\n\t\x3c!-- 属性名通常会表示为"文件名.属性名"防止重名 --\x3e\n    <properties resource="jdbc.properties"></properties>\n    <settings>\n        \x3c!--将表中字段的下划线自动转换为驼峰--\x3e\n        <setting name="mapUnderscoreToCamelCase" value="true"/>\n        \x3c!--开启延迟加载--\x3e\n        <setting name="lazyLoadingEnabled" value="true"/>\n    </settings>\n    <typeAliases>\n        \x3c!--\n        typeAlias：设置某个具体的类型的别名\n        属性：\n        type：需要设置别名的类型的全类名\n        alias：设置此类型的别名，且别名不区分大小写。\n\t\t若不设置此属性，该类型拥有默认的别名，即类名\n        --\x3e\n        \x3c!--<typeAlias type="com.atguigu.mybatis.bean.User"></typeAlias>--\x3e\n        \x3c!--<typeAlias type="com.atguigu.mybatis.bean.User" alias="user">\n        </typeAlias>--\x3e\n        \x3c!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--\x3e\n        <package name="com.atguigu.mybatis.bean"/>\n    </typeAliases>\n    \x3c!--\n    environments：设置多个连接数据库的环境\n    属性：\n\t    default：设置默认使用的环境的id\n    --\x3e\n    <environments default="mysql_test">\n        \x3c!--\n        environment：设置具体的连接数据库的环境信息\n        属性：\n\t        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境 的id，表示默认使用的环境\n        --\x3e\n        <environment id="mysql_test">\n            \x3c!--\n            transactionManager：设置事务管理方式\n            属性：\n\t            type：设置事务管理方式，type="JDBC|MANAGED"\n\t            type="JDBC"：设置当前环境的事务管理都必须手动处理\n\t            type="MANAGED"：设置事务被管理，例如spring中的AOP\n            --\x3e\n            <transactionManager type="JDBC"/>\n            \x3c!--\n            dataSource：设置数据源\n            属性：\n\t            type：设置数据源的类型，type="POOLED|UNPOOLED|JNDI"\n\t            type="POOLED"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建\n\t            type="UNPOOLED"：不使用数据库连接池，即每次使用连接都需要重新创建\n\t            type="JNDI"：调用上下文中的数据源\n            --\x3e\n            <dataSource type="POOLED">\n                \x3c!--设置驱动类的全类名--\x3e\n                <property name="driver" value="${jdbc.driver}"/>\n                \x3c!--设置连接数据库的连接地址--\x3e\n                <property name="url" value="${jdbc.url}"/>\n                \x3c!--设置连接数据库的用户名--\x3e\n                <property name="username" value="${jdbc.username}"/>\n                \x3c!--设置连接数据库的密码--\x3e\n                <property name="password" value="${jdbc.password}"/>\n            </dataSource>\n        </environment>\n    </environments>\n    \x3c!--引入映射文件--\x3e\n    <mappers>\n        \x3c!-- <mapper resource="UserMapper.xml"/> --\x3e\n        \x3c!--\n        以包为单位，将包下所有的映射文件引入核心配置文件\n        注意：\n\t\t\t1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下\n\t\t\t2. mapper接口要和mapper映射文件的名字一致\n        --\x3e\n        <package name="com.atguigu.mybatis.mapper"/>\n    </mappers>\n</configuration>\n\n\n * \n\n\n# 默认的类型别名\n\n\n\n\n# MyBatis的增删改查\n\n 1. 添加\n    \n    \x3c!--int insertUser();--\x3e\n    <insert id="insertUser">\n    \tinsert into t_user values(null,\'admin\',\'123456\',23,\'男\',\'12345@qq.com\')\n    </insert>\n    \n\n 2. 删除\n    \n    \x3c!--int deleteUser();--\x3e\n    <delete id="deleteUser">\n        delete from t_user where id = 6\n    </delete>\n    \n\n 3. 修改\n    \n    \x3c!--int updateUser();--\x3e\n    <update id="updateUser">\n        update t_user set username = \'张三\' where id = 5\n    </update>\n    \n\n 4. 查询一个实体类对象\n    \n    \x3c!--User getUserById();--\x3e  \n    <select id="getUserById" resultType="com.atguigu.mybatis.bean.User">  \n    \tselect * from t_user where id = 2  \n    </select>\n    \n\n 5. 查询集合\n    \n    \x3c!--List<User> getUserList();--\x3e\n    <select id="getUserList" resultType="com.atguigu.mybatis.bean.User">\n    \tselect * from t_user\n    </select>\n    \n\n * 注意：\n   \n   1. 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系\n      * resultType：自动映射，用于属性名和表中字段名一致的情况\n      * resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况\n   2. 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值\n\n\n# MyBatis获取参数值的两种方式（重点）\n\n * MyBatis获取参数值的两种方式：${}和#{}（这种方法最推荐）\n * ${}的本质就是字符串拼接，#{}的本质就是占位符赋值\n * ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号\n\n\n# 单个字面量类型的参数\n\n * 若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意，使用和原参数相同的）获取参数的值，注意${}需要手动加单引号（\'$(See YOU!)\'）\n\n\x3c!--User getUserByUsername(String username);--\x3e\n<select id="getUserByUsername" resultType="User">\n\tselect * from t_user where username = #{username}\n</select>\n\n\n\x3c!--User getUserByUsername(String username);--\x3e\n<select id="getUserByUsername" resultType="User">  \n\tselect * from t_user where username = \'${username}\'  \n</select>\n\n\n\n# 多个字面量类型的参数\n\n * 若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中\n   \n   1. 以arg0,arg1...为键，以参数为值；\n   2. 以param1,param2...为键，以参数为值；\n\n * 因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。\n\n * 使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的\n\n * 这里可以混用，arg0和param1相等\n\n\x3c!--User checkLogin(String username,String password);--\x3e\n<select id="checkLogin" resultType="User">  \n\tselect * from t_user where username = #{arg0} and password = #{arg1}  \n</select>\n\n\n\x3c!--User checkLogin(String username,String password);--\x3e\n<select id="checkLogin" resultType="User">\n\tselect * from t_user where username = \'${param1}\' and password = \'${param2}\'\n</select> \x3c!--${}要注意单引号为对象进行研究--\x3e\n\n\n\n# map集合类型的参数（第二种情况的演变）\n\n * 若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号\n\n\x3c!--User checkLoginByMap(Map<String,Object> map);--\x3e \n<select id="  checkLoginByMap" resultType="User">\n\tselect * from t_user where username = #{username} and password = #{password}\n</select>\n\n\n@Test\npublic void checkLoginByMap() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tParamet erMapper mapper = sqlSession.getMapper(ParameterMapper.class);\n\tMap<String,Object> map = new HashMap<>();\n\tmap.put("usermane","admin");\n\tmap.put("password","123456");\n\tUser user = mapper.checkLoginByMap(map);\n\tSystem.out.println(user);\n}\n\n\n\n# 实体类类型的参数\n\n * 若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号\n\n\x3c!--int insertUser(User user);--\x3e\n<insert id="insertUser">\n\tinsert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})\n</insert>\n\n\n@Test\npublic void insertUser() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);\n\tUser user = new User(null,"Tom","123456",12,"男","123@321.com");\n\tmapper.insertUser(user);\n}\n\n\n\n# 使用@Param标识参数\n\n * 可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中\n   \n   1. 以@Param注解的value属性值为键，以参数为值；\n   2. 以param1,param2...为键，以参数为值；\n\n * 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号、\n\n这里需要强调一个点: @Param("username")等价于@Param(value = "username")\n\n\x3c!--User CheckLoginByParam(@Param("username") String username, @Param("password") String password);--\x3e\n    <select id="CheckLoginByParam" resultType="User">\n        select * from t_user where username = #{username} and password = #{password}\n    </select>\n\n\n@Test\npublic void checkLoginByParam() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);\n\tmapper.CheckLoginByParam("admin","123456");\n}\n\n\n\n# 总结\n\n * 建议分成两种情况进行处理\n   \n   1. 实体类类型的参数\n   2. 使用@Param标识参数',normalizedContent:'# 核心配置文件详解\n\n> 核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)： properties、settings、typealiases、typehandlers、objectfactory、objectwrapperfactory、reflectorfactory、plugins、environments、databaseidprovider、mappers\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    \x3c!--引入properties文件，此时就可以${属性名}的方式访问属性值--\x3e\n\t\x3c!-- 属性名通常会表示为"文件名.属性名"防止重名 --\x3e\n    <properties resource="jdbc.properties"></properties>\n    <settings>\n        \x3c!--将表中字段的下划线自动转换为驼峰--\x3e\n        <setting name="mapunderscoretocamelcase" value="true"/>\n        \x3c!--开启延迟加载--\x3e\n        <setting name="lazyloadingenabled" value="true"/>\n    </settings>\n    <typealiases>\n        \x3c!--\n        typealias：设置某个具体的类型的别名\n        属性：\n        type：需要设置别名的类型的全类名\n        alias：设置此类型的别名，且别名不区分大小写。\n\t\t若不设置此属性，该类型拥有默认的别名，即类名\n        --\x3e\n        \x3c!--<typealias type="com.atguigu.mybatis.bean.user"></typealias>--\x3e\n        \x3c!--<typealias type="com.atguigu.mybatis.bean.user" alias="user">\n        </typealias>--\x3e\n        \x3c!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--\x3e\n        <package name="com.atguigu.mybatis.bean"/>\n    </typealiases>\n    \x3c!--\n    environments：设置多个连接数据库的环境\n    属性：\n\t    default：设置默认使用的环境的id\n    --\x3e\n    <environments default="mysql_test">\n        \x3c!--\n        environment：设置具体的连接数据库的环境信息\n        属性：\n\t        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境 的id，表示默认使用的环境\n        --\x3e\n        <environment id="mysql_test">\n            \x3c!--\n            transactionmanager：设置事务管理方式\n            属性：\n\t            type：设置事务管理方式，type="jdbc|managed"\n\t            type="jdbc"：设置当前环境的事务管理都必须手动处理\n\t            type="managed"：设置事务被管理，例如spring中的aop\n            --\x3e\n            <transactionmanager type="jdbc"/>\n            \x3c!--\n            datasource：设置数据源\n            属性：\n\t            type：设置数据源的类型，type="pooled|unpooled|jndi"\n\t            type="pooled"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建\n\t            type="unpooled"：不使用数据库连接池，即每次使用连接都需要重新创建\n\t            type="jndi"：调用上下文中的数据源\n            --\x3e\n            <datasource type="pooled">\n                \x3c!--设置驱动类的全类名--\x3e\n                <property name="driver" value="${jdbc.driver}"/>\n                \x3c!--设置连接数据库的连接地址--\x3e\n                <property name="url" value="${jdbc.url}"/>\n                \x3c!--设置连接数据库的用户名--\x3e\n                <property name="username" value="${jdbc.username}"/>\n                \x3c!--设置连接数据库的密码--\x3e\n                <property name="password" value="${jdbc.password}"/>\n            </datasource>\n        </environment>\n    </environments>\n    \x3c!--引入映射文件--\x3e\n    <mappers>\n        \x3c!-- <mapper resource="usermapper.xml"/> --\x3e\n        \x3c!--\n        以包为单位，将包下所有的映射文件引入核心配置文件\n        注意：\n\t\t\t1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下\n\t\t\t2. mapper接口要和mapper映射文件的名字一致\n        --\x3e\n        <package name="com.atguigu.mybatis.mapper"/>\n    </mappers>\n</configuration>\n\n\n * \n\n\n# 默认的类型别名\n\n\n\n\n# mybatis的增删改查\n\n 1. 添加\n    \n    \x3c!--int insertuser();--\x3e\n    <insert id="insertuser">\n    \tinsert into t_user values(null,\'admin\',\'123456\',23,\'男\',\'12345@qq.com\')\n    </insert>\n    \n\n 2. 删除\n    \n    \x3c!--int deleteuser();--\x3e\n    <delete id="deleteuser">\n        delete from t_user where id = 6\n    </delete>\n    \n\n 3. 修改\n    \n    \x3c!--int updateuser();--\x3e\n    <update id="updateuser">\n        update t_user set username = \'张三\' where id = 5\n    </update>\n    \n\n 4. 查询一个实体类对象\n    \n    \x3c!--user getuserbyid();--\x3e  \n    <select id="getuserbyid" resulttype="com.atguigu.mybatis.bean.user">  \n    \tselect * from t_user where id = 2  \n    </select>\n    \n\n 5. 查询集合\n    \n    \x3c!--list<user> getuserlist();--\x3e\n    <select id="getuserlist" resulttype="com.atguigu.mybatis.bean.user">\n    \tselect * from t_user\n    </select>\n    \n\n * 注意：\n   \n   1. 查询的标签select必须设置属性resulttype或resultmap，用于设置实体类和数据库表的映射关系\n      * resulttype：自动映射，用于属性名和表中字段名一致的情况\n      * resultmap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况\n   2. 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常toomanyresultsexception；但是若查询的数据只有一条，可以使用实体类或集合作为返回值\n\n\n# mybatis获取参数值的两种方式（重点）\n\n * mybatis获取参数值的两种方式：${}和#{}（这种方法最推荐）\n * ${}的本质就是字符串拼接，#{}的本质就是占位符赋值\n * ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号\n\n\n# 单个字面量类型的参数\n\n * 若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意，使用和原参数相同的）获取参数的值，注意${}需要手动加单引号（\'$(see you!)\'）\n\n\x3c!--user getuserbyusername(string username);--\x3e\n<select id="getuserbyusername" resulttype="user">\n\tselect * from t_user where username = #{username}\n</select>\n\n\n\x3c!--user getuserbyusername(string username);--\x3e\n<select id="getuserbyusername" resulttype="user">  \n\tselect * from t_user where username = \'${username}\'  \n</select>\n\n\n\n# 多个字面量类型的参数\n\n * 若mapper接口中的方法参数为多个时，此时mybatis会自动将这些参数放在一个map集合中\n   \n   1. 以arg0,arg1...为键，以参数为值；\n   2. 以param1,param2...为键，以参数为值；\n\n * 因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。\n\n * 使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的\n\n * 这里可以混用，arg0和param1相等\n\n\x3c!--user checklogin(string username,string password);--\x3e\n<select id="checklogin" resulttype="user">  \n\tselect * from t_user where username = #{arg0} and password = #{arg1}  \n</select>\n\n\n\x3c!--user checklogin(string username,string password);--\x3e\n<select id="checklogin" resulttype="user">\n\tselect * from t_user where username = \'${param1}\' and password = \'${param2}\'\n</select> \x3c!--${}要注意单引号为对象进行研究--\x3e\n\n\n\n# map集合类型的参数（第二种情况的演变）\n\n * 若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号\n\n\x3c!--user checkloginbymap(map<string,object> map);--\x3e \n<select id="  checkloginbymap" resulttype="user">\n\tselect * from t_user where username = #{username} and password = #{password}\n</select>\n\n\n@test\npublic void checkloginbymap() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tparamet ermapper mapper = sqlsession.getmapper(parametermapper.class);\n\tmap<string,object> map = new hashmap<>();\n\tmap.put("usermane","admin");\n\tmap.put("password","123456");\n\tuser user = mapper.checkloginbymap(map);\n\tsystem.out.println(user);\n}\n\n\n\n# 实体类类型的参数\n\n * 若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号\n\n\x3c!--int insertuser(user user);--\x3e\n<insert id="insertuser">\n\tinsert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})\n</insert>\n\n\n@test\npublic void insertuser() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tparametermapper mapper = sqlsession.getmapper(parametermapper.class);\n\tuser user = new user(null,"tom","123456",12,"男","123@321.com");\n\tmapper.insertuser(user);\n}\n\n\n\n# 使用@param标识参数\n\n * 可以通过@param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中\n   \n   1. 以@param注解的value属性值为键，以参数为值；\n   2. 以param1,param2...为键，以参数为值；\n\n * 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号、\n\n这里需要强调一个点: @param("username")等价于@param(value = "username")\n\n\x3c!--user checkloginbyparam(@param("username") string username, @param("password") string password);--\x3e\n    <select id="checkloginbyparam" resulttype="user">\n        select * from t_user where username = #{username} and password = #{password}\n    </select>\n\n\n@test\npublic void checkloginbyparam() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tparametermapper mapper = sqlsession.getmapper(parametermapper.class);\n\tmapper.checkloginbyparam("admin","123456");\n}\n\n\n\n# 总结\n\n * 建议分成两种情况进行处理\n   \n   1. 实体类类型的参数\n   2. 使用@param标识参数',charsets:{cjk:!0}},{title:"开发",frontmatter:{title:"开发",date:"2022-03-26T00:00:00.000Z",permalink:"/springboot/003/",categories:["框架","SpringBoot"],tags:["SpringBoot"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/03.SpringBoot/03.%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87.html",relativePath:"07.框架/03.SpringBoot/03.开发实用篇.md",key:"v-55ea32ac",path:"/springboot/003/",headers:[{level:2,title:"KF-1.热部署",slug:"kf-1-热部署",normalizedTitle:"kf-1.热部署",charIndex:469},{level:3,title:"KF-1-1.手动启动热部署",slug:"kf-1-1-手动启动热部署",normalizedTitle:"kf-1-1.手动启动热部署",charIndex:1754},{level:3,title:"KF-1-2.自动启动热部署",slug:"kf-1-2-自动启动热部署",normalizedTitle:"kf-1-2.自动启动热部署",charIndex:2738},{level:3,title:"KF-1-3.参与热部署监控的文件范围配置",slug:"kf-1-3-参与热部署监控的文件范围配置",normalizedTitle:"kf-1-3.参与热部署监控的文件范围配置",charIndex:3402},{level:3,title:"KF-1-4.关闭热部署",slug:"kf-1-4-关闭热部署",normalizedTitle:"kf-1-4.关闭热部署",charIndex:3902},{level:2,title:"KF-2.配置高级",slug:"kf-2-配置高级",normalizedTitle:"kf-2.配置高级",charIndex:4473},{level:3,title:"KF-2-1.@ConfigurationProperties",slug:"kf-2-1-configurationproperties",normalizedTitle:"kf-2-1.@configurationproperties",charIndex:4589},{level:3,title:"KF-2-2.宽松绑定/松散绑定",slug:"kf-2-2-宽松绑定-松散绑定",normalizedTitle:"kf-2-2.宽松绑定/松散绑定",charIndex:7279},{level:3,title:"KF-2-3.常用计量单位绑定",slug:"kf-2-3-常用计量单位绑定",normalizedTitle:"kf-2-3.常用计量单位绑定",charIndex:9675},{level:3,title:"KF-2-4.校验",slug:"kf-2-4-校验",normalizedTitle:"kf-2-4.校验",charIndex:10571},{level:3,title:"KF-2-5.数据类型转换",slug:"kf-2-5-数据类型转换",normalizedTitle:"kf-2-5.数据类型转换",charIndex:11742},{level:2,title:"KF-3.测试",slug:"kf-3-测试",normalizedTitle:"kf-3.测试",charIndex:12724},{level:3,title:"KF-3-1.加载测试专用属性",slug:"kf-3-1-加载测试专用属性",normalizedTitle:"kf-3-1.加载测试专用属性",charIndex:12897},{level:3,title:"KF-3-2.加载测试专用配置",slug:"kf-3-2-加载测试专用配置",normalizedTitle:"kf-3-2.加载测试专用配置",charIndex:14591},{level:3,title:"KF-3-3.Web环境模拟测试",slug:"kf-3-3-web环境模拟测试",normalizedTitle:"kf-3-3.web环境模拟测试",charIndex:15601},{level:3,title:"KF-3-4.数据层测试回滚",slug:"kf-3-4-数据层测试回滚",normalizedTitle:"kf-3-4.数据层测试回滚",charIndex:20858},{level:3,title:"KF-3-5.测试用例数据设定",slug:"kf-3-5-测试用例数据设定",normalizedTitle:"kf-3-5.测试用例数据设定",charIndex:22023},{level:2,title:"KF-4.数据层解决方案",slug:"kf-4-数据层解决方案",normalizedTitle:"kf-4.数据层解决方案",charIndex:22909},{level:3,title:"KF-4-1.SQL",slug:"kf-4-1-sql",normalizedTitle:"kf-4-1.sql",charIndex:23173},{level:4,title:"数据源技术",slug:"数据源技术",normalizedTitle:"数据源技术",charIndex:23322},{level:4,title:"持久化技术",slug:"持久化技术",normalizedTitle:"持久化技术",charIndex:23337},{level:4,title:"数据库技术",slug:"数据库技术",normalizedTitle:"数据库技术",charIndex:23358},{level:3,title:"KF-4-2.NoSQL",slug:"kf-4-2-nosql",normalizedTitle:"kf-4-2.nosql",charIndex:29580},{level:4,title:"SpringBoot整合Redis",slug:"springboot整合redis",normalizedTitle:"springboot整合redis",charIndex:30071},{level:5,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:716},{level:5,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:30418},{level:5,title:"整合",slug:"整合",normalizedTitle:"整合",charIndex:190},{level:4,title:"SpringBoot整合MongoDB",slug:"springboot整合mongodb",normalizedTitle:"springboot整合mongodb",charIndex:34746},{level:5,title:"安装",slug:"安装-2",normalizedTitle:"安装",charIndex:716},{level:5,title:"基本操作",slug:"基本操作-2",normalizedTitle:"基本操作",charIndex:30418},{level:5,title:"整合",slug:"整合-2",normalizedTitle:"整合",charIndex:190},{level:4,title:"SpringBoot整合ES",slug:"springboot整合es",normalizedTitle:"springboot整合es",charIndex:38814},{level:5,title:"安装",slug:"安装-3",normalizedTitle:"安装",charIndex:716},{level:5,title:"基本操作",slug:"基本操作-3",normalizedTitle:"基本操作",charIndex:30418},{level:5,title:"整合",slug:"整合-3",normalizedTitle:"整合",charIndex:190},{level:2,title:"KF-5.整合第三方技术",slug:"kf-5-整合第三方技术",normalizedTitle:"kf-5.整合第三方技术",charIndex:55820},{level:3,title:"KF-5-1.缓存",slug:"kf-5-1-缓存",normalizedTitle:"kf-5-1.缓存",charIndex:56048},{level:4,title:"SpringBoot内置缓存解决方案",slug:"springboot内置缓存解决方案",normalizedTitle:"springboot内置缓存解决方案",charIndex:56467},{level:4,title:"手机验证码案例",slug:"手机验证码案例",normalizedTitle:"手机验证码案例",charIndex:57507},{level:4,title:"SpringBoot常用缓存技术",slug:"springboot常用缓存技术",normalizedTitle:"springboot常用缓存技术",charIndex:60436},{level:4,title:"SpringBoot整合Ehcache缓存",slug:"springboot整合ehcache缓存",normalizedTitle:"springboot整合ehcache缓存",charIndex:60469},{level:4,title:"SpringBoot整合Redis缓存",slug:"springboot整合redis缓存",normalizedTitle:"springboot整合redis缓存",charIndex:62810},{level:4,title:"SpringBoot整合Memcached缓存",slug:"springboot整合memcached缓存",normalizedTitle:"springboot整合memcached缓存",charIndex:63745},{level:4,title:"SpringBoot整合jetcache缓存",slug:"springboot整合jetcache缓存",normalizedTitle:"springboot整合jetcache缓存",charIndex:67592},{level:5,title:"纯远程方案",slug:"纯远程方案",normalizedTitle:"纯远程方案",charIndex:68288},{level:5,title:"纯本地方案",slug:"纯本地方案",normalizedTitle:"纯本地方案",charIndex:70786},{level:5,title:"本地+远程方案",slug:"本地-远程方案",normalizedTitle:"本地+远程方案",charIndex:72218},{level:5,title:"远程方案的数据同步",slug:"远程方案的数据同步",normalizedTitle:"远程方案的数据同步",charIndex:75622},{level:5,title:"数据报表",slug:"数据报表",normalizedTitle:"数据报表",charIndex:76181},{level:4,title:"SpringBoot整合j2cache缓存",slug:"springboot整合j2cache缓存",normalizedTitle:"springboot整合j2cache缓存",charIndex:77109},{level:3,title:"KF-5-2.任务",slug:"kf-5-2-任务",normalizedTitle:"kf-5-2.任务",charIndex:85690},{level:4,title:"Quartz",slug:"quartz",normalizedTitle:"quartz",charIndex:85877},{level:4,title:"Task",slug:"task",normalizedTitle:"task",charIndex:87797},{level:3,title:"KF-5-3.邮件",slug:"kf-5-3-邮件",normalizedTitle:"kf-5-3.邮件",charIndex:88937},{level:4,title:"发送简单邮件",slug:"发送简单邮件",normalizedTitle:"发送简单邮件",charIndex:89681},{level:4,title:"发送多组件邮件（附件、复杂正文）",slug:"发送多组件邮件-附件、复杂正文",normalizedTitle:"发送多组件邮件（附件、复杂正文）",charIndex:90954},{level:3,title:"KF-5-4.消息",slug:"kf-5-4-消息",normalizedTitle:"kf-5-4.消息",charIndex:93098},{level:4,title:"消息的概念",slug:"消息的概念",normalizedTitle:"消息的概念",charIndex:93159},{level:4,title:"Java处理消息的标准规范(也就是在处理消息队列)",slug:"java处理消息的标准规范-也就是在处理消息队列",normalizedTitle:"java处理消息的标准规范(也就是在处理消息队列)",charIndex:94400},{level:5,title:"JMS",slug:"jms",normalizedTitle:"jms",charIndex:94461},{level:5,title:"AMQP",slug:"amqp",normalizedTitle:"amqp",charIndex:94468},{level:5,title:"MQTT",slug:"mqtt",normalizedTitle:"mqtt",charIndex:94476},{level:5,title:"KafKa",slug:"kafka",normalizedTitle:"kafka",charIndex:96518},{level:4,title:"购物订单发送手机短信案例",slug:"购物订单发送手机短信案例",normalizedTitle:"购物订单发送手机短信案例",charIndex:96765},{level:4,title:"SpringBoot整合ActiveMQ",slug:"springboot整合activemq",normalizedTitle:"springboot整合activemq",charIndex:98853},{level:5,title:"安装",slug:"安装-4",normalizedTitle:"安装",charIndex:716},{level:5,title:"整合",slug:"整合-4",normalizedTitle:"整合",charIndex:190},{level:4,title:"SpringBoot整合RabbitMQ",slug:"springboot整合rabbitmq",normalizedTitle:"springboot整合rabbitmq",charIndex:123101},{level:5,title:"安装",slug:"安装-5",normalizedTitle:"安装",charIndex:716},{level:5,title:"整合(direct模型)",slug:"整合-direct模型",normalizedTitle:"整合(direct模型)",charIndex:124284},{level:5,title:"整合(topic模型)",slug:"整合-topic模型",normalizedTitle:"整合(topic模型)",charIndex:126239},{level:4,title:"SpringBoot整合RocketMQ",slug:"springboot整合rocketmq",normalizedTitle:"springboot整合rocketmq",charIndex:128474},{level:5,title:"安装",slug:"安装-6",normalizedTitle:"安装",charIndex:716},{level:5,title:"整合（异步消息）",slug:"整合-异步消息",normalizedTitle:"整合（异步消息）",charIndex:129474},{level:4,title:"SpringBoot整合Kafka",slug:"springboot整合kafka",normalizedTitle:"springboot整合kafka",charIndex:131170},{level:5,title:"安装",slug:"安装-7",normalizedTitle:"安装",charIndex:716},{level:5,title:"整合",slug:"整合-5",normalizedTitle:"整合",charIndex:190},{level:2,title:"KF-6.监控",slug:"kf-6-监控",normalizedTitle:"kf-6.监控",charIndex:133565},{level:3,title:"KF-6-1.监控的意义",slug:"kf-6-1-监控的意义",normalizedTitle:"kf-6-1.监控的意义",charIndex:134130},{level:3,title:"KF-6-2.可视化监控平台",slug:"kf-6-2-可视化监控平台",normalizedTitle:"kf-6-2.可视化监控平台",charIndex:135755},{level:3,title:"KF-6-3.监控原理",slug:"kf-6-3-监控原理",normalizedTitle:"kf-6-3.监控原理",charIndex:138887},{level:3,title:"KF-6-4.自定义监控指标",slug:"kf-6-4-自定义监控指标",normalizedTitle:"kf-6-4.自定义监控指标",charIndex:145929},{level:2,title:"开发实用篇完结",slug:"开发实用篇完结",normalizedTitle:"开发实用篇完结",charIndex:148653}],headersStr:"KF-1.热部署 KF-1-1.手动启动热部署 KF-1-2.自动启动热部署 KF-1-3.参与热部署监控的文件范围配置 KF-1-4.关闭热部署 KF-2.配置高级 KF-2-1.@ConfigurationProperties KF-2-2.宽松绑定/松散绑定 KF-2-3.常用计量单位绑定 KF-2-4.校验 KF-2-5.数据类型转换 KF-3.测试 KF-3-1.加载测试专用属性 KF-3-2.加载测试专用配置 KF-3-3.Web环境模拟测试 KF-3-4.数据层测试回滚 KF-3-5.测试用例数据设定 KF-4.数据层解决方案 KF-4-1.SQL 数据源技术 持久化技术 数据库技术 KF-4-2.NoSQL SpringBoot整合Redis 安装 基本操作 整合 SpringBoot整合MongoDB 安装 基本操作 整合 SpringBoot整合ES 安装 基本操作 整合 KF-5.整合第三方技术 KF-5-1.缓存 SpringBoot内置缓存解决方案 手机验证码案例 SpringBoot常用缓存技术 SpringBoot整合Ehcache缓存 SpringBoot整合Redis缓存 SpringBoot整合Memcached缓存 SpringBoot整合jetcache缓存 纯远程方案 纯本地方案 本地+远程方案 远程方案的数据同步 数据报表 SpringBoot整合j2cache缓存 KF-5-2.任务 Quartz Task KF-5-3.邮件 发送简单邮件 发送多组件邮件（附件、复杂正文） KF-5-4.消息 消息的概念 Java处理消息的标准规范(也就是在处理消息队列) JMS AMQP MQTT KafKa 购物订单发送手机短信案例 SpringBoot整合ActiveMQ 安装 整合 SpringBoot整合RabbitMQ 安装 整合(direct模型) 整合(topic模型) SpringBoot整合RocketMQ 安装 整合（异步消息） SpringBoot整合Kafka 安装 整合 KF-6.监控 KF-6-1.监控的意义 KF-6-2.可视化监控平台 KF-6-3.监控原理 KF-6-4.自定义监控指标 开发实用篇完结",content:'# SpringBoot开发实用篇\n\n怀着忐忑的心情，开始了开发实用篇文档的编写。为什么忐忑？特喵的债欠的太多，不知道从何写起。哎，不煽情了，开工。\n\n运维实用篇完结以后，开发实用篇采用日更新的形式发布给各位小伙伴，基本上是每天一集，目前已经发布完毕。看评论区，好多小伙伴在求文档，所以赶紧来补文档，加班加点把开发实用篇的文档刨出来。\n\n开发实用篇中因为牵扯到SpringBoot整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：\n\n * 热部署\n * 配置高级\n * 测试\n * 数据层解决方案\n * 整合第三方技术\n * 监控\n\n看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习\n\n\n# KF-1.热部署\n\n什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。\n\n热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。\n\n非springboot项目热部署实现原理\n\n开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。\n\n上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串"abc"改成"cba"，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。\n\n看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。\n\nspringboot项目热部署实现原理\n\n基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。\n\n下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。\n\n\n# KF-1-1.手动启动热部署\n\n步骤①：导入开发者工具对应的坐标\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional>\n</dependency>\n\n\n步骤②：构建项目，可以使用快捷键激活此功能\n\n\n\n对应的快捷键一定要记得\n\n<CTRL>+<F9>\n\n\n以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。\n\n重启与重载\n\n一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。\n\n * base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化\n * restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响\n\n当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。\n\n总结\n\n 1. 使用开发者工具可以为当前项目开启热部署功能\n 2. 使用构建项目操作对工程进行热部署\n\n思考\n\n上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就OK了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。\n\n\n\n\n# KF-1-2.自动启动热部署\n\n自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署\n\n步骤①：设置自动构建项目\n\n打开【File】，选择【settings...】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目\n\n\n\n自动构建项目选项勾选后\n\n步骤②：允许在程序运行时进行自动构建\n\n使用快捷键【Ctrl】+【Alt】+【Shit】+【/】打开维护面板，选择第1项【Registry...】\n\n\n\n在选项中搜索comple，然后勾选对应项即可\n\n这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。\n\n关注：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点(鼠标离开)5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。\n\n总结\n\n 1. 自动热部署要开启自动构建项目\n 2. 自动热部署要开启在程序运行时自动构建项目\n\n思考\n\n现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？咱们下一节再说。\n\n\n# KF-1-3.参与热部署监控的文件范围配置\n\n通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下\n\n * /META-INF/maven\n * /META-INF/resources\n * /resources\n * /static\n * /public\n * /templates\n\n以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作\n\nspring:\n  devtools:\n    restart:\n      # 设置不参与热部署的文件或文件夹\n      exclude: static/**,public/**,config/application.yml\n\n\n总结\n\n 1. 通过配置可以修改不参与热部署的文件或目录\n\n思考\n\n热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。\n\n\n# KF-1-4.关闭热部署\n\n线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。\n\nspring:\n  devtools:\n    restart:\n      enabled: false\n\n\n如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。\n\n@SpringBootApplication\npublic class SSMPApplication {\n    public static void main(String[] args) {\n        System.setProperty("spring.devtools.restart.enabled","false");\n        SpringApplication.run(SSMPApplication.class);\n    }\n}\n\n\n其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。\n\n总结\n\n 1. 通过配置可以关闭热部署功能降低线上程序的资源消耗\n\n\n# KF-2.配置高级\n\n进入开发实用篇第二章内容，配置高级，其实配置在基础篇讲了一部分，在运维实用篇讲了一部分，这里还要讲，讲的东西有什么区别呢？距离开发过程越来越接近，解决的问题也越来越靠近线上环境，下面就开启本章的学习。\n\n\n# KF-2-1.@ConfigurationProperties\n\n在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性\n\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n\n\n然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法\n\n@Component\n@Data\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n\n\n使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上\n\n@Component\n@Data\n@ConfigurationProperties(prefix = "servers")\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n\n\n这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。\n\n使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。\n\n步骤①：使用@Bean注解定义第三方bean\n\n@Bean\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n\n\n步骤②：在yml中定义要绑定的属性，注意datasource此时全小写\n\ndriverClassName用于指定driverClassName属性\n\ndatasource:\n  driverClassName: com.mysql.jdbc.Driver\n\n\n步骤③：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource\n\n@Bean\n@ConfigurationProperties(prefix = "datasource")\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n\n\n操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。\n\n做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？\n\n步骤①：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类\n\n@SpringBootApplication\n@EnableConfigurationProperties(ServerConfig.class)\npublic class Springboot13ConfigurationApplication {\n}\n\n\n步骤②：在对应的类上直接使用@ConfigurationProperties进行属性绑定\n\n@Data\n@ConfigurationProperties(prefix = "servers")\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n\n\n有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了。\n\n最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息\n\n\n\n出现这个提示后只需要添加一个坐标此提醒就消失了\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n</dependency>\n\n\n总结\n\n 1. 使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性\n 2. 当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明\n\n\n# KF-2-2.宽松绑定/松散绑定\n\n在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：\n\ndataSource:\n  driverClassName: com.mysql.jdbc.Driver\n\n\n此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：\n\n@Bean\n@ConfigurationProperties(prefix = "dataSource")\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n\n\n此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的\n\nConfiguration property name \'dataSource\' is not valid:\n\n    Invalid characters: \'S\'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case (\'-\' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify \'dataSource\' so that it conforms to the canonical names requirements.\n\n\n为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。\n\n什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：\n\n在ServerConfig中的ipAddress属性名\n\n@Component\n@Data\n@ConfigurationProperties(prefix = "servers")\npublic class ServerConfig {\n    private String ipAddress;\n}\n\n\n可以与下面的配置属性名规则全兼容\n\nservers:\n  ipAddress: 192.168.0.2       # 驼峰模式\n  ip_address: 192.168.0.2      # 下划线模式\n  ip-address: 192.168.0.2      # 烤肉串模式\n  IP_ADDRESS: 192.168.0.2      # 常量模式\n\n\n也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。\n\n到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息\n\nConfiguration property name \'dataSource\' is not valid:\n\n    Invalid characters: \'S\'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case (\'-\' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify \'dataSource\' so that it conforms to the canonical names requirements.\n\n\n其中Reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头（绑定前缀名命名规范：仅能使用纯小写字幕、数字、下划线作为合法字符，和属性名绑定不一样，还是为了避免错误干脆全部小写吧）。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。\n\n最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效 。有人就说，那我不用你不就行了？不用，你小看springboot的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。\n\n总结\n\n 1. @ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上\n 2. @Value注解不支持松散绑定规则\n 3. 绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符\n\n\n# KF-2-3.常用计量单位绑定\n\n在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。\n\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n\n\n但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？\n\n除了加强约定之外，springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize\n\n@Component\n@Data\n@ConfigurationProperties(prefix = "servers")\npublic class ServerConfig {\n    @DurationUnit(ChronoUnit.HOURS)\n    private Duration serverTimeOut;\n    @DataSizeUnit(DataUnit.MEGABYTES)\n    private DataSize dataSize;\n}\n\n\n\nDuration：表示时间间隔，可以通过**@DurationUnit**注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）\n\nDataSize：表示存储空间，可以通过**@DataSizeUnit**注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）\n\n使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。\n\nDruation常用单位如下：\n\nDataSize常用单位如下：\n\n\n# KF-2-4.校验\n\n目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a"，这种数据肯定无法有效的绑定，还会引发错误。 SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤\n\n步骤①：开启校验框架\n\n\x3c!--1.导入JSR303规范，这个是接口规范--\x3e\n<dependency>\n    <groupId>javax.validation</groupId>\n    <artifactId>validation-api</artifactId>\n</dependency>\n\x3c!--使用hibernate框架提供的校验器做实现，这一部分实现上面的接口--\x3e\n<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n</dependency>\n\n\n步骤②：在需要开启校验功能的类上使用注解@Validated开启校验功能\n\n@Component\n@Data\n@ConfigurationProperties(prefix = "servers")\n//开启对当前bean的属性注入校验\n@Validated\npublic class ServerConfig {\n}\n\n\n步骤③：对具体的字段设置校验规则\n\n@Component\n@Data\n@ConfigurationProperties(prefix = "servers")\n@Validated  //开启对当前bean的属性注入校验\npublic class ServerConfig {\n    //设置具体的规则\n    @Max(value = 8888,message = "最大值不能超过8888")\n    @Min(value = 202,message = "最小值不能低于202")\n    private int port;\n}\n\n\n通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。\n\n总结\n\n 1. 开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式\n\n\n# KF-2-5.数据类型转换\n\n有关spring属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于bean的属性注入引发的灾难。\n\n先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。\n\njava.sql.SQLException: Access denied for user \'root\'@\'localhost\' (using password: YES)\n\n\n其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    username: root\n    password: 0127\n\n\n这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。\n\n之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，支持二进制，八进制，十六进制\n\n这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。\n\n这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。\n\n总结\n\n 1. yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注\n\n\n# KF-3.测试\n\n说完bean配置相关的内容，下面要对前面讲过的一个知识做加强了，测试。测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。\n\n\n# KF-3-1.加载测试专用属性\n\n测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置\n\nenv:\n  maxMemory: 32GB\n  minMemory: 16GB\n\n\n但是你现在想测试对应的兼容性，需要测试如下配置\n\nenv:\n  maxMemory: 16GB\n  minMemory: 8GB\n\n\n这个时候我们能不能每次测试的时候都去修改源码application.yml中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。\n\n临时属性\n\nspringboot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@SpringBootTest添加属性来模拟临时属性，具体如下：\n\n//properties属性可以为当前测试用例添加临时的属性配置\n@SpringBootTest(properties = {"test.prop=testValue1"})\npublic class PropertiesAndArgsTest {\n\n    @Value("${test.prop}")\n    private String msg;\n    \n    @Test\n    void testProperties(){\n        System.out.println(msg);\n    }\n}\n\n\n使用注解@SpringBootTest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。\n\n临时参数\n\n除了上述这种情况，在前面讲解使用命令行启动springboot程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解@SpringBootTest的另一个属性来进行设定。\n\n//args属性可以为当前测试用例添加临时的命令行参数\n@SpringBootTest(args={"--test.prop=testValue2"})\npublic class PropertiesAndArgsTest {\n    \n    @Value("${test.prop}")\n    private String msg;\n    \n    @Test\n    void testProperties(){\n        System.out.println(msg);\n    }\n}\n\n\n使用注解@SpringBootTest的args属性就可以为当前测试用例模拟命令行参数并进行测试。\n\n说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？\n\n在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是11，而配置属性的优先级是3，结果不言而喻了，args属性配置优先于properties属性配置加载。\n\n到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。\n\n总结\n\n 1. 加载测试临时属性可以通过注解@SpringBootTest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例\n\n思考\n\n应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些bean能不做呢？也就是说我测试时，想搞一些独立的bean出来，专门应用于测试环境，能否实现呢？咱们下一节再讲。\n\n\n# KF-3-2.加载测试专用配置\n\n上一节提出了临时配置一些专用于测试环境的bean的需求，这一节我们就来解决这个问题。\n\n学习过Spring的知识，我们都知道，其实一个spring环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：\n\n步骤①：在测试包test中创建专用的测试环境配置类\n\n@Configuration\npublic class MsgConfig {\n    @Bean\n    public String msg(){\n        return "bean msg";\n    }\n}\n\n\n上述配置仅用于演示当前实验效果，实际开发可不能这么注入String类型的数据\n\n步骤②：在启动测试环境时，导入测试环境专用的配置类，使用@Import注解即可实现\n\n@SpringBootTest\n@Import({MsgConfig.class})\npublic class ConfigurationTest {\n\n    @Autowired\n    private String msg;\n\n    @Test\n    void testConfiguration(){\n        System.out.println(msg);\n    }\n}\n\n\n到这里就通过@Import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了1+1的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。\n\n总结\n\n 1. 定义测试环境专用的配置类，然后通过@Import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境\n\n思考\n\n当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过postman手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？还真可以，咱们下一节再讲。\n\n\n# KF-3-3.Web环境模拟测试\n\n在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动web环境，不然没法测试web功能。一个功能是必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动web测试，二，如何在测试类中发送web请求。下面一件事一件事进行，先说第一个\n\n测试类中启动web环境\n\n每一个springboot的测试类上方都会标准@SpringBootTest注解，而注解带有一个属性，叫做webEnvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class WebTest {\t\n}\n\n\n测试类中启动web环境时，可以指定启动的Web环境对应的端口，springboot提供了4种设置值，分别如下：\n\n * MOCK：根据当前设置确认是否启动web环境，例如使用了Servlet的API就启动web环境，属于适配性的配置\n * DEFINED_PORT：使用自定义的端口作为web服务器端口\n * RANDOM_PORT：使用随机端口作为web服务器端口\n * NONE：不启动web环境\n\n通过上述配置，现在启动测试程序时就可以正常启用web环境了，建议大家测试时使用RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用8080端口，结果线上环境8080端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。\n\n测试环境中的web环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送web请求。\n\n测试类中发送请求\n\n对于测试类中发送请求，其实java的API就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：\n\n步骤①：在测试类中开启web虚拟调用功能，通过注解@AutoConfigureMockMvc实现此功能的开启\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest {\n}\n\n\n步骤②：定义发起虚拟调用的对象MockMVC，通过自动装配的形式初始化对象\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest {\n\n    @Test\n    void testWeb(@Autowired MockMvc mvc) {\n    }\n}\n\n\n步骤③：创建一个虚拟请求对象，封装请求的路径，并使用MockMVC对象发送对应请求\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest {\n\n    @Test\n    void testWeb(@Autowired MockMvc mvc) throws Exception {\n        //http://localhost:8080/books\n        //模拟创建虚拟请求，当前访问/books\n        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");\n        //执行对应的请求\n        mvc.perform(builder);\n    }\n}\n\n\n执行测试程序，现在就可以正常的发送/books对应的请求了，注意访问路径不要写http://localhost:8080/books，因为前面的服务器IP地址和端口使用的是当前虚拟的web环境，无需指定，仅指定请求的具体路径即可。\n\n总结\n\n 1. 在测试类中测试web层接口要保障测试类启动时启动web容器，使用@SpringBootTest注解的webEnvironment属性可以虚拟web环境用于测试\n 2. 为测试方法注入MockMvc对象，通过MockMvc对象可以发送虚拟请求，模拟web请求调用过程\n\n思考\n\n目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？咱们下一节再讲。\n\nweb环境请求结果比对\n\n上一节已经在测试用例中成功的模拟出了web环境，并成功的发送了web请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：\n\n * 响应状态匹配\n   \n   @Test\n   void testStatus(@Autowired MockMvc mvc) throws Exception {\n       MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");\n       ResultActions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       StatusResultMatchers status = MockMvcResultMatchers.status();\n       //预计本次调用时成功的：状态200\n       ResultMatcher ok = status.isOk();\n       //添加预计值到本次调用过程中进行匹配\n       action.andExpect(ok);\n   }\n   \n\n * 响应体匹配（非json数据格式）\n   \n   @Test\n   void testBody(@Autowired MockMvc mvc) throws Exception {\n       MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");\n       ResultActions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       ContentResultMatchers content = MockMvcResultMatchers.content\n       // 取出的状态值变为字符串\n       ResultMatcher result = content.string("springboot2");\n       //添加预计值到本次调用过程中进行匹配\n       action.andExpect(result);\n   }\n   \n\n * 响应体匹配（json数据格式，开发中的主流使用方式）\n   \n   @Test\n   void testJson(@Autowired MockMvc mvc) throws Exception {\n       MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");\n       ResultActions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       ContentResultMatchers content = MockMvcResultMatchers.content();\n       ResultMatcher result = content.json("{\\"id\\":1,\\"name\\":\\"springboot2\\",\\"type\\":\\"springboot\\"}");\n       //添加预计值到本次调用过程中进行匹配\n       action.andExpect(result);\n   }\n   \n\n * 响应头信息匹配\n   \n   @Test\n   void testContentType(@Autowired MockMvc mvc) throws Exception {\n       MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");\n       ResultActions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       HeaderResultMatchers header = MockMvcResultMatchers.header();\n       ResultMatcher contentType = header.string("Content-Type", "application/json");\n       //添加预计值到本次调用过程中进行匹配\n       action.andExpect(contentType);\n   }\n   \n\n基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。\n\n@Test\nvoid testGetById(@Autowired MockMvc mvc) throws Exception {\n    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");\n    ResultActions action = mvc.perform(builder);\n\n    StatusResultMatchers status = MockMvcResultMatchers.status();\n    ResultMatcher ok = status.isOk();\n    action.andExpect(ok);\n\n    HeaderResultMatchers header = MockMvcResultMatchers.header();\n    ResultMatcher contentType = header.string("Content-Type", "application/json");\n    action.andExpect(contentType);\n\n    ContentResultMatchers content = MockMvcResultMatchers.content();\n    ResultMatcher result = content.json("{\\"id\\":1,\\"name\\":\\"springboot\\",\\"type\\":\\"springboot\\"}");\n    action.andExpect(result);\n}\n\n\n总结\n\n 1. web虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对\n\n\n# KF-3-4.数据层测试回滚\n\n当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？\n\nspringboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解@Transactional即可实现当前测试用例的事务不提交。当程序运行后，只要注解@Transactional出现的位置存在注解@SpringBootTest，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。\n\n@SpringBootTest\n@Transactional\n@Rollback(true)\npublic class DaoTest {\n    @Autowired\n    private BookService bookService;\n\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setName("springboot3");\n        book.setType("springboot3");\n        book.setDescription("springboot3");\n\n        bookService.save(book);\n    }\n}\n\n\n如果开发者想提交事务，也可以，再添加一个@RollBack的注解，设置回滚状态为false即可正常提交事务（FALSE表示不能回滚），是不是很方便？springboot在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。\n\n总结\n\n 1. 在springboot的测试类中通过添加注解@Transactional来阻止测试用例提交事务\n 2. 通过注解@Rollback控制springboot测试类执行结果是否提交事务，需要配合注解@Transactional使用\n\n思考\n\n当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？咱们下一节再讲。\n\n\n# KF-3-5.测试用例数据设定\n\n对于测试用例的数据固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：\n\ntestcase:\n  book:\n    id: ${random.int}\n    id2: ${random.int(10)}\n    type: ${random.int!5,10!}\n    name: ${random.value}\n    uuid: ${random.uuid}\n    publishTime: ${random.long}\n\n\n当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@ConfigurationProperties注解即可\n\n@Component\n@Data\n@ConfigurationProperties(prefix = "testcase.book")\npublic class BookCase {\n    private int id;\n    private int id2;\n    private int type;\n    private String name;\n    private String uuid;\n    private long publishTime;\n}\n\n\n对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：\n\n * ${random.int}表示随机整数\n * ${random.int(10)}表示10以内的随机数\n * ${random.int(10,20)}表示10到20的随机数\n * 其中()可以是任意字符，例如[]，!!均可，也就是random.int!5,10!等价于random.int(5,10)等价于random.int[5,10]\n\n总结\n\n 1. 使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性\n\n\n# KF-4.数据层解决方案\n\n开发实用篇前三章基本上是开胃菜，从第四章开始，开发实用篇进入到了噩梦难度了，从这里开始，不再是单纯的在springboot内部搞事情了，要涉及到很多相关知识。本章节主要内容都是和数据存储与读取相关，前期学习的知识与数据层有关的技术基本上都围绕在数据库这个层面上，所以本章要讲的第一个大的分支就是SQL解决方案相关的内容，除此之外，数据的来源还可以是非SQL技术相关的数据操作，因此第二部分围绕着NOSQL解决方案讲解。至于什么是NOSQL解决方案，讲到了再说吧。下面就从SQL解决方案说起。\n\n\n# KF-4-1.SQL\n\n回忆一下之前做SSMP整合的时候数据层解决方案涉及到了哪些技术？MySQL数据库与MyBatisPlus框架，后面又学了Druid数据源的配置，所以现在数据层解决方案可以说是Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：\n\n * 数据源技术：Druid\n * 持久化技术：MyBatisPlus\n * 数据库技术：MySQL\n\n下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。\n\n# 数据源技术\n\n目前我们使用的数据源技术是Druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：\n\nINFO 28600 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource\nINFO 28600 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited\n\n\n如果不使用Druid数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将Druid技术对应的starter去掉再次运行程序可以在日志中找到如下初始化信息：\n\nINFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\nINFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n\n\n\n\n虽然没有DruidDataSource相关的信息了，但是我们发现日志中有HikariDataSource这个信息，就算不懂这是个什么技术，看名字也能看出来，以DataSource结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot内嵌数据源。\n\n数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。\n\nspringboot提供了3款内嵌数据源技术，分别如下：\n\n * HikariCP\n * Tomcat提供DataSource\n * Commons DBCP\n\n第一种，HikartCP，这是springboot官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。\n\n第二种，Tomcat提供的DataSource，如果不想用HikartCP，并且使用tomcat作为web服务器进行web程序的开发，使用这个。为什么是Tomcat，不是其他web服务器呢？因为web技术导入starter后，默认使用内嵌tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用HikartCP用tomcat提供的默认数据源对象呢？把HikartCP技术的坐标排除掉就OK了。\n\n第三种，DBCP，这个使用的条件就更苛刻了，既不使用HikartCP也不使用tomcat的DataSource时，默认给你用这个。\n\nspringboot这心操的，也是稀碎啊，就怕你自己管不好连接对象，给你一顿推荐，真是开发界的最强辅助。既然都给你奶上了，那就受用吧，怎么配置使用这些东西呢？之前我们配置druid时使用druid的starter对应的配置如下：\n\nspring:\n  datasource:\n    druid:\t\n   \t  url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n\n\n换成是默认的数据源HikariCP后，直接吧druid删掉就行了，如下：\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: root\n    password: root\n\n\n当然，也可以写上是对hikari做的配置，但是url地址要单独配置，不能放到hikari的配置项下面，如下：\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n\n\n这就是配置hikari数据源的方式。如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n      maximum-pool-size: 50\n\n\n如果不想使用hikari数据源，使用tomcat的数据源或者DBCP配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。\n\n\n\n总结\n\n 1. springboot技术提供了3种内置的数据源技术，分别是Hikari、tomcat内置数据源、DBCP\n\n# 持久化技术\n\n说完数据源解决方案，再来说一下持久化解决方案。springboot充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做JdbcTemplate。其实这个技术不能说是springboot提供的，因为不使用springboot技术，一样能使用它，谁提供的呢？spring技术提供的，所以在springboot技术范畴中，这个技术也是存在的，毕竟springboot技术是加速spring程序开发而创建的。\n\n这个技术其实就是回归到jdbc最原始的编程形式来进行数据层的开发，下面直接上操作步骤：\n\n步骤①：导入jdbc对应的坐标，记得是starter\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency\n\n\n步骤②：自动装配JdbcTemplate对象\n\n@SpringBootTest\nclass Springboot15SqlApplicationTests {\n    @Test\n    void testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n    }\n}\n\n\n步骤③：使用JdbcTemplate实现查询操作（非实体类封装数据的查询操作）\n\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n    String sql = "select * from tbl_book";\n    List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);\n    System.out.println(maps);\n}\n\n\n步骤④：使用JdbcTemplate实现查询操作（实体类封装数据的查询操作）记得复习一下query操作\n\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n\n    String sql = "select * from tbl_book";\n    RowMapper<Book> rm = new RowMapper<Book>() {\n        @Override\n        public Book mapRow(ResultSet rs, int rowNum) throws SQLException {\n            Book temp = new Book();\n            temp.setId(rs.getInt("id"));\n            temp.setName(rs.getString("name"));\n            temp.setType(rs.getString("type"));\n            temp.setDescription(rs.getString("description"));\n            return temp;\n        }\n    };\n    List<Book> list = jdbcTemplate.query(sql, rm);\n    System.out.println(list);\n}\n\n\n步骤⑤：使用JdbcTemplate实现增删改操作\n\n@Test\nvoid testJdbcTemplateSave(@Autowired JdbcTemplate jdbcTemplate){\n    String sql = "insert into tbl_book values(3,\'springboot1\',\'springboot2\',\'springboot3\')";\n    jdbcTemplate.update(sql);\n}\n\n\n如果想对JdbcTemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：\n\nspring:\n  jdbc:\n    template:\n      query-timeout: -1   # 查询超时时间\n      max-rows: 500       # 最大行数\n      fetch-size: -1      # 缓存行数\n\n\n总结\n\n 1. SpringBoot内置JdbcTemplate持久化解决方案\n\n 2. 使用JdbcTemplate需要导入spring-boot-starter-jdbc的坐标\n    \n    \n\n# 数据库技术\n\n截止到目前，springboot给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非springboot也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。\n\nspringboot提供了3款内置的数据库，分别是\n\n * H2\n * HSQL\n * Derby\n\n以上三款数据库除了可以独立安装之外，还可以像是tomcat服务器一样，采用内嵌的形式运行在spirngboot容器中。内嵌在容器中运行，那必须是java对象啊，对，这三款数据库底层都是使用java语言开发的。\n\n我们一直使用MySQL数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。\n\n下面以H2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛\n\n步骤①：导入H2数据库对应的坐标，一共2个\n\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n\n步骤②：将工程设置为web工程，启动工程时启动H2数据库\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n步骤③：通过配置开启H2数据库控制台访问程序，也可以使用其他的数据库连接软件操作\n\nspring:\n  h2:\n    console:\n      enabled: true\n      path: /h2\n\n\nweb端访问路径localhost/h2就可以访问访问数据库，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问localhost/h2路径就可以正常访问了\n\ndatasource:\n  url: jdbc:h2:~/test\n  hikari:\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: 123456\n\n\n步骤④：使用JdbcTemplate或MyBatisPlus技术操作数据库即可\n\n（略）\n\n其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用MySQL数据库作为数据持久化方案，关闭方式就是设置enabled属性为false即可。\n\n总结\n\n 1. H2内嵌式数据库启动方式，添加坐标，添加配置\n 2. H2数据库线上运行时请务必关闭\n\n到这里SQL相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。\n\n * 数据源技术：Druid、Hikari、tomcat DataSource、DBCP\n * 持久化技术：MyBatisPlus、MyBatis、JdbcTemplate\n * 数据库技术：MySQL、H2、HSQL、Derby\n\n现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。\n\n\n# KF-4-2.NoSQL\n\nSQL数据层解决方案说完了，下面来说收NoSQL数据层解决方案。这个NoSQL是什么意思呢？从字面来看，No表示否定，NoSQL就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如Redis等。本节讲解的内容就是springboot如何整合这些技术，在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款NoSQL数据库整合方案，分别是Redis、MongoDB、ES。\n\n因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在Linux服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以Windows平台作为安装基础讲解，如果想看Linux版软件安装，可以再找到对应技术的学习文档查阅学习。\n\n# SpringBoot整合Redis\n\nRedis是一款采用key-value数据存储格式的内存级NoSQL数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与MySQL数据库不同，MySQL数据库有表、有字段、有记录，Redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实Redis有它的数据持久化方案，分别是RDB和AOF，但是Redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。\n\nRedis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合\n\n# 安装\n\nwindows版安装包下载地址：https://github.com/tporadowski/redis/releases\n\n下载的安装包有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是msi一键安装的msi文件进行安装的。\n\n啥是msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。\n\n安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动Redis的核心命令，需要再CMD命令行模式执行。\n\n启动服务器\n\nredis-server.exe redis.windows.conf\n\n\n初学者无需调整服务器对外服务端口，默认6379。\n\n启动客户端\n\nredis-cli.exe\n\n\n如果启动redis服务器失败，可以先启动客户端，然后执行shutdown操作后退出，此时redis服务器就可以正常执行了。\n\n# 基本操作\n\n服务器启动后，使用客户端就可以连接服务器，类似于启动完MySQL数据库，然后启动SQL命令行操作数据库。\n\n放置一个字符串数据到redis中，先为数据定义一个名称，比如name,age等，然后使用命令set设置数据到redis服务器中即可\n\nset name itheima\nset age 12\n\n\n从redis中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到(nil)\n\nget name\nget age\n\n\n以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向hash结构中存储数据格式如下：\n\nhset a a1 aa1\t\t#对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1\nhset a a2 aa2\n\n\n获取hash结构中的数据命令如下\n\nhget a a1\t\t\t#得到aa1\nhget a a2\t\t\t#得到aa2\n\n\n有关redis的基础操作就普及到这里，需要全面掌握redis技术，请参看相关教程学习。\n\n# 整合\n\n在进行整合之前先梳理一下整合的思想，springboot整合任何技术其实就是在springboot中使用对应技术的API。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用springboot技术去管理其他技术，几个问题是躲不掉的。\n\n第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化\n\n第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题\n\n第三，没有整合之前操作如果是模式A的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同\n\n按照上面的三个问题去思考springboot整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。\n\n下面就开始springboot整合redis，操作步骤如下：\n\n步骤①：导入springboot整合redis的starter坐标\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属NoSQL分类中\n\n步骤②：进行基础配置\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n\n\n操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。\n\n步骤③：使用springboot整合redis的专用客户端接口操作，此处使用的是RedisTemplate\n\n@SpringBootTest\nclass Springboot16RedisApplicationTests {\n    @Autowired\n    private RedisTemplate redisTemplate;\n    // 以下为普通的key-value操作\n    @Test\n    void set() {\n        ValueOperations ops = redisTemplate.opsForValue();\n        ops.set("age",41);\n    }\n    @Test\n    void get() {\n        ValueOperations ops = redisTemplate.opsForValue();\n        Object age = ops.get("name");\n        System.out.println(age);\n    }\n    \n    // 以下为hash操作\n    @Test\n    void hset() {\n        HashOperations ops = redisTemplate.opsForHash();\n        ops.put("info","b","bb");\n    }\n    @Test\n    void hget() {\n        HashOperations ops = redisTemplate.opsForHash();\n        Object val = ops.get("info", "b");\n        System.out.println(val);\n    }\n}\n\n\n\n在操作redis时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用opsForValue()获取string类型的数据操作接口，使用opsForHash()获取hash类型的数据操作接口，剩下的就是调用对应api操作了。各种类型的数据操作接口如下：\n\n总结\n\n 1. springboot整合redis步骤\n    1. 导入springboot整合redis的starter坐标\n    2. 进行基础配置\n    3. 使用springboot整合redis的专用客户端接口RedisTemplate操作\n\nStringRedisTemplate\n\n由于**redis内部不提供java对象的存储格式，因此当操作的数据以对象（泛型）的形式存在时，会进行转码，转换成字符串格式后进行操作。**为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的API接口StringRedisTemplate，你可以理解为这是RedisTemplate的一种指定数据泛型的操作API。\n\n@SpringBootTest\npublic class StringRedisTemplateTest {\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    @Test\n    void get(){\n        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();\n        String name = ops.get("name");\n        System.out.println(name);\n    }\n}\n\n\nredis客户端选择\n\n\tspringboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：\n\n\n步骤①：导入jedis坐标\n\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n</dependency>\n\n\njedis坐标受springboot管理，无需提供版本号\n\n步骤②：配置客户端技术类型，设置为jedis\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n\n\n步骤③：根据需要设置对应的配置\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n    lettuce:\n      pool:\n        max-active: 16\n    jedis:\n      pool:\n        max-active: 16\n\n\nlettcus与jedis区别\n\n * jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响\n * lettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作\n\n总结\n\n 1. springboot整合redis提供了StringRedisTemplate对象，以字符串的数据格式操作redis\n 2. 如果需要切换redis客户端实现技术，可以通过配置的形式进行\n\n# SpringBoot整合MongoDB\n\n使用Redis技术可以有效的提高数据访问速度，但是由于Redis的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，Redis就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来Redis无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解springboot如何整合MongoDB技术。\n\nMongoDB是一个开源、高性能、无模式的文档型数据库（他的文档格式和JSON很像，但又不完全相同，所以文档名称为BSON），它是NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库。\n\n上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有A、B、C一共3个字段，第二条数据可能有D、E、F也是3个字段，第三条数据可能是A、C、E3个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，MongoDB的应用面也会产生一些变化。以下列出了一些可以使用MongoDB作为数据存储的场景，但是并不是必须使用MongoDB的场景：\n\n * 淘宝用户数据（一旦设置之后很少变化）\n   * 存储位置：数据库\n   * 特征：永久性存储，修改频度极低\n * 游戏装备数据、游戏道具数据\n   * 存储位置：数据库、Mongodb\n   * 特征：永久性存储与临时存储相结合、修改频度较高\n * 直播数据、打赏数据、粉丝数据\n   * 存储位置：数据库、Mongodb\n   * 特征：永久性存储与临时存储相结合，修改频度极高\n * 物联网数据\n   * 存储位置：Mongodb\n   * 特征：临时存储，修改频度飞速\n\n快速了解一下MongoDB，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合\n\n# 安装\n\nwindows版安装包下载地址：https://www.mongodb.com/try/download\n\n下载的安装包也有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，本课程采用解压缩zip文件进行安装。\n\n解压缩完毕后会得到如下文件，其中bin目录包含了所有mongodb的可执行命令\n\n\n\nmongodb在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建data的目录用来存储数据，具体如下\n\n\n\n如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。\n\n根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到windows安装目录的system32目录下，然后在命令行中执行regsvr32命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。\n\nregsvr32 vcruntime140_1.dll\n\n\n启动服务器\n\nmongod --dbpath=..\\data\\db\n\n\n启动服务器时需要指定数据存储位置，通过参数--dbpath进行设置，可以根据需要自行设置数据存储路径。默认服务端口27017。\n\n启动客户端\n\nmongo --host=127.0.0.1 --port=27017\n\n\n# 基本操作\n\nMongoDB虽然是一款数据库，但是它的操作并不是使用SQL语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于Navicat的数据库客户端软件，能够便捷的操作MongoDB，先安装一个客户端，再来操作MongoDB。\n\n同类型的软件较多，本次安装的软件时Robo3t，Robot3t是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击robot3t.exe即可使用（MongoDB和Robot3t版本不匹配可能安装失败）。\n\n打开软件首先要连接MongoDB服务器，选择【File】菜单，选择【Connect...】\n\n\n\n进入连接管理界面后，选择左上角的【Create】链接，创建新的连接设置\n\n如果输入设置值即可连接（默认不修改即可连接本机27017端口）\n\n\n\n连接成功后在命令输入区域输入命令即可操作MongoDB。\n\n创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可\n\n创建集合：在Collections上使用右键创建，输入集合名称即可（这里的集合其实就是MySql的表），集合等同于数据库中的表的作用\n\n新增文档：（文档是一种类似json格式的数据，初学者可以先把数据理解为就是json数据）\n\ndb.集合名称.insert/save/insertOne(文档)\n\n\n删除文档：\n\ndb.集合名称.remove(条件)\n\n\n修改文档：\n\ndb.集合名称.update(条件，{操作种类:{文档}})\n\n\n查询文档：\n\n基础查询\n查询全部：\t\t   db.集合.find();\n查第一条：\t\t   db.集合.findOne()\n查询指定数量文档：\tdb.集合.find().limit(10)\t\t\t\t\t//查10条文档\n跳过指定数量文档：\tdb.集合.find().skip(20)\t\t\t\t\t//跳过20条文档\n统计：\t\t\t  \tdb.集合.count()\n排序：\t\t\t\tdb.集合.sort({age:1})\t\t\t\t\t\t//按age升序排序\n投影：\t\t\t\tdb.集合名称.find(条件,{name:1,age:1})\t\t //仅保留name与age域\n\n条件查询\n基本格式：\t\t\tdb.集合.find({条件})\n模糊查询：\t\t\tdb.集合.find({域名:/正则表达式/})\t\t  //等同SQL中的like，比like强大，可以执行正则所有规则\n条件比较运算：\t\t   db.集合.find({域名:{$gt:值}})\t\t\t\t//等同SQL中的数值比较操作，例如：name>18\n包含查询：\t\t\tdb.集合.find({域名:{$in:[值1，值2]}})\t\t//等同于SQL中的in\n条件连接查询：\t\t   db.集合.find({$and:[{条件1},{条件2}]})\t   //等同于SQL中的and、or\n\n\n有关MongoDB的基础操作就普及到这里，需要全面掌握MongoDB技术，请参看相关教程学习。\n\n# 整合\n\n使用springboot整合MongDB该如何进行呢？其实springboot为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB同样如此。\n\n第一，先导入对应技术的整合starter坐标\n\n第二，配置必要信息\n\n第三，使用提供的API操作即可\n\n下面就开始springboot整合MongoDB，操作步骤如下：\n\n步骤①：导入springboot整合MongoDB的starter坐标\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>\n\n\n上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属NoSQL分类中\n\n步骤②：进行基础配置\n\nspring:\n  data:\n    mongodb:\n      uri: mongodb://localhost/itheima\n\n\n操作MongoDB需要的配置与操作redis一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器IP地址和端口不同，书写格式不同而已。\n\n步骤③：使用springboot整合MongoDB的专用客户端接口MongoTemplate来进行操作\n\n@SpringBootTest\nclass Springboot17MongodbApplicationTests {\n    @Autowired\n    private MongoTemplate mongoTemplate;\n    @Test\n    void contextLoads() {\n        Book book = new Book();\n        book.setId(2);\n        book.setName("springboot2");\n        book.setType("springboot2");\n        book.setDescription("springboot2");\n        mongoTemplate.save(book);\n    }\n    @Test\n    void find(){\n        List<Book> all = mongoTemplate.findAll(Book.class);\n        System.out.println(all);\n    }\n}\n\n\n整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用API操作，陌生的是这个技术，里面具体的操作API可能会不熟悉，有关springboot整合MongoDB我们就讲到这里。有兴趣可以继续学习MongoDB的操作，然后再来这里通过编程的形式操作MongoDB。\n\n总结\n\n 1. springboot整合MongoDB步骤\n    1. 导入springboot整合MongoDB的starter坐标\n    2. 进行基础配置\n    3. 使用springboot整合MongoDB的专用客户端接口MongoTemplate操作\n\n# SpringBoot整合ES\n\nNoSQL解决方案已经讲完了两种技术的整合了，Redis可以使用内存加载数据并实现数据快速访问，MongoDB可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款NoSQL解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做ES技术。\n\nES（Elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。\n\n那什么是全文搜索呢？比如用户要买一本书，以Java为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含java就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而ES技术就是一种可以实现上述效果的技术。\n\n要实现全文搜索的效果，不可能使用数据库中like操作去进行比对，这种效率太低了。ES设计了一种全新的思想，来实现全文搜索。具体操作过程如下：\n\n 1. 将被查询的字段的数据全部文本信息进行查分，分成若干个词\n    \n    * 例如“中华人民共和国”就会被拆分成三个词，分别是“中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。\n\n 2. 将分词得到的结果存储起来，对应每条数据的id\n    \n    * 例如id为1的数据中名称这一项的值是“中华人民共和国”，那么分词结束后，就会出现“中华”对应id为1，“人民”对应id为1，“共和国”对应id为1\n    \n    * 例如id为2的数据中名称这一项的值是“人民代表大会“，那么分词结束后，就会出现“人民”对应id为2，“代表”对应id为2，“大会”对应id为2\n    \n    * 此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中\n      \n      分词结果关键字   对应ID\n      中华        1\n      人民        1,2\n      共和国       1\n      代表        2\n      大会        2\n\n 3. 当进行查询时，如果输入“人民”作为查询条件，可以通过上述表格数据进行比对，得到id值1,2，然后根据id值就可以得到查询的结果数据了。\n\n上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做倒排索引（正向排序是根据查询内容遍历每一个文件，然后在文件中进行匹配；倒排索引是将构建关键词和文件的映射，根据关键词来找文件。）。\n\n通过上述内容的学习，发现使用ES其实准备工作还是挺多的，必须先建立文档的倒排索引，然后才能继续使用。快速了解一下ES的工作原理，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合。\n\n# 安装\n\nwindows版安装包下载地址：https://www.elastic.co/cn/downloads/elasticsearch\n\n下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n\n * bin目录：包含所有的可执行命令\n * config目录：包含ES服务器使用的配置文件\n * jdk目录：此目录中包含了一个完整的jdk工具包，版本17，当ES升级时，使用最新版本的jdk确保不会出现版本支持性不足的问题\n * lib目录：包含ES运行的依赖jar文件\n * logs目录：包含ES运行后产生的所有日志文件\n * modules目录：包含ES软件中所有的功能模块，也是一个一个的jar包。和jar目录不同，jar目录是ES运行期间依赖的jar包，modules是ES软件自己的功能jar包\n * plugins目录：包含ES软件安装的插件，默认为空\n\n启动服务器\n\nelasticsearch.bat\n\n\n双击elasticsearch.bat文件即可启动ES服务器，默认服务端口9200。通过浏览器访问http://localhost:9200看到如下信息视为ES服务器正常启动\n\n{\n  "name" : "CZBK-**********",\n  "cluster_name" : "elasticsearch",\n  "cluster_uuid" : "j137DSswTPG8U4Yb-0T1Mg",\n  "version" : {\n    "number" : "7.16.2",\n    "build_flavor" : "default",\n    "build_type" : "zip",\n    "build_hash" : "2b937c44140b6559905130a8650c64dbd0879cfb",\n    "build_date" : "2021-12-18T19:42:46.604893745Z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.10.1",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "You Know, for Search"\n}\n\n\n# 基本操作\n\nES中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在ES中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行ES的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。\n\n要操作ES可以通过Rest风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。\n\n * 创建索引，books是索引名称，下同\n   \n   PUT请求\t\thttp://localhost:9200/books\n   \n   \n   发送请求后，看到如下信息即索引创建成功\n   \n   {\n       "acknowledged": true,\n       "shards_acknowledged": true,\n       "index": "books"\n   }\n   \n   \n   重复创建已经存在的索引会出现错误信息，reason属性中描述错误原因\n   \n   {\n       "error": {\n           "root_cause": [\n               {\n                   "type": "resource_already_exists_exception",\n                   "reason": "index [books/VgC_XMVAQmedaiBNSgO2-w] already exists",\n                   "index_uuid": "VgC_XMVAQmedaiBNSgO2-w",\n                   "index": "books"\n               }\n           ],\n           "type": "resource_already_exists_exception",\n           "reason": "index [books/VgC_XMVAQmedaiBNSgO2-w] already exists",\t# books索引已经存在\n           "index_uuid": "VgC_XMVAQmedaiBNSgO2-w",\n           "index": "book"\n       },\n       "status": 400\n   }\n   \n\n * 查询索引\n   \n   GET请求\thttp://localhost:9200/books\n   \n   \n   查询索引得到索引相关信息，如下\n   \n   {\n       "book": {\n           "aliases": {},\n           "mappings": {},\n           "settings": {\n               "index": {\n                   "routing": {\n                       "allocation": {\n                           "include": {\n                               "_tier_preference": "data_content"\n                           }\n                       }\n                   },\n                   "number_of_shards": "1",\n                   "provided_name": "books",\n                   "creation_date": "1645768584849",\n                   "number_of_replicas": "1",\n                   "uuid": "VgC_XMVAQmedaiBNSgO2-w",\n                   "version": {\n                       "created": "7160299"\n                   }\n               }\n           }\n       }\n   }\n   \n   \n   如果查询了不存在的索引，会返回错误信息，例如查询名称为book的索引后信息如下\n   \n   {\n       "error": {\n           "root_cause": [\n               {\n                   "type": "index_not_found_exception",\n                   "reason": "no such index [book]",\n                   "resource.type": "index_or_alias",\n                   "resource.id": "book",\n                   "index_uuid": "_na_",\n                   "index": "book"\n               }\n           ],\n           "type": "index_not_found_exception",\n           "reason": "no such index [book]",\t\t# 没有book索引\n           "resource.type": "index_or_alias",\n           "resource.id": "book",\n           "index_uuid": "_na_",\n           "index": "book"\n       },\n       "status": 404\n   }\n   \n\n * 删除索引\n   \n   DELETE请求\thttp://localhost:9200/books\n   \n   \n   删除所有后，给出删除结果\n   \n   {\n       "acknowledged": true\n   }\n   \n   \n   如果重复删除，会给出错误信息，同样在reason属性中描述具体的错误原因\n   \n   {\n       "error": {\n           "root_cause": [\n               {\n                   "type": "index_not_found_exception",\n                   "reason": "no such index [books]",\n                   "resource.type": "index_or_alias",\n                   "resource.id": "book",\n                   "index_uuid": "_na_",\n                   "index": "book"\n               }\n           ],\n           "type": "index_not_found_exception",\n           "reason": "no such index [books]",\t\t# 没有books索引\n           "resource.type": "index_or_alias",\n           "resource.id": "book",\n           "index_uuid": "_na_",\n           "index": "book"\n       },\n       "status": 404\n   }\n   \n\n * 创建索引并指定分词器\n   \n   前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是IK分词器，使用前先在下对应的分词器，然后使用。IK分词器下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n   \n   分词器下载后解压到ES安装目录的plugins目录中即可，安装分词器后需要重新启动ES服务器。使用IK分词器创建索引格式：\n   \n   \n   \n   PUT请求\t\thttp://localhost:9200/books\n   \n   请求参数如下（注意是json格式的参数）\n   {\n       "mappings":{\t\t\t\t\t\t\t#定义mappings属性，替换创建索引时对应的mappings属性\t\t\n           "properties":{\t\t\t\t\t\t#定义索引中包含的属性设置\n               "id":{\t\t\t\t\t\t\t#设置索引中包含id属性\n                   "type":"keyword"\t\t\t#当前属性可以被直接搜索\n               },\n               "name":{\t\t\t\t\t\t#设置索引中包含name属性\n                   "type":"text",              #当前属性是文本信息,是字符创，参与分词  \n                   "analyzer":"ik_max_word",   #使用IK分词器进行分词             \n                   "copy_to":"all"\t\t\t\t#分词结果拷贝到all属性中\n               },\n               "type":{\n                   "type":"keyword"\n               },\n               "description":{\n                   "type":"text",\t                \n                   "analyzer":"ik_max_word",                \n                   "copy_to":"all"\n               },\n               "all":{\t\t\t\t\t\t\t#定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询\n                   "type":"text",\t            # 这个属性将name 和description中的拷贝到all中    \n                   "analyzer":"ik_max_word"\n               }\n           }\n       }\n   }\n   \n   \n   创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数mappings已经进入到了索引属性中，具体属性顺序按照内部设定进行排序\n   \n   {\n       "books": {\n           "aliases": {},\n           "mappings": {\t\t\t\t\t\t#mappings属性已经被替换\n               "properties": {\n                   "all": {\n                       "type": "text",\n                       "analyzer": "ik_max_word"\n                   },\n                   "description": {\n                       "type": "text",\n                       "copy_to": [\n                           "all"\n                       ],\n                       "analyzer": "ik_max_word"\n                   },\n                   "id": {\n                       "type": "keyword"\n                   },\n                   "name": {\n                       "type": "text",\n                       "copy_to": [\n                           "all"\n                       ],\n                       "analyzer": "ik_max_word"\n                   },\n                   "type": {\n                       "type": "keyword"\n                   }\n               }\n           },\n           "settings": {\n               "index": {\n                   "routing": {\n                       "allocation": {\n                           "include": {\n                               "_tier_preference": "data_content"\n                           }\n                       }\n                   },\n                   "number_of_shards": "1",\n                   "provided_name": "books",\n                   "creation_date": "1645769809521",\n                   "number_of_replicas": "1",\n                   "uuid": "DohYKvr_SZO4KRGmbZYmTQ",\n                   "version": {\n                       "created": "7160299"\n                   }\n               }\n           }\n       }\n   }\n   \n\n目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，ES中称数据为文档，下面进行文档操作。\n\n * 添加文档，有三种方式\n   \n   POST请求\thttp://localhost:9200/books/_doc\t\t#使用系统生成id\n   POST请求\thttp://localhost:9200/books/_create/1\t#使用指定id\n   POST请求\thttp://localhost:9200/books/_doc/1\t\t#使用指定id，不存在创建，存在更新（版本递增）\n   \n   文档通过请求参数传递，数据格式json\n   {\n       "name":"springboot",\n       "type":"springboot",\n       "description":"springboot"\n   }  \n   \n\n * 查询文档\n   \n   GET请求\thttp://localhost:9200/books/_doc/1\t\t #查询单个文档 \t\t\n   GET请求\thttp://localhost:9200/books/_search\t\t #查询全部文档\n   \n\n * 条件查询\n   \n   GET请求\thttp://localhost:9200/books/_search?q=name:springboot\t# q=查询属性名:查询属性值\n   \n\n * 删除文档\n   \n   DELETE请求\thttp://localhost:9200/books/_doc/1\n   \n\n * 修改文档（全量更新）\n   \n   PUT请求\thttp://localhost:9200/books/_doc/1\n   \n   文档通过请求参数传递，数据格式json\n   {\n       "name":"springboot",\n       "type":"springboot",\n       "description":"springboot"\n   }\n   \n\n * 修改文档（部分更新）\n   \n   POST请求\thttp://localhost:9200/books/_update/1\n   \n   文档通过请求参数传递，数据格式json\n   {\t\t\t\n       "doc":{\t\t\t\t\t\t#部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新\n           "name":"springboot"\t\t#仅更新提供的属性值，未提供的属性值不参与更新操作\n       }\n   }\n   \n\n# 整合\n\n使用springboot整合ES该如何进行呢？老规矩，导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB如此，整合ES依然如此。太没有新意了，其实不是没有新意，这就是springboot的强大之处，所有东西都做成相同规则，对开发者来说非常友好。\n\n下面就开始springboot整合ES，操作步骤如下：\n\n步骤①：导入springboot整合ES的starter坐标\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\n</dependency>\n\n\n步骤②：进行基础配置\n\nspring:\n  elasticsearch:\n    rest:\n      uris: http://localhost:9200\n\n\n配置ES服务器地址，端口9200\n\n步骤③：使用springboot整合ES的专用客户端接口ElasticsearchRestTemplate来进行操作\n\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    @Autowired\n    private ElasticsearchRestTemplate template;\n}\n\n\n上述操作形式是ES早期的操作方式，使用的客户端被称为Low Level Client，这种客户端操作方式性能方面略显不足，于是ES开发了全新的客户端操作方式，称为High Level Client。高级别客户端与ES版本同步更新，但是springboot最初整合ES的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。\n\n下面使用高级别客户端方式进行springboot整合ES，操作步骤如下：\n\n步骤①：导入springboot整合ES高级别客户端的坐标，此种形式目前没有对应的starter\n\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n</dependency>\n\n\n步骤②：使用编程的形式设置连接的ES服务器，并获取客户端对象\n\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    private RestHighLevelClient client;\n      @Test\n      void testCreateClient() throws IOException {\n          HttpHost host = HttpHost.create("http://localhost:9200");\n          RestClientBuilder builder = RestClient.builder(host);\n          client = new RestHighLevelClient(builder);\n  \n          client.close();\n      }\n}\n\n\n配置ES服务器地址与端口9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。\n\n步骤③：使用客户端对象操作ES，例如创建索引\n\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    private RestHighLevelClient client;\n      @Test\n      void testCreateIndex() throws IOException {\n          HttpHost host = HttpHost.create("http://localhost:9200");\n          RestClientBuilder builder = RestClient.builder(host);\n          client = new RestHighLevelClient(builder);\n          // 客户端操作\n          CreateIndexRequest request = new CreateIndexRequest("books");\n          // 获取操作索引的客户端对象，调用创建索引操作\n          client.indices().create(request, RequestOptions.DEFAULT); \n          // 关闭客户端\n          client.close();\n      }\n}\n\n\n高级别客户端操作是通过发送请求的方式完成所有操作的，ES针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是CreateIndexRequest，其他操作也会有自己专用的Request对象。\n\n当前操作我们发现，无论进行ES何种操作，第一步永远是获取RestHighLevelClient对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。\n\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    @BeforeEach\t\t//在测试类中每个操作运行前运行的方法\n    void setUp() {\n        HttpHost host = HttpHost.create("http://localhost:9200");\n        RestClientBuilder builder = RestClient.builder(host);\n        client = new RestHighLevelClient(builder);\n    }\n\n    @AfterEach\t\t//在测试类中每个操作运行后运行的方法\n    void tearDown() throws IOException {\n        client.close();，\n    }\n\n    private RestHighLevelClient client;\n\n    @Test\n    void testCreateIndex() throws IOException {\n        CreateIndexRequest request = new CreateIndexRequest("books");\n        client.indices().create(request, RequestOptions.DEFAULT);\n    }\n}\n\n\n现在的书写简化了很多，也更合理。下面使用上述模式将所有的ES操作执行一遍，测试结果\n\n创建索引（IK分词器）：\n\n@Test\nvoid testCreateIndexByIK() throws IOException {\n    CreateIndexRequest request = new CreateIndexRequest("books");\n    String json = "{\\n" +\n            "    \\"mappings\\":{\\n" +\n            "        \\"properties\\":{\\n" +\n            "            \\"id\\":{\\n" +\n            "                \\"type\\":\\"keyword\\"\\n" +\n            "            },\\n" +\n            "            \\"name\\":{\\n" +\n            "                \\"type\\":\\"text\\",\\n" +\n            "                \\"analyzer\\":\\"ik_max_word\\",\\n" +\n            "                \\"copy_to\\":\\"all\\"\\n" +\n            "            },\\n" +\n            "            \\"type\\":{\\n" +\n            "                \\"type\\":\\"keyword\\"\\n" +\n            "            },\\n" +\n            "            \\"description\\":{\\n" +\n            "                \\"type\\":\\"text\\",\\n" +\n            "                \\"analyzer\\":\\"ik_max_word\\",\\n" +\n            "                \\"copy_to\\":\\"all\\"\\n" +\n            "            },\\n" +\n            "            \\"all\\":{\\n" +\n            "                \\"type\\":\\"text\\",\\n" +\n            "                \\"analyzer\\":\\"ik_max_word\\"\\n" +\n            "            }\\n" +\n            "        }\\n" +\n            "    }\\n" +\n            "}";\n    //设置请求中的参数\n    request.source(json, XContentType.JSON);\n    client.indices().create(request, RequestOptions.DEFAULT);\n}\n\n\nIK分词器是通过请求参数的形式进行设置的，设置请求参数使用request对象中的source方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。\n\n添加文档：\n\n@Test\n//添加Id为1的数据（文档）\nvoid testCreateDoc() throws IOException {\n    Book book = bookDao.selectById(1);\n    IndexRequest request = new IndexRequest("books").id(book.getId().toString());\n    String json = JSON.toJSONString(book);\n    request.source(json,XContentType.JSON);\n    client.index(request,RequestOptions.DEFAULT);\n}\n\n\n添加文档使用的请求对象是IndexRequest，与创建索引使用的请求对象不同。\n\n批量添加文档：\n\n@Test\n//批量添加文档\nvoid testCreateDocAll() throws IOException {\n    List<Book> bookList = bookDao.selectList(null);\n    BulkRequest bulk = new BulkRequest();\n    for (Book book : bookList) {\n        IndexRequest request = new IndexRequest("books").id(book.getId().toString());\n        String json = JSON.toJSONString(book);\n        request.source(json,XContentType.JSON);\n        bulk.add(request);\n    }\n    client.bulk(bulk,RequestOptions.DEFAULT);\n}\n\n\n批量做时，先创建一个BulkRequest的对象，可以将该对象理解为是一个保存request对象的容器，将所有的请求都初始化好后，添加到BulkRequest对象中，再使用BulkRequest对象的bulk方法，一次性执行完毕。\n\n按id查询文档：\n\n@Test\n//按id查询\nvoid testGet() throws IOException {\n    GetRequest request = new GetRequest("books","1");\n    GetResponse response = client.get(request, RequestOptions.DEFAULT);\n    String json = response.getSourceAsString();\n    System.out.println(json);\n}\n\n\n根据id查询文档使用的请求对象是GetRequest。\n\n按条件查询文档：\n\n@Test\n//按条件查询\nvoid testSearch() throws IOException {\n    SearchRequest request = new SearchRequest("books");\n\n    SearchSourceBuilder builder = new SearchSourceBuilder();\n    builder.query(QueryBuilders.termQuery("all","spring"));    // 查询对象\n    request.source(builder);  // 使设置条件 \n\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    SearchHits hits = response.getHits();\n    for (SearchHit hit : hits) {\n        String source = hit.getSourceAsString();\n        //System.out.println(source);\n        Book book = JSON.parseObject(source, Book.class);\n        System.out.println(book);\n    }\n}\n\n\n按条件查询文档使用的请求对象是SearchRequest，查询时调用SearchRequest对象的termQuery方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的all属性。\n\nspringboot整合ES的操作到这里就说完了，与前期进行springboot整合redis和mongodb的差别还是蛮大的，主要原始就是我们没有使用springboot整合ES的客户端对象。至于操作，由于ES操作种类过多，所以显得操作略微有点复杂。有关springboot整合ES就先学习到这里吧。\n\n总结\n\n 1. springboot整合ES步骤\n    1. 导入springboot整合ES的High Level Client坐标\n    2. 手工管理客户端对象，包括初始化和关闭操作\n    3. 使用High Level Client根据操作的种类不同，选择不同的Request对象完成对应操作\n\n\n# KF-5.整合第三方技术\n\n通过第四章的学习，我们领略到了springboot在整合第三方技术时强大的一致性，在第五章中我们要使用springboot继续整合各种各样的第三方技术，通过本章的学习，可以将之前学习的springboot整合第三方技术的思想贯彻到底，还是那三板斧。导坐标、做配置、调API。\n\nspringboot能够整合的技术实在是太多了，可以说是万物皆可整。本章将从企业级开发中常用的一些技术作为出发点，对各种各样的技术进行整合。\n\n\n# KF-5-1.缓存\n\n企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。\n\n应用程序直接与数据库打交道，访问效率低\n\n为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。\n\n\t\t\t\t\t\t\t\t\t\t使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高\n\n\n\n\n多级缓存\n\n缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。而springboot提供了对市面上几乎所有的缓存技术进行整合的方案，下面就一起开启springboot整合缓存之旅。\n\n# SpringBoot内置缓存解决方案\n\nspringboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。\n\n步骤①：导入springboot提供的缓存技术对应的starter\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n\n\n步骤②：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n\n@SpringBootApplication\n//开启缓存功能\n@EnableCaching\npublic class Springboot19CacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot19CacheApplication.class, args);\n    }\n}\n\n\n步骤③：设置操作的数据是否使用缓存\n\n@Service\npublic class BookServiceImpl implements BookService {\n    @Autowired\n    private BookDao bookDao;\n\n    @Cacheable(value="cacheSpace",key="#id")\n    public Book getById(Integer id) {\n        return bookDao.selectById(id);\n    }\n}\n\n\n在业务方法上面使用注解@Cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。\n\n使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。\n\n# 手机验证码案例\n\n为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。\n\n手机验证码案例需求如下：\n\n * 输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）\n * 输入手机号和验证码验证结果\n\n为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。\n\n步骤①：导入springboot提供的缓存技术对应的starter\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n\n\n步骤②：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n\n@SpringBootApplication\n//开启缓存功能\n@EnableCaching\npublic class Springboot19CacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot19CacheApplication.class, args);\n    }\n}\n\n\n步骤③：定义验证码对应的实体类，封装手机号与验证码两个属性\n\n@Data\npublic class SMSCode {\n    private String tele;\n    private String code;\n}\n\n\n步骤④：定义验证码功能的业务层接口与实现类\n\npublic interface SMSCodeService {\n    public String sendCodeToSMS(String tele);\n    public boolean checkCode(SMSCode smsCode);\n}\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n\n    @CachePut(value = "smsCode", key = "#tele")\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        //取出内存中的验证码与传递过来的验证码比对，如果相同，返回true\n        String code = smsCode.getCode();\n        String cacheCode = codeUtils.get(smsCode.getTele());  // 缓存中取出对应的验证码\n        return code.equals(cacheCode);\n    }\n}\n\n\n获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@Cacheable注解，@Cacheable注解是缓存中没有值则放入值，缓存中有值则取值，在这里就不能根据手机号重新生成验证码了。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@Cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@CachePut注解即可。\n\n对于校验验证码的功能建议放入工具类中进行。\n\n步骤⑤：定义验证码的生成策略与根据手机号读取验证码的功能\n\n@Component\npublic class CodeUtils {\n    private String [] patch = {"000000","00000","0000","000","00","0",""};\n\n    public String generator(String tele){\n        int hash = tele.hashCode();\n        int encryption = 20206666;\n        long result = hash ^ encryption;\n        long nowTime = System.currentTimeMillis();\n        result = result ^ nowTime;\n        long code = result % 1000000;\n        code = code < 0 ? -code : code;\n        String codeStr = code +   // 转成字符串\n        int len = codeStr.length();\n        return patch[len] + codeStr;\n    }\n\n    @Cacheable(value = "smsCode",key="#tele")\n    public String get(String tele){\n        return null;\n    }\n}\n\n\n步骤⑥：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验\n\n@RestController\n@RequestMapping("/sms")\npublic class SMSCodeController {\n    @Autowired\n    private SMSCodeService smsCodeService;\n    \n    @GetMapping\n    public String getCode(String tele){\n        String code = smsCodeService.sendCodeToSMS(tele);\n        return code;\n    }\n    \n    @PostMapping\n    public boolean checkCode(SMSCode smsCode){\n        return smsCodeService.checkCode(smsCode);\n    }\n}\n\n\n# SpringBoot常用缓存技术\n\n标红的是最为常用的\n\n\n\n# SpringBoot整合Ehcache缓存\n\n手机验证码的案例已经完成了，下面就开始springboot整合各种各样的缓存技术，第一个整合Ehcache技术。Ehcache是一种缓存技术，使用springboot整合Ehcache其实就是变更一下缓存技术的实现方式，话不多说，直接开整\n\n步骤①：导入Ehcache的坐标\n\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n</dependency>\n\n\n此处为什么不是导入Ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。\n\n步骤②：配置缓存技术实现使用Ehcache\n\nspring:\n  cache:\n    type: ehcache\n    ehcache:\n      config: ehcache.xml\n\n\n配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。\n\n由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"\n         updateCheck="false">\n    <diskStore path="D:\\ehcache" />\n\n    \x3c!--默认缓存策略 --\x3e\n    \x3c!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false--\x3e\n    \x3c!-- diskPersistent：是否启用磁盘持久化--\x3e\n    \x3c!-- maxElementsInMemory：最大缓存数量--\x3e\n    \x3c!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘--\x3e\n    \x3c!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码--\x3e\n    \x3c!-- timeToLiveSeconds：最大存活时间--\x3e\n    \x3c!-- memoryStoreEvictionPolicy：缓存清除策略--\x3e\n    <defaultCache\n        eternal="false"\n        diskPersistent="false"\n        maxElementsInMemory="1000"\n        overflowToDisk="false"\n        timeToIdleSeconds="60"\n        timeToLiveSeconds="60"\n        memoryStoreEvictionPolicy="LRU" />\n    \x3c!--自定义的缓存name要和Cacheable或者CachePut中的name一致，因为Cacheable或者CachePut会根据value寻找对应的cache配置，否则报错--\x3e\n    <cache\n        name="smsCode"\n        eternal="false"\n        diskPersistent="false"\n        maxElementsInMemory="1000"\n        overflowToDisk="false"\n        timeToIdleSeconds="10"\n        timeToLiveSeconds="10"\n        memoryStoreEvictionPolicy="LRU" />\n</ehcache>\n\n\n注意前面的案例中，设置了数据保存的位置是smsCode\n\n@CachePut(value = "smsCode", key = "#tele")\npublic String sendCodeToSMS(String tele) {\n    String code = codeUtils.generator(tele);\n    return code;\n}\t\n\n\n这个设定需要保障ehcache中有一个缓存空间名称叫做smsCode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。\n\n到这里springboot整合Ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。\n\n总结\n\n 1. springboot使用Ehcache作为缓存实现需要导入Ehcache的坐标\n 2. 修改设置，配置缓存供应商为ehcache，并提供对应的缓存配置文件\n\n\n\n# SpringBoot整合Redis缓存\n\n上节使用Ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。\n\n比对使用Ehcache的过程，加坐标，改缓存实现类型为ehcache，做Ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。\n\n步骤①：导入redis的坐标\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n步骤②：配置缓存技术实现使用redis\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n\n\n如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n    redis:\n      use-key-prefix: false  # 是否有前缀，默认是TRUE\n      key-prefix: sms_  # 上面如果为false，这个配置选项将会失效\n      cache-null-values: false   # 是否缓存空值\n      time-to-live: 10s  # 缓存周期\n\n\n总结\n\n 1. springboot使用redis作为缓存实现需要导入redis的坐标\n 2. 修改设置，配置缓存供应商为redis，并提供对应的缓存配置\n\n# SpringBoot整合Memcached缓存\n\n目前我们已经掌握了3种缓存解决方案的配置形式，分别是springboot内置缓存，ehcache和redis，本节研究一下国内比较流行的一款缓存memcached。\n\n按照之前的套路，其实变更缓存并不繁琐，但是springboot并没有支持使用memcached作为其缓存解决方案，也就是说在type属性中没有memcached的配置选项，这里就需要更变一下处理方式了。在整合之前先安装memcached。\n\n安装\n\nwindows版安装包下载地址：https://www.runoob.com/memcached/window-install-memcached.html\n\n下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n\n可执行文件只有一个memcached.exe，使用该文件可以将memcached作为系统服务启动，执行此文件时会出现报错信息，如下：\n\n此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行\n\n然后再次执行安装服务的命令即可，如下：\n\nmemcached.exe -d install\n\n\n服务安装完毕后可以使用命令启动和停止服务，如下：\n\nmemcached.exe -d start\t\t# 启动服务\nmemcached.exe -d stop\t\t# 停止服务\n\n\n也可以在任务管理器中进行服务状态的切换\n\n变更缓存为Memcached\n\n由于memcached未被springboot收录为缓存解决方案，因此使用memcached需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。\n\nmemcached目前提供有三种客户端技术，分别是Memcached Client for Java、SpyMemcached和Xmemcached，其中性能指标各方面最好的客户端是Xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用Xmemcached\n\n步骤①：导入xmemcached的坐标\n\n<dependency>\n    <groupId>com.googlecode.xmemcached</groupId>\n    <artifactId>xmemcached</artifactId>\n    <version>2.4.7</version>\n</dependency>\n\n\n步骤②：配置memcached，制作memcached的配置类\n\n@Configuration\npublic class XMemcachedConfig {\n    @Bean\n    public MemcachedClient getMemcachedClient() throws IOException {\n        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder("localhost:11211");\n        MemcachedClient memcachedClient = memcachedClientBuilder.build();\n        return memcachedClient;\n    }\n}\n\n\nmemcached默认对外服务端口11211。\n\n步骤③：使用xmemcached客户端操作缓存，注入MemcachedClient对象\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n    @Autowired\n    private MemcachedClient memcachedClient;\n    // 生成并发送验证码\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        try {\n            // 10秒更新一次\n            memcachedClient.set(tele,10,code);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return code;\n    }\n    // 比对验证码是否相同\n    public boolean checkCode(SMSCode smsCode) {\n        String code = null;\n        try {\n            // memcachedClient.get(smsCode.getTele())得到是一个Object类型的值，因此需要将这部分内容转成一个字符串\n            code = memcachedClient.get(smsCode.getTele()).toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return smsCode.getCode().equals(code);\n    }\n}\n\n\n设置值到缓存中使用set操作，取值使用get操作，其实更符合我们开发者的习惯。\n\n上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。\n\n定义配置属性\n\n以下过程采用前期学习的属性配置方式进行，当前操作有助于理解原理篇中的很多知识。\n\n * 定义配置类，加载必要的配置属性，读取配置文件中memcached节点信息\n   \n   @Component\n   @ConfigurationProperties(prefix = "memcached")\n   @Data\n   public class XMemcachedProperties {\n       private String servers;\n       private int poolSize;\n       private long opTimeout;\n   }\n   \n\n * 定义memcached节点信息\n   \n   memcached:\n     servers: localhost:11211\n     poolSize: 10\n     opTimeout: 3000\n   \n\n * 在memcached配置类中加载信息\n\n@Configuration\npublic class XMemcachedConfig {\n    @Autowired\n    private XMemcachedProperties props;\n    @Bean\n    public MemcachedClient getMemcachedClient() throws IOException {\n        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(props.getServers());\n        memcachedClientBuilder.setConnectionPoolSize(props.getPoolSize());\n        memcachedClientBuilder.setOpTimeout(props.getOpTimeout());\n        MemcachedClient memcachedClient = memcachedClientBuilder.build();\n        return memcachedClient;\n    }\n}\n\n\n总结\n\n 1. memcached安装后需要启动对应服务才可以对外提供缓存功能，安装memcached服务需要基于windows系统管理员权限\n 2. 由于springboot没有提供对memcached的缓存整合方案，需要采用手工编码的形式创建xmemcached客户端操作缓存\n 3. 导入xmemcached坐标后，创建memcached配置类，注册MemcachedClient对应的bean，用于操作缓存\n 4. 初始化MemcachedClient对象所需要使用的属性可以通过自定义配置属性类的形式加载\n\n思考\n\n到这里已经完成了三种缓存的整合，其中redis和mongodb需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，Ehcache是一个典型的内存级缓存，因为它什么也不用安装，启动后导入jar包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？咱们下节再说。\n\n# SpringBoot整合jetcache缓存\n\n目前我们使用的缓存都是要么A要么B，能不能AB一起用呢？这一节就解决这个问题。springboot针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持AB一起用，springboot也没办法，所以要想解决AB缓存一起用的问题，就必须找一款缓存能够支持AB两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。\n\njetcache严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到jetcache中管理，这样就可以支持AB缓存一起用了。并且jetcache参考了springboot整合缓存的思想，整体技术使用方式和springboot的缓存解决方案思想非常类似。下面咱们就先把jetcache用起来，然后再说它里面的一些小的功能。\n\n本地缓存和远程缓存的区别是什么？后面了解一下。远程是要去远程主机上去吗\n\n做之前要先明确一下，jetcache并不是随便拿两个缓存都能拼到一起去的。目前jetcache支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：\n\n * 本地缓存（Local）\n   * LinkedHashMap\n   * Caffeine\n * 远程缓存（Remote）\n   * Redis\n   * Tair\n\n其实也有人问我，为什么jetcache只支持2+2这么4款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有1+1种，逐步变化成2+2种。下面就以LinkedHashMap+Redis的方案实现本地与远程缓存方案同时使用。\n\n# 纯远程方案\n\n步骤①：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis\n\n<dependency>\n    <groupId>com.alicp.jetcache</groupId>\n    <artifactId>jetcache-starter-redis</artifactId>\n    <version>2.6.2</version>\n</dependency>\n\n\n步骤②：远程方案基本配置\n\njetcache:\n  remote:\n    default:  # 默认方案，其他方案用名字命名\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n\n其中poolConfig是必配项，否则会报错\n\n步骤③：启用缓存，在引导类上方标注注解@EnableCreateCacheAnnotation配置springboot程序中可以使用注解的形式创建缓存\n\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\npublic class Springboot20JetCacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    }\n}\n\n\n步骤④：创建缓存对象Cache，并使用注解@CreateCache标记当前缓存的信息，然后使用Cache对象的API操作缓存，put写缓存，get读缓存。\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n    \n    @CreateCache(name="jetCache_",expire = 10,timeUnit = TimeUnit.SECONDS)  //不设置timeUnit默认单位是秒\n    private Cache<String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    }\n}\n\n\n通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象Cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。\n\n上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：\n\njetcache:\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n\n如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n    \n    @CreateCache(area="sms",name="jetCache_",expire = 10,timeUnit = TimeUnit.SECONDS)\n    private Cache<String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code); // 放入\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = jetCache.get(smsCode.getTele());  // 获取\n        return smsCode.getCode().equals(code);  \n    }\n}\n\n\n# 纯本地方案\n\n远程方案中，配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已。\n\n步骤①：导入springboot整合jetcache对应的坐标starter\n\n<dependency>\n    <groupId>com.alicp.jetcache</groupId>\n    <artifactId>jetcache-starter-redis</artifactId>\n    <version>2.6.2</version>\n</dependency>\n\n\n步骤②：本地缓存基本配置\n\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n\n\n为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个Object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的Object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。\n\n步骤③：启用缓存\n\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\npublic class Springboot20JetCacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    }\n}\n\n\n步骤④：创建缓存对象Cache时，标注当前使用本地缓存\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @CreateCache(name="jetCache_",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.LOCAL)\n    private Cache<String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    }\n    \n    public boolean checkCode(SMSCode smsCode) {\n        String code = jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    }\n}\n\n\ncacheType控制当前缓存使用本地缓存还是远程缓存，配置cacheType=CacheType.LOCAL即使用本地缓存，默认采用远程方案。\n\n# 本地+远程方案\n\n本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一 起就可以了。\n\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n\n在创建缓存的时候，配置cacheType为BOTH即则本地缓存与远程缓存同时使用。\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @CreateCache(name="jetCache_",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.BOTH)\n    private Cache<String ,String> jetCache;\n}\n\n\ncacheType如果不进行配置，默认值是REMOTE，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息\n\n属性                                                         默认值    说明\njetcache.statIntervalMinutes                               0      统计间隔，0表示不统计\njetcache.hiddenPackages                                    无      自动生成name时，隐藏指定的包名前缀\njetcache.[local|remote].${area}.type                       无      缓存类型，本地支持linkedhashmap、caffeine，远程支持redis、tair\njetcache.[local|remote].${area}.keyConvertor               无      key转换器，当前仅支持fastjson\njetcache.[local|remote].${area}.valueEncoder               java   仅remote类型的缓存需要指定，可选java和kryo\njetcache.[local|remote].${area}.valueDecoder               java   仅remote类型的缓存需要指定，可选java和kryo\njetcache.[local|remote].${area}.limit                      100    仅local类型的缓存需要指定，缓存实例最大元素数\njetcache.[local|remote].${area}.expireAfterWriteInMillis   无穷大    默认过期时间，毫秒单位\njetcache.local.${area}.expireAfterAccessInMillis           0      仅local类型的缓存有效，毫秒单位，最大不活动间隔\n\n以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。\n\n方法缓存\n\njetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@Cached即可\n\n步骤①：导入springboot整合jetcache对应的坐标starter\n\n<dependency>\n    <groupId>com.alicp.jetcache</groupId>\n    <artifactId>jetcache-starter-redis</artifactId>\n    <version>2.6.2</version>\n</dependency>\n\n\n步骤②：配置缓存\n\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      keyConvertor: fastjson\n      valueEncode: java\n      valueDecode: java\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n\n\n由于redis缓存中不支持保存对象，因此需要对redis设置当Object类型数据进入到redis中时如何进行类型转换。需要配置keyConvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueEncode为java，值从redis中读取时转换成java，标注valueDecode为java。\n\n注意，为了实现Object类型的值进出redis，需要保障进出redis的Object类型的数据必须实现序列化接口。\n\n@Data\npublic class Book implements Serializable {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n\n\n步骤③：启用缓存时开启方法缓存功能，并配置basePackages，说明在哪些包中开启方法缓存\n\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation \n//开启方法注解缓存\n@EnableMethodCache(basePackages = "com.itheima")\npublic class Springboot20JetCacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    }\n}\n\n\n步骤④：使用注解@Cached标注当前方法使用缓存\n\n@Service\npublic class BookServiceImpl implements BookService {\n    @Autowired\n    private BookDao bookDao;\n    \n    @Override\n    @Cached(name="book_",key="#id",expire = 3600,cacheType = CacheType.REMOTE)\n    public Book getById(Integer id) {\n        return bookDao.selectById(id);\n    }\n}\n\n\n# 远程方案的数据同步\n\n由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据\n\n更新缓存\n\n@CacheUpdate(name="book_",key="#book.id",value="#book")\npublic boolean update(Book book) {\n    return bookDao.updateById(book) > 0;\n}\n\n\n删除缓存\n\n@CacheInvalidate(name="book_",key = "#id")\npublic boolean delete(Integer id) {\n    return bookDao.deleteById(id) > 0;\n}\n\n\n定时刷新缓存\n\n@Cached(name="book_",key="#id",expire = 3600,cacheType = CacheType.REMOTE)\n@CacheRefresh(refresh = 5)\npublic Book getById(Integer id) {\n    return bookDao.selectById(id);\n}\n\n\n# 数据报表\n\njetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可\n\njetcache:\n  statIntervalMinutes: 1\n\n\n设置后，每1分钟在控制台输出缓存数据命中信息\n\n[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003\ncache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\nbook_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\n\n\n总结\n\n 1. jetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案\n 2. jetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种\n 3. 注意数据进入远程缓存时的类型转换问题\n 4. jetcache提供方法缓存，并提供了对应的缓存更新与刷新功能\n 5. jetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况\n\n思考\n\njetcache解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？有，咱们下一节再讲。\n\n# SpringBoot整合j2cache缓存\n\njetcache可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以Ehcache与redis整合为例：\n\n步骤①：导入j2cache、redis、ehcache坐标\n\n<dependency>\n    <groupId>net.oschina.j2cache</groupId>\n    <artifactId>j2cache-core</artifactId>\n    <version>2.8.4-release</version>\n</dependency>\n<dependency>\n    <groupId>net.oschina.j2cache</groupId>\n    <artifactId>j2cache-spring-boot2-starter</artifactId>\n    <version>2.8.0-release</version>\n</dependency>\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n</dependency>\n\n\nj2cache的starter中默认包含了redis坐标，官方推荐使用redis作为二级缓存，因此此处无需导入redis坐标\n\n步骤②：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为j2cache.properties的文件中。如果使用ehcache还需要单独添加ehcache的配置文件\n\n# 这是最基础的配置方法\n# 1级缓存\nj2cache.L1.provider_class = ehcache\nehcache.configXml = ehcache.xml\n\n# 2级缓存\nj2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProvider\nj2cache.L2.config_section = redis\nredis.hosts = localhost :6379\n\n# 1级缓存中的数据如何到达二级缓存\nj2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy\n\n\n此处配置不能乱配置，需要参照官方给出的配置说明进行。例如1级供应商选择ehcache，供应商名称仅仅是一个ehcache，但是2级供应商选择redis时要写专用的Spring整合Redis的供应商类名SpringRedisProvider，而且这个名称并不是所有的redis包中能提供的，也不是spring包中提供的。因此配置j2cache必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。\n\n一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。\n\n步骤③：使用缓存\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n\n    @Autowired\n    private CacheChannel cacheChannel;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        cacheChannel.set("sms",tele,code);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = cacheChannel.get("sms",smsCode.getTele()).asString();\n        return smsCode.getCode().equals(code);\n    }\n}\n\n\nj2cache的使用和jetcache比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名CacheChannel。\n\nj2cache的使用不复杂，配置是j2cache的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅j2cache-core核心包中的j2cache.properties文件中的说明。如下：\n\n#J2Cache configuration\n#########################################\n# Cache Broadcast Method\n# values:\n# jgroups -> use jgroups\'s multicast\n# redis -> use redis publish/subscribe mechanism (using jedis)\n# lettuce -> use redis publish/subscribe mechanism (using lettuce, Recommend)\n# rabbitmq -> use RabbitMQ publisher/consumer mechanism\n# rocketmq -> use RocketMQ publisher/consumer mechanism\n# none -> don\'t notify the other nodes in cluster\n# xx.xxxx.xxxx.Xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.ClusterPolicy\n#########################################\nj2cache.broadcast = redis\n\n# jgroups properties\njgroups.channel.name = j2cache\njgroups.configXml = /network.xml\n\n# RabbitMQ properties\nrabbitmq.exchange = j2cache\nrabbitmq.host = localhost\nrabbitmq.port = 5672\nrabbitmq.username = guest\nrabbitmq.password = guest\n\n# RocketMQ properties\nrocketmq.name = j2cache\nrocketmq.topic = j2cache\n# use ; to split multi hosts\nrocketmq.hosts = 127.0.0.1:9876\n\n#########################################\n# Level 1&2 provider\n# values:\n# none -> disable this level cache\n# ehcache -> use ehcache2 as level 1 cache\n# ehcache3 -> use ehcache3 as level 1 cache\n# caffeine -> use caffeine as level 1 cache(only in memory)\n# redis -> use redis as level 2 cache (using jedis)\n# lettuce -> use redis as level 2 cache (using lettuce)\n# readonly-redis -> use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.L2.config_section` to make the redis configurations available.\n# memcached -> use memcached as level 2 cache (xmemcached),\n# [classname] -> use custom provider\n#########################################\n\nj2cache.L1.provider_class = caffeine\nj2cache.L2.provider_class = redis\n\n# When L2 provider isn\'t `redis`, using `L2.config_section = redis` to read redis configurations\n# j2cache.L2.config_section = redis\n\n# Enable/Disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)\n# NOTICE: redis hash mode (redis.storage = hash) do not support this feature)\nj2cache.sync_ttl_to_redis = true\n\n\n\n# 是否启用二级缓存\nj2cache.l2-cache-open = false\n# Whether to cache null objects by default (default false)\nj2cache.default_cache_null_object = true\n\n#########################################\n# Cache Serialization Provider\n# values:\n# fst -> using fast-serialization (recommend)\n# kryo -> using kryo serialization\n# json -> using fst\'s json serialization (testing)\n# fastjson -> using fastjson serialization (embed non-static class not support)\n# java -> java standard\n# fse -> using fse serialization\n# [classname implements Serializer]\n#########################################\n\nj2cache.serialization = json\n#json.map.person = net.oschina.j2cache.demo.Person\n\n#########################################\n# Ehcache configuration\n#########################################\n\n# ehcache.configXml = /ehcache.xml\n\n# ehcache3.configXml = /ehcache3.xml\n# ehcache3.defaultHeapSize = 1000\n\n#########################################\n# Caffeine configuration\n# caffeine.region.[name] = size, xxxx[s|m|h|d]\n#\n#########################################\ncaffeine.properties = /caffeine.properties\n\n#########################################\n# Redis connection configuration\n#########################################\n\n#########################################\n# Redis Cluster Mode\n#\n# single -> single redis server  # 单机的redis服务器\n# sentinel -> master-slaves servers    # 主从模式服务器\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n# 这个选项没有在文件配置会有warning警告\nredis.mode = single  \n\n#redis storage mode (generic|hash)\nredis.storage = generic\n\n## redis pub/sub channel name\nredis.channel = j2cache\n## redis pub/sub server (using redis.hosts when empty)\nredis.channel.host =\n\n#cluster name just for sharded\nredis.cluster_name = j2cache\n\n## redis cache namespace optional, default[empty] \n## 这个属性可以在Key前面加上一个前缀，默认是空\nredis.namespace =\n\n\n## redis command scan parameter count, default[1000]\n#redis.scanCount = 1000\n\n## connection\n# Separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379\n\nredis.hosts = 127.0.0.1:6379\nredis.timeout = 2000\nredis.password =\nredis.database = 0\nredis.ssl = false\n\n## redis pool properties\nredis.maxTotal = 100\nredis.maxIdle = 10\nredis.maxWaitMillis = 5000\nredis.minEvictableIdleTimeMillis = 60000\nredis.minIdle = 1\nredis.numTestsPerEvictionRun = 10\nredis.lifo = false\nredis.softMinEvictableIdleTimeMillis = 10\nredis.testOnBorrow = true\nredis.testOnReturn = false\nredis.testWhileIdle = true\nredis.timeBetweenEvictionRunsMillis = 300000\nredis.blockWhenExhausted = false\nredis.jmxEnabled = false\n\n#########################################\n# Lettuce scheme\n#\n# redis -> single redis server\n# rediss -> single redis server with ssl\n# redis-sentinel -> redis sentinel\n# redis-cluster -> cluster servers\n#\n#########################################\n\n#########################################\n# Lettuce Mode\n#\n# single -> single redis server\n# sentinel -> master-slaves servers\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n\n## redis command scan parameter count, default[1000]\n#lettuce.scanCount = 1000\nlettuce.mode = single\nlettuce.namespace =\nlettuce.storage = hash\nlettuce.channel = j2cache\nlettuce.scheme = redis\nlettuce.hosts = 127.0.0.1:6379\nlettuce.password =\nlettuce.database = 0\nlettuce.sentinelMasterId =\nlettuce.maxTotal = 100\nlettuce.maxIdle = 10\nlettuce.minIdle = 10\n# timeout in milliseconds\nlettuce.timeout = 10000\n# redis cluster topology refresh interval in milliseconds\nlettuce.clusterTopologyRefresh = 3000\n\n#########################################\n# memcached server configurations\n# refer to https://gitee.com/mirrors/XMemcached\n#########################################\n\nmemcached.servers = 127.0.0.1:11211\nmemcached.username =\nmemcached.password =\nmemcached.connectionPoolSize = 10\nmemcached.connectTimeout = 1000\nmemcached.failureMode = false\nmemcached.healSessionInterval = 1000\nmemcached.maxQueuedNoReplyOperations = 100\nmemcached.opTimeout = 100\nmemcached.sanitizeKeys = false\n\n\n总结\n\n 1. j2cache是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案\n 2. j2cache需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式\n 3. j2cache操作接口通过CacheChannel实现\n\n\n# KF-5-2.任务\n\nspringboot整合第三方技术第二部分我们来说说任务系统，其实这里说的任务系统指的是定时任务。定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。\n\n最简单的是Timer定时任务\n\n\n\n# Quartz\n\nQuartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习springboot整合Quartz前先普及几个Quartz的概念。\n\n * 工作（Job）：用于定义具体执行的工作\n * 工作明细（JobDetail）：用于描述定时工作相关的信息\n * 触发器（Trigger）：描述了工作明细与调度器的对应关系\n * 调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则\n\n简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始springboot整合Quartz。\n\n步骤①：导入springboot整合Quartz的starter\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-quartz</artifactId>\n</dependency>\n\n\n步骤②：定义任务Bean，按照Quartz的开发规范制作，继承QuartzJobBean\n\npublic class MyQuartz extends QuartzJobBean {\n    @Override\n    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n        System.out.println("quartz task run...");\n    }\n}\n\n\n步骤③：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean\n\n@Configuration\npublic class QuartzConfig {\n    @Bean\n    public JobDetail printJobDetail(){\n        //绑定具体的工作\n        // STOREDURABLY用来指定持久化\n        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();\n    }\n    @Bean\n    public Trigger printJobTrigger(){\n        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule("0/5 * * * * ?");\n        //绑定对应的工作明细\n        return TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();\n    }\n}\n\n\n工作明细中要设置对应的具体工作，使用newJob()操作传入对应的工作任务类型即可。\n\n触发器需要绑定任务，使用forJob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是cron表达式（这是什么？查阅一下）。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。\n\n总结\n\n 1. springboot整合Quartz就是将Quartz对应的核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象\n 2. JobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象\n 3. Trigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器\n\n思考\n\n上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring针对上述规则进行了简化，开发了自己的任务管理组件——Task，如何用呢？咱们下节再说。\n\n# Task\n\nspring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做\n\n步骤①：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling\n\n@SpringBootApplication\n//开启定时任务功能\n@EnableScheduling\npublic class Springboot22TaskApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot22TaskApplication.class, args);\n    }\n}\n\n\n步骤②：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式\n\n@Component\npublic class MyBean {\n    @Scheduled(cron = "0/1 * * * * ?")\n    public void print(){\n        System.out.println(Thread.currentThread().getName()+" :spring task run...");\n    }\n}\n\n\n完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。\n\n如何想对定时任务进行相关配置，可以通过配置文件进行\n\nspring:\n  task:\n   \tscheduling:\n      pool:\n       \tsize: 1\t\t\t\t\t\t\t# 任务调度线程池大小 默认 1\n      thread-name-prefix: ssm_      \t# 调度线程名称前缀 默认 scheduling-      \n        shutdown:\n          await-termination: false\t\t# 线程池关闭时等待所有任务完成\n          await-termination-period: 10s\t# 调度线程关闭前最大等待时间，确保最后一定关闭\n\n\n总结\n\n 1. spring task需要使用注解@EnableScheduling开启定时任务功能\n\n 2. 为定时执行的的任务设置执行周期，描述方式cron表达式\n\n\n# KF-5-3.邮件\n\nspringboot整合第三方技术第三部分我们来说说邮件系统，发邮件是java程序的基本操作，springboot整合javamail其实就是简化开发。不熟悉邮件的小伙伴可以先学习完javamail的基础操作，再来看这一部分内容才能感触到springboot整合javamail究竟简化了哪些操作。简化的多码？其实不多，差别不大，只是还个格式而已。\n\n学习邮件发送之前先了解3个概念，这些概念规范了邮件操作过程中的标准。\n\n * SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于发送电子邮件的传输协议（最关注的协议）\n * POP3（Post Office Protocol - Version 3）：用于接收电子邮件的标准协议\n * IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议\n\n简单说就是SMPT是发邮件的标准，POP3是收邮件的标准，IMAP是对POP3的升级。我们制作程序中操作邮件，通常是发邮件，所以SMTP是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如HR的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习springboot如何整合javamail发送邮件。\n\n# 发送简单邮件\n\n步骤①：导入springboot整合javamail的starter\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n\n\n步骤②：配置邮箱的登录信息\n\nspring:\n  mail:\n    host: smtp.126.com\n    username: test@126.com\n    password: test\n\n\njava程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。\n\nhost配置的是提供邮件服务的主机协议（提供邮件的服务商），当前程序仅用于发送邮件，因此配置的是smtp的协议。\n\npassword并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找POP3或IMAP这些关键词找到对应的获取位置。下例仅供参考：\n\n\n\n步骤③：使用JavaMailSender接口发送邮件\n\n@Service\npublic class SendMailServiceImpl implements SendMailService {\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    //发送人\n    private String from = "test@qq.com";\n    //接收人\n    private String to = "test@126.com";\n    //标题\n    private String subject = "测试邮件";\n    //正文\n    private String context = "测试邮件正文内容";\n\n    @Override\n    public void sendMail() {\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(from+"(小甜甜)");\n        message.setTo(to);\n        message.setSubject(subject);\n        message.setText(context);\n        javaMailSender.send(message);\n    }\n}\n\n\n将发送邮件的必要信息（发件人、收件人、标题、正文）封装到SimpleMailMessage对象中，可以根据规则设置发送人昵称等。\n\n# 发送多组件邮件（附件、复杂正文）\n\n发送简单邮件仅需要提供对应的4个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用MimeMessage可以发送特殊的邮件。\n\n发送网页正文邮件\n\n@Service\npublic class SendMailServiceImpl2 implements SendMailService {\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    //发送人\n    private String from = "test@qq.com";\n    //接收人\n    private String to = "test@126.com";\n    //标题\n    private String subject = "测试邮件";\n    //正文\n    private String context = "<img src=\'ABC.JPG\'/><a href=\'https://www.itcast.cn\'>点开有惊喜</a>";\n\n    public void sendMail() {\n        try {\n            // 以下为固定操作\n            MimeMessage message = javaMailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message);\n            helper.setFrom(to+"(小甜甜)");\n            helper.setTo(from);\n            helper.setSubject(subject);\n            helper.setText(context,true);\t\t//此处设置正文支持html解析\n\n            javaMailSender.send(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n发送带有附件的邮件\n\n@Service\npublic class SendMailServiceImpl2 implements SendMailService {\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    //发送人\n    private String from = "test@qq.com";\n    //接收人\n    private String to = "test@126.com";\n    //标题\n    private String subject = "测试邮件";\n    //正文\n    private String context = "测试邮件正文";\n\n    public void sendMail() {\n        try {\n            MimeMessage message = javaMailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message,true);\t\t//此处设置支持附件\n            helper.setFrom(from+"(小甜甜)");\n            helper.setTo(to);\n            helper.setSubject(subject);\n            helper.setText(context);\n\n            //添加附件\n            File f1 = new File("springboot_23_mail-0.0.1-SNAPSHOT.jar");\n            File f2 = new File("resources\\\\logo.png");\n\n            helper.addAttachment(f1.getName(),f1);\n            helper.addAttachment("最靠谱的培训结构.png",f2);\n\n            javaMailSender.send(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n总结\n\n 1. springboot整合javamail其实就是简化了发送邮件的客户端对象JavaMailSender的初始化过程，通过配置的形式加载信息简化开发过程\n\n\n# KF-5-4.消息\n\nspringboot整合第三方技术最后一部分我们来说说消息中间件，首先先介绍一下消息的应用。\n\n# 消息的概念\n\n从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。\n\n为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。\n\n对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到A程序，而A程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。\n\n对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。\n\n所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。\n\n所谓**异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。**比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。\n\n以上简单的介绍了一下消息这种工作模式存在的意义，希望对各位学习者有所帮助。\n\n# Java处理消息的标准规范(也就是在处理消息队列)\n\n目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：\n\n * JMS\n * AMQP\n * MQTT\n\n为什么是三大类，而不是三个技术呢？因为这些都是规范，就想JDBC技术，是个规范，开发针对规范开发，运行还要靠实现类，例如MySQL提供了JDBC的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及\n\n# JMS\n\nJMS（Java Message Service）,这是一个规范，作用等同于JDBC规范，提供了与消息服务相关的API接口。\n\nJMS消息模型\n\nJMS规范中规范了消息有两种模型。分别是点对点模型和发布订阅模型。\n\n点对点模型：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。\n\n发布订阅模型：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。\n\n以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。\n\nJMS消息种类\n\n根据消息中包含的数据种类划分，可以将消息划分成6种消息。\n\n * TextMessage\n * MapMessage\n * BytesMessage\n * StreamMessage\n * ObjectMessage\n * Message （只有消息头和属性）\n\nJMS主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，JMS就是典型的保守派，什么都按照J2EE的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批API。目前对JMS规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如ActiveMQ、Redis、HornetMQ。但是也有一些不太规范的实现，参考JMS的标准设计，但是又不完全满足其规范，例如：RabbitMQ、RocketMQ。\n\n# AMQP\n\nJMS的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如JMS设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于JMS的设计是J2EE规范，站在Java开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.NET开发的系统A，有一个Java开发的系统B，现在要从A系统给B系统发业务消息，结果两边数据格式不统一，没法操作。JMS不是可以统一数据格式吗？提供了6种数据种类，总有一款适合你啊。NO，一个都不能用。因为A系统的底层语言不是Java语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统A继续开发已经不可能了，必须推翻重新做使用Java语言开发的A系统。\n\n这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是AMQP孕育而生。\n\n单从上面的说明中其实可以明确感知到，AMQP的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻JMS的操作API，所以说AMQP仅仅是一种协议，规范了数据传输的格式而已。\n\nAMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范，不是像JMS一样的规范），规范了网络交换的数据格式，兼容JMS操作。 优点\n\n具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现\n\nJMS消息种类\n\nAMQP消息种类：byte[]\n\nAMQP在JMS的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。\n\nAMQP消息模型\n\n * direct exchange\n * fanout exchange\n * topic exchange\n * headers exchange\n * system exchange\n\n目前实现了AMQP协议的消息中间件技术也很多，而且都是较为流行的技术，例如：RabbitMQ、StormMQ、RocketMQ\n\nAMQP用来规范消息传递的格式（炒菜原料），JMS用来规范消息开发的API（炒菜动作）\n\n# MQTT\n\nMQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一。由于与JavaEE企业级开发没有交集，此处不作过多的说明。\n\n除了上述3种J2EE企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，Kafka。\n\n# KafKa\n\n**Kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。**Kafka技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。\n\n本节内容讲围绕着上述内容中的几种实现方案讲解springboot整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用Windows系统安装，降低各位学习者的学习难度，基本套路和之前学习NoSQL解决方案一样，先安装再整合。\n\n# 购物订单发送手机短信案例\n\n为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。\n\n手机验证码案例需求如下：\n\n * 执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单id传递给消息中间件\n\n * 消息处理服务接收到要发送的订单id后输出订单id（模拟发短信）\n   \n   由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：\n\n订单业务\n\n业务层接口\n\npublic interface OrderService {\n    void order(String id);\n}\n\n\n模拟传入订单id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类\n\n业务层实现\n\n@Service\npublic class OrderServiceImpl implements OrderService {\n    @Autowired\n    private MessageService messageService;\n    \n    @Override\n    public void order(String id) {\n        //一系列操作，包含各种服务调用，处理各种业务\n        System.out.println("订单处理开始");\n        //短信消息处理\n        messageService.sendMessage(id);\n        System.out.println("订单处理结束");\n        System.out.println();\n    }\n}\n\n\n业务层转调短信处理的服务MessageService\n\n表现层服务\n\n@RestController\n@RequestMapping("/orders")\npublic class OrderController {\n\n    @Autowired\n    private OrderService orderService;\n\n    @PostMapping("{id}")\n    public void order(@PathVariable String id){\n        orderService.order(id);\n    }\n}\n\n\n表现层对外开发接口，传入订单id即可（模拟）\n\n短信处理业务\n\n业务层接口\n\npublic interface MessageService {\n    void sendMessage(String id);\n    String doMessage();\n}\n\n\n短信处理业务层接口提供两个操作，发送要处理的订单id到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计\n\n业务层实现\n\n@Service\npublic class MessageServiceImpl implements MessageService {\n    private ArrayList<String> msgList = new ArrayList<String>();\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println("待发送短信的订单已纳入处理队列，id："+id);\n        msgList.add(id);\n    }\n\n    @Override\n    public String doMessage() {\n        String id = msgList.remove(0);\n        System.out.println("已完成短信发送业务，id："+id);\n        return id;\n    }\n}\n\n\n短信处理业务层实现中使用集合先模拟消息队列，观察效果\n\n表现层服务\n\n@RestController\n@RequestMapping("/msgs")\npublic class MessageController {\n\n    @Autowired\n    private MessageService messageService;\n\n    @GetMapping\n    public String doMessage(){\n        String id = messageService.doMessage();\n        return id;\n    }\n}\n\n\n短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。\n\n下面开启springboot整合各种各样的消息中间件，从严格满足JMS规范的ActiveMQ开始\n\n# SpringBoot整合ActiveMQ\n\nActiveMQ是MQ产品中的元老级产品，早期标准MQ产品之一，在AMQP协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为AMQP系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。\n\n# 安装\n\nwindows版安装包下载地址：https://activemq.apache.org/components/classic/download/\n\n下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n\n启动服务器\n\nactivemq.bat\n\n\n运行bin目录下的win32或win64目录下的activemq.bat命令即可，根据自己的操作系统选择即可，默认对外服务端口61616。\n\n访问web管理服务\n\nActiveMQ启动后会启动一个Web控制台服务，可以通过该服务管理ActiveMQ。\n\nhttp://127.0.0.1:8161/\n\n\nweb管理服务默认端口8161，访问后可以打开ActiveMQ的管理界面，如下：\n\n首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：\n\n\n\n看到上述界面视为启动ActiveMQ服务成功。\n\n启动失败\n\n在ActiveMQ启动时要占用多个端口，以下为正常启动信息：\n\nwrapper  | --\x3e Wrapper Started as Console\nwrapper  | Launching a JVM...\njvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.org\njvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.\njvm 1    |\njvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   Heap sizes: current=249344k  free=235037k  max=932352k\njvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=7ySrCD75XhLCpLjd -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=9364 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1\njvm 1    | Extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | ACTIVEMQ_HOME: ..\\..\njvm 1    | ACTIVEMQ_BASE: ..\\..\njvm 1    | ACTIVEMQ_CONF: ..\\..\\conf\njvm 1    | ACTIVEMQ_DATA: ..\\..\\data\njvm 1    | Loading message broker from: xbean:activemq.xml\njvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@5f3ebfe0: startup date [Mon Feb 28 16:07:48 CST 2022]; root of context hierarchy\njvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  INFO | KahaDB is version 7\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) is starting\njvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector openwire started\njvm 1    |  INFO | Listening for connections at: amqp://CZBK-20210302VL:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector amqp started\njvm 1    |  INFO | Listening for connections at: stomp://CZBK-20210302VL:61613?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector stomp started\njvm 1    |  INFO | Listening for connections at: mqtt://CZBK-20210302VL:1883?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector mqtt started\njvm 1    |  INFO | Starting Jetty server\njvm 1    |  INFO | Creating Jetty connector\njvm 1    |  WARN | ServletContext@o.e.j.s.ServletContextHandler@7350746f{/,null,STARTING} has uncovered http methods for path: /\njvm 1    |  INFO | Listening for connections at ws://CZBK-20210302VL:61614?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector ws started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) started\njvm 1    |  INFO | For help or more information please see: http://activemq.apache.org\njvm 1    |  WARN | Store limit is 102400 mb (current store usage is 0 mb). The data directory: D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb only has 68936 mb of usable space. - resetting to maximum available disk space: 68936 mb\njvm 1    |  INFO | ActiveMQ WebConsole available at http://127.0.0.1:8161/\njvm 1    |  INFO | ActiveMQ Jolokia REST API available at http://127.0.0.1:8161/api/jolokia/\n\n\n其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动5672端口时端口被占用，显示java.net.BindException: Address already in use: JVM_Bind。Windows系统中终止端口运行的操作参看【命令行启动常见问题及解决方案】\n\nwrapper  | --\x3e Wrapper Started as Console\nwrapper  | Launching a JVM...\njvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.org\njvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.\njvm 1    |\njvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   Heap sizes: current=249344k  free=235038k  max=932352k\njvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=QPJoy9ZoXeWmmwTS -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=14836 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1\njvm 1    | Extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | ACTIVEMQ_HOME: ..\\..\njvm 1    | ACTIVEMQ_BASE: ..\\..\njvm 1    | ACTIVEMQ_CONF: ..\\..\\conf\njvm 1    | ACTIVEMQ_DATA: ..\\..\\data\njvm 1    | Loading message broker from: xbean:activemq.xml\njvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchy\njvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  INFO | KahaDB is version 7\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is starting\njvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector openwire started\njvm 1    | ERROR | Failed to start Apache ActiveMQ (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1)\njvm 1    | java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:28)\njvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2288)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:2769)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:2665)\njvm 1    |      at org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:780)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:742)\njvm 1    |      at org.apache.activemq.broker.BrokerService.start(BrokerService.java:645)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:73)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1748)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1685)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1615)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312)\njvm 1    |      at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\njvm 1    |      at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:756)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\njvm 1    | Caused by: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:34)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:146)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:62)\njvm 1    |      at org.apache.activemq.transport.TransportFactorySupport.bind(TransportFactorySupport.java:40)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:335)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:145)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:110)\njvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2283)\njvm 1    |      ... 46 more\njvm 1    | Caused by: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at java.net.DualStackPlainSocketImpl.bind0(Native Method)\njvm 1    |      at java.net.DualStackPlainSocketImpl.socketBind(DualStackPlainSocketImpl.java:106)\njvm 1    |      at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)\njvm 1    |      at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:190)\njvm 1    |      at java.net.ServerSocket.bind(ServerSocket.java:375)\njvm 1    |      at java.net.ServerSocket.<init>(ServerSocket.java:237)\njvm 1    |      at javax.net.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:231)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:143)\njvm 1    |      ... 52 more\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutting down\njvm 1    |  INFO | socketQueue interrupted - stopping\njvm 1    |  INFO | Connector openwire stopped\njvm 1    |  INFO | Could not accept connection during shutdown  : null (null)\njvm 1    |  INFO | Connector amqp stopped\njvm 1    |  INFO | Connector stomp stopped\njvm 1    |  INFO | Connector mqtt stopped\njvm 1    |  INFO | Connector ws stopped\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] stopped\njvm 1    |  INFO | Stopping async queue tasks\njvm 1    |  INFO | Stopping async topic tasks\njvm 1    |  INFO | Stopped KahaDB\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) uptime 0.426 seconds\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutdown\njvm 1    |  INFO | Closing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchy\njvm 1    |  WARN | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name \'org.apache.activemq.xbean.XBeanBrokerService#0\' defined in class path resource [activemq.xml]: Invocation of init method failed; nested exception is java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    | ERROR: java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call \'refresh\' before accessing beans via the ApplicationContext\njvm 1    | java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call \'refresh\' before accessing beans via the ApplicationContext\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:91)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\njvm 1    | Caused by: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call \'refresh\' before accessing beans via the ApplicationContext\njvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      ... 16 more\njvm 1    | ERROR: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call \'refresh\' before accessing beans via the ApplicationContext\njvm 1    | java.lang.IllegalStateException: BeanFactory not initialized or already closed - call \'refresh\' before accessing beans via the ApplicationContext\njvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\nwrapper  | <-- Wrapper Stopped\n请按任意键继续. . .\n\n\n# 整合\n\n做了这么多springboot整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工\n\n步骤①：导入springboot整合ActiveMQ的starter\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n\n\n步骤②：配置ActiveMQ的服务器地址（带pool的选项用来配置连接池的相关设置）\n\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n  jms:\n  \ttemplate:\n  \t\tdefault-destination: itheima  # 这个选项配置消息的保存位置，converAndSend中的参数也可以指定消息对应的保存位置\n\n\n步骤③：使用JmsMessagingTemplate操作ActiveMQ\n\n@Service\npublic class MessageServiceActivemqImpl implements MessageService {\n    @Autowired\n    private JmsMessagingTemplate messagingTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println("待发送短信的订单已纳入处理队列，id："+id);\n        messagingTemplate.convertAndSend("order.queue.id",id);\n    }\n\n    @Override\n    public String doMessage() {\n        String id = messagingTemplate.receiveAndConvert("order.queue.id",String.class);\n        System.out.println("已完成短信发送业务，id："+id);\n        return id;\n    }\n}\n\n\n发送消息需要先将消息的类型转换成字符串，然后再发送，所以是convertAndSend，定义消息发送的位置，和具体的消息内容，此处使用id作为消息内容。\n\n接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是receiveAndConvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。\n\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@Component\npublic class MessageListener {\n    @JmsListener(destination = "order.queue.id")\n    @SendTo("order.other.queue.id")  // 将返回值传到order.other.queue.id队列中\n    public String receive(String id){\n        System.out.println("已完成短信发送业务，id："+id);\n        return "new:"+id;\n    }\n}\n\n\n使用注解@JmsListener定义当前方法监听ActiveMQ中指定名称的消息队列。\n\n如果当前消息队列处理完的结果还需要继续向下传递当前消息到另一个队列中使用注解@SendTo即可，这样即可构造连续执行的顺序消息队列。\n\n步骤⑤：切换消息模型由点对点模型到发布订阅模型，修改jms配置即可\n\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n  jms:\n    pub-sub-domain: true\n\n\npub-sub-domain默认值为false，即点对点模型，修改为true后就是发布订阅模型。\n\n总结\n\n 1. springboot整合ActiveMQ提供了JmsMessagingTemplate对象作为客户端操作消息队列\n 2. 操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口61616\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@JmsListener\n 4. 配置jms的pub-sub-domain属性可以在点对点模型和发布订阅模型间切换消息模型\n\n# SpringBoot整合RabbitMQ\n\nRabbitMQ是MQ产品中的目前较为流行的产品之一，它遵从AMQP协议。RabbitMQ的底层实现语言使用的是Erlang，所以安装RabbitMQ需要先安装Erlang。\n\nErlang安装\n\nwindows版安装包下载地址：https😕/www.erlang.org/downloads\n\n下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。\n\n安装的过程中可能会出现依赖Windows组件的提示，根据提示下载安装即可，都是自动执行的，如下：\n\n\n\nErlang安装后需要配置环境变量，否则RabbitMQ将无法找到安装的Erlang。需要配置项如下，作用等同JDK配置环境变量的作用。\n\n * ERLANG_HOME\n * PATH\n\n# 安装\n\nwindows版安装包下载地址：https://rabbitmq.com/install-windows.html\n\n下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕后会得到如下文件\n\n启动服务器\n\nrabbitmq-service.bat start\t\t# 启动服务\nrabbitmq-service.bat stop\t\t# 停止服务\nrabbitmqctl status\t\t\t\t# 查看服务状态\n\n\n运行sbin目录下的rabbitmq-service.bat命令即可，start参数表示启动，stop参数表示退出，默认对外服务端口5672。\n\n注意：启动rabbitmq的过程实际上是开启rabbitmq对应的系统服务，需要管理员权限方可执行。\n\n说明：有没有感觉5672的服务端口很熟悉？activemq与rabbitmq有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。\n\n说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到RabbitMQ服务，使用鼠标右键菜单控制服务的启停。\n\n访问web管理服务\n\nRabbitMQ也提供有web控制台服务，但是此功能是一个插件，需要先启用才可以使用。\n\nrabbitmq-plugins.bat list\t\t\t\t\t\t\t# 查看当前所有插件的运行状态\nrabbitmq-plugins.bat enable rabbitmq_management\t\t# 启动rabbitmq_management插件\n\n\n启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面\n\nhttp://localhost:15672\n\n\nweb管理服务默认端口15672，访问后可以打开RabbitMQ的管理界面，如下：\n\n\n\n首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：\n\n\n\n# 整合(direct模型)\n\nRabbitMQ满足AMQP协议，因此不同的消息模型对应的制作不同，先使用最简单的direct模型开发。\n\n步骤①：导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n\n步骤②：配置RabbitMQ的服务器地址\n\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n\n\n步骤③：初始化直连模式系统设置\n\n由于RabbitMQ不同模型要使用不同的交换机，因此需要先初始化RabbitMQ相关的对象，例如队列，交换机等\n\n@Configuration\npublic class RabbitConfigDirect {\n    \n    // 消息队列1\n    @Bean\n    public Queue directQueue(){\n        return new Queue("direct_queue");\n    }\n    // 消息队列2\n    @Bean\n    public Queue directQueue2(){\n        return new Queue("direct_queue2");\n    }\n    \n    // 交换机\n    @Bean\n    public DirectExchange directExchange(){\n        return new DirectExchange("directExchange");\n    }\n    \n    // 绑定交换机和消息队列1\n    @Bean\n    public Binding bindingDirect(){\n        return BindingBuilder.bind(directQueue()).to(directExchange()).with("direct");\n    }\n    // 绑定交换机和消息队列2\n    @Bean\n    public Binding bindingDirect2(){\n        return BindingBuilder.bind(directQueue2()).to(directExchange()).with("direct2");\n    }\n}\n\n\n队列Queue与直连交换机DirectExchange创建后，还需要绑定他们之间的关系Binding，这样就可以通过交换机操作对应队列。\n\n步骤④：使用AmqpTemplate操作RabbitMQ\n\n@Service\npublic class MessageServiceRabbitmqDirectImpl implements MessageService {\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println("待发送短信的订单已纳入处理队列（rabbitmq direct），id："+id);\n        amqpTemplate.convertAndSend("directExchange","direct",id);  // 第一个参数为交换机名称，第二个参数为交换机和消息队列绑定的名称， 第三个参数为具体的消息\n    }\n}\n\n\namqp协议中的操作API接口名称看上去和jms规范的操作API接口很相似，但是传递参数差异很大。\n\n步骤⑤：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@Component\npublic class MessageListener {\n    @RabbitListener(queues = "direct_queue")\n    public void receive(String id){\n        System.out.println("已完成短信发送业务(rabbitmq direct)，id："+id);\n    }\n}\n\n\n使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n\n# 整合(topic模型)\n\n步骤①：同上\n\n步骤②：同上\n\n步骤③：初始化主题模式系统设置\n\n@Configuration\npublic class RabbitConfigTopic {\n    @Bean\n    public Queue topicQueue(){\n        return new Queue("topic_queue");\n    }\n    @Bean\n    public Queue topicQueue2(){\n        return new Queue("topic_queue2");\n    }\n    @Bean\n    public TopicExchange topicExchange(){\n        return new TopicExchange("topicExchange");\n    }\n    @Bean\n    public Binding bindingTopic(){\n        return BindingBuilder.bind(topicQueue()).to(topicExchange()).with("topic.*.id");\n    }\n    @Bean\n    public Binding bindingTopic2(){\n        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with("topic.orders.*");\n    }\n}\n\n\n*主题模式支持routingKey匹配模式，表示匹配一个单词，#表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看RabbitMQ系列课程。\n\n匹配键                 TOPIC.*.*   TOPIC.#\ntopic.order.id      true        true\norder.topic.id      false       false\ntopic.sm.order.id   false       true\ntopic.sm.id         false       true\ntopic.id.order      true        true\ntopic.id            false       true\ntopic.order         false       true\n\ntopic.sm.id和topic.id.order中在topic.*.*的匹配中是有区别的吗？记得看一下对应的匹配规则\n\n步骤④：使用AmqpTemplate操作RabbitMQ\n\n@Service\npublic class MessageServiceRabbitmqTopicImpl implements MessageService {\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println("待发送短信的订单已纳入处理队列（rabbitmq topic），id："+id);\n        amqpTemplate.convertAndSend("topicExchange","topic.orders.id",id);\n    }\n}\n\n\n发送消息后，根据当前提供的routingKey与绑定交换机时设定的routingKey进行匹配，规则匹配成功消息才会进入到对应的队列中。如果消息匹配到多个队列，他会同时进入多个队列\n\n步骤⑤：使用消息监听器在服务器启动后，监听指定队列\n\n@Component\npublic class MessageListener {\n    @RabbitListener(queues = "topic_queue")\n    public void receive(String id){\n        System.out.println("已完成短信发送业务(rabbitmq topic 1)，id："+id);\n    }\n    @RabbitListener(queues = "topic_queue2")\n    public void receive2(String id){\n        System.out.println("已完成短信发送业务(rabbitmq topic 22222222)，id："+id);\n     \n}\n\n\n使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n\n总结\n\n 1. springboot整合RabbitMQ提供了AmqpTemplate对象作为客户端操作消息队列\n 2. 操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口5672\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RabbitListener\n 4. RabbitMQ有5种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同\n\n# SpringBoot整合RocketMQ\n\nRocketMQ由阿里研发，后捐赠给apache基金会，目前是apache基金会顶级项目之一，也是目前市面上的MQ产品中较为流行的产品之一，它遵从AMQP协议。\n\n# 安装\n\nwindows版安装包下载地址：https://rocketmq.apache.org/\n\n下载完毕后得到zip压缩文件，解压缩即可使用，解压后得到如下文件\n\n\n\nRocketMQ安装后需要配置环境变量，具体如下：\n\n * ROCKETMQ_HOME\n * PATH\n * NAMESRV_ADDR （建议）： 127.0.0.1:9876\n\n关于NAMESRV_ADDR对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习RocketMQ知识后即可灵活控制该项。\n\nRocketMQ工作模式\n\n在RocketMQ中，处理业务的服务器称为broker，生产者与消费者不是直接与broker联系的，而是通过命名服务器进行通信。broker启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的broker信息。当生产者与消费者需要连接broker时，通过命名服务器找到对应的处理业务的broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且broker启动前必须保障命名服务器先启动。\n\n启动服务器\n\nmqnamesrv\t\t# 启动命名服务器\nmqbroker\t\t# 启动broker\n\n\n运行bin目录下的mqnamesrv命令即可启动命名服务器，默认对外服务端口9876。\n\n运行bin目录下的mqbroker命令即可启动broker服务器，如果环境变量中没有设置NAMESRV_ADDR则需要在运行mqbroker指令前通过set指令设置NAMESRV_ADDR的值，并且每次开启均需要设置此项。\n\n测试服务器启动状态\n\nRocketMQ提供有一套测试服务器功能的测试程序，运行bin目录下的tools命令即可使用。Producer正确执行如下图所示\n\ntools org.apache.rocketmq.example.quickstart.Producer\t\t# 生产消息\ntools org.apache.rocketmq.example.quickstart.Consumer\t\t# 消费消息\n\n\n\n\n\n\n# 整合（异步消息）\n\n步骤①：导入springboot整合RocketMQ的starter，此坐标不由springboot维护版本\n\n<dependency>\n    <groupId>org.apache.rocketmq</groupId>\n    <artifactId>rocketmq-spring-boot-starter</artifactId>\n    <version>2.2.1</version>\n</dependency>\n\n\n步骤②：配置RocketMQ的服务器地址\n\nrocketmq:\n  name-server: localhost:9876\n  producer:\n    group: group_rocketmq   # 设置默认的生产者消费者所属组group\n\n\n\n\n步骤③：使用RocketMQTemplate操作RocketMQ\n\n@Service\npublic class MessageServiceRocketmqImpl implements MessageService {\n    @Autowired\n    private RocketMQTemplate rocketMQTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println("待发送短信的订单已纳入处理队列（rocketmq），id："+id);\n        SendCallback callback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                System.out.println("消息发送成功");\n            }\n            @Override\n            public void onException(Throwable e) {\n                System.out.println("消息发送失败！！！！！");\n            }\n        };\n        rocketMQTemplate.asyncSend("order_id",id,callback);\n    }\n}\n\n\n\n使用asyncSend方法发送异步消息。\n\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@Component\n@RocketMQMessageListener(topic = "order_id",consumerGroup = "group_rocketmq")  // 至少给定左边的两个参数\npublic class MessageListener implements RocketMQListener<String> {\n    @Override\n    public void onMessage(String id) {\n        System.out.println("已完成短信发送业务(rocketmq)，id："+id);\n    }\n}\n\n\nRocketMQ的监听器必须按照标准格式开发，实现RocketMQListener接口，泛型为消息类型。\n\n使用注解@RocketMQMessageListener定义当前类监听RabbitMQ中指定名称的消息队列和指定组。\n\n总结\n\n 1. springboot整合RocketMQ使用RocketMQTemplate对象作为客户端操作消息队列\n 2. 操作RocketMQ需要配置RocketMQ服务器地址，默认端口9876\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RocketMQMessageListener\n\n# SpringBoot整合Kafka\n\n# 安装\n\nwindows版安装包下载地址：https://kafka.apache.org/downloads\n\n下载完毕后得到tgz压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件\n\n\n\n建议使用windows版2.8.1版本。（3.x.x版本在windows上有些小问题，但是在linux上没问题）\n\n启动服务器\n\nkafka服务器的功能相当于RocketMQ中的broker，kafka运行还需要一个类似于命名服务器的服务。在kafka安装目录中自带一个类似于命名服务器的工具，叫做zookeeper，它的作用是注册中心，相关知识请到对应课程中学习。\n\nzookeeper-server-start.bat ..\\..\\config\\zookeeper.properties\t\t# 启动zookeeper\nkafka-server-start.bat ..\\..\\config\\server.properties\t\t\t\t# 启动kafka\n\n\n运行bin目录下的windows目录下的zookeeper-server-start命令即可启动注册中心，默认对外服务端口2181。\n\n运行bin目录下的windows目录下的kafka-server-start命令即可启动kafka服务器，默认对外服务端口9092。\n\n创建主题\n\n和之前操作其他MQ产品相似，kakfa也是基于主题操作，操作之前需要先初始化topic。\n\n# 创建topic\nkafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic itheima\n# 查询topic\nkafka-topics.bat --zookeeper 127.0.0.1:2181 --list\t\t\t\t\t\n# 删除topic\nkafka-topics.bat --delete --zookeeper localhost:2181 --topic itheima\n\n\n测试服务器启动状态\n\nKafka提供有一套测试服务器功能的测试程序，运行bin目录下的windows目录下的命令即可使用。\n\n生产者启动之后再启动消费者\n\nkafka-console-producer.bat --broker-list localhost:9092 --topic itheima\t\t\t\t\t\t\t# 测试生产消息\nkafka-console-consumer.bat --bootstrap-server localhost:9092 --topic itheima --from-beginning\t# 测试消息消费\n\n\n# 整合\n\n步骤①：导入springboot整合Kafka的starter，此坐标由springboot维护版本\n\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n\n\n步骤②：配置Kafka的服务器地址\n\nspring:\n  kafka:\n    bootstrap-servers: localhost:9092\n    consumer:\n      group-id: order\n\n\n设置默认的生产者消费者所属组id。\n\n步骤③：使用KafkaTemplate操作Kafka\n\n@Service\npublic class MessageServiceKafkaImpl implements MessageService {\n    @Autowired\n    private KafkaTemplate<String,String> kafkaTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println("待发送短信的订单已纳入处理队列（kafka），id："+id);\n        kafkaTemplate.send("itheima2022",id);\n    }\n}\n\n\n使用send方法发送消息，需要传入topic名称。\n\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@Component\npublic class MessageListener {\n    @KafkaListener(topics = "itheima2022")\n    public void onMessage(ConsumerRecord<String,String> record){\n        System.out.println("已完成短信发送业务(kafka)，id："+record.value());\n    }\n}\n\n\n使用注解@KafkaListener定义当前方法监听Kafka中指定topic的消息，接收到的消息封装在对象ConsumerRecord中，获取数据从ConsumerRecord对象中获取即可。\n\n总结\n\n 1. springboot整合Kafka使用KafkaTemplate对象作为客户端操作消息队列\n\n 2. 操作Kafka需要配置Kafka服务器地址，默认端口9092\n\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@KafkaListener。接收消息保存在形参ConsumerRecord对象中\n\n\n# KF-6.监控\n\n在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。\n\n什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。\n\n本章要讲解的监控就是对软件的运行情况进行监督，但是springboot程序与非springboot程序的差异还是很大的，为了方便监控软件的开发，springboot提供了一套功能接口，为开发者加速开发过程。\n\n\n# KF-6-1.监控的意义\n\n对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是监控服务状态是否处理宕机状态。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，监控服务运行指标。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，监控程序运行日志。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，管理服务状态。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。\n\n通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有3个服务支撑着一个程序的运行，每个服务都有自己的运行状态。\n\n此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成30个，300个，3000个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。\n\n新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。\n\n如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。\n\n被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。\n\n以上描述的整个过程就是一个监控系统的基本流程。\n\n总结\n\n 1. 监控是一个非常重要的工作，是保障程序正常运行的基础手段\n 2. 监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示\n 3. 被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控\n\n思考\n\n下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控，咱们下节再讲。\n\n\n# KF-6-2.可视化监控平台\n\nspringboot抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于springboot监控的核心思想制作的，所以这个程序被命名为Spring Boot Admin。java自带的监控平台为Jconsole\n\nSpring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。\n\n下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个web程序，收到一些信息后展示这些信息。\n\n服务端开发\n\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-server</artifactId>\n    <version>2.5.4</version>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n上述过程可以通过创建项目时使用勾选的形式完成。\n\n步骤②：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用\n\n@SpringBootApplication\n@EnableAdminServer\npublic class Springboot25AdminServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot25AdminServerApplication.class, args);\n    }\n}\n\n\n做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。\n\n由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。\n\n客户端开发\n\n客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。\n\n\n\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-client</artifactId>\n    <version>2.5.4</version>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。\n\n步骤②：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置\n\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\n\n\n做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。\n\n可以看到，当前监控了1个程序，点击进去查看详细信息。\n\n由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。\n\n 1. 开放指定信息给服务器看\n\n 2. 允许服务器以HTTP请求的方式获取对应的信息\n    \n    配置如下：\n\nserver:\n  port: 80\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n\n\n上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过HTTP请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。\n\n但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。\n\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n\n\n健康明细信息如下：\n\n目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过HTTP请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。\n\nendpoints:\n  web:\n    exposure:\n      include: "*"\n\n\n配置后再刷新服务器页面，就可以看到所有的信息了。\n\n以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。\n\n配置多个客户端\n\n可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。\n\n进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。\n\n * 类加载面板中可以查阅到开发者自定义的类，如左图\n\n\n\n * 映射中可以查阅到当前应用配置的所有请求\n\n\n\n * 性能指标中可以查阅当前应用独有的请求路径统计数据\n\n\n\n总结\n\n 1. 开发监控服务端需要导入坐标，然后在引导类上添加注解@EnableAdminServer，并将其配置成web程序即可\n 2. 开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可\n 3. 在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标\n\n思考\n\n之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？咱们下一节再讲。\n\n\n# KF-6-3.监控原理\n\n通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以/actuator开头\n\n首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。\n\n\n\n通过发送请求，可以得到一组json信息，如下\n\n{\n    "_links": {\n        "self": {\n            "href": "http://localhost:81/actuator",\n            "templated": false\n        },\n        "beans": {\n            "href": "http://localhost:81/actuator/beans",\n            "templated": false\n        },\n        "caches-cache": {\n            "href": "http://localhost:81/actuator/caches/{cache}",\n            "templated": true\n        },\n        "caches": {\n            "href": "http://localhost:81/actuator/caches",\n            "templated": false\n        },\n        "health": {\n            "href": "http://localhost:81/actuator/health",\n            "templated": false\n        },\n        "health-path": {\n            "href": "http://localhost:81/actuator/health/{*path}",\n            "templated": true\n        },\n        "info": {\n            "href": "http://localhost:81/actuator/info",\n            "templated": false\n        },\n        "conditions": {\n            "href": "http://localhost:81/actuator/conditions",\n            "templated": false\n        },\n        "shutdown": {\n            "href": "http://localhost:81/actuator/shutdown",\n            "templated": false\n        },\n        "configprops": {\n            "href": "http://localhost:81/actuator/configprops",\n            "templated": false\n        },\n        "configprops-prefix": {\n            "href": "http://localhost:81/actuator/configprops/{prefix}",\n            "templated": true\n        },\n        "env": {\n            "href": "http://localhost:81/actuator/env",\n            "templated": false\n        },\n        "env-toMatch": {\n            "href": "http://localhost:81/actuator/env/{toMatch}",\n            "templated": true\n        },\n        "loggers": {\n            "href": "http://localhost:81/actuator/loggers",\n            "templated": false\n        },\n        "loggers-name": {\n            "href": "http://localhost:81/actuator/loggers/{name}",\n            "templated": true\n        },\n        "heapdump": {\n            "href": "http://localhost:81/actuator/heapdump",\n            "templated": false\n        },\n        "threaddump": {\n            "href": "http://localhost:81/actuator/threaddump",\n            "templated": false\n        },\n        "metrics-requiredMetricName": {\n            "href": "http://localhost:81/actuator/metrics/{requiredMetricName}",\n            "templated": true\n        },\n        "metrics": {\n            "href": "http://localhost:81/actuator/metrics",\n            "templated": false\n        },\n        "scheduledtasks": {\n            "href": "http://localhost:81/actuator/scheduledtasks",\n            "templated": false\n        },\n        "mappings": {\n            "href": "http://localhost:81/actuator/mappings",\n            "templated": false\n        }\n    }\n}\n\n\n其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息\n\n{\n    "status": "UP",\n    "components": {\n        "diskSpace": {\n            "status": "UP",\n            "details": {\n                "total": 297042808832,\n                "free": 72284409856,\n                "threshold": 10485760,\n                "exists": true\n            }\n        },\n        "ping": {\n            "status": "UP"\n        }\n    }\n}\n\n\n当前信息与监控面板中的数据存在着对应关系\n\n** 原来监控中显示的信息实际上是通过发送地址请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以/actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。**\n\n到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。\n\n\n\n这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。\n\nActuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**/actuator可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求/actuator/端点名称**来获取详细信息。以下列出了所有端点信息说明：（加粗的是我们经常关注的信息）\n\nID                 描述                                                             默认启用\nauditevents        暴露当前应用程序的审计事件信息。                                               是\nbeans              显示应用程序中所有 Spring bean 的完整列表。                                   是\ncaches             暴露可用的缓存。                                                       是\nconditions         显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。                                是\nconfigprops        显示所有 @ConfigurationProperties 的校对清单。                           是\nenv                暴露 Spring ConfigurableEnvironment 中的属性。                        是\nflyway             显示已应用的 Flyway 数据库迁移。                                           是\nhealth             显示应用程序健康信息                                                     是\nhttptrace          显示 HTTP 追踪信息（默认情况下，最后 100 个 HTTP 请求/响应交换）。                     是\ninfo               显示应用程序信息。                                                      是\nintegrationgraph   显示 Spring Integration 图。                                       是\nloggers            显示和修改应用程序中日志记录器的配置。                                            是\nliquibase          显示已应用的 Liquibase 数据库迁移。                                        是\nmetrics            显示当前应用程序的指标度量信息。                                               是\nmappings           显示所有 @RequestMapping 路径的整理清单。                                  是\nscheduledtasks     显示应用程序中的调度任务。                                                  是\nsessions           允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式   是\n                   Web 应用程序支持时不可用。\nshutdown           正常关闭应用程序。                                                      否\nthreaddump         执行线程 dump。                                                     是\nheapdump           返回一个 hprof 堆 dump 文件。                                          是\njolokia            通过 HTTP 暴露 JMX bean（当 Jolokia 在 classpath 上时，不适用于 WebFlux）。    是\nlogfile            返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP      是\n                   Range 头来检索部分日志文件的内容。\nprometheus         以可以由 Prometheus 服务器抓取的格式暴露指标。                                  是\n\n上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。\n\n注：这里如果不开放端点接口，即使web端include “*”也不能查询信息.\n\n注：端点的开放分为后端端点和WEB端点两种，都要分别配置\n\nmanagement:\n  endpoint:\n    health:\t\t\t\t\t\t# 端点名称\n      show-details: always\n    info:\t\t\t\t\t\t# 端点名称\n      enabled: true\t\t\t\t# 是否开放\n\n\n为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：\n\nmanagement:\n  endpoints:\n    enabled-by-default: true\t# 是否开启默认端点，默认值true\n\n\n上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"  # 开放所有端点\n        # include: health, info  # 开放health和info两个端点，这里配置的是只能在WEB看到的信息\n\n\n整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。\n\nmanagement:\n  endpoint:\t\t# 具体端点的配置\n    health:\n      show-details: always\n    info:\n      enabled: true\n  endpoints:\t# 全部端点的配置\n    web:\n      exposure:\n        include: "*"\n    enabled-by-default: true\n\n\n\n\n\n\n\n\n总结\n\n 1. 被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能\n\n 2. 端点功能的开放与关闭可以通过配置进行控制\n\n 3. web端默认无法获取所有端点信息，通过配置开放端点功能\n\n\n# KF-6-4.自定义监控指标\n\n端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。\n\nINFO端点\n\ninfo端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息\n\n * 配置形式\n   \n   在yml文件中通过设置info节点的信息就可以快速配置端点信息\n   \n   info:\n     appName: @project.artifactId@\n     version: @project.version@\n     company: 传智教育\n     author: itheima\n   \n   \n   配置完毕后，对应信息显示在监控平台上\n   \n   也可以通过请求端点信息路径获取对应json信息\n\n * 编程形式\n   \n   通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存\n   \n   @Component\n   public class InfoConfig implements InfoContributor {\n       @Override\n       public void contribute(Info.Builder builder) {  // Builder就是里面加各种信息\n           builder.withDetail("runTime",System.currentTimeMillis());\t\t//添加单个信息\n           Map infoMap = new HashMap();\t\t\n           infoMap.put("buildTime","2006");\n           builder.withDetails(infoMap);\t\t\t\t\t\t\t\t\t//添加一组信息\n       }\n   }\n   \n\nHealth端点\n\nhealth端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。\n\n@Component\npublic class HealthConfig extends AbstractHealthIndicator {\n    @Override\n    protected void doHealthCheck(Health.Builder builder) throws Exception {\n        boolean condition = true;\n        if(condition) {\n            builder.status(Status.UP);\t\t\t\t\t//设置运行状态为启动状态\n            builder.withDetail("runTime", System.currentTimeMillis());\n            Map infoMap = new HashMap();\n            infoMap.put("buildTime", "2006");\n            builder.withDetails(infoMap);\n        }else{\n            builder.status(Status.OUT_OF_SERVICE);\t\t//设置运行状态为不在服务状态\n            builder.withDetail("上线了吗？","你做梦");\n        }\n    }\n}\n\n\n当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。\n\nMetrics端点\n\nmetrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。\n\n@Service\npublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService {\n    @Autowired\n    private BookDao bookDao;\n\n    private Counter counter;\n\n    public BookServiceImpl(MeterRegistry meterRegistry){\n        counter = meterRegistry.counter("用户付费操作次数：");\n    }\n\n    @Override\n    public boolean delete(Integer id) {\n        //每次执行删除业务等同于执行了付费业务\n        counter.increment();\n        return bookDao.deleteById(id) > 0;\n    }\n}\n\n\n在性能指标中就出现了自定义的性能指标监控项\n\n自定义端点\n\n可以根据业务需要自定义端点，方便业务监控\n\n@Component\n@Endpoint(id="pay",enableByDefault = true)\npublic class PayEndpoint {\n    @ReadOperation\n    public Object getPay(){\n        Map payMap = new HashMap();\n        payMap.put("level 1","300");\n        payMap.put("level 2","291");\n        payMap.put("level 3","666");\n        return payMap;\n    }\n}\n\n\n由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。\n\n总结\n\n 1. 端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同\n 2. info端点通过配置和编程的方式都可以添加端点指标\n 3. health端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定\n 4. metrics指标通过在业务中添加监控操作设置指标\n 5. 可以自定义端点添加更多的指标\n\n\n# 开发实用篇完结\n\n开发实用篇到这里就暂时完结了，在开发实用篇中我们讲解了大量的第三方技术的整合方案，选择的方案都是市面上比较流行的常用方案，还有一些国内流行度较低的方案目前还没讲，留到番外篇中慢慢讲吧。\n\n整体开发实用篇中讲解的内容可以分为两大类知识：实用性知识与经验性知识。\n\n实用性知识就是新知识了，springboot整合各种技术，每种技术整合中都有一些特殊操作，整体来说其实就是三句话。加坐标做配置调接口。经验性知识是对前面两篇中出现的一些知识的补充，在学习基础篇时如果将精力放在这些东西上就有点学偏了，容易钻牛角尖，放到实用开发篇中结合实际开发说一些不常见的但是对系统功能又危害的操作解决方案，提升理解。\n\n开发实用篇做到这里就告一段落，下面就要着手准备原理篇了。市面上很多课程原理篇讲的过于高深莫测，在新手还没明白123的时候就开始讲微积分了，着实让人看了着急。至于原理篇我讲成什么样子？一起期待吧。',normalizedContent:'# springboot开发实用篇\n\n怀着忐忑的心情，开始了开发实用篇文档的编写。为什么忐忑？特喵的债欠的太多，不知道从何写起。哎，不煽情了，开工。\n\n运维实用篇完结以后，开发实用篇采用日更新的形式发布给各位小伙伴，基本上是每天一集，目前已经发布完毕。看评论区，好多小伙伴在求文档，所以赶紧来补文档，加班加点把开发实用篇的文档刨出来。\n\n开发实用篇中因为牵扯到springboot整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：\n\n * 热部署\n * 配置高级\n * 测试\n * 数据层解决方案\n * 整合第三方技术\n * 监控\n\n看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习\n\n\n# kf-1.热部署\n\n什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。\n\n热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。\n\n非springboot项目热部署实现原理\n\n开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么ide工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过ide工具进行配置，比如在idea工具中进行设置，这种形式需要依赖ide工具，每款ide工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。\n\n上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串"abc"改成"cba"，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。\n\n看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。\n\nspringboot项目热部署实现原理\n\n基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序x在spring容器中盯着你原始开发的程序a不就行了吗？确实，搞一个盯着程序a的程序x就行了，如果你自己开发的程序a变化了，那么程序x就命令tomcat容器重新加载程序a就ok了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。\n\n下面就说说，怎么搞出来这么一个程序x，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。\n\n\n# kf-1-1.手动启动热部署\n\n步骤①：导入开发者工具对应的坐标\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-devtools</artifactid>\n    <optional>true</optional>\n</dependency>\n\n\n步骤②：构建项目，可以使用快捷键激活此功能\n\n\n\n对应的快捷键一定要记得\n\n<ctrl>+<f9>\n\n\n以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。\n\n重启与重载\n\n一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。\n\n * base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化\n * restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响\n\n当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。\n\n总结\n\n 1. 使用开发者工具可以为当前项目开启热部署功能\n 2. 使用构建项目操作对工程进行热部署\n\n思考\n\n上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就ok了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。\n\n\n\n\n# kf-1-2.自动启动热部署\n\n自动热部署其实就是设计一个开关，打开这个开关后，ide工具就可以自动热部署。因此这个操作和ide工具有关，以下以idea为例设置idea中启动热部署\n\n步骤①：设置自动构建项目\n\n打开【file】，选择【settings...】,在面板左侧的菜单中找到【compile】选项，然后勾选【build project automatically】，意思是自动构建项目\n\n\n\n自动构建项目选项勾选后\n\n步骤②：允许在程序运行时进行自动构建\n\n使用快捷键【ctrl】+【alt】+【shit】+【/】打开维护面板，选择第1项【registry...】\n\n\n\n在选项中搜索comple，然后勾选对应项即可\n\n这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。\n\n关注：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点(鼠标离开)5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。\n\n总结\n\n 1. 自动热部署要开启自动构建项目\n 2. 自动热部署要开启在程序运行时自动构建项目\n\n思考\n\n现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？咱们下一节再说。\n\n\n# kf-1-3.参与热部署监控的文件范围配置\n\n通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下\n\n * /meta-inf/maven\n * /meta-inf/resources\n * /resources\n * /static\n * /public\n * /templates\n\n以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作\n\nspring:\n  devtools:\n    restart:\n      # 设置不参与热部署的文件或文件夹\n      exclude: static/**,public/**,config/application.yml\n\n\n总结\n\n 1. 通过配置可以修改不参与热部署的文件或目录\n\n思考\n\n热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。\n\n\n# kf-1-4.关闭热部署\n\n线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。\n\nspring:\n  devtools:\n    restart:\n      enabled: false\n\n\n如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。\n\n@springbootapplication\npublic class ssmpapplication {\n    public static void main(string[] args) {\n        system.setproperty("spring.devtools.restart.enabled","false");\n        springapplication.run(ssmpapplication.class);\n    }\n}\n\n\n其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。\n\n总结\n\n 1. 通过配置可以关闭热部署功能降低线上程序的资源消耗\n\n\n# kf-2.配置高级\n\n进入开发实用篇第二章内容，配置高级，其实配置在基础篇讲了一部分，在运维实用篇讲了一部分，这里还要讲，讲的东西有什么区别呢？距离开发过程越来越接近，解决的问题也越来越靠近线上环境，下面就开启本章的学习。\n\n\n# kf-2-1.@configurationproperties\n\n在基础篇学习了@configurationproperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性\n\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n\n\n然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法\n\n@component\n@data\npublic class serverconfig {\n    private string ipaddress;\n    private int port;\n    private long timeout;\n}\n\n\n使用@configurationproperties注解就可以将配置中的属性值关联到开发的模型类上\n\n@component\n@data\n@configurationproperties(prefix = "servers")\npublic class serverconfig {\n    private string ipaddress;\n    private int port;\n    private long timeout;\n}\n\n\n这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@configurationproperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@configurationproperties注解，这种问题该怎么解决呢？下面就来说说这个问题。\n\n使用@configurationproperties注解其实可以为第三方bean加载属性，格式特殊一点而已。\n\n步骤①：使用@bean注解定义第三方bean\n\n@bean\npublic druiddatasource datasource(){\n    druiddatasource ds = new druiddatasource();\n    return ds;\n}\n\n\n步骤②：在yml中定义要绑定的属性，注意datasource此时全小写\n\ndriverclassname用于指定driverclassname属性\n\ndatasource:\n  driverclassname: com.mysql.jdbc.driver\n\n\n步骤③：使用@configurationproperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource\n\n@bean\n@configurationproperties(prefix = "datasource")\npublic druiddatasource datasource(){\n    druiddatasource ds = new druiddatasource();\n    return ds;\n}\n\n\n操作方式完全一样，只不过@configurationproperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。\n\n做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@bean定义，使用@configurationproperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@configurationproperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@configurationproperties注解绑定属性的bean是哪些。这个注解叫做@enableconfigurationproperties。具体如何使用呢？\n\n步骤①：在配置类上开启@enableconfigurationproperties注解，并标注要使用@configurationproperties注解绑定属性的类\n\n@springbootapplication\n@enableconfigurationproperties(serverconfig.class)\npublic class springboot13configurationapplication {\n}\n\n\n步骤②：在对应的类上直接使用@configurationproperties进行属性绑定\n\n@data\n@configurationproperties(prefix = "servers")\npublic class serverconfig {\n    private string ipaddress;\n    private int port;\n    private long timeout;\n}\n\n\n有人感觉这没区别啊？注意观察，现在绑定属性的serverconfig类并没有声明@component注解。当使用@enableconfigurationproperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@component注解了。\n\n最后再说一个小技巧，使用@configurationproperties注解时，会出现一个提示信息\n\n\n\n出现这个提示后只需要添加一个坐标此提醒就消失了\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-configuration-processor</artifactid>\n</dependency>\n\n\n总结\n\n 1. 使用@configurationproperties可以为使用@bean声明的第三方bean绑定属性\n 2. 当使用@enableconfigurationproperties声明进行属性绑定的bean后，无需使用@component注解再次进行bean声明\n\n\n# kf-2-2.宽松绑定/松散绑定\n\n在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为datasource，如下：\n\ndatasource:\n  driverclassname: com.mysql.jdbc.driver\n\n\n此时程序可以正常运行，然后又将代码中的前缀datasource修改为datasource，如下：\n\n@bean\n@configurationproperties(prefix = "datasource")\npublic druiddatasource datasource(){\n    druiddatasource ds = new druiddatasource();\n    return ds;\n}\n\n\n此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名datasource是无效的\n\nconfiguration property name \'datasource\' is not valid:\n\n    invalid characters: \'s\'\n    bean: datasource\n    reason: canonical names should be kebab-case (\'-\' separated), lowercase alpha-numeric characters and must start with a letter\n\naction:\nmodify \'datasource\' so that it conforms to the canonical names requirements.\n\n\n为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。\n\n什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：\n\n在serverconfig中的ipaddress属性名\n\n@component\n@data\n@configurationproperties(prefix = "servers")\npublic class serverconfig {\n    private string ipaddress;\n}\n\n\n可以与下面的配置属性名规则全兼容\n\nservers:\n  ipaddress: 192.168.0.2       # 驼峰模式\n  ip_address: 192.168.0.2      # 下划线模式\n  ip-address: 192.168.0.2      # 烤肉串模式\n  ip_address: 192.168.0.2      # 常量模式\n\n\n也可以说，以上4种模式最终都可以匹配到ipaddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。\n\n到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息\n\nconfiguration property name \'datasource\' is not valid:\n\n    invalid characters: \'s\'\n    bean: datasource\n    reason: canonical names should be kebab-case (\'-\' separated), lowercase alpha-numeric characters and must start with a letter\n\naction:\nmodify \'datasource\' so that it conforms to the canonical names requirements.\n\n\n其中reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头（绑定前缀名命名规范：仅能使用纯小写字幕、数字、下划线作为合法字符，和属性名绑定不一样，还是为了避免错误干脆全部小写吧）。然后再看我们写的名称datasource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。\n\n最后说一句，以上规则仅针对springboot中@configurationproperties注解进行属性绑定时有效，对@value注解进行属性映射无效 。有人就说，那我不用你不就行了？不用，你小看springboot的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。\n\n总结\n\n 1. @configurationproperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上\n 2. @value注解不支持松散绑定规则\n 3. 绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符\n\n\n# kf-2-3.常用计量单位绑定\n\n在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。\n\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n\n\n但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？\n\n除了加强约定之外，springboot充分利用了jdk8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个jdk8中新增的类，分别是duration和datasize\n\n@component\n@data\n@configurationproperties(prefix = "servers")\npublic class serverconfig {\n    @durationunit(chronounit.hours)\n    private duration servertimeout;\n    @datasizeunit(dataunit.megabytes)\n    private datasize datasize;\n}\n\n\n\nduration：表示时间间隔，可以通过**@durationunit**注解描述时间单位，例如上例中描述的单位为小时（chronounit.hours）\n\ndatasize：表示存储空间，可以通过**@datasizeunit**注解描述存储空间单位，例如上例中描述的单位为mb（dataunit.megabytes）\n\n使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。\n\ndruation常用单位如下：\n\ndatasize常用单位如下：\n\n\n# kf-2-4.校验\n\n目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a"，这种数据肯定无法有效的绑定，还会引发错误。 springboot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在javaee的jsr303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤\n\n步骤①：开启校验框架\n\n\x3c!--1.导入jsr303规范，这个是接口规范--\x3e\n<dependency>\n    <groupid>javax.validation</groupid>\n    <artifactid>validation-api</artifactid>\n</dependency>\n\x3c!--使用hibernate框架提供的校验器做实现，这一部分实现上面的接口--\x3e\n<dependency>\n    <groupid>org.hibernate.validator</groupid>\n    <artifactid>hibernate-validator</artifactid>\n</dependency>\n\n\n步骤②：在需要开启校验功能的类上使用注解@validated开启校验功能\n\n@component\n@data\n@configurationproperties(prefix = "servers")\n//开启对当前bean的属性注入校验\n@validated\npublic class serverconfig {\n}\n\n\n步骤③：对具体的字段设置校验规则\n\n@component\n@data\n@configurationproperties(prefix = "servers")\n@validated  //开启对当前bean的属性注入校验\npublic class serverconfig {\n    //设置具体的规则\n    @max(value = 8888,message = "最大值不能超过8888")\n    @min(value = 202,message = "最小值不能低于202")\n    private int port;\n}\n\n\n通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。\n\n总结\n\n 1. 开启bean属性校验功能一共3步：导入jsr303与hibernate校验框架坐标、使用@validated注解启用校验功能、使用具体校验规则规范数据校验格式\n\n\n# kf-2-5.数据类型转换\n\n有关spring属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于bean的属性注入引发的灾难。\n\n先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。\n\njava.sql.sqlexception: access denied for user \'root\'@\'localhost\' (using password: yes)\n\n\n其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.driver\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n    username: root\n    password: 0127\n\n\n这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。\n\n之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，支持二进制，八进制，十六进制\n\n这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用string类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。\n\n这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。\n\n总结\n\n 1. yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注\n\n\n# kf-3.测试\n\n说完bean配置相关的内容，下面要对前面讲过的一个知识做加强了，测试。测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。\n\n\n# kf-3-1.加载测试专用属性\n\n测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置\n\nenv:\n  maxmemory: 32gb\n  minmemory: 16gb\n\n\n但是你现在想测试对应的兼容性，需要测试如下配置\n\nenv:\n  maxmemory: 16gb\n  minmemory: 8gb\n\n\n这个时候我们能不能每次测试的时候都去修改源码application.yml中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。\n\n临时属性\n\nspringboot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@springboottest添加属性来模拟临时属性，具体如下：\n\n//properties属性可以为当前测试用例添加临时的属性配置\n@springboottest(properties = {"test.prop=testvalue1"})\npublic class propertiesandargstest {\n\n    @value("${test.prop}")\n    private string msg;\n    \n    @test\n    void testproperties(){\n        system.out.println(msg);\n    }\n}\n\n\n使用注解@springboottest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。\n\n临时参数\n\n除了上述这种情况，在前面讲解使用命令行启动springboot程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解@springboottest的另一个属性来进行设定。\n\n//args属性可以为当前测试用例添加临时的命令行参数\n@springboottest(args={"--test.prop=testvalue2"})\npublic class propertiesandargstest {\n    \n    @value("${test.prop}")\n    private string msg;\n    \n    @test\n    void testproperties(){\n        system.out.println(msg);\n    }\n}\n\n\n使用注解@springboottest的args属性就可以为当前测试用例模拟命令行参数并进行测试。\n\n说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？\n\n在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是11，而配置属性的优先级是3，结果不言而喻了，args属性配置优先于properties属性配置加载。\n\n到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。\n\n总结\n\n 1. 加载测试临时属性可以通过注解@springboottest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例\n\n思考\n\n应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些bean能不做呢？也就是说我测试时，想搞一些独立的bean出来，专门应用于测试环境，能否实现呢？咱们下一节再讲。\n\n\n# kf-3-2.加载测试专用配置\n\n上一节提出了临时配置一些专用于测试环境的bean的需求，这一节我们就来解决这个问题。\n\n学习过spring的知识，我们都知道，其实一个spring环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：\n\n步骤①：在测试包test中创建专用的测试环境配置类\n\n@configuration\npublic class msgconfig {\n    @bean\n    public string msg(){\n        return "bean msg";\n    }\n}\n\n\n上述配置仅用于演示当前实验效果，实际开发可不能这么注入string类型的数据\n\n步骤②：在启动测试环境时，导入测试环境专用的配置类，使用@import注解即可实现\n\n@springboottest\n@import({msgconfig.class})\npublic class configurationtest {\n\n    @autowired\n    private string msg;\n\n    @test\n    void testconfiguration(){\n        system.out.println(msg);\n    }\n}\n\n\n到这里就通过@import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了1+1的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。\n\n总结\n\n 1. 定义测试环境专用的配置类，然后通过@import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境\n\n思考\n\n当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过postman手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？还真可以，咱们下一节再讲。\n\n\n# kf-3-3.web环境模拟测试\n\n在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动web环境，不然没法测试web功能。一个功能是必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动web测试，二，如何在测试类中发送web请求。下面一件事一件事进行，先说第一个\n\n测试类中启动web环境\n\n每一个springboot的测试类上方都会标准@springboottest注解，而注解带有一个属性，叫做webenvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：\n\n@springboottest(webenvironment = springboottest.webenvironment.random_port)\npublic class webtest {\t\n}\n\n\n测试类中启动web环境时，可以指定启动的web环境对应的端口，springboot提供了4种设置值，分别如下：\n\n * mock：根据当前设置确认是否启动web环境，例如使用了servlet的api就启动web环境，属于适配性的配置\n * defined_port：使用自定义的端口作为web服务器端口\n * random_port：使用随机端口作为web服务器端口\n * none：不启动web环境\n\n通过上述配置，现在启动测试程序时就可以正常启用web环境了，建议大家测试时使用random_port，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用8080端口，结果线上环境8080端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。\n\n测试环境中的web环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送web请求。\n\n测试类中发送请求\n\n对于测试类中发送请求，其实java的api就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：\n\n步骤①：在测试类中开启web虚拟调用功能，通过注解@autoconfiguremockmvc实现此功能的开启\n\n@springboottest(webenvironment = springboottest.webenvironment.random_port)\n//开启虚拟mvc调用\n@autoconfiguremockmvc\npublic class webtest {\n}\n\n\n步骤②：定义发起虚拟调用的对象mockmvc，通过自动装配的形式初始化对象\n\n@springboottest(webenvironment = springboottest.webenvironment.random_port)\n//开启虚拟mvc调用\n@autoconfiguremockmvc\npublic class webtest {\n\n    @test\n    void testweb(@autowired mockmvc mvc) {\n    }\n}\n\n\n步骤③：创建一个虚拟请求对象，封装请求的路径，并使用mockmvc对象发送对应请求\n\n@springboottest(webenvironment = springboottest.webenvironment.random_port)\n//开启虚拟mvc调用\n@autoconfiguremockmvc\npublic class webtest {\n\n    @test\n    void testweb(@autowired mockmvc mvc) throws exception {\n        //http://localhost:8080/books\n        //模拟创建虚拟请求，当前访问/books\n        mockhttpservletrequestbuilder builder = mockmvcrequestbuilders.get("/books");\n        //执行对应的请求\n        mvc.perform(builder);\n    }\n}\n\n\n执行测试程序，现在就可以正常的发送/books对应的请求了，注意访问路径不要写http://localhost:8080/books，因为前面的服务器ip地址和端口使用的是当前虚拟的web环境，无需指定，仅指定请求的具体路径即可。\n\n总结\n\n 1. 在测试类中测试web层接口要保障测试类启动时启动web容器，使用@springboottest注解的webenvironment属性可以虚拟web环境用于测试\n 2. 为测试方法注入mockmvc对象，通过mockmvc对象可以发送虚拟请求，模拟web请求调用过程\n\n思考\n\n目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？咱们下一节再讲。\n\nweb环境请求结果比对\n\n上一节已经在测试用例中成功的模拟出了web环境，并成功的发送了web请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：\n\n * 响应状态匹配\n   \n   @test\n   void teststatus(@autowired mockmvc mvc) throws exception {\n       mockhttpservletrequestbuilder builder = mockmvcrequestbuilders.get("/books");\n       resultactions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       statusresultmatchers status = mockmvcresultmatchers.status();\n       //预计本次调用时成功的：状态200\n       resultmatcher ok = status.isok();\n       //添加预计值到本次调用过程中进行匹配\n       action.andexpect(ok);\n   }\n   \n\n * 响应体匹配（非json数据格式）\n   \n   @test\n   void testbody(@autowired mockmvc mvc) throws exception {\n       mockhttpservletrequestbuilder builder = mockmvcrequestbuilders.get("/books");\n       resultactions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       contentresultmatchers content = mockmvcresultmatchers.content\n       // 取出的状态值变为字符串\n       resultmatcher result = content.string("springboot2");\n       //添加预计值到本次调用过程中进行匹配\n       action.andexpect(result);\n   }\n   \n\n * 响应体匹配（json数据格式，开发中的主流使用方式）\n   \n   @test\n   void testjson(@autowired mockmvc mvc) throws exception {\n       mockhttpservletrequestbuilder builder = mockmvcrequestbuilders.get("/books");\n       resultactions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       contentresultmatchers content = mockmvcresultmatchers.content();\n       resultmatcher result = content.json("{\\"id\\":1,\\"name\\":\\"springboot2\\",\\"type\\":\\"springboot\\"}");\n       //添加预计值到本次调用过程中进行匹配\n       action.andexpect(result);\n   }\n   \n\n * 响应头信息匹配\n   \n   @test\n   void testcontenttype(@autowired mockmvc mvc) throws exception {\n       mockhttpservletrequestbuilder builder = mockmvcrequestbuilders.get("/books");\n       resultactions action = mvc.perform(builder);\n       //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n       //定义本次调用的预期值\n       headerresultmatchers header = mockmvcresultmatchers.header();\n       resultmatcher contenttype = header.string("content-type", "application/json");\n       //添加预计值到本次调用过程中进行匹配\n       action.andexpect(contenttype);\n   }\n   \n\n基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。\n\n@test\nvoid testgetbyid(@autowired mockmvc mvc) throws exception {\n    mockhttpservletrequestbuilder builder = mockmvcrequestbuilders.get("/books");\n    resultactions action = mvc.perform(builder);\n\n    statusresultmatchers status = mockmvcresultmatchers.status();\n    resultmatcher ok = status.isok();\n    action.andexpect(ok);\n\n    headerresultmatchers header = mockmvcresultmatchers.header();\n    resultmatcher contenttype = header.string("content-type", "application/json");\n    action.andexpect(contenttype);\n\n    contentresultmatchers content = mockmvcresultmatchers.content();\n    resultmatcher result = content.json("{\\"id\\":1,\\"name\\":\\"springboot\\",\\"type\\":\\"springboot\\"}");\n    action.andexpect(result);\n}\n\n\n总结\n\n 1. web虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对\n\n\n# kf-3-4.数据层测试回滚\n\n当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？\n\nspringboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解@transactional即可实现当前测试用例的事务不提交。当程序运行后，只要注解@transactional出现的位置存在注解@springboottest，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。\n\n@springboottest\n@transactional\n@rollback(true)\npublic class daotest {\n    @autowired\n    private bookservice bookservice;\n\n    @test\n    void testsave(){\n        book book = new book();\n        book.setname("springboot3");\n        book.settype("springboot3");\n        book.setdescription("springboot3");\n\n        bookservice.save(book);\n    }\n}\n\n\n如果开发者想提交事务，也可以，再添加一个@rollback的注解，设置回滚状态为false即可正常提交事务（false表示不能回滚），是不是很方便？springboot在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。\n\n总结\n\n 1. 在springboot的测试类中通过添加注解@transactional来阻止测试用例提交事务\n 2. 通过注解@rollback控制springboot测试类执行结果是否提交事务，需要配合注解@transactional使用\n\n思考\n\n当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？咱们下一节再讲。\n\n\n# kf-3-5.测试用例数据设定\n\n对于测试用例的数据固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：\n\ntestcase:\n  book:\n    id: ${random.int}\n    id2: ${random.int(10)}\n    type: ${random.int!5,10!}\n    name: ${random.value}\n    uuid: ${random.uuid}\n    publishtime: ${random.long}\n\n\n当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@configurationproperties注解即可\n\n@component\n@data\n@configurationproperties(prefix = "testcase.book")\npublic class bookcase {\n    private int id;\n    private int id2;\n    private int type;\n    private string name;\n    private string uuid;\n    private long publishtime;\n}\n\n\n对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：\n\n * ${random.int}表示随机整数\n * ${random.int(10)}表示10以内的随机数\n * ${random.int(10,20)}表示10到20的随机数\n * 其中()可以是任意字符，例如[]，!!均可，也就是random.int!5,10!等价于random.int(5,10)等价于random.int[5,10]\n\n总结\n\n 1. 使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性\n\n\n# kf-4.数据层解决方案\n\n开发实用篇前三章基本上是开胃菜，从第四章开始，开发实用篇进入到了噩梦难度了，从这里开始，不再是单纯的在springboot内部搞事情了，要涉及到很多相关知识。本章节主要内容都是和数据存储与读取相关，前期学习的知识与数据层有关的技术基本上都围绕在数据库这个层面上，所以本章要讲的第一个大的分支就是sql解决方案相关的内容，除此之外，数据的来源还可以是非sql技术相关的数据操作，因此第二部分围绕着nosql解决方案讲解。至于什么是nosql解决方案，讲到了再说吧。下面就从sql解决方案说起。\n\n\n# kf-4-1.sql\n\n回忆一下之前做ssmp整合的时候数据层解决方案涉及到了哪些技术？mysql数据库与mybatisplus框架，后面又学了druid数据源的配置，所以现在数据层解决方案可以说是mysql+druid+mybatisplus。而三个技术分别对应了数据层操作的三个层面：\n\n * 数据源技术：druid\n * 持久化技术：mybatisplus\n * 数据库技术：mysql\n\n下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。\n\n# 数据源技术\n\n目前我们使用的数据源技术是druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：\n\ninfo 28600 --- [           main] c.a.d.s.b.a.druiddatasourceautoconfigure : init druiddatasource\ninfo 28600 --- [           main] com.alibaba.druid.pool.druiddatasource   : {datasource-1} inited\n\n\n如果不使用druid数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将druid技术对应的starter去掉再次运行程序可以在日志中找到如下初始化信息：\n\ninfo 31820 --- [           main] com.zaxxer.hikari.hikaridatasource       : hikaripool-1 - starting...\ninfo 31820 --- [           main] com.zaxxer.hikari.hikaridatasource       : hikaripool-1 - start completed.\n\n\n\n\n虽然没有druiddatasource相关的信息了，但是我们发现日志中有hikaridatasource这个信息，就算不懂这是个什么技术，看名字也能看出来，以datasource结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot内嵌数据源。\n\n数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。\n\nspringboot提供了3款内嵌数据源技术，分别如下：\n\n * hikaricp\n * tomcat提供datasource\n * commons dbcp\n\n第一种，hikartcp，这是springboot官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。\n\n第二种，tomcat提供的datasource，如果不想用hikartcp，并且使用tomcat作为web服务器进行web程序的开发，使用这个。为什么是tomcat，不是其他web服务器呢？因为web技术导入starter后，默认使用内嵌tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用hikartcp用tomcat提供的默认数据源对象呢？把hikartcp技术的坐标排除掉就ok了。\n\n第三种，dbcp，这个使用的条件就更苛刻了，既不使用hikartcp也不使用tomcat的datasource时，默认给你用这个。\n\nspringboot这心操的，也是稀碎啊，就怕你自己管不好连接对象，给你一顿推荐，真是开发界的最强辅助。既然都给你奶上了，那就受用吧，怎么配置使用这些东西呢？之前我们配置druid时使用druid的starter对应的配置如下：\n\nspring:\n  datasource:\n    druid:\t\n   \t  url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n      driver-class-name: com.mysql.cj.jdbc.driver\n      username: root\n      password: root\n\n\n换成是默认的数据源hikaricp后，直接吧druid删掉就行了，如下：\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n    driver-class-name: com.mysql.cj.jdbc.driver\n    username: root\n    password: root\n\n\n当然，也可以写上是对hikari做的配置，但是url地址要单独配置，不能放到hikari的配置项下面，如下：\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.driver\n      username: root\n      password: root\n\n\n这就是配置hikari数据源的方式。如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?servertimezone=utc\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.driver\n      username: root\n      password: root\n      maximum-pool-size: 50\n\n\n如果不想使用hikari数据源，使用tomcat的数据源或者dbcp配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。\n\n\n\n总结\n\n 1. springboot技术提供了3种内置的数据源技术，分别是hikari、tomcat内置数据源、dbcp\n\n# 持久化技术\n\n说完数据源解决方案，再来说一下持久化解决方案。springboot充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做jdbctemplate。其实这个技术不能说是springboot提供的，因为不使用springboot技术，一样能使用它，谁提供的呢？spring技术提供的，所以在springboot技术范畴中，这个技术也是存在的，毕竟springboot技术是加速spring程序开发而创建的。\n\n这个技术其实就是回归到jdbc最原始的编程形式来进行数据层的开发，下面直接上操作步骤：\n\n步骤①：导入jdbc对应的坐标，记得是starter\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-jdbc</artifactid>\n</dependency\n\n\n步骤②：自动装配jdbctemplate对象\n\n@springboottest\nclass springboot15sqlapplicationtests {\n    @test\n    void testjdbctemplate(@autowired jdbctemplate jdbctemplate){\n    }\n}\n\n\n步骤③：使用jdbctemplate实现查询操作（非实体类封装数据的查询操作）\n\n@test\nvoid testjdbctemplate(@autowired jdbctemplate jdbctemplate){\n    string sql = "select * from tbl_book";\n    list<map<string, object>> maps = jdbctemplate.queryforlist(sql);\n    system.out.println(maps);\n}\n\n\n步骤④：使用jdbctemplate实现查询操作（实体类封装数据的查询操作）记得复习一下query操作\n\n@test\nvoid testjdbctemplate(@autowired jdbctemplate jdbctemplate){\n\n    string sql = "select * from tbl_book";\n    rowmapper<book> rm = new rowmapper<book>() {\n        @override\n        public book maprow(resultset rs, int rownum) throws sqlexception {\n            book temp = new book();\n            temp.setid(rs.getint("id"));\n            temp.setname(rs.getstring("name"));\n            temp.settype(rs.getstring("type"));\n            temp.setdescription(rs.getstring("description"));\n            return temp;\n        }\n    };\n    list<book> list = jdbctemplate.query(sql, rm);\n    system.out.println(list);\n}\n\n\n步骤⑤：使用jdbctemplate实现增删改操作\n\n@test\nvoid testjdbctemplatesave(@autowired jdbctemplate jdbctemplate){\n    string sql = "insert into tbl_book values(3,\'springboot1\',\'springboot2\',\'springboot3\')";\n    jdbctemplate.update(sql);\n}\n\n\n如果想对jdbctemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：\n\nspring:\n  jdbc:\n    template:\n      query-timeout: -1   # 查询超时时间\n      max-rows: 500       # 最大行数\n      fetch-size: -1      # 缓存行数\n\n\n总结\n\n 1. springboot内置jdbctemplate持久化解决方案\n\n 2. 使用jdbctemplate需要导入spring-boot-starter-jdbc的坐标\n    \n    \n\n# 数据库技术\n\n截止到目前，springboot给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非springboot也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。\n\nspringboot提供了3款内置的数据库，分别是\n\n * h2\n * hsql\n * derby\n\n以上三款数据库除了可以独立安装之外，还可以像是tomcat服务器一样，采用内嵌的形式运行在spirngboot容器中。内嵌在容器中运行，那必须是java对象啊，对，这三款数据库底层都是使用java语言开发的。\n\n我们一直使用mysql数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。\n\n下面以h2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛\n\n步骤①：导入h2数据库对应的坐标，一共2个\n\n<dependency>\n    <groupid>com.h2database</groupid>\n    <artifactid>h2</artifactid>\n</dependency>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-jpa</artifactid>\n</dependency>\n\n\n步骤②：将工程设置为web工程，启动工程时启动h2数据库\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n步骤③：通过配置开启h2数据库控制台访问程序，也可以使用其他的数据库连接软件操作\n\nspring:\n  h2:\n    console:\n      enabled: true\n      path: /h2\n\n\nweb端访问路径localhost/h2就可以访问访问数据库，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问localhost/h2路径就可以正常访问了\n\ndatasource:\n  url: jdbc:h2:~/test\n  hikari:\n    driver-class-name: org.h2.driver\n    username: sa\n    password: 123456\n\n\n步骤④：使用jdbctemplate或mybatisplus技术操作数据库即可\n\n（略）\n\n其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用mysql数据库作为数据持久化方案，关闭方式就是设置enabled属性为false即可。\n\n总结\n\n 1. h2内嵌式数据库启动方式，添加坐标，添加配置\n 2. h2数据库线上运行时请务必关闭\n\n到这里sql相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。\n\n * 数据源技术：druid、hikari、tomcat datasource、dbcp\n * 持久化技术：mybatisplus、mybatis、jdbctemplate\n * 数据库技术：mysql、h2、hsql、derby\n\n现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。\n\n\n# kf-4-2.nosql\n\nsql数据层解决方案说完了，下面来说收nosql数据层解决方案。这个nosql是什么意思呢？从字面来看，no表示否定，nosql就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如redis等。本节讲解的内容就是springboot如何整合这些技术，在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款nosql数据库整合方案，分别是redis、mongodb、es。\n\n因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在linux服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以windows平台作为安装基础讲解，如果想看linux版软件安装，可以再找到对应技术的学习文档查阅学习。\n\n# springboot整合redis\n\nredis是一款采用key-value数据存储格式的内存级nosql数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与mysql数据库不同，mysql数据库有表、有字段、有记录，redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实redis有它的数据持久化方案，分别是rdb和aof，但是redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。\n\nredis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合\n\n# 安装\n\nwindows版安装包下载地址：https://github.com/tporadowski/redis/releases\n\n下载的安装包有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是msi一键安装的msi文件进行安装的。\n\n啥是msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。\n\n安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动redis的核心命令，需要再cmd命令行模式执行。\n\n启动服务器\n\nredis-server.exe redis.windows.conf\n\n\n初学者无需调整服务器对外服务端口，默认6379。\n\n启动客户端\n\nredis-cli.exe\n\n\n如果启动redis服务器失败，可以先启动客户端，然后执行shutdown操作后退出，此时redis服务器就可以正常执行了。\n\n# 基本操作\n\n服务器启动后，使用客户端就可以连接服务器，类似于启动完mysql数据库，然后启动sql命令行操作数据库。\n\n放置一个字符串数据到redis中，先为数据定义一个名称，比如name,age等，然后使用命令set设置数据到redis服务器中即可\n\nset name itheima\nset age 12\n\n\n从redis中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到(nil)\n\nget name\nget age\n\n\n以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向hash结构中存储数据格式如下：\n\nhset a a1 aa1\t\t#对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1\nhset a a2 aa2\n\n\n获取hash结构中的数据命令如下\n\nhget a a1\t\t\t#得到aa1\nhget a a2\t\t\t#得到aa2\n\n\n有关redis的基础操作就普及到这里，需要全面掌握redis技术，请参看相关教程学习。\n\n# 整合\n\n在进行整合之前先梳理一下整合的思想，springboot整合任何技术其实就是在springboot中使用对应技术的api。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用springboot技术去管理其他技术，几个问题是躲不掉的。\n\n第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化\n\n第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题\n\n第三，没有整合之前操作如果是模式a的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同\n\n按照上面的三个问题去思考springboot整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。\n\n下面就开始springboot整合redis，操作步骤如下：\n\n步骤①：导入springboot整合redis的starter坐标\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属nosql分类中\n\n步骤②：进行基础配置\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n\n\n操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。\n\n步骤③：使用springboot整合redis的专用客户端接口操作，此处使用的是redistemplate\n\n@springboottest\nclass springboot16redisapplicationtests {\n    @autowired\n    private redistemplate redistemplate;\n    // 以下为普通的key-value操作\n    @test\n    void set() {\n        valueoperations ops = redistemplate.opsforvalue();\n        ops.set("age",41);\n    }\n    @test\n    void get() {\n        valueoperations ops = redistemplate.opsforvalue();\n        object age = ops.get("name");\n        system.out.println(age);\n    }\n    \n    // 以下为hash操作\n    @test\n    void hset() {\n        hashoperations ops = redistemplate.opsforhash();\n        ops.put("info","b","bb");\n    }\n    @test\n    void hget() {\n        hashoperations ops = redistemplate.opsforhash();\n        object val = ops.get("info", "b");\n        system.out.println(val);\n    }\n}\n\n\n\n在操作redis时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用opsforvalue()获取string类型的数据操作接口，使用opsforhash()获取hash类型的数据操作接口，剩下的就是调用对应api操作了。各种类型的数据操作接口如下：\n\n总结\n\n 1. springboot整合redis步骤\n    1. 导入springboot整合redis的starter坐标\n    2. 进行基础配置\n    3. 使用springboot整合redis的专用客户端接口redistemplate操作\n\nstringredistemplate\n\n由于**redis内部不提供java对象的存储格式，因此当操作的数据以对象（泛型）的形式存在时，会进行转码，转换成字符串格式后进行操作。**为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的api接口stringredistemplate，你可以理解为这是redistemplate的一种指定数据泛型的操作api。\n\n@springboottest\npublic class stringredistemplatetest {\n    @autowired\n    private stringredistemplate stringredistemplate;\n    @test\n    void get(){\n        valueoperations<string, string> ops = stringredistemplate.opsforvalue();\n        string name = ops.get("name");\n        system.out.println(name);\n    }\n}\n\n\nredis客户端选择\n\n\tspringboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：\n\n\n步骤①：导入jedis坐标\n\n<dependency>\n    <groupid>redis.clients</groupid>\n    <artifactid>jedis</artifactid>\n</dependency>\n\n\njedis坐标受springboot管理，无需提供版本号\n\n步骤②：配置客户端技术类型，设置为jedis\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n\n\n步骤③：根据需要设置对应的配置\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n    lettuce:\n      pool:\n        max-active: 16\n    jedis:\n      pool:\n        max-active: 16\n\n\nlettcus与jedis区别\n\n * jedis连接redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响\n * lettcus基于netty框架进行与redis服务器连接，底层设计中采用statefulredisconnection。 statefulredisconnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作\n\n总结\n\n 1. springboot整合redis提供了stringredistemplate对象，以字符串的数据格式操作redis\n 2. 如果需要切换redis客户端实现技术，可以通过配置的形式进行\n\n# springboot整合mongodb\n\n使用redis技术可以有效的提高数据访问速度，但是由于redis的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，redis就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来redis无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解springboot如何整合mongodb技术。\n\nmongodb是一个开源、高性能、无模式的文档型数据库（他的文档格式和json很像，但又不完全相同，所以文档名称为bson），它是nosql数据库产品中的一种，是最像关系型数据库的非关系型数据库。\n\n上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有a、b、c一共3个字段，第二条数据可能有d、e、f也是3个字段，第三条数据可能是a、c、e3个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，mongodb的应用面也会产生一些变化。以下列出了一些可以使用mongodb作为数据存储的场景，但是并不是必须使用mongodb的场景：\n\n * 淘宝用户数据（一旦设置之后很少变化）\n   * 存储位置：数据库\n   * 特征：永久性存储，修改频度极低\n * 游戏装备数据、游戏道具数据\n   * 存储位置：数据库、mongodb\n   * 特征：永久性存储与临时存储相结合、修改频度较高\n * 直播数据、打赏数据、粉丝数据\n   * 存储位置：数据库、mongodb\n   * 特征：永久性存储与临时存储相结合，修改频度极高\n * 物联网数据\n   * 存储位置：mongodb\n   * 特征：临时存储，修改频度飞速\n\n快速了解一下mongodb，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合\n\n# 安装\n\nwindows版安装包下载地址：https://www.mongodb.com/try/download\n\n下载的安装包也有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，本课程采用解压缩zip文件进行安装。\n\n解压缩完毕后会得到如下文件，其中bin目录包含了所有mongodb的可执行命令\n\n\n\nmongodb在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建data的目录用来存储数据，具体如下\n\n\n\n如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。\n\n根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到windows安装目录的system32目录下，然后在命令行中执行regsvr32命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。\n\nregsvr32 vcruntime140_1.dll\n\n\n启动服务器\n\nmongod --dbpath=..\\data\\db\n\n\n启动服务器时需要指定数据存储位置，通过参数--dbpath进行设置，可以根据需要自行设置数据存储路径。默认服务端口27017。\n\n启动客户端\n\nmongo --host=127.0.0.1 --port=27017\n\n\n# 基本操作\n\nmongodb虽然是一款数据库，但是它的操作并不是使用sql语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于navicat的数据库客户端软件，能够便捷的操作mongodb，先安装一个客户端，再来操作mongodb。\n\n同类型的软件较多，本次安装的软件时robo3t，robot3t是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击robot3t.exe即可使用（mongodb和robot3t版本不匹配可能安装失败）。\n\n打开软件首先要连接mongodb服务器，选择【file】菜单，选择【connect...】\n\n\n\n进入连接管理界面后，选择左上角的【create】链接，创建新的连接设置\n\n如果输入设置值即可连接（默认不修改即可连接本机27017端口）\n\n\n\n连接成功后在命令输入区域输入命令即可操作mongodb。\n\n创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可\n\n创建集合：在collections上使用右键创建，输入集合名称即可（这里的集合其实就是mysql的表），集合等同于数据库中的表的作用\n\n新增文档：（文档是一种类似json格式的数据，初学者可以先把数据理解为就是json数据）\n\ndb.集合名称.insert/save/insertone(文档)\n\n\n删除文档：\n\ndb.集合名称.remove(条件)\n\n\n修改文档：\n\ndb.集合名称.update(条件，{操作种类:{文档}})\n\n\n查询文档：\n\n基础查询\n查询全部：\t\t   db.集合.find();\n查第一条：\t\t   db.集合.findone()\n查询指定数量文档：\tdb.集合.find().limit(10)\t\t\t\t\t//查10条文档\n跳过指定数量文档：\tdb.集合.find().skip(20)\t\t\t\t\t//跳过20条文档\n统计：\t\t\t  \tdb.集合.count()\n排序：\t\t\t\tdb.集合.sort({age:1})\t\t\t\t\t\t//按age升序排序\n投影：\t\t\t\tdb.集合名称.find(条件,{name:1,age:1})\t\t //仅保留name与age域\n\n条件查询\n基本格式：\t\t\tdb.集合.find({条件})\n模糊查询：\t\t\tdb.集合.find({域名:/正则表达式/})\t\t  //等同sql中的like，比like强大，可以执行正则所有规则\n条件比较运算：\t\t   db.集合.find({域名:{$gt:值}})\t\t\t\t//等同sql中的数值比较操作，例如：name>18\n包含查询：\t\t\tdb.集合.find({域名:{$in:[值1，值2]}})\t\t//等同于sql中的in\n条件连接查询：\t\t   db.集合.find({$and:[{条件1},{条件2}]})\t   //等同于sql中的and、or\n\n\n有关mongodb的基础操作就普及到这里，需要全面掌握mongodb技术，请参看相关教程学习。\n\n# 整合\n\n使用springboot整合mongdb该如何进行呢？其实springboot为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用api接口操作。整合redis如此，整合mongodb同样如此。\n\n第一，先导入对应技术的整合starter坐标\n\n第二，配置必要信息\n\n第三，使用提供的api操作即可\n\n下面就开始springboot整合mongodb，操作步骤如下：\n\n步骤①：导入springboot整合mongodb的starter坐标\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-mongodb</artifactid>\n</dependency>\n\n\n上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属nosql分类中\n\n步骤②：进行基础配置\n\nspring:\n  data:\n    mongodb:\n      uri: mongodb://localhost/itheima\n\n\n操作mongodb需要的配置与操作redis一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器ip地址和端口不同，书写格式不同而已。\n\n步骤③：使用springboot整合mongodb的专用客户端接口mongotemplate来进行操作\n\n@springboottest\nclass springboot17mongodbapplicationtests {\n    @autowired\n    private mongotemplate mongotemplate;\n    @test\n    void contextloads() {\n        book book = new book();\n        book.setid(2);\n        book.setname("springboot2");\n        book.settype("springboot2");\n        book.setdescription("springboot2");\n        mongotemplate.save(book);\n    }\n    @test\n    void find(){\n        list<book> all = mongotemplate.findall(book.class);\n        system.out.println(all);\n    }\n}\n\n\n整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用api操作，陌生的是这个技术，里面具体的操作api可能会不熟悉，有关springboot整合mongodb我们就讲到这里。有兴趣可以继续学习mongodb的操作，然后再来这里通过编程的形式操作mongodb。\n\n总结\n\n 1. springboot整合mongodb步骤\n    1. 导入springboot整合mongodb的starter坐标\n    2. 进行基础配置\n    3. 使用springboot整合mongodb的专用客户端接口mongotemplate操作\n\n# springboot整合es\n\nnosql解决方案已经讲完了两种技术的整合了，redis可以使用内存加载数据并实现数据快速访问，mongodb可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款nosql解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做es技术。\n\nes（elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。\n\n那什么是全文搜索呢？比如用户要买一本书，以java为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含java就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而es技术就是一种可以实现上述效果的技术。\n\n要实现全文搜索的效果，不可能使用数据库中like操作去进行比对，这种效率太低了。es设计了一种全新的思想，来实现全文搜索。具体操作过程如下：\n\n 1. 将被查询的字段的数据全部文本信息进行查分，分成若干个词\n    \n    * 例如“中华人民共和国”就会被拆分成三个词，分别是“中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。\n\n 2. 将分词得到的结果存储起来，对应每条数据的id\n    \n    * 例如id为1的数据中名称这一项的值是“中华人民共和国”，那么分词结束后，就会出现“中华”对应id为1，“人民”对应id为1，“共和国”对应id为1\n    \n    * 例如id为2的数据中名称这一项的值是“人民代表大会“，那么分词结束后，就会出现“人民”对应id为2，“代表”对应id为2，“大会”对应id为2\n    \n    * 此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中\n      \n      分词结果关键字   对应id\n      中华        1\n      人民        1,2\n      共和国       1\n      代表        2\n      大会        2\n\n 3. 当进行查询时，如果输入“人民”作为查询条件，可以通过上述表格数据进行比对，得到id值1,2，然后根据id值就可以得到查询的结果数据了。\n\n上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做倒排索引（正向排序是根据查询内容遍历每一个文件，然后在文件中进行匹配；倒排索引是将构建关键词和文件的映射，根据关键词来找文件。）。\n\n通过上述内容的学习，发现使用es其实准备工作还是挺多的，必须先建立文档的倒排索引，然后才能继续使用。快速了解一下es的工作原理，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合。\n\n# 安装\n\nwindows版安装包下载地址：https://www.elastic.co/cn/downloads/elasticsearch\n\n下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n\n * bin目录：包含所有的可执行命令\n * config目录：包含es服务器使用的配置文件\n * jdk目录：此目录中包含了一个完整的jdk工具包，版本17，当es升级时，使用最新版本的jdk确保不会出现版本支持性不足的问题\n * lib目录：包含es运行的依赖jar文件\n * logs目录：包含es运行后产生的所有日志文件\n * modules目录：包含es软件中所有的功能模块，也是一个一个的jar包。和jar目录不同，jar目录是es运行期间依赖的jar包，modules是es软件自己的功能jar包\n * plugins目录：包含es软件安装的插件，默认为空\n\n启动服务器\n\nelasticsearch.bat\n\n\n双击elasticsearch.bat文件即可启动es服务器，默认服务端口9200。通过浏览器访问http://localhost:9200看到如下信息视为es服务器正常启动\n\n{\n  "name" : "czbk-**********",\n  "cluster_name" : "elasticsearch",\n  "cluster_uuid" : "j137dsswtpg8u4yb-0t1mg",\n  "version" : {\n    "number" : "7.16.2",\n    "build_flavor" : "default",\n    "build_type" : "zip",\n    "build_hash" : "2b937c44140b6559905130a8650c64dbd0879cfb",\n    "build_date" : "2021-12-18t19:42:46.604893745z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.10.1",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "you know, for search"\n}\n\n\n# 基本操作\n\nes中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在es中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行es的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。\n\n要操作es可以通过rest风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。\n\n * 创建索引，books是索引名称，下同\n   \n   put请求\t\thttp://localhost:9200/books\n   \n   \n   发送请求后，看到如下信息即索引创建成功\n   \n   {\n       "acknowledged": true,\n       "shards_acknowledged": true,\n       "index": "books"\n   }\n   \n   \n   重复创建已经存在的索引会出现错误信息，reason属性中描述错误原因\n   \n   {\n       "error": {\n           "root_cause": [\n               {\n                   "type": "resource_already_exists_exception",\n                   "reason": "index [books/vgc_xmvaqmedaibnsgo2-w] already exists",\n                   "index_uuid": "vgc_xmvaqmedaibnsgo2-w",\n                   "index": "books"\n               }\n           ],\n           "type": "resource_already_exists_exception",\n           "reason": "index [books/vgc_xmvaqmedaibnsgo2-w] already exists",\t# books索引已经存在\n           "index_uuid": "vgc_xmvaqmedaibnsgo2-w",\n           "index": "book"\n       },\n       "status": 400\n   }\n   \n\n * 查询索引\n   \n   get请求\thttp://localhost:9200/books\n   \n   \n   查询索引得到索引相关信息，如下\n   \n   {\n       "book": {\n           "aliases": {},\n           "mappings": {},\n           "settings": {\n               "index": {\n                   "routing": {\n                       "allocation": {\n                           "include": {\n                               "_tier_preference": "data_content"\n                           }\n                       }\n                   },\n                   "number_of_shards": "1",\n                   "provided_name": "books",\n                   "creation_date": "1645768584849",\n                   "number_of_replicas": "1",\n                   "uuid": "vgc_xmvaqmedaibnsgo2-w",\n                   "version": {\n                       "created": "7160299"\n                   }\n               }\n           }\n       }\n   }\n   \n   \n   如果查询了不存在的索引，会返回错误信息，例如查询名称为book的索引后信息如下\n   \n   {\n       "error": {\n           "root_cause": [\n               {\n                   "type": "index_not_found_exception",\n                   "reason": "no such index [book]",\n                   "resource.type": "index_or_alias",\n                   "resource.id": "book",\n                   "index_uuid": "_na_",\n                   "index": "book"\n               }\n           ],\n           "type": "index_not_found_exception",\n           "reason": "no such index [book]",\t\t# 没有book索引\n           "resource.type": "index_or_alias",\n           "resource.id": "book",\n           "index_uuid": "_na_",\n           "index": "book"\n       },\n       "status": 404\n   }\n   \n\n * 删除索引\n   \n   delete请求\thttp://localhost:9200/books\n   \n   \n   删除所有后，给出删除结果\n   \n   {\n       "acknowledged": true\n   }\n   \n   \n   如果重复删除，会给出错误信息，同样在reason属性中描述具体的错误原因\n   \n   {\n       "error": {\n           "root_cause": [\n               {\n                   "type": "index_not_found_exception",\n                   "reason": "no such index [books]",\n                   "resource.type": "index_or_alias",\n                   "resource.id": "book",\n                   "index_uuid": "_na_",\n                   "index": "book"\n               }\n           ],\n           "type": "index_not_found_exception",\n           "reason": "no such index [books]",\t\t# 没有books索引\n           "resource.type": "index_or_alias",\n           "resource.id": "book",\n           "index_uuid": "_na_",\n           "index": "book"\n       },\n       "status": 404\n   }\n   \n\n * 创建索引并指定分词器\n   \n   前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是ik分词器，使用前先在下对应的分词器，然后使用。ik分词器下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n   \n   分词器下载后解压到es安装目录的plugins目录中即可，安装分词器后需要重新启动es服务器。使用ik分词器创建索引格式：\n   \n   \n   \n   put请求\t\thttp://localhost:9200/books\n   \n   请求参数如下（注意是json格式的参数）\n   {\n       "mappings":{\t\t\t\t\t\t\t#定义mappings属性，替换创建索引时对应的mappings属性\t\t\n           "properties":{\t\t\t\t\t\t#定义索引中包含的属性设置\n               "id":{\t\t\t\t\t\t\t#设置索引中包含id属性\n                   "type":"keyword"\t\t\t#当前属性可以被直接搜索\n               },\n               "name":{\t\t\t\t\t\t#设置索引中包含name属性\n                   "type":"text",              #当前属性是文本信息,是字符创，参与分词  \n                   "analyzer":"ik_max_word",   #使用ik分词器进行分词             \n                   "copy_to":"all"\t\t\t\t#分词结果拷贝到all属性中\n               },\n               "type":{\n                   "type":"keyword"\n               },\n               "description":{\n                   "type":"text",\t                \n                   "analyzer":"ik_max_word",                \n                   "copy_to":"all"\n               },\n               "all":{\t\t\t\t\t\t\t#定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询\n                   "type":"text",\t            # 这个属性将name 和description中的拷贝到all中    \n                   "analyzer":"ik_max_word"\n               }\n           }\n       }\n   }\n   \n   \n   创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数mappings已经进入到了索引属性中，具体属性顺序按照内部设定进行排序\n   \n   {\n       "books": {\n           "aliases": {},\n           "mappings": {\t\t\t\t\t\t#mappings属性已经被替换\n               "properties": {\n                   "all": {\n                       "type": "text",\n                       "analyzer": "ik_max_word"\n                   },\n                   "description": {\n                       "type": "text",\n                       "copy_to": [\n                           "all"\n                       ],\n                       "analyzer": "ik_max_word"\n                   },\n                   "id": {\n                       "type": "keyword"\n                   },\n                   "name": {\n                       "type": "text",\n                       "copy_to": [\n                           "all"\n                       ],\n                       "analyzer": "ik_max_word"\n                   },\n                   "type": {\n                       "type": "keyword"\n                   }\n               }\n           },\n           "settings": {\n               "index": {\n                   "routing": {\n                       "allocation": {\n                           "include": {\n                               "_tier_preference": "data_content"\n                           }\n                       }\n                   },\n                   "number_of_shards": "1",\n                   "provided_name": "books",\n                   "creation_date": "1645769809521",\n                   "number_of_replicas": "1",\n                   "uuid": "dohykvr_szo4krgmbzymtq",\n                   "version": {\n                       "created": "7160299"\n                   }\n               }\n           }\n       }\n   }\n   \n\n目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，es中称数据为文档，下面进行文档操作。\n\n * 添加文档，有三种方式\n   \n   post请求\thttp://localhost:9200/books/_doc\t\t#使用系统生成id\n   post请求\thttp://localhost:9200/books/_create/1\t#使用指定id\n   post请求\thttp://localhost:9200/books/_doc/1\t\t#使用指定id，不存在创建，存在更新（版本递增）\n   \n   文档通过请求参数传递，数据格式json\n   {\n       "name":"springboot",\n       "type":"springboot",\n       "description":"springboot"\n   }  \n   \n\n * 查询文档\n   \n   get请求\thttp://localhost:9200/books/_doc/1\t\t #查询单个文档 \t\t\n   get请求\thttp://localhost:9200/books/_search\t\t #查询全部文档\n   \n\n * 条件查询\n   \n   get请求\thttp://localhost:9200/books/_search?q=name:springboot\t# q=查询属性名:查询属性值\n   \n\n * 删除文档\n   \n   delete请求\thttp://localhost:9200/books/_doc/1\n   \n\n * 修改文档（全量更新）\n   \n   put请求\thttp://localhost:9200/books/_doc/1\n   \n   文档通过请求参数传递，数据格式json\n   {\n       "name":"springboot",\n       "type":"springboot",\n       "description":"springboot"\n   }\n   \n\n * 修改文档（部分更新）\n   \n   post请求\thttp://localhost:9200/books/_update/1\n   \n   文档通过请求参数传递，数据格式json\n   {\t\t\t\n       "doc":{\t\t\t\t\t\t#部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新\n           "name":"springboot"\t\t#仅更新提供的属性值，未提供的属性值不参与更新操作\n       }\n   }\n   \n\n# 整合\n\n使用springboot整合es该如何进行呢？老规矩，导入坐标，做配置，使用api接口操作。整合redis如此，整合mongodb如此，整合es依然如此。太没有新意了，其实不是没有新意，这就是springboot的强大之处，所有东西都做成相同规则，对开发者来说非常友好。\n\n下面就开始springboot整合es，操作步骤如下：\n\n步骤①：导入springboot整合es的starter坐标\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-elasticsearch</artifactid>\n</dependency>\n\n\n步骤②：进行基础配置\n\nspring:\n  elasticsearch:\n    rest:\n      uris: http://localhost:9200\n\n\n配置es服务器地址，端口9200\n\n步骤③：使用springboot整合es的专用客户端接口elasticsearchresttemplate来进行操作\n\n@springboottest\nclass springboot18esapplicationtests {\n    @autowired\n    private elasticsearchresttemplate template;\n}\n\n\n上述操作形式是es早期的操作方式，使用的客户端被称为low level client，这种客户端操作方式性能方面略显不足，于是es开发了全新的客户端操作方式，称为high level client。高级别客户端与es版本同步更新，但是springboot最初整合es的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。\n\n下面使用高级别客户端方式进行springboot整合es，操作步骤如下：\n\n步骤①：导入springboot整合es高级别客户端的坐标，此种形式目前没有对应的starter\n\n<dependency>\n    <groupid>org.elasticsearch.client</groupid>\n    <artifactid>elasticsearch-rest-high-level-client</artifactid>\n</dependency>\n\n\n步骤②：使用编程的形式设置连接的es服务器，并获取客户端对象\n\n@springboottest\nclass springboot18esapplicationtests {\n    private resthighlevelclient client;\n      @test\n      void testcreateclient() throws ioexception {\n          httphost host = httphost.create("http://localhost:9200");\n          restclientbuilder builder = restclient.builder(host);\n          client = new resthighlevelclient(builder);\n  \n          client.close();\n      }\n}\n\n\n配置es服务器地址与端口9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。\n\n步骤③：使用客户端对象操作es，例如创建索引\n\n@springboottest\nclass springboot18esapplicationtests {\n    private resthighlevelclient client;\n      @test\n      void testcreateindex() throws ioexception {\n          httphost host = httphost.create("http://localhost:9200");\n          restclientbuilder builder = restclient.builder(host);\n          client = new resthighlevelclient(builder);\n          // 客户端操作\n          createindexrequest request = new createindexrequest("books");\n          // 获取操作索引的客户端对象，调用创建索引操作\n          client.indices().create(request, requestoptions.default); \n          // 关闭客户端\n          client.close();\n      }\n}\n\n\n高级别客户端操作是通过发送请求的方式完成所有操作的，es针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是createindexrequest，其他操作也会有自己专用的request对象。\n\n当前操作我们发现，无论进行es何种操作，第一步永远是获取resthighlevelclient对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。\n\n@springboottest\nclass springboot18esapplicationtests {\n    @beforeeach\t\t//在测试类中每个操作运行前运行的方法\n    void setup() {\n        httphost host = httphost.create("http://localhost:9200");\n        restclientbuilder builder = restclient.builder(host);\n        client = new resthighlevelclient(builder);\n    }\n\n    @aftereach\t\t//在测试类中每个操作运行后运行的方法\n    void teardown() throws ioexception {\n        client.close();，\n    }\n\n    private resthighlevelclient client;\n\n    @test\n    void testcreateindex() throws ioexception {\n        createindexrequest request = new createindexrequest("books");\n        client.indices().create(request, requestoptions.default);\n    }\n}\n\n\n现在的书写简化了很多，也更合理。下面使用上述模式将所有的es操作执行一遍，测试结果\n\n创建索引（ik分词器）：\n\n@test\nvoid testcreateindexbyik() throws ioexception {\n    createindexrequest request = new createindexrequest("books");\n    string json = "{\\n" +\n            "    \\"mappings\\":{\\n" +\n            "        \\"properties\\":{\\n" +\n            "            \\"id\\":{\\n" +\n            "                \\"type\\":\\"keyword\\"\\n" +\n            "            },\\n" +\n            "            \\"name\\":{\\n" +\n            "                \\"type\\":\\"text\\",\\n" +\n            "                \\"analyzer\\":\\"ik_max_word\\",\\n" +\n            "                \\"copy_to\\":\\"all\\"\\n" +\n            "            },\\n" +\n            "            \\"type\\":{\\n" +\n            "                \\"type\\":\\"keyword\\"\\n" +\n            "            },\\n" +\n            "            \\"description\\":{\\n" +\n            "                \\"type\\":\\"text\\",\\n" +\n            "                \\"analyzer\\":\\"ik_max_word\\",\\n" +\n            "                \\"copy_to\\":\\"all\\"\\n" +\n            "            },\\n" +\n            "            \\"all\\":{\\n" +\n            "                \\"type\\":\\"text\\",\\n" +\n            "                \\"analyzer\\":\\"ik_max_word\\"\\n" +\n            "            }\\n" +\n            "        }\\n" +\n            "    }\\n" +\n            "}";\n    //设置请求中的参数\n    request.source(json, xcontenttype.json);\n    client.indices().create(request, requestoptions.default);\n}\n\n\nik分词器是通过请求参数的形式进行设置的，设置请求参数使用request对象中的source方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。\n\n添加文档：\n\n@test\n//添加id为1的数据（文档）\nvoid testcreatedoc() throws ioexception {\n    book book = bookdao.selectbyid(1);\n    indexrequest request = new indexrequest("books").id(book.getid().tostring());\n    string json = json.tojsonstring(book);\n    request.source(json,xcontenttype.json);\n    client.index(request,requestoptions.default);\n}\n\n\n添加文档使用的请求对象是indexrequest，与创建索引使用的请求对象不同。\n\n批量添加文档：\n\n@test\n//批量添加文档\nvoid testcreatedocall() throws ioexception {\n    list<book> booklist = bookdao.selectlist(null);\n    bulkrequest bulk = new bulkrequest();\n    for (book book : booklist) {\n        indexrequest request = new indexrequest("books").id(book.getid().tostring());\n        string json = json.tojsonstring(book);\n        request.source(json,xcontenttype.json);\n        bulk.add(request);\n    }\n    client.bulk(bulk,requestoptions.default);\n}\n\n\n批量做时，先创建一个bulkrequest的对象，可以将该对象理解为是一个保存request对象的容器，将所有的请求都初始化好后，添加到bulkrequest对象中，再使用bulkrequest对象的bulk方法，一次性执行完毕。\n\n按id查询文档：\n\n@test\n//按id查询\nvoid testget() throws ioexception {\n    getrequest request = new getrequest("books","1");\n    getresponse response = client.get(request, requestoptions.default);\n    string json = response.getsourceasstring();\n    system.out.println(json);\n}\n\n\n根据id查询文档使用的请求对象是getrequest。\n\n按条件查询文档：\n\n@test\n//按条件查询\nvoid testsearch() throws ioexception {\n    searchrequest request = new searchrequest("books");\n\n    searchsourcebuilder builder = new searchsourcebuilder();\n    builder.query(querybuilders.termquery("all","spring"));    // 查询对象\n    request.source(builder);  // 使设置条件 \n\n    searchresponse response = client.search(request, requestoptions.default);\n    searchhits hits = response.gethits();\n    for (searchhit hit : hits) {\n        string source = hit.getsourceasstring();\n        //system.out.println(source);\n        book book = json.parseobject(source, book.class);\n        system.out.println(book);\n    }\n}\n\n\n按条件查询文档使用的请求对象是searchrequest，查询时调用searchrequest对象的termquery方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的all属性。\n\nspringboot整合es的操作到这里就说完了，与前期进行springboot整合redis和mongodb的差别还是蛮大的，主要原始就是我们没有使用springboot整合es的客户端对象。至于操作，由于es操作种类过多，所以显得操作略微有点复杂。有关springboot整合es就先学习到这里吧。\n\n总结\n\n 1. springboot整合es步骤\n    1. 导入springboot整合es的high level client坐标\n    2. 手工管理客户端对象，包括初始化和关闭操作\n    3. 使用high level client根据操作的种类不同，选择不同的request对象完成对应操作\n\n\n# kf-5.整合第三方技术\n\n通过第四章的学习，我们领略到了springboot在整合第三方技术时强大的一致性，在第五章中我们要使用springboot继续整合各种各样的第三方技术，通过本章的学习，可以将之前学习的springboot整合第三方技术的思想贯彻到底，还是那三板斧。导坐标、做配置、调api。\n\nspringboot能够整合的技术实在是太多了，可以说是万物皆可整。本章将从企业级开发中常用的一些技术作为出发点，对各种各样的技术进行整合。\n\n\n# kf-5-1.缓存\n\n企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。\n\n应用程序直接与数据库打交道，访问效率低\n\n为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。\n\n\t\t\t\t\t\t\t\t\t\t使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高\n\n\n\n\n多级缓存\n\n缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘io），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。而springboot提供了对市面上几乎所有的缓存技术进行整合的方案，下面就一起开启springboot整合缓存之旅。\n\n# springboot内置缓存解决方案\n\nspringboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。\n\n步骤①：导入springboot提供的缓存技术对应的starter\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-cache</artifactid>\n</dependency>\n\n\n步骤②：启用缓存，在引导类上方标注注解@enablecaching配置springboot程序中可以使用缓存\n\n@springbootapplication\n//开启缓存功能\n@enablecaching\npublic class springboot19cacheapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot19cacheapplication.class, args);\n    }\n}\n\n\n步骤③：设置操作的数据是否使用缓存\n\n@service\npublic class bookserviceimpl implements bookservice {\n    @autowired\n    private bookdao bookdao;\n\n    @cacheable(value="cachespace",key="#id")\n    public book getbyid(integer id) {\n        return bookdao.selectbyid(id);\n    }\n}\n\n\n在业务方法上面使用注解@cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。\n\n使用@cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。\n\n# 手机验证码案例\n\n为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。\n\n手机验证码案例需求如下：\n\n * 输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）\n * 输入手机号和验证码验证结果\n\n为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。\n\n步骤①：导入springboot提供的缓存技术对应的starter\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-cache</artifactid>\n</dependency>\n\n\n步骤②：启用缓存，在引导类上方标注注解@enablecaching配置springboot程序中可以使用缓存\n\n@springbootapplication\n//开启缓存功能\n@enablecaching\npublic class springboot19cacheapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot19cacheapplication.class, args);\n    }\n}\n\n\n步骤③：定义验证码对应的实体类，封装手机号与验证码两个属性\n\n@data\npublic class smscode {\n    private string tele;\n    private string code;\n}\n\n\n步骤④：定义验证码功能的业务层接口与实现类\n\npublic interface smscodeservice {\n    public string sendcodetosms(string tele);\n    public boolean checkcode(smscode smscode);\n}\n\n@service\npublic class smscodeserviceimpl implements smscodeservice {\n    @autowired\n    private codeutils codeutils;\n\n    @cacheput(value = "smscode", key = "#tele")\n    public string sendcodetosms(string tele) {\n        string code = codeutils.generator(tele);\n        return code;\n    }\n\n    public boolean checkcode(smscode smscode) {\n        //取出内存中的验证码与传递过来的验证码比对，如果相同，返回true\n        string code = smscode.getcode();\n        string cachecode = codeutils.get(smscode.gettele());  // 缓存中取出对应的验证码\n        return code.equals(cachecode);\n    }\n}\n\n\n获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@cacheable注解，@cacheable注解是缓存中没有值则放入值，缓存中有值则取值，在这里就不能根据手机号重新生成验证码了。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@cacheput注解即可。\n\n对于校验验证码的功能建议放入工具类中进行。\n\n步骤⑤：定义验证码的生成策略与根据手机号读取验证码的功能\n\n@component\npublic class codeutils {\n    private string [] patch = {"000000","00000","0000","000","00","0",""};\n\n    public string generator(string tele){\n        int hash = tele.hashcode();\n        int encryption = 20206666;\n        long result = hash ^ encryption;\n        long nowtime = system.currenttimemillis();\n        result = result ^ nowtime;\n        long code = result % 1000000;\n        code = code < 0 ? -code : code;\n        string codestr = code +   // 转成字符串\n        int len = codestr.length();\n        return patch[len] + codestr;\n    }\n\n    @cacheable(value = "smscode",key="#tele")\n    public string get(string tele){\n        return null;\n    }\n}\n\n\n步骤⑥：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验\n\n@restcontroller\n@requestmapping("/sms")\npublic class smscodecontroller {\n    @autowired\n    private smscodeservice smscodeservice;\n    \n    @getmapping\n    public string getcode(string tele){\n        string code = smscodeservice.sendcodetosms(tele);\n        return code;\n    }\n    \n    @postmapping\n    public boolean checkcode(smscode smscode){\n        return smscodeservice.checkcode(smscode);\n    }\n}\n\n\n# springboot常用缓存技术\n\n标红的是最为常用的\n\n\n\n# springboot整合ehcache缓存\n\n手机验证码的案例已经完成了，下面就开始springboot整合各种各样的缓存技术，第一个整合ehcache技术。ehcache是一种缓存技术，使用springboot整合ehcache其实就是变更一下缓存技术的实现方式，话不多说，直接开整\n\n步骤①：导入ehcache的坐标\n\n<dependency>\n    <groupid>net.sf.ehcache</groupid>\n    <artifactid>ehcache</artifactid>\n</dependency>\n\n\n此处为什么不是导入ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。\n\n步骤②：配置缓存技术实现使用ehcache\n\nspring:\n  cache:\n    type: ehcache\n    ehcache:\n      config: ehcache.xml\n\n\n配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。\n\n由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:nonamespaceschemalocation="http://ehcache.org/ehcache.xsd"\n         updatecheck="false">\n    <diskstore path="d:\\ehcache" />\n\n    \x3c!--默认缓存策略 --\x3e\n    \x3c!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false--\x3e\n    \x3c!-- diskpersistent：是否启用磁盘持久化--\x3e\n    \x3c!-- maxelementsinmemory：最大缓存数量--\x3e\n    \x3c!-- overflowtodisk：超过最大缓存数量是否持久化到磁盘--\x3e\n    \x3c!-- timetoidleseconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码--\x3e\n    \x3c!-- timetoliveseconds：最大存活时间--\x3e\n    \x3c!-- memorystoreevictionpolicy：缓存清除策略--\x3e\n    <defaultcache\n        eternal="false"\n        diskpersistent="false"\n        maxelementsinmemory="1000"\n        overflowtodisk="false"\n        timetoidleseconds="60"\n        timetoliveseconds="60"\n        memorystoreevictionpolicy="lru" />\n    \x3c!--自定义的缓存name要和cacheable或者cacheput中的name一致，因为cacheable或者cacheput会根据value寻找对应的cache配置，否则报错--\x3e\n    <cache\n        name="smscode"\n        eternal="false"\n        diskpersistent="false"\n        maxelementsinmemory="1000"\n        overflowtodisk="false"\n        timetoidleseconds="10"\n        timetoliveseconds="10"\n        memorystoreevictionpolicy="lru" />\n</ehcache>\n\n\n注意前面的案例中，设置了数据保存的位置是smscode\n\n@cacheput(value = "smscode", key = "#tele")\npublic string sendcodetosms(string tele) {\n    string code = codeutils.generator(tele);\n    return code;\n}\t\n\n\n这个设定需要保障ehcache中有一个缓存空间名称叫做smscode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。\n\n到这里springboot整合ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。\n\n总结\n\n 1. springboot使用ehcache作为缓存实现需要导入ehcache的坐标\n 2. 修改设置，配置缓存供应商为ehcache，并提供对应的缓存配置文件\n\n\n\n# springboot整合redis缓存\n\n上节使用ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。\n\n比对使用ehcache的过程，加坐标，改缓存实现类型为ehcache，做ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。\n\n步骤①：导入redis的坐标\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n步骤②：配置缓存技术实现使用redis\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n\n\n如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。\n\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n    redis:\n      use-key-prefix: false  # 是否有前缀，默认是true\n      key-prefix: sms_  # 上面如果为false，这个配置选项将会失效\n      cache-null-values: false   # 是否缓存空值\n      time-to-live: 10s  # 缓存周期\n\n\n总结\n\n 1. springboot使用redis作为缓存实现需要导入redis的坐标\n 2. 修改设置，配置缓存供应商为redis，并提供对应的缓存配置\n\n# springboot整合memcached缓存\n\n目前我们已经掌握了3种缓存解决方案的配置形式，分别是springboot内置缓存，ehcache和redis，本节研究一下国内比较流行的一款缓存memcached。\n\n按照之前的套路，其实变更缓存并不繁琐，但是springboot并没有支持使用memcached作为其缓存解决方案，也就是说在type属性中没有memcached的配置选项，这里就需要更变一下处理方式了。在整合之前先安装memcached。\n\n安装\n\nwindows版安装包下载地址：https://www.runoob.com/memcached/window-install-memcached.html\n\n下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n\n可执行文件只有一个memcached.exe，使用该文件可以将memcached作为系统服务启动，执行此文件时会出现报错信息，如下：\n\n此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行\n\n然后再次执行安装服务的命令即可，如下：\n\nmemcached.exe -d install\n\n\n服务安装完毕后可以使用命令启动和停止服务，如下：\n\nmemcached.exe -d start\t\t# 启动服务\nmemcached.exe -d stop\t\t# 停止服务\n\n\n也可以在任务管理器中进行服务状态的切换\n\n变更缓存为memcached\n\n由于memcached未被springboot收录为缓存解决方案，因此使用memcached需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。\n\nmemcached目前提供有三种客户端技术，分别是memcached client for java、spymemcached和xmemcached，其中性能指标各方面最好的客户端是xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用xmemcached\n\n步骤①：导入xmemcached的坐标\n\n<dependency>\n    <groupid>com.googlecode.xmemcached</groupid>\n    <artifactid>xmemcached</artifactid>\n    <version>2.4.7</version>\n</dependency>\n\n\n步骤②：配置memcached，制作memcached的配置类\n\n@configuration\npublic class xmemcachedconfig {\n    @bean\n    public memcachedclient getmemcachedclient() throws ioexception {\n        memcachedclientbuilder memcachedclientbuilder = new xmemcachedclientbuilder("localhost:11211");\n        memcachedclient memcachedclient = memcachedclientbuilder.build();\n        return memcachedclient;\n    }\n}\n\n\nmemcached默认对外服务端口11211。\n\n步骤③：使用xmemcached客户端操作缓存，注入memcachedclient对象\n\n@service\npublic class smscodeserviceimpl implements smscodeservice {\n    @autowired\n    private codeutils codeutils;\n    @autowired\n    private memcachedclient memcachedclient;\n    // 生成并发送验证码\n    public string sendcodetosms(string tele) {\n        string code = codeutils.generator(tele);\n        try {\n            // 10秒更新一次\n            memcachedclient.set(tele,10,code);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n        return code;\n    }\n    // 比对验证码是否相同\n    public boolean checkcode(smscode smscode) {\n        string code = null;\n        try {\n            // memcachedclient.get(smscode.gettele())得到是一个object类型的值，因此需要将这部分内容转成一个字符串\n            code = memcachedclient.get(smscode.gettele()).tostring();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n        return smscode.getcode().equals(code);\n    }\n}\n\n\n设置值到缓存中使用set操作，取值使用get操作，其实更符合我们开发者的习惯。\n\n上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。\n\n定义配置属性\n\n以下过程采用前期学习的属性配置方式进行，当前操作有助于理解原理篇中的很多知识。\n\n * 定义配置类，加载必要的配置属性，读取配置文件中memcached节点信息\n   \n   @component\n   @configurationproperties(prefix = "memcached")\n   @data\n   public class xmemcachedproperties {\n       private string servers;\n       private int poolsize;\n       private long optimeout;\n   }\n   \n\n * 定义memcached节点信息\n   \n   memcached:\n     servers: localhost:11211\n     poolsize: 10\n     optimeout: 3000\n   \n\n * 在memcached配置类中加载信息\n\n@configuration\npublic class xmemcachedconfig {\n    @autowired\n    private xmemcachedproperties props;\n    @bean\n    public memcachedclient getmemcachedclient() throws ioexception {\n        memcachedclientbuilder memcachedclientbuilder = new xmemcachedclientbuilder(props.getservers());\n        memcachedclientbuilder.setconnectionpoolsize(props.getpoolsize());\n        memcachedclientbuilder.setoptimeout(props.getoptimeout());\n        memcachedclient memcachedclient = memcachedclientbuilder.build();\n        return memcachedclient;\n    }\n}\n\n\n总结\n\n 1. memcached安装后需要启动对应服务才可以对外提供缓存功能，安装memcached服务需要基于windows系统管理员权限\n 2. 由于springboot没有提供对memcached的缓存整合方案，需要采用手工编码的形式创建xmemcached客户端操作缓存\n 3. 导入xmemcached坐标后，创建memcached配置类，注册memcachedclient对应的bean，用于操作缓存\n 4. 初始化memcachedclient对象所需要使用的属性可以通过自定义配置属性类的形式加载\n\n思考\n\n到这里已经完成了三种缓存的整合，其中redis和mongodb需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，ehcache是一个典型的内存级缓存，因为它什么也不用安装，启动后导入jar包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？咱们下节再说。\n\n# springboot整合jetcache缓存\n\n目前我们使用的缓存都是要么a要么b，能不能ab一起用呢？这一节就解决这个问题。springboot针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持ab一起用，springboot也没办法，所以要想解决ab缓存一起用的问题，就必须找一款缓存能够支持ab两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。\n\njetcache严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到jetcache中管理，这样就可以支持ab缓存一起用了。并且jetcache参考了springboot整合缓存的思想，整体技术使用方式和springboot的缓存解决方案思想非常类似。下面咱们就先把jetcache用起来，然后再说它里面的一些小的功能。\n\n本地缓存和远程缓存的区别是什么？后面了解一下。远程是要去远程主机上去吗\n\n做之前要先明确一下，jetcache并不是随便拿两个缓存都能拼到一起去的。目前jetcache支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：\n\n * 本地缓存（local）\n   * linkedhashmap\n   * caffeine\n * 远程缓存（remote）\n   * redis\n   * tair\n\n其实也有人问我，为什么jetcache只支持2+2这么4款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有1+1种，逐步变化成2+2种。下面就以linkedhashmap+redis的方案实现本地与远程缓存方案同时使用。\n\n# 纯远程方案\n\n步骤①：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis\n\n<dependency>\n    <groupid>com.alicp.jetcache</groupid>\n    <artifactid>jetcache-starter-redis</artifactid>\n    <version>2.6.2</version>\n</dependency>\n\n\n步骤②：远程方案基本配置\n\njetcache:\n  remote:\n    default:  # 默认方案，其他方案用名字命名\n      type: redis\n      host: localhost\n      port: 6379\n      poolconfig:\n        maxtotal: 50\n\n\n其中poolconfig是必配项，否则会报错\n\n步骤③：启用缓存，在引导类上方标注注解@enablecreatecacheannotation配置springboot程序中可以使用注解的形式创建缓存\n\n@springbootapplication\n//jetcache启用缓存的主开关\n@enablecreatecacheannotation\npublic class springboot20jetcacheapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot20jetcacheapplication.class, args);\n    }\n}\n\n\n步骤④：创建缓存对象cache，并使用注解@createcache标记当前缓存的信息，然后使用cache对象的api操作缓存，put写缓存，get读缓存。\n\n@service\npublic class smscodeserviceimpl implements smscodeservice {\n    @autowired\n    private codeutils codeutils;\n    \n    @createcache(name="jetcache_",expire = 10,timeunit = timeunit.seconds)  //不设置timeunit默认单位是秒\n    private cache<string ,string> jetcache;\n\n    public string sendcodetosms(string tele) {\n        string code = codeutils.generator(tele);\n        jetcache.put(tele,code);\n        return code;\n    }\n\n    public boolean checkcode(smscode smscode) {\n        string code = jetcache.get(smscode.gettele());\n        return smscode.getcode().equals(code);\n    }\n}\n\n\n通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。\n\n上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：\n\njetcache:\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolconfig:\n        maxtotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolconfig:\n        maxtotal: 50\n\n\n如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可\n\n@service\npublic class smscodeserviceimpl implements smscodeservice {\n    @autowired\n    private codeutils codeutils;\n    \n    @createcache(area="sms",name="jetcache_",expire = 10,timeunit = timeunit.seconds)\n    private cache<string ,string> jetcache;\n\n    public string sendcodetosms(string tele) {\n        string code = codeutils.generator(tele);\n        jetcache.put(tele,code); // 放入\n        return code;\n    }\n\n    public boolean checkcode(smscode smscode) {\n        string code = jetcache.get(smscode.gettele());  // 获取\n        return smscode.getcode().equals(code);  \n    }\n}\n\n\n# 纯本地方案\n\n远程方案中，配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已。\n\n步骤①：导入springboot整合jetcache对应的坐标starter\n\n<dependency>\n    <groupid>com.alicp.jetcache</groupid>\n    <artifactid>jetcache-starter-redis</artifactid>\n    <version>2.6.2</version>\n</dependency>\n\n\n步骤②：本地缓存基本配置\n\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyconvertor: fastjson\n\n\n为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。\n\n步骤③：启用缓存\n\n@springbootapplication\n//jetcache启用缓存的主开关\n@enablecreatecacheannotation\npublic class springboot20jetcacheapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot20jetcacheapplication.class, args);\n    }\n}\n\n\n步骤④：创建缓存对象cache时，标注当前使用本地缓存\n\n@service\npublic class smscodeserviceimpl implements smscodeservice {\n    @createcache(name="jetcache_",expire = 1000,timeunit = timeunit.seconds,cachetype = cachetype.local)\n    private cache<string ,string> jetcache;\n\n    public string sendcodetosms(string tele) {\n        string code = codeutils.generator(tele);\n        jetcache.put(tele,code);\n        return code;\n    }\n    \n    public boolean checkcode(smscode smscode) {\n        string code = jetcache.get(smscode.gettele());\n        return smscode.getcode().equals(code);\n    }\n}\n\n\ncachetype控制当前缓存使用本地缓存还是远程缓存，配置cachetype=cachetype.local即使用本地缓存，默认采用远程方案。\n\n# 本地+远程方案\n\n本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一 起就可以了。\n\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyconvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolconfig:\n        maxtotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolconfig:\n        maxtotal: 50\n\n\n在创建缓存的时候，配置cachetype为both即则本地缓存与远程缓存同时使用。\n\n@service\npublic class smscodeserviceimpl implements smscodeservice {\n    @createcache(name="jetcache_",expire = 1000,timeunit = timeunit.seconds,cachetype = cachetype.both)\n    private cache<string ,string> jetcache;\n}\n\n\ncachetype如果不进行配置，默认值是remote，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息\n\n属性                                                         默认值    说明\njetcache.statintervalminutes                               0      统计间隔，0表示不统计\njetcache.hiddenpackages                                    无      自动生成name时，隐藏指定的包名前缀\njetcache.[local|remote].${area}.type                       无      缓存类型，本地支持linkedhashmap、caffeine，远程支持redis、tair\njetcache.[local|remote].${area}.keyconvertor               无      key转换器，当前仅支持fastjson\njetcache.[local|remote].${area}.valueencoder               java   仅remote类型的缓存需要指定，可选java和kryo\njetcache.[local|remote].${area}.valuedecoder               java   仅remote类型的缓存需要指定，可选java和kryo\njetcache.[local|remote].${area}.limit                      100    仅local类型的缓存需要指定，缓存实例最大元素数\njetcache.[local|remote].${area}.expireafterwriteinmillis   无穷大    默认过期时间，毫秒单位\njetcache.local.${area}.expireafteraccessinmillis           0      仅local类型的缓存有效，毫秒单位，最大不活动间隔\n\n以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。\n\n方法缓存\n\njetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@cached即可\n\n步骤①：导入springboot整合jetcache对应的坐标starter\n\n<dependency>\n    <groupid>com.alicp.jetcache</groupid>\n    <artifactid>jetcache-starter-redis</artifactid>\n    <version>2.6.2</version>\n</dependency>\n\n\n步骤②：配置缓存\n\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyconvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      keyconvertor: fastjson\n      valueencode: java\n      valuedecode: java\n      poolconfig:\n        maxtotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolconfig:\n        maxtotal: 50\n\n\n由于redis缓存中不支持保存对象，因此需要对redis设置当object类型数据进入到redis中时如何进行类型转换。需要配置keyconvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueencode为java，值从redis中读取时转换成java，标注valuedecode为java。\n\n注意，为了实现object类型的值进出redis，需要保障进出redis的object类型的数据必须实现序列化接口。\n\n@data\npublic class book implements serializable {\n    private integer id;\n    private string type;\n    private string name;\n    private string description;\n}\n\n\n步骤③：启用缓存时开启方法缓存功能，并配置basepackages，说明在哪些包中开启方法缓存\n\n@springbootapplication\n//jetcache启用缓存的主开关\n@enablecreatecacheannotation \n//开启方法注解缓存\n@enablemethodcache(basepackages = "com.itheima")\npublic class springboot20jetcacheapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot20jetcacheapplication.class, args);\n    }\n}\n\n\n步骤④：使用注解@cached标注当前方法使用缓存\n\n@service\npublic class bookserviceimpl implements bookservice {\n    @autowired\n    private bookdao bookdao;\n    \n    @override\n    @cached(name="book_",key="#id",expire = 3600,cachetype = cachetype.remote)\n    public book getbyid(integer id) {\n        return bookdao.selectbyid(id);\n    }\n}\n\n\n# 远程方案的数据同步\n\n由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据\n\n更新缓存\n\n@cacheupdate(name="book_",key="#book.id",value="#book")\npublic boolean update(book book) {\n    return bookdao.updatebyid(book) > 0;\n}\n\n\n删除缓存\n\n@cacheinvalidate(name="book_",key = "#id")\npublic boolean delete(integer id) {\n    return bookdao.deletebyid(id) > 0;\n}\n\n\n定时刷新缓存\n\n@cached(name="book_",key="#id",expire = 3600,cachetype = cachetype.remote)\n@cacherefresh(refresh = 5)\npublic book getbyid(integer id) {\n    return bookdao.selectbyid(id);\n}\n\n\n# 数据报表\n\njetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可\n\njetcache:\n  statintervalminutes: 1\n\n\n设置后，每1分钟在控制台输出缓存数据命中信息\n\n[defaultexecutor] c.alicp.jetcache.support.statinfologger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003\ncache    |    qps|   rate|   get|    hit|   fail|   expire|   avgloadtime|   maxloadtime\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\nbook_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\n\n\n总结\n\n 1. jetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案\n 2. jetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种\n 3. 注意数据进入远程缓存时的类型转换问题\n 4. jetcache提供方法缓存，并提供了对应的缓存更新与刷新功能\n 5. jetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况\n\n思考\n\njetcache解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？有，咱们下一节再讲。\n\n# springboot整合j2cache缓存\n\njetcache可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以ehcache与redis整合为例：\n\n步骤①：导入j2cache、redis、ehcache坐标\n\n<dependency>\n    <groupid>net.oschina.j2cache</groupid>\n    <artifactid>j2cache-core</artifactid>\n    <version>2.8.4-release</version>\n</dependency>\n<dependency>\n    <groupid>net.oschina.j2cache</groupid>\n    <artifactid>j2cache-spring-boot2-starter</artifactid>\n    <version>2.8.0-release</version>\n</dependency>\n<dependency>\n    <groupid>net.sf.ehcache</groupid>\n    <artifactid>ehcache</artifactid>\n</dependency>\n\n\nj2cache的starter中默认包含了redis坐标，官方推荐使用redis作为二级缓存，因此此处无需导入redis坐标\n\n步骤②：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为j2cache.properties的文件中。如果使用ehcache还需要单独添加ehcache的配置文件\n\n# 这是最基础的配置方法\n# 1级缓存\nj2cache.l1.provider_class = ehcache\nehcache.configxml = ehcache.xml\n\n# 2级缓存\nj2cache.l2.provider_class = net.oschina.j2cache.cache.support.redis.springredisprovider\nj2cache.l2.config_section = redis\nredis.hosts = localhost :6379\n\n# 1级缓存中的数据如何到达二级缓存\nj2cache.broadcast = net.oschina.j2cache.cache.support.redis.springredispubsubpolicy\n\n\n此处配置不能乱配置，需要参照官方给出的配置说明进行。例如1级供应商选择ehcache，供应商名称仅仅是一个ehcache，但是2级供应商选择redis时要写专用的spring整合redis的供应商类名springredisprovider，而且这个名称并不是所有的redis包中能提供的，也不是spring包中提供的。因此配置j2cache必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。\n\n一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。\n\n步骤③：使用缓存\n\n@service\npublic class smscodeserviceimpl implements smscodeservice {\n    @autowired\n    private codeutils codeutils;\n\n    @autowired\n    private cachechannel cachechannel;\n\n    public string sendcodetosms(string tele) {\n        string code = codeutils.generator(tele);\n        cachechannel.set("sms",tele,code);\n        return code;\n    }\n\n    public boolean checkcode(smscode smscode) {\n        string code = cachechannel.get("sms",smscode.gettele()).asstring();\n        return smscode.getcode().equals(code);\n    }\n}\n\n\nj2cache的使用和jetcache比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名cachechannel。\n\nj2cache的使用不复杂，配置是j2cache的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅j2cache-core核心包中的j2cache.properties文件中的说明。如下：\n\n#j2cache configuration\n#########################################\n# cache broadcast method\n# values:\n# jgroups -> use jgroups\'s multicast\n# redis -> use redis publish/subscribe mechanism (using jedis)\n# lettuce -> use redis publish/subscribe mechanism (using lettuce, recommend)\n# rabbitmq -> use rabbitmq publisher/consumer mechanism\n# rocketmq -> use rocketmq publisher/consumer mechanism\n# none -> don\'t notify the other nodes in cluster\n# xx.xxxx.xxxx.xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.clusterpolicy\n#########################################\nj2cache.broadcast = redis\n\n# jgroups properties\njgroups.channel.name = j2cache\njgroups.configxml = /network.xml\n\n# rabbitmq properties\nrabbitmq.exchange = j2cache\nrabbitmq.host = localhost\nrabbitmq.port = 5672\nrabbitmq.username = guest\nrabbitmq.password = guest\n\n# rocketmq properties\nrocketmq.name = j2cache\nrocketmq.topic = j2cache\n# use ; to split multi hosts\nrocketmq.hosts = 127.0.0.1:9876\n\n#########################################\n# level 1&2 provider\n# values:\n# none -> disable this level cache\n# ehcache -> use ehcache2 as level 1 cache\n# ehcache3 -> use ehcache3 as level 1 cache\n# caffeine -> use caffeine as level 1 cache(only in memory)\n# redis -> use redis as level 2 cache (using jedis)\n# lettuce -> use redis as level 2 cache (using lettuce)\n# readonly-redis -> use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.l2.config_section` to make the redis configurations available.\n# memcached -> use memcached as level 2 cache (xmemcached),\n# [classname] -> use custom provider\n#########################################\n\nj2cache.l1.provider_class = caffeine\nj2cache.l2.provider_class = redis\n\n# when l2 provider isn\'t `redis`, using `l2.config_section = redis` to read redis configurations\n# j2cache.l2.config_section = redis\n\n# enable/disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)\n# notice: redis hash mode (redis.storage = hash) do not support this feature)\nj2cache.sync_ttl_to_redis = true\n\n\n\n# 是否启用二级缓存\nj2cache.l2-cache-open = false\n# whether to cache null objects by default (default false)\nj2cache.default_cache_null_object = true\n\n#########################################\n# cache serialization provider\n# values:\n# fst -> using fast-serialization (recommend)\n# kryo -> using kryo serialization\n# json -> using fst\'s json serialization (testing)\n# fastjson -> using fastjson serialization (embed non-static class not support)\n# java -> java standard\n# fse -> using fse serialization\n# [classname implements serializer]\n#########################################\n\nj2cache.serialization = json\n#json.map.person = net.oschina.j2cache.demo.person\n\n#########################################\n# ehcache configuration\n#########################################\n\n# ehcache.configxml = /ehcache.xml\n\n# ehcache3.configxml = /ehcache3.xml\n# ehcache3.defaultheapsize = 1000\n\n#########################################\n# caffeine configuration\n# caffeine.region.[name] = size, xxxx[s|m|h|d]\n#\n#########################################\ncaffeine.properties = /caffeine.properties\n\n#########################################\n# redis connection configuration\n#########################################\n\n#########################################\n# redis cluster mode\n#\n# single -> single redis server  # 单机的redis服务器\n# sentinel -> master-slaves servers    # 主从模式服务器\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n# 这个选项没有在文件配置会有warning警告\nredis.mode = single  \n\n#redis storage mode (generic|hash)\nredis.storage = generic\n\n## redis pub/sub channel name\nredis.channel = j2cache\n## redis pub/sub server (using redis.hosts when empty)\nredis.channel.host =\n\n#cluster name just for sharded\nredis.cluster_name = j2cache\n\n## redis cache namespace optional, default[empty] \n## 这个属性可以在key前面加上一个前缀，默认是空\nredis.namespace =\n\n\n## redis command scan parameter count, default[1000]\n#redis.scancount = 1000\n\n## connection\n# separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379\n\nredis.hosts = 127.0.0.1:6379\nredis.timeout = 2000\nredis.password =\nredis.database = 0\nredis.ssl = false\n\n## redis pool properties\nredis.maxtotal = 100\nredis.maxidle = 10\nredis.maxwaitmillis = 5000\nredis.minevictableidletimemillis = 60000\nredis.minidle = 1\nredis.numtestsperevictionrun = 10\nredis.lifo = false\nredis.softminevictableidletimemillis = 10\nredis.testonborrow = true\nredis.testonreturn = false\nredis.testwhileidle = true\nredis.timebetweenevictionrunsmillis = 300000\nredis.blockwhenexhausted = false\nredis.jmxenabled = false\n\n#########################################\n# lettuce scheme\n#\n# redis -> single redis server\n# rediss -> single redis server with ssl\n# redis-sentinel -> redis sentinel\n# redis-cluster -> cluster servers\n#\n#########################################\n\n#########################################\n# lettuce mode\n#\n# single -> single redis server\n# sentinel -> master-slaves servers\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n\n## redis command scan parameter count, default[1000]\n#lettuce.scancount = 1000\nlettuce.mode = single\nlettuce.namespace =\nlettuce.storage = hash\nlettuce.channel = j2cache\nlettuce.scheme = redis\nlettuce.hosts = 127.0.0.1:6379\nlettuce.password =\nlettuce.database = 0\nlettuce.sentinelmasterid =\nlettuce.maxtotal = 100\nlettuce.maxidle = 10\nlettuce.minidle = 10\n# timeout in milliseconds\nlettuce.timeout = 10000\n# redis cluster topology refresh interval in milliseconds\nlettuce.clustertopologyrefresh = 3000\n\n#########################################\n# memcached server configurations\n# refer to https://gitee.com/mirrors/xmemcached\n#########################################\n\nmemcached.servers = 127.0.0.1:11211\nmemcached.username =\nmemcached.password =\nmemcached.connectionpoolsize = 10\nmemcached.connecttimeout = 1000\nmemcached.failuremode = false\nmemcached.healsessioninterval = 1000\nmemcached.maxqueuednoreplyoperations = 100\nmemcached.optimeout = 100\nmemcached.sanitizekeys = false\n\n\n总结\n\n 1. j2cache是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案\n 2. j2cache需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式\n 3. j2cache操作接口通过cachechannel实现\n\n\n# kf-5-2.任务\n\nspringboot整合第三方技术第二部分我们来说说任务系统，其实这里说的任务系统指的是定时任务。定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。\n\n最简单的是timer定时任务\n\n\n\n# quartz\n\nquartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习springboot整合quartz前先普及几个quartz的概念。\n\n * 工作（job）：用于定义具体执行的工作\n * 工作明细（jobdetail）：用于描述定时工作相关的信息\n * 触发器（trigger）：描述了工作明细与调度器的对应关系\n * 调度器（scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则\n\n简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始springboot整合quartz。\n\n步骤①：导入springboot整合quartz的starter\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-quartz</artifactid>\n</dependency>\n\n\n步骤②：定义任务bean，按照quartz的开发规范制作，继承quartzjobbean\n\npublic class myquartz extends quartzjobbean {\n    @override\n    protected void executeinternal(jobexecutioncontext context) throws jobexecutionexception {\n        system.out.println("quartz task run...");\n    }\n}\n\n\n步骤③：创建quartz配置类，定义工作明细（jobdetail）与触发器的（trigger）bean\n\n@configuration\npublic class quartzconfig {\n    @bean\n    public jobdetail printjobdetail(){\n        //绑定具体的工作\n        // storedurably用来指定持久化\n        return jobbuilder.newjob(myquartz.class).storedurably().build();\n    }\n    @bean\n    public trigger printjobtrigger(){\n        schedulebuilder schedbuilder = cronschedulebuilder.cronschedule("0/5 * * * * ?");\n        //绑定对应的工作明细\n        return triggerbuilder.newtrigger().forjob(printjobdetail()).withschedule(schedbuilder).build();\n    }\n}\n\n\n工作明细中要设置对应的具体工作，使用newjob()操作传入对应的工作任务类型即可。\n\n触发器需要绑定任务，使用forjob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是cron表达式（这是什么？查阅一下）。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。\n\n总结\n\n 1. springboot整合quartz就是将quartz对应的核心对象交给spring容器管理，包含两个对象，jobdetail和trigger对象\n 2. jobdetail对象描述的是工作的执行信息，需要绑定一个quartzjobbean类型的对象\n 3. trigger对象定义了一个触发器，需要为其指定绑定的jobdetail是哪个，同时要设置执行周期调度器\n\n思考\n\n上面的操作看上去不多，但是quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring针对上述规则进行了简化，开发了自己的任务管理组件——task，如何用呢？咱们下节再说。\n\n# task\n\nspring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做\n\n步骤①：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@enablescheduling\n\n@springbootapplication\n//开启定时任务功能\n@enablescheduling\npublic class springboot22taskapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot22taskapplication.class, args);\n    }\n}\n\n\n步骤②：定义bean，在对应要定时执行的操作上方，使用注解@scheduled定义执行的时间，执行时间的描述方式还是cron表达式\n\n@component\npublic class mybean {\n    @scheduled(cron = "0/1 * * * * ?")\n    public void print(){\n        system.out.println(thread.currentthread().getname()+" :spring task run...");\n    }\n}\n\n\n完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。\n\n如何想对定时任务进行相关配置，可以通过配置文件进行\n\nspring:\n  task:\n   \tscheduling:\n      pool:\n       \tsize: 1\t\t\t\t\t\t\t# 任务调度线程池大小 默认 1\n      thread-name-prefix: ssm_      \t# 调度线程名称前缀 默认 scheduling-      \n        shutdown:\n          await-termination: false\t\t# 线程池关闭时等待所有任务完成\n          await-termination-period: 10s\t# 调度线程关闭前最大等待时间，确保最后一定关闭\n\n\n总结\n\n 1. spring task需要使用注解@enablescheduling开启定时任务功能\n\n 2. 为定时执行的的任务设置执行周期，描述方式cron表达式\n\n\n# kf-5-3.邮件\n\nspringboot整合第三方技术第三部分我们来说说邮件系统，发邮件是java程序的基本操作，springboot整合javamail其实就是简化开发。不熟悉邮件的小伙伴可以先学习完javamail的基础操作，再来看这一部分内容才能感触到springboot整合javamail究竟简化了哪些操作。简化的多码？其实不多，差别不大，只是还个格式而已。\n\n学习邮件发送之前先了解3个概念，这些概念规范了邮件操作过程中的标准。\n\n * smtp（simple mail transfer protocol）：简单邮件传输协议，用于发送电子邮件的传输协议（最关注的协议）\n * pop3（post office protocol - version 3）：用于接收电子邮件的标准协议\n * imap（internet mail access protocol）：互联网消息协议，是pop3的替代协议\n\n简单说就是smpt是发邮件的标准，pop3是收邮件的标准，imap是对pop3的升级。我们制作程序中操作邮件，通常是发邮件，所以smtp是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如hr的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习springboot如何整合javamail发送邮件。\n\n# 发送简单邮件\n\n步骤①：导入springboot整合javamail的starter\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-mail</artifactid>\n</dependency>\n\n\n步骤②：配置邮箱的登录信息\n\nspring:\n  mail:\n    host: smtp.126.com\n    username: test@126.com\n    password: test\n\n\njava程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。\n\nhost配置的是提供邮件服务的主机协议（提供邮件的服务商），当前程序仅用于发送邮件，因此配置的是smtp的协议。\n\npassword并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找pop3或imap这些关键词找到对应的获取位置。下例仅供参考：\n\n\n\n步骤③：使用javamailsender接口发送邮件\n\n@service\npublic class sendmailserviceimpl implements sendmailservice {\n    @autowired\n    private javamailsender javamailsender;\n\n    //发送人\n    private string from = "test@qq.com";\n    //接收人\n    private string to = "test@126.com";\n    //标题\n    private string subject = "测试邮件";\n    //正文\n    private string context = "测试邮件正文内容";\n\n    @override\n    public void sendmail() {\n        simplemailmessage message = new simplemailmessage();\n        message.setfrom(from+"(小甜甜)");\n        message.setto(to);\n        message.setsubject(subject);\n        message.settext(context);\n        javamailsender.send(message);\n    }\n}\n\n\n将发送邮件的必要信息（发件人、收件人、标题、正文）封装到simplemailmessage对象中，可以根据规则设置发送人昵称等。\n\n# 发送多组件邮件（附件、复杂正文）\n\n发送简单邮件仅需要提供对应的4个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用mimemessage可以发送特殊的邮件。\n\n发送网页正文邮件\n\n@service\npublic class sendmailserviceimpl2 implements sendmailservice {\n    @autowired\n    private javamailsender javamailsender;\n\n    //发送人\n    private string from = "test@qq.com";\n    //接收人\n    private string to = "test@126.com";\n    //标题\n    private string subject = "测试邮件";\n    //正文\n    private string context = "<img src=\'abc.jpg\'/><a href=\'https://www.itcast.cn\'>点开有惊喜</a>";\n\n    public void sendmail() {\n        try {\n            // 以下为固定操作\n            mimemessage message = javamailsender.createmimemessage();\n            mimemessagehelper helper = new mimemessagehelper(message);\n            helper.setfrom(to+"(小甜甜)");\n            helper.setto(from);\n            helper.setsubject(subject);\n            helper.settext(context,true);\t\t//此处设置正文支持html解析\n\n            javamailsender.send(message);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n发送带有附件的邮件\n\n@service\npublic class sendmailserviceimpl2 implements sendmailservice {\n    @autowired\n    private javamailsender javamailsender;\n\n    //发送人\n    private string from = "test@qq.com";\n    //接收人\n    private string to = "test@126.com";\n    //标题\n    private string subject = "测试邮件";\n    //正文\n    private string context = "测试邮件正文";\n\n    public void sendmail() {\n        try {\n            mimemessage message = javamailsender.createmimemessage();\n            mimemessagehelper helper = new mimemessagehelper(message,true);\t\t//此处设置支持附件\n            helper.setfrom(from+"(小甜甜)");\n            helper.setto(to);\n            helper.setsubject(subject);\n            helper.settext(context);\n\n            //添加附件\n            file f1 = new file("springboot_23_mail-0.0.1-snapshot.jar");\n            file f2 = new file("resources\\\\logo.png");\n\n            helper.addattachment(f1.getname(),f1);\n            helper.addattachment("最靠谱的培训结构.png",f2);\n\n            javamailsender.send(message);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n总结\n\n 1. springboot整合javamail其实就是简化了发送邮件的客户端对象javamailsender的初始化过程，通过配置的形式加载信息简化开发过程\n\n\n# kf-5-4.消息\n\nspringboot整合第三方技术最后一部分我们来说说消息中间件，首先先介绍一下消息的应用。\n\n# 消息的概念\n\n从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。\n\n为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。\n\n对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到a程序，而a程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。\n\n对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。\n\n所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。\n\n所谓**异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。**比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。\n\n以上简单的介绍了一下消息这种工作模式存在的意义，希望对各位学习者有所帮助。\n\n# java处理消息的标准规范(也就是在处理消息队列)\n\n目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：\n\n * jms\n * amqp\n * mqtt\n\n为什么是三大类，而不是三个技术呢？因为这些都是规范，就想jdbc技术，是个规范，开发针对规范开发，运行还要靠实现类，例如mysql提供了jdbc的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及\n\n# jms\n\njms（java message service）,这是一个规范，作用等同于jdbc规范，提供了与消息服务相关的api接口。\n\njms消息模型\n\njms规范中规范了消息有两种模型。分别是点对点模型和发布订阅模型。\n\n点对点模型：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。\n\n发布订阅模型：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。\n\n以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。\n\njms消息种类\n\n根据消息中包含的数据种类划分，可以将消息划分成6种消息。\n\n * textmessage\n * mapmessage\n * bytesmessage\n * streammessage\n * objectmessage\n * message （只有消息头和属性）\n\njms主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，jms就是典型的保守派，什么都按照j2ee的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批api。目前对jms规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如activemq、redis、hornetmq。但是也有一些不太规范的实现，参考jms的标准设计，但是又不完全满足其规范，例如：rabbitmq、rocketmq。\n\n# amqp\n\njms的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如jms设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于jms的设计是j2ee规范，站在java开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.net开发的系统a，有一个java开发的系统b，现在要从a系统给b系统发业务消息，结果两边数据格式不统一，没法操作。jms不是可以统一数据格式吗？提供了6种数据种类，总有一款适合你啊。no，一个都不能用。因为a系统的底层语言不是java语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统a继续开发已经不可能了，必须推翻重新做使用java语言开发的a系统。\n\n这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是amqp孕育而生。\n\n单从上面的说明中其实可以明确感知到，amqp的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻jms的操作api，所以说amqp仅仅是一种协议，规范了数据传输的格式而已。\n\namqp（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范，不是像jms一样的规范），规范了网络交换的数据格式，兼容jms操作。 优点\n\n具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现\n\njms消息种类\n\namqp消息种类：byte[]\n\namqp在jms的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。\n\namqp消息模型\n\n * direct exchange\n * fanout exchange\n * topic exchange\n * headers exchange\n * system exchange\n\n目前实现了amqp协议的消息中间件技术也很多，而且都是较为流行的技术，例如：rabbitmq、stormmq、rocketmq\n\namqp用来规范消息传递的格式（炒菜原料），jms用来规范消息开发的api（炒菜动作）\n\n# mqtt\n\nmqtt（message queueing telemetry transport）消息队列遥测传输，专为小设备设计，是物联网（iot）生态系统中主要成分之一。由于与javaee企业级开发没有交集，此处不作过多的说明。\n\n除了上述3种j2ee企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，kafka。\n\n# kafka\n\n**kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。**kafka技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。\n\n本节内容讲围绕着上述内容中的几种实现方案讲解springboot整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用windows系统安装，降低各位学习者的学习难度，基本套路和之前学习nosql解决方案一样，先安装再整合。\n\n# 购物订单发送手机短信案例\n\n为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。\n\n手机验证码案例需求如下：\n\n * 执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单id传递给消息中间件\n\n * 消息处理服务接收到要发送的订单id后输出订单id（模拟发短信）\n   \n   由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：\n\n订单业务\n\n业务层接口\n\npublic interface orderservice {\n    void order(string id);\n}\n\n\n模拟传入订单id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类\n\n业务层实现\n\n@service\npublic class orderserviceimpl implements orderservice {\n    @autowired\n    private messageservice messageservice;\n    \n    @override\n    public void order(string id) {\n        //一系列操作，包含各种服务调用，处理各种业务\n        system.out.println("订单处理开始");\n        //短信消息处理\n        messageservice.sendmessage(id);\n        system.out.println("订单处理结束");\n        system.out.println();\n    }\n}\n\n\n业务层转调短信处理的服务messageservice\n\n表现层服务\n\n@restcontroller\n@requestmapping("/orders")\npublic class ordercontroller {\n\n    @autowired\n    private orderservice orderservice;\n\n    @postmapping("{id}")\n    public void order(@pathvariable string id){\n        orderservice.order(id);\n    }\n}\n\n\n表现层对外开发接口，传入订单id即可（模拟）\n\n短信处理业务\n\n业务层接口\n\npublic interface messageservice {\n    void sendmessage(string id);\n    string domessage();\n}\n\n\n短信处理业务层接口提供两个操作，发送要处理的订单id到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计\n\n业务层实现\n\n@service\npublic class messageserviceimpl implements messageservice {\n    private arraylist<string> msglist = new arraylist<string>();\n\n    @override\n    public void sendmessage(string id) {\n        system.out.println("待发送短信的订单已纳入处理队列，id："+id);\n        msglist.add(id);\n    }\n\n    @override\n    public string domessage() {\n        string id = msglist.remove(0);\n        system.out.println("已完成短信发送业务，id："+id);\n        return id;\n    }\n}\n\n\n短信处理业务层实现中使用集合先模拟消息队列，观察效果\n\n表现层服务\n\n@restcontroller\n@requestmapping("/msgs")\npublic class messagecontroller {\n\n    @autowired\n    private messageservice messageservice;\n\n    @getmapping\n    public string domessage(){\n        string id = messageservice.domessage();\n        return id;\n    }\n}\n\n\n短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。\n\n下面开启springboot整合各种各样的消息中间件，从严格满足jms规范的activemq开始\n\n# springboot整合activemq\n\nactivemq是mq产品中的元老级产品，早期标准mq产品之一，在amqp协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为amqp系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。\n\n# 安装\n\nwindows版安装包下载地址：https://activemq.apache.org/components/classic/download/\n\n下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n\n启动服务器\n\nactivemq.bat\n\n\n运行bin目录下的win32或win64目录下的activemq.bat命令即可，根据自己的操作系统选择即可，默认对外服务端口61616。\n\n访问web管理服务\n\nactivemq启动后会启动一个web控制台服务，可以通过该服务管理activemq。\n\nhttp://127.0.0.1:8161/\n\n\nweb管理服务默认端口8161，访问后可以打开activemq的管理界面，如下：\n\n首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：\n\n\n\n看到上述界面视为启动activemq服务成功。\n\n启动失败\n\n在activemq启动时要占用多个端口，以下为正常启动信息：\n\nwrapper  | --\x3e wrapper started as console\nwrapper  | launching a jvm...\njvm 1    | wrapper (version 3.2.3) http://wrapper.tanukisoftware.org\njvm 1    |   copyright 1999-2006 tanuki software, inc.  all rights reserved.\njvm 1    |\njvm 1    | java runtime: oracle corporation 1.8.0_172 d:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   heap sizes: current=249344k  free=235037k  max=932352k\njvm 1    |     jvm args: -dactivemq.home=../.. -dactivemq.base=../.. -djavax.net.ssl.keystorepassword=password -djavax.net.ssl.truststorepassword=password -djavax.net.ssl.keystore=../../conf/broker.ks -djavax.net.ssl.truststore=../../conf/broker.ts -dcom.sun.management.jmxremote -dorg.apache.activemq.usededicatedtaskrunner=true -djava.util.logging.config.file=logging.properties -dactivemq.conf=../../conf -dactivemq.data=../../data -djava.security.auth.login.config=../../conf/login.config -xmx1024m -djava.library.path=../../bin/win64 -dwrapper.key=7ysrcd75xhlcpljd -dwrapper.port=32000 -dwrapper.jvm.port.min=31000 -dwrapper.jvm.port.max=31999 -dwrapper.pid=9364 -dwrapper.version=3.2.3 -dwrapper.native_library=wrapper -dwrapper.cpu.timeout=10 -dwrapper.jvmid=1\njvm 1    | extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | activemq_home: ..\\..\njvm 1    | activemq_base: ..\\..\njvm 1    | activemq_conf: ..\\..\\conf\njvm 1    | activemq_data: ..\\..\\data\njvm 1    | loading message broker from: xbean:activemq.xml\njvm 1    |  info | refreshing org.apache.activemq.xbean.xbeanbrokerfactory$1@5f3ebfe0: startup date [mon feb 28 16:07:48 cst 2022]; root of context hierarchy\njvm 1    |  info | using persistence adapter: kahadbpersistenceadapter[d:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  info | kahadb is version 7\njvm 1    |  info | pliststore:[d:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  info | apache activemq 5.16.3 (localhost, id:czbk-20210302vl-10434-1646035669595-0:1) is starting\njvm 1    |  info | listening for connections at: tcp://czbk-20210302vl:61616?maximumconnections=1000&wireformat.maxframesize=104857600\njvm 1    |  info | connector openwire started\njvm 1    |  info | listening for connections at: amqp://czbk-20210302vl:5672?maximumconnections=1000&wireformat.maxframesize=104857600\njvm 1    |  info | connector amqp started\njvm 1    |  info | listening for connections at: stomp://czbk-20210302vl:61613?maximumconnections=1000&wireformat.maxframesize=104857600\njvm 1    |  info | connector stomp started\njvm 1    |  info | listening for connections at: mqtt://czbk-20210302vl:1883?maximumconnections=1000&wireformat.maxframesize=104857600\njvm 1    |  info | connector mqtt started\njvm 1    |  info | starting jetty server\njvm 1    |  info | creating jetty connector\njvm 1    |  warn | servletcontext@o.e.j.s.servletcontexthandler@7350746f{/,null,starting} has uncovered http methods for path: /\njvm 1    |  info | listening for connections at ws://czbk-20210302vl:61614?maximumconnections=1000&wireformat.maxframesize=104857600\njvm 1    |  info | connector ws started\njvm 1    |  info | apache activemq 5.16.3 (localhost, id:czbk-20210302vl-10434-1646035669595-0:1) started\njvm 1    |  info | for help or more information please see: http://activemq.apache.org\njvm 1    |  warn | store limit is 102400 mb (current store usage is 0 mb). the data directory: d:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb only has 68936 mb of usable space. - resetting to maximum available disk space: 68936 mb\njvm 1    |  info | activemq webconsole available at http://127.0.0.1:8161/\njvm 1    |  info | activemq jolokia rest api available at http://127.0.0.1:8161/api/jolokia/\n\n\n其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动5672端口时端口被占用，显示java.net.bindexception: address already in use: jvm_bind。windows系统中终止端口运行的操作参看【命令行启动常见问题及解决方案】\n\nwrapper  | --\x3e wrapper started as console\nwrapper  | launching a jvm...\njvm 1    | wrapper (version 3.2.3) http://wrapper.tanukisoftware.org\njvm 1    |   copyright 1999-2006 tanuki software, inc.  all rights reserved.\njvm 1    |\njvm 1    | java runtime: oracle corporation 1.8.0_172 d:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   heap sizes: current=249344k  free=235038k  max=932352k\njvm 1    |     jvm args: -dactivemq.home=../.. -dactivemq.base=../.. -djavax.net.ssl.keystorepassword=password -djavax.net.ssl.truststorepassword=password -djavax.net.ssl.keystore=../../conf/broker.ks -djavax.net.ssl.truststore=../../conf/broker.ts -dcom.sun.management.jmxremote -dorg.apache.activemq.usededicatedtaskrunner=true -djava.util.logging.config.file=logging.properties -dactivemq.conf=../../conf -dactivemq.data=../../data -djava.security.auth.login.config=../../conf/login.config -xmx1024m -djava.library.path=../../bin/win64 -dwrapper.key=qpjoy9zoxewmmwts -dwrapper.port=32000 -dwrapper.jvm.port.min=31000 -dwrapper.jvm.port.max=31999 -dwrapper.pid=14836 -dwrapper.version=3.2.3 -dwrapper.native_library=wrapper -dwrapper.cpu.timeout=10 -dwrapper.jvmid=1\njvm 1    | extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | activemq_home: ..\\..\njvm 1    | activemq_base: ..\\..\njvm 1    | activemq_conf: ..\\..\\conf\njvm 1    | activemq_data: ..\\..\\data\njvm 1    | loading message broker from: xbean:activemq.xml\njvm 1    |  info | refreshing org.apache.activemq.xbean.xbeanbrokerfactory$1@2c9392f5: startup date [mon feb 28 16:06:16 cst 2022]; root of context hierarchy\njvm 1    |  info | using persistence adapter: kahadbpersistenceadapter[d:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  info | kahadb is version 7\njvm 1    |  info | pliststore:[d:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  info | apache activemq 5.16.3 (localhost, id:czbk-20210302vl-10257-1646035577620-0:1) is starting\njvm 1    |  info | listening for connections at: tcp://czbk-20210302vl:61616?maximumconnections=1000&wireformat.maxframesize=104857600\njvm 1    |  info | connector openwire started\njvm 1    | error | failed to start apache activemq (localhost, id:czbk-20210302vl-10257-1646035577620-0:1)\njvm 1    | java.io.ioexception: transport connector could not be registered in jmx: java.io.ioexception: failed to bind to server socket: amqp://0.0.0.0:5672?maximumconnections=1000&wireformat.maxframesize=104857600 due to: java.net.bindexception: address already in use: jvm_bind\njvm 1    |      at org.apache.activemq.util.ioexceptionsupport.create(ioexceptionsupport.java:28)\njvm 1    |      at org.apache.activemq.broker.brokerservice.registerconnectormbean(brokerservice.java:2288)\njvm 1    |      at org.apache.activemq.broker.brokerservice.starttransportconnector(brokerservice.java:2769)\njvm 1    |      at org.apache.activemq.broker.brokerservice.startallconnectors(brokerservice.java:2665)\njvm 1    |      at org.apache.activemq.broker.brokerservice.dostartbroker(brokerservice.java:780)\njvm 1    |      at org.apache.activemq.broker.brokerservice.startbroker(brokerservice.java:742)\njvm 1    |      at org.apache.activemq.broker.brokerservice.start(brokerservice.java:645)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerservice.afterpropertiesset(xbeanbrokerservice.java:73)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\njvm 1    |      at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\njvm 1    |      at java.lang.reflect.method.invoke(method.java:498)\njvm 1    |      at org.springframework.beans.factory.support.abstractautowirecapablebeanfactory.invokecustominitmethod(abstractautowirecapablebeanfactory.java:1748)\njvm 1    |      at org.springframework.beans.factory.support.abstractautowirecapablebeanfactory.invokeinitmethods(abstractautowirecapablebeanfactory.java:1685)\njvm 1    |      at org.springframework.beans.factory.support.abstractautowirecapablebeanfactory.initializebean(abstractautowirecapablebeanfactory.java:1615)\njvm 1    |      at org.springframework.beans.factory.support.abstractautowirecapablebeanfactory.docreatebean(abstractautowirecapablebeanfactory.java:553)\njvm 1    |      at org.springframework.beans.factory.support.abstractautowirecapablebeanfactory.createbean(abstractautowirecapablebeanfactory.java:481)\njvm 1    |      at org.springframework.beans.factory.support.abstractbeanfactory$1.getobject(abstractbeanfactory.java:312)\njvm 1    |      at org.springframework.beans.factory.support.defaultsingletonbeanregistry.getsingleton(defaultsingletonbeanregistry.java:230)\njvm 1    |      at org.springframework.beans.factory.support.abstractbeanfactory.dogetbean(abstractbeanfactory.java:308)\njvm 1    |      at org.springframework.beans.factory.support.abstractbeanfactory.getbean(abstractbeanfactory.java:197)\njvm 1    |      at org.springframework.beans.factory.support.defaultlistablebeanfactory.preinstantiatesingletons(defaultlistablebeanfactory.java:756)\njvm 1    |      at org.springframework.context.support.abstractapplicationcontext.finishbeanfactoryinitialization(abstractapplicationcontext.java:867)\njvm 1    |      at org.springframework.context.support.abstractapplicationcontext.refresh(abstractapplicationcontext.java:542)\njvm 1    |      at org.apache.xbean.spring.context.resourcexmlapplicationcontext.<init>(resourcexmlapplicationcontext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.resourcexmlapplicationcontext.<init>(resourcexmlapplicationcontext.java:52)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory$1.<init>(xbeanbrokerfactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory.createapplicationcontext(xbeanbrokerfactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory.createbroker(xbeanbrokerfactory.java:67)\njvm 1    |      at org.apache.activemq.broker.brokerfactory.createbroker(brokerfactory.java:71)\njvm 1    |      at org.apache.activemq.broker.brokerfactory.createbroker(brokerfactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.startcommand.runtask(startcommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.abstractcommand.execute(abstractcommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.shellcommand.runtask(shellcommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.abstractcommand.execute(abstractcommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.shellcommand.main(shellcommand.java:104)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\njvm 1    |      at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\njvm 1    |      at java.lang.reflect.method.invoke(method.java:498)\njvm 1    |      at org.apache.activemq.console.main.runtaskclass(main.java:262)\njvm 1    |      at org.apache.activemq.console.main.main(main.java:115)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\njvm 1    |      at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\njvm 1    |      at java.lang.reflect.method.invoke(method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.wrappersimpleapp.run(wrappersimpleapp.java:240)\njvm 1    |      at java.lang.thread.run(thread.java:748)\njvm 1    | caused by: java.io.ioexception: failed to bind to server socket: amqp://0.0.0.0:5672?maximumconnections=1000&wireformat.maxframesize=104857600 due to: java.net.bindexception: address already in use: jvm_bind\njvm 1    |      at org.apache.activemq.util.ioexceptionsupport.create(ioexceptionsupport.java:34)\njvm 1    |      at org.apache.activemq.transport.tcp.tcptransportserver.bind(tcptransportserver.java:146)\njvm 1    |      at org.apache.activemq.transport.tcp.tcptransportfactory.dobind(tcptransportfactory.java:62)\njvm 1    |      at org.apache.activemq.transport.transportfactorysupport.bind(transportfactorysupport.java:40)\njvm 1    |      at org.apache.activemq.broker.transportconnector.createtransportserver(transportconnector.java:335)\njvm 1    |      at org.apache.activemq.broker.transportconnector.getserver(transportconnector.java:145)\njvm 1    |      at org.apache.activemq.broker.transportconnector.asmanagedconnector(transportconnector.java:110)\njvm 1    |      at org.apache.activemq.broker.brokerservice.registerconnectormbean(brokerservice.java:2283)\njvm 1    |      ... 46 more\njvm 1    | caused by: java.net.bindexception: address already in use: jvm_bind\njvm 1    |      at java.net.dualstackplainsocketimpl.bind0(native method)\njvm 1    |      at java.net.dualstackplainsocketimpl.socketbind(dualstackplainsocketimpl.java:106)\njvm 1    |      at java.net.abstractplainsocketimpl.bind(abstractplainsocketimpl.java:387)\njvm 1    |      at java.net.plainsocketimpl.bind(plainsocketimpl.java:190)\njvm 1    |      at java.net.serversocket.bind(serversocket.java:375)\njvm 1    |      at java.net.serversocket.<init>(serversocket.java:237)\njvm 1    |      at javax.net.defaultserversocketfactory.createserversocket(serversocketfactory.java:231)\njvm 1    |      at org.apache.activemq.transport.tcp.tcptransportserver.bind(tcptransportserver.java:143)\njvm 1    |      ... 52 more\njvm 1    |  info | apache activemq 5.16.3 (localhost, id:czbk-20210302vl-10257-1646035577620-0:1) is shutting down\njvm 1    |  info | socketqueue interrupted - stopping\njvm 1    |  info | connector openwire stopped\njvm 1    |  info | could not accept connection during shutdown  : null (null)\njvm 1    |  info | connector amqp stopped\njvm 1    |  info | connector stomp stopped\njvm 1    |  info | connector mqtt stopped\njvm 1    |  info | connector ws stopped\njvm 1    |  info | pliststore:[d:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] stopped\njvm 1    |  info | stopping async queue tasks\njvm 1    |  info | stopping async topic tasks\njvm 1    |  info | stopped kahadb\njvm 1    |  info | apache activemq 5.16.3 (localhost, id:czbk-20210302vl-10257-1646035577620-0:1) uptime 0.426 seconds\njvm 1    |  info | apache activemq 5.16.3 (localhost, id:czbk-20210302vl-10257-1646035577620-0:1) is shutdown\njvm 1    |  info | closing org.apache.activemq.xbean.xbeanbrokerfactory$1@2c9392f5: startup date [mon feb 28 16:06:16 cst 2022]; root of context hierarchy\njvm 1    |  warn | exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.beancreationexception: error creating bean with name \'org.apache.activemq.xbean.xbeanbrokerservice#0\' defined in class path resource [activemq.xml]: invocation of init method failed; nested exception is java.io.ioexception: transport connector could not be registered in jmx: java.io.ioexception: failed to bind to server socket: amqp://0.0.0.0:5672?maximumconnections=1000&wireformat.maxframesize=104857600 due to: java.net.bindexception: address already in use: jvm_bind\njvm 1    | error: java.lang.runtimeexception: failed to execute start task. reason: java.lang.illegalstateexception: beanfactory not initialized or already closed - call \'refresh\' before accessing beans via the applicationcontext\njvm 1    | java.lang.runtimeexception: failed to execute start task. reason: java.lang.illegalstateexception: beanfactory not initialized or already closed - call \'refresh\' before accessing beans via the applicationcontext\njvm 1    |      at org.apache.activemq.console.command.startcommand.runtask(startcommand.java:91)\njvm 1    |      at org.apache.activemq.console.command.abstractcommand.execute(abstractcommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.shellcommand.runtask(shellcommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.abstractcommand.execute(abstractcommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.shellcommand.main(shellcommand.java:104)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\njvm 1    |      at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\njvm 1    |      at java.lang.reflect.method.invoke(method.java:498)\njvm 1    |      at org.apache.activemq.console.main.runtaskclass(main.java:262)\njvm 1    |      at org.apache.activemq.console.main.main(main.java:115)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\njvm 1    |      at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\njvm 1    |      at java.lang.reflect.method.invoke(method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.wrappersimpleapp.run(wrappersimpleapp.java:240)\njvm 1    |      at java.lang.thread.run(thread.java:748)\njvm 1    | caused by: java.lang.illegalstateexception: beanfactory not initialized or already closed - call \'refresh\' before accessing beans via the applicationcontext\njvm 1    |      at org.springframework.context.support.abstractrefreshableapplicationcontext.getbeanfactory(abstractrefreshableapplicationcontext.java:164)\njvm 1    |      at org.springframework.context.support.abstractapplicationcontext.destroybeans(abstractapplicationcontext.java:1034)\njvm 1    |      at org.springframework.context.support.abstractapplicationcontext.refresh(abstractapplicationcontext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.resourcexmlapplicationcontext.<init>(resourcexmlapplicationcontext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.resourcexmlapplicationcontext.<init>(resourcexmlapplicationcontext.java:52)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory$1.<init>(xbeanbrokerfactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory.createapplicationcontext(xbeanbrokerfactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory.createbroker(xbeanbrokerfactory.java:67)\njvm 1    |      at org.apache.activemq.broker.brokerfactory.createbroker(brokerfactory.java:71)\njvm 1    |      at org.apache.activemq.broker.brokerfactory.createbroker(brokerfactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.startcommand.runtask(startcommand.java:87)\njvm 1    |      ... 16 more\njvm 1    | error: java.lang.illegalstateexception: beanfactory not initialized or already closed - call \'refresh\' before accessing beans via the applicationcontext\njvm 1    | java.lang.illegalstateexception: beanfactory not initialized or already closed - call \'refresh\' before accessing beans via the applicationcontext\njvm 1    |      at org.springframework.context.support.abstractrefreshableapplicationcontext.getbeanfactory(abstractrefreshableapplicationcontext.java:164)\njvm 1    |      at org.springframework.context.support.abstractapplicationcontext.destroybeans(abstractapplicationcontext.java:1034)\njvm 1    |      at org.springframework.context.support.abstractapplicationcontext.refresh(abstractapplicationcontext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.resourcexmlapplicationcontext.<init>(resourcexmlapplicationcontext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.resourcexmlapplicationcontext.<init>(resourcexmlapplicationcontext.java:52)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory$1.<init>(xbeanbrokerfactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory.createapplicationcontext(xbeanbrokerfactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.xbeanbrokerfactory.createbroker(xbeanbrokerfactory.java:67)\njvm 1    |      at org.apache.activemq.broker.brokerfactory.createbroker(brokerfactory.java:71)\njvm 1    |      at org.apache.activemq.broker.brokerfactory.createbroker(brokerfactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.startcommand.runtask(startcommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.abstractcommand.execute(abstractcommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.shellcommand.runtask(shellcommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.abstractcommand.execute(abstractcommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.shellcommand.main(shellcommand.java:104)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\njvm 1    |      at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\njvm 1    |      at java.lang.reflect.method.invoke(method.java:498)\njvm 1    |      at org.apache.activemq.console.main.runtaskclass(main.java:262)\njvm 1    |      at org.apache.activemq.console.main.main(main.java:115)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\njvm 1    |      at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\njvm 1    |      at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\njvm 1    |      at java.lang.reflect.method.invoke(method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.wrappersimpleapp.run(wrappersimpleapp.java:240)\njvm 1    |      at java.lang.thread.run(thread.java:748)\nwrapper  | <-- wrapper stopped\n请按任意键继续. . .\n\n\n# 整合\n\n做了这么多springboot整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工\n\n步骤①：导入springboot整合activemq的starter\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-activemq</artifactid>\n</dependency>\n\n\n步骤②：配置activemq的服务器地址（带pool的选项用来配置连接池的相关设置）\n\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n  jms:\n  \ttemplate:\n  \t\tdefault-destination: itheima  # 这个选项配置消息的保存位置，converandsend中的参数也可以指定消息对应的保存位置\n\n\n步骤③：使用jmsmessagingtemplate操作activemq\n\n@service\npublic class messageserviceactivemqimpl implements messageservice {\n    @autowired\n    private jmsmessagingtemplate messagingtemplate;\n\n    @override\n    public void sendmessage(string id) {\n        system.out.println("待发送短信的订单已纳入处理队列，id："+id);\n        messagingtemplate.convertandsend("order.queue.id",id);\n    }\n\n    @override\n    public string domessage() {\n        string id = messagingtemplate.receiveandconvert("order.queue.id",string.class);\n        system.out.println("已完成短信发送业务，id："+id);\n        return id;\n    }\n}\n\n\n发送消息需要先将消息的类型转换成字符串，然后再发送，所以是convertandsend，定义消息发送的位置，和具体的消息内容，此处使用id作为消息内容。\n\n接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是receiveandconvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。\n\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@component\npublic class messagelistener {\n    @jmslistener(destination = "order.queue.id")\n    @sendto("order.other.queue.id")  // 将返回值传到order.other.queue.id队列中\n    public string receive(string id){\n        system.out.println("已完成短信发送业务，id："+id);\n        return "new:"+id;\n    }\n}\n\n\n使用注解@jmslistener定义当前方法监听activemq中指定名称的消息队列。\n\n如果当前消息队列处理完的结果还需要继续向下传递当前消息到另一个队列中使用注解@sendto即可，这样即可构造连续执行的顺序消息队列。\n\n步骤⑤：切换消息模型由点对点模型到发布订阅模型，修改jms配置即可\n\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n  jms:\n    pub-sub-domain: true\n\n\npub-sub-domain默认值为false，即点对点模型，修改为true后就是发布订阅模型。\n\n总结\n\n 1. springboot整合activemq提供了jmsmessagingtemplate对象作为客户端操作消息队列\n 2. 操作activemq需要配置activemq服务器地址，默认端口61616\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@jmslistener\n 4. 配置jms的pub-sub-domain属性可以在点对点模型和发布订阅模型间切换消息模型\n\n# springboot整合rabbitmq\n\nrabbitmq是mq产品中的目前较为流行的产品之一，它遵从amqp协议。rabbitmq的底层实现语言使用的是erlang，所以安装rabbitmq需要先安装erlang。\n\nerlang安装\n\nwindows版安装包下载地址：https😕/www.erlang.org/downloads\n\n下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。\n\n安装的过程中可能会出现依赖windows组件的提示，根据提示下载安装即可，都是自动执行的，如下：\n\n\n\nerlang安装后需要配置环境变量，否则rabbitmq将无法找到安装的erlang。需要配置项如下，作用等同jdk配置环境变量的作用。\n\n * erlang_home\n * path\n\n# 安装\n\nwindows版安装包下载地址：https://rabbitmq.com/install-windows.html\n\n下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕后会得到如下文件\n\n启动服务器\n\nrabbitmq-service.bat start\t\t# 启动服务\nrabbitmq-service.bat stop\t\t# 停止服务\nrabbitmqctl status\t\t\t\t# 查看服务状态\n\n\n运行sbin目录下的rabbitmq-service.bat命令即可，start参数表示启动，stop参数表示退出，默认对外服务端口5672。\n\n注意：启动rabbitmq的过程实际上是开启rabbitmq对应的系统服务，需要管理员权限方可执行。\n\n说明：有没有感觉5672的服务端口很熟悉？activemq与rabbitmq有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。\n\n说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到rabbitmq服务，使用鼠标右键菜单控制服务的启停。\n\n访问web管理服务\n\nrabbitmq也提供有web控制台服务，但是此功能是一个插件，需要先启用才可以使用。\n\nrabbitmq-plugins.bat list\t\t\t\t\t\t\t# 查看当前所有插件的运行状态\nrabbitmq-plugins.bat enable rabbitmq_management\t\t# 启动rabbitmq_management插件\n\n\n启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面\n\nhttp://localhost:15672\n\n\nweb管理服务默认端口15672，访问后可以打开rabbitmq的管理界面，如下：\n\n\n\n首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：\n\n\n\n# 整合(direct模型)\n\nrabbitmq满足amqp协议，因此不同的消息模型对应的制作不同，先使用最简单的direct模型开发。\n\n步骤①：导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-amqp</artifactid>\n</dependency>\n\n\n步骤②：配置rabbitmq的服务器地址\n\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n\n\n步骤③：初始化直连模式系统设置\n\n由于rabbitmq不同模型要使用不同的交换机，因此需要先初始化rabbitmq相关的对象，例如队列，交换机等\n\n@configuration\npublic class rabbitconfigdirect {\n    \n    // 消息队列1\n    @bean\n    public queue directqueue(){\n        return new queue("direct_queue");\n    }\n    // 消息队列2\n    @bean\n    public queue directqueue2(){\n        return new queue("direct_queue2");\n    }\n    \n    // 交换机\n    @bean\n    public directexchange directexchange(){\n        return new directexchange("directexchange");\n    }\n    \n    // 绑定交换机和消息队列1\n    @bean\n    public binding bindingdirect(){\n        return bindingbuilder.bind(directqueue()).to(directexchange()).with("direct");\n    }\n    // 绑定交换机和消息队列2\n    @bean\n    public binding bindingdirect2(){\n        return bindingbuilder.bind(directqueue2()).to(directexchange()).with("direct2");\n    }\n}\n\n\n队列queue与直连交换机directexchange创建后，还需要绑定他们之间的关系binding，这样就可以通过交换机操作对应队列。\n\n步骤④：使用amqptemplate操作rabbitmq\n\n@service\npublic class messageservicerabbitmqdirectimpl implements messageservice {\n    @autowired\n    private amqptemplate amqptemplate;\n\n    @override\n    public void sendmessage(string id) {\n        system.out.println("待发送短信的订单已纳入处理队列（rabbitmq direct），id："+id);\n        amqptemplate.convertandsend("directexchange","direct",id);  // 第一个参数为交换机名称，第二个参数为交换机和消息队列绑定的名称， 第三个参数为具体的消息\n    }\n}\n\n\namqp协议中的操作api接口名称看上去和jms规范的操作api接口很相似，但是传递参数差异很大。\n\n步骤⑤：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@component\npublic class messagelistener {\n    @rabbitlistener(queues = "direct_queue")\n    public void receive(string id){\n        system.out.println("已完成短信发送业务(rabbitmq direct)，id："+id);\n    }\n}\n\n\n使用注解@rabbitlistener定义当前方法监听rabbitmq中指定名称的消息队列。\n\n# 整合(topic模型)\n\n步骤①：同上\n\n步骤②：同上\n\n步骤③：初始化主题模式系统设置\n\n@configuration\npublic class rabbitconfigtopic {\n    @bean\n    public queue topicqueue(){\n        return new queue("topic_queue");\n    }\n    @bean\n    public queue topicqueue2(){\n        return new queue("topic_queue2");\n    }\n    @bean\n    public topicexchange topicexchange(){\n        return new topicexchange("topicexchange");\n    }\n    @bean\n    public binding bindingtopic(){\n        return bindingbuilder.bind(topicqueue()).to(topicexchange()).with("topic.*.id");\n    }\n    @bean\n    public binding bindingtopic2(){\n        return bindingbuilder.bind(topicqueue2()).to(topicexchange()).with("topic.orders.*");\n    }\n}\n\n\n*主题模式支持routingkey匹配模式，表示匹配一个单词，#表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看rabbitmq系列课程。\n\n匹配键                 topic.*.*   topic.#\ntopic.order.id      true        true\norder.topic.id      false       false\ntopic.sm.order.id   false       true\ntopic.sm.id         false       true\ntopic.id.order      true        true\ntopic.id            false       true\ntopic.order         false       true\n\ntopic.sm.id和topic.id.order中在topic.*.*的匹配中是有区别的吗？记得看一下对应的匹配规则\n\n步骤④：使用amqptemplate操作rabbitmq\n\n@service\npublic class messageservicerabbitmqtopicimpl implements messageservice {\n    @autowired\n    private amqptemplate amqptemplate;\n\n    @override\n    public void sendmessage(string id) {\n        system.out.println("待发送短信的订单已纳入处理队列（rabbitmq topic），id："+id);\n        amqptemplate.convertandsend("topicexchange","topic.orders.id",id);\n    }\n}\n\n\n发送消息后，根据当前提供的routingkey与绑定交换机时设定的routingkey进行匹配，规则匹配成功消息才会进入到对应的队列中。如果消息匹配到多个队列，他会同时进入多个队列\n\n步骤⑤：使用消息监听器在服务器启动后，监听指定队列\n\n@component\npublic class messagelistener {\n    @rabbitlistener(queues = "topic_queue")\n    public void receive(string id){\n        system.out.println("已完成短信发送业务(rabbitmq topic 1)，id："+id);\n    }\n    @rabbitlistener(queues = "topic_queue2")\n    public void receive2(string id){\n        system.out.println("已完成短信发送业务(rabbitmq topic 22222222)，id："+id);\n     \n}\n\n\n使用注解@rabbitlistener定义当前方法监听rabbitmq中指定名称的消息队列。\n\n总结\n\n 1. springboot整合rabbitmq提供了amqptemplate对象作为客户端操作消息队列\n 2. 操作activemq需要配置activemq服务器地址，默认端口5672\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@rabbitlistener\n 4. rabbitmq有5种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同\n\n# springboot整合rocketmq\n\nrocketmq由阿里研发，后捐赠给apache基金会，目前是apache基金会顶级项目之一，也是目前市面上的mq产品中较为流行的产品之一，它遵从amqp协议。\n\n# 安装\n\nwindows版安装包下载地址：https://rocketmq.apache.org/\n\n下载完毕后得到zip压缩文件，解压缩即可使用，解压后得到如下文件\n\n\n\nrocketmq安装后需要配置环境变量，具体如下：\n\n * rocketmq_home\n * path\n * namesrv_addr （建议）： 127.0.0.1:9876\n\n关于namesrv_addr对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习rocketmq知识后即可灵活控制该项。\n\nrocketmq工作模式\n\n在rocketmq中，处理业务的服务器称为broker，生产者与消费者不是直接与broker联系的，而是通过命名服务器进行通信。broker启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的broker信息。当生产者与消费者需要连接broker时，通过命名服务器找到对应的处理业务的broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且broker启动前必须保障命名服务器先启动。\n\n启动服务器\n\nmqnamesrv\t\t# 启动命名服务器\nmqbroker\t\t# 启动broker\n\n\n运行bin目录下的mqnamesrv命令即可启动命名服务器，默认对外服务端口9876。\n\n运行bin目录下的mqbroker命令即可启动broker服务器，如果环境变量中没有设置namesrv_addr则需要在运行mqbroker指令前通过set指令设置namesrv_addr的值，并且每次开启均需要设置此项。\n\n测试服务器启动状态\n\nrocketmq提供有一套测试服务器功能的测试程序，运行bin目录下的tools命令即可使用。producer正确执行如下图所示\n\ntools org.apache.rocketmq.example.quickstart.producer\t\t# 生产消息\ntools org.apache.rocketmq.example.quickstart.consumer\t\t# 消费消息\n\n\n\n\n\n\n# 整合（异步消息）\n\n步骤①：导入springboot整合rocketmq的starter，此坐标不由springboot维护版本\n\n<dependency>\n    <groupid>org.apache.rocketmq</groupid>\n    <artifactid>rocketmq-spring-boot-starter</artifactid>\n    <version>2.2.1</version>\n</dependency>\n\n\n步骤②：配置rocketmq的服务器地址\n\nrocketmq:\n  name-server: localhost:9876\n  producer:\n    group: group_rocketmq   # 设置默认的生产者消费者所属组group\n\n\n\n\n步骤③：使用rocketmqtemplate操作rocketmq\n\n@service\npublic class messageservicerocketmqimpl implements messageservice {\n    @autowired\n    private rocketmqtemplate rocketmqtemplate;\n\n    @override\n    public void sendmessage(string id) {\n        system.out.println("待发送短信的订单已纳入处理队列（rocketmq），id："+id);\n        sendcallback callback = new sendcallback() {\n            @override\n            public void onsuccess(sendresult sendresult) {\n                system.out.println("消息发送成功");\n            }\n            @override\n            public void onexception(throwable e) {\n                system.out.println("消息发送失败！！！！！");\n            }\n        };\n        rocketmqtemplate.asyncsend("order_id",id,callback);\n    }\n}\n\n\n\n使用asyncsend方法发送异步消息。\n\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@component\n@rocketmqmessagelistener(topic = "order_id",consumergroup = "group_rocketmq")  // 至少给定左边的两个参数\npublic class messagelistener implements rocketmqlistener<string> {\n    @override\n    public void onmessage(string id) {\n        system.out.println("已完成短信发送业务(rocketmq)，id："+id);\n    }\n}\n\n\nrocketmq的监听器必须按照标准格式开发，实现rocketmqlistener接口，泛型为消息类型。\n\n使用注解@rocketmqmessagelistener定义当前类监听rabbitmq中指定名称的消息队列和指定组。\n\n总结\n\n 1. springboot整合rocketmq使用rocketmqtemplate对象作为客户端操作消息队列\n 2. 操作rocketmq需要配置rocketmq服务器地址，默认端口9876\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@rocketmqmessagelistener\n\n# springboot整合kafka\n\n# 安装\n\nwindows版安装包下载地址：https://kafka.apache.org/downloads\n\n下载完毕后得到tgz压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件\n\n\n\n建议使用windows版2.8.1版本。（3.x.x版本在windows上有些小问题，但是在linux上没问题）\n\n启动服务器\n\nkafka服务器的功能相当于rocketmq中的broker，kafka运行还需要一个类似于命名服务器的服务。在kafka安装目录中自带一个类似于命名服务器的工具，叫做zookeeper，它的作用是注册中心，相关知识请到对应课程中学习。\n\nzookeeper-server-start.bat ..\\..\\config\\zookeeper.properties\t\t# 启动zookeeper\nkafka-server-start.bat ..\\..\\config\\server.properties\t\t\t\t# 启动kafka\n\n\n运行bin目录下的windows目录下的zookeeper-server-start命令即可启动注册中心，默认对外服务端口2181。\n\n运行bin目录下的windows目录下的kafka-server-start命令即可启动kafka服务器，默认对外服务端口9092。\n\n创建主题\n\n和之前操作其他mq产品相似，kakfa也是基于主题操作，操作之前需要先初始化topic。\n\n# 创建topic\nkafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic itheima\n# 查询topic\nkafka-topics.bat --zookeeper 127.0.0.1:2181 --list\t\t\t\t\t\n# 删除topic\nkafka-topics.bat --delete --zookeeper localhost:2181 --topic itheima\n\n\n测试服务器启动状态\n\nkafka提供有一套测试服务器功能的测试程序，运行bin目录下的windows目录下的命令即可使用。\n\n生产者启动之后再启动消费者\n\nkafka-console-producer.bat --broker-list localhost:9092 --topic itheima\t\t\t\t\t\t\t# 测试生产消息\nkafka-console-consumer.bat --bootstrap-server localhost:9092 --topic itheima --from-beginning\t# 测试消息消费\n\n\n# 整合\n\n步骤①：导入springboot整合kafka的starter，此坐标由springboot维护版本\n\n<dependency>\n    <groupid>org.springframework.kafka</groupid>\n    <artifactid>spring-kafka</artifactid>\n</dependency>\n\n\n步骤②：配置kafka的服务器地址\n\nspring:\n  kafka:\n    bootstrap-servers: localhost:9092\n    consumer:\n      group-id: order\n\n\n设置默认的生产者消费者所属组id。\n\n步骤③：使用kafkatemplate操作kafka\n\n@service\npublic class messageservicekafkaimpl implements messageservice {\n    @autowired\n    private kafkatemplate<string,string> kafkatemplate;\n\n    @override\n    public void sendmessage(string id) {\n        system.out.println("待发送短信的订单已纳入处理队列（kafka），id："+id);\n        kafkatemplate.send("itheima2022",id);\n    }\n}\n\n\n使用send方法发送消息，需要传入topic名称。\n\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n@component\npublic class messagelistener {\n    @kafkalistener(topics = "itheima2022")\n    public void onmessage(consumerrecord<string,string> record){\n        system.out.println("已完成短信发送业务(kafka)，id："+record.value());\n    }\n}\n\n\n使用注解@kafkalistener定义当前方法监听kafka中指定topic的消息，接收到的消息封装在对象consumerrecord中，获取数据从consumerrecord对象中获取即可。\n\n总结\n\n 1. springboot整合kafka使用kafkatemplate对象作为客户端操作消息队列\n\n 2. 操作kafka需要配置kafka服务器地址，默认端口9092\n\n 3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@kafkalistener。接收消息保存在形参consumerrecord对象中\n\n\n# kf-6.监控\n\n在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。\n\n什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。\n\n本章要讲解的监控就是对软件的运行情况进行监督，但是springboot程序与非springboot程序的差异还是很大的，为了方便监控软件的开发，springboot提供了一套功能接口，为开发者加速开发过程。\n\n\n# kf-6-1.监控的意义\n\n对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是监控服务状态是否处理宕机状态。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，监控服务运行指标。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，监控程序运行日志。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，管理服务状态。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。\n\n通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有3个服务支撑着一个程序的运行，每个服务都有自己的运行状态。\n\n此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成30个，300个，3000个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。\n\n新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。\n\n如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。\n\n被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。\n\n以上描述的整个过程就是一个监控系统的基本流程。\n\n总结\n\n 1. 监控是一个非常重要的工作，是保障程序正常运行的基础手段\n 2. 监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示\n 3. 被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控\n\n思考\n\n下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控，咱们下节再讲。\n\n\n# kf-6-2.可视化监控平台\n\nspringboot抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于springboot监控的核心思想制作的，所以这个程序被命名为spring boot admin。java自带的监控平台为jconsole\n\nspring boot admin，这是一个开源社区项目，用于管理和监控springboot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过http请求的方式从客户端获取对应的信息，并通过ui界面展示对应信息。\n\n下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个web程序，收到一些信息后展示这些信息。\n\n服务端开发\n\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n\n<dependency>\n    <groupid>de.codecentric</groupid>\n    <artifactid>spring-boot-admin-starter-server</artifactid>\n    <version>2.5.4</version>\n</dependency>\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n上述过程可以通过创建项目时使用勾选的形式完成。\n\n步骤②：在引导类上添加注解@enableadminserver，声明当前应用启动后作为springbootadmin的服务器使用\n\n@springbootapplication\n@enableadminserver\npublic class springboot25adminserverapplication {\n    public static void main(string[] args) {\n        springapplication.run(springboot25adminserverapplication.class, args);\n    }\n}\n\n\n做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。\n\n由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。\n\n客户端开发\n\n客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。\n\n\n\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n\n<dependency>\n    <groupid>de.codecentric</groupid>\n    <artifactid>spring-boot-admin-starter-client</artifactid>\n    <version>2.5.4</version>\n</dependency>\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。\n\n步骤②：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置\n\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\n\n\n做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。\n\n可以看到，当前监控了1个程序，点击进去查看详细信息。\n\n由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。\n\n 1. 开放指定信息给服务器看\n\n 2. 允许服务器以http请求的方式获取对应的信息\n    \n    配置如下：\n\nserver:\n  port: 80\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n\n\n上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过http请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。\n\n但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。\n\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n\n\n健康明细信息如下：\n\n目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过http请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。\n\nendpoints:\n  web:\n    exposure:\n      include: "*"\n\n\n配置后再刷新服务器页面，就可以看到所有的信息了。\n\n以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。\n\n配置多个客户端\n\n可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。\n\n进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。\n\n * 类加载面板中可以查阅到开发者自定义的类，如左图\n\n\n\n * 映射中可以查阅到当前应用配置的所有请求\n\n\n\n * 性能指标中可以查阅当前应用独有的请求路径统计数据\n\n\n\n总结\n\n 1. 开发监控服务端需要导入坐标，然后在引导类上添加注解@enableadminserver，并将其配置成web程序即可\n 2. 开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可\n 3. 在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标\n\n思考\n\n之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？咱们下一节再讲。\n\n\n# kf-6-3.监控原理\n\n通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以/actuator开头\n\n首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。\n\n\n\n通过发送请求，可以得到一组json信息，如下\n\n{\n    "_links": {\n        "self": {\n            "href": "http://localhost:81/actuator",\n            "templated": false\n        },\n        "beans": {\n            "href": "http://localhost:81/actuator/beans",\n            "templated": false\n        },\n        "caches-cache": {\n            "href": "http://localhost:81/actuator/caches/{cache}",\n            "templated": true\n        },\n        "caches": {\n            "href": "http://localhost:81/actuator/caches",\n            "templated": false\n        },\n        "health": {\n            "href": "http://localhost:81/actuator/health",\n            "templated": false\n        },\n        "health-path": {\n            "href": "http://localhost:81/actuator/health/{*path}",\n            "templated": true\n        },\n        "info": {\n            "href": "http://localhost:81/actuator/info",\n            "templated": false\n        },\n        "conditions": {\n            "href": "http://localhost:81/actuator/conditions",\n            "templated": false\n        },\n        "shutdown": {\n            "href": "http://localhost:81/actuator/shutdown",\n            "templated": false\n        },\n        "configprops": {\n            "href": "http://localhost:81/actuator/configprops",\n            "templated": false\n        },\n        "configprops-prefix": {\n            "href": "http://localhost:81/actuator/configprops/{prefix}",\n            "templated": true\n        },\n        "env": {\n            "href": "http://localhost:81/actuator/env",\n            "templated": false\n        },\n        "env-tomatch": {\n            "href": "http://localhost:81/actuator/env/{tomatch}",\n            "templated": true\n        },\n        "loggers": {\n            "href": "http://localhost:81/actuator/loggers",\n            "templated": false\n        },\n        "loggers-name": {\n            "href": "http://localhost:81/actuator/loggers/{name}",\n            "templated": true\n        },\n        "heapdump": {\n            "href": "http://localhost:81/actuator/heapdump",\n            "templated": false\n        },\n        "threaddump": {\n            "href": "http://localhost:81/actuator/threaddump",\n            "templated": false\n        },\n        "metrics-requiredmetricname": {\n            "href": "http://localhost:81/actuator/metrics/{requiredmetricname}",\n            "templated": true\n        },\n        "metrics": {\n            "href": "http://localhost:81/actuator/metrics",\n            "templated": false\n        },\n        "scheduledtasks": {\n            "href": "http://localhost:81/actuator/scheduledtasks",\n            "templated": false\n        },\n        "mappings": {\n            "href": "http://localhost:81/actuator/mappings",\n            "templated": false\n        }\n    }\n}\n\n\n其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息\n\n{\n    "status": "up",\n    "components": {\n        "diskspace": {\n            "status": "up",\n            "details": {\n                "total": 297042808832,\n                "free": 72284409856,\n                "threshold": 10485760,\n                "exists": true\n            }\n        },\n        "ping": {\n            "status": "up"\n        }\n    }\n}\n\n\n当前信息与监控面板中的数据存在着对应关系\n\n** 原来监控中显示的信息实际上是通过发送地址请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以/actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。**\n\n到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。\n\n\n\n这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。\n\nactuator，可以称为端点，描述了一组监控信息，springbootadmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**/actuator可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求/actuator/端点名称**来获取详细信息。以下列出了所有端点信息说明：（加粗的是我们经常关注的信息）\n\nid                 描述                                                             默认启用\nauditevents        暴露当前应用程序的审计事件信息。                                               是\nbeans              显示应用程序中所有 spring bean 的完整列表。                                   是\ncaches             暴露可用的缓存。                                                       是\nconditions         显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。                                是\nconfigprops        显示所有 @configurationproperties 的校对清单。                           是\nenv                暴露 spring configurableenvironment 中的属性。                        是\nflyway             显示已应用的 flyway 数据库迁移。                                           是\nhealth             显示应用程序健康信息                                                     是\nhttptrace          显示 http 追踪信息（默认情况下，最后 100 个 http 请求/响应交换）。                     是\ninfo               显示应用程序信息。                                                      是\nintegrationgraph   显示 spring integration 图。                                       是\nloggers            显示和修改应用程序中日志记录器的配置。                                            是\nliquibase          显示已应用的 liquibase 数据库迁移。                                        是\nmetrics            显示当前应用程序的指标度量信息。                                               是\nmappings           显示所有 @requestmapping 路径的整理清单。                                  是\nscheduledtasks     显示应用程序中的调度任务。                                                  是\nsessions           允许从 spring session 支持的会话存储中检索和删除用户会话。当使用 spring session 的响应式   是\n                   web 应用程序支持时不可用。\nshutdown           正常关闭应用程序。                                                      否\nthreaddump         执行线程 dump。                                                     是\nheapdump           返回一个 hprof 堆 dump 文件。                                          是\njolokia            通过 http 暴露 jmx bean（当 jolokia 在 classpath 上时，不适用于 webflux）。    是\nlogfile            返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 http      是\n                   range 头来检索部分日志文件的内容。\nprometheus         以可以由 prometheus 服务器抓取的格式暴露指标。                                  是\n\n上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。\n\n注：这里如果不开放端点接口，即使web端include “*”也不能查询信息.\n\n注：端点的开放分为后端端点和web端点两种，都要分别配置\n\nmanagement:\n  endpoint:\n    health:\t\t\t\t\t\t# 端点名称\n      show-details: always\n    info:\t\t\t\t\t\t# 端点名称\n      enabled: true\t\t\t\t# 是否开放\n\n\n为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：\n\nmanagement:\n  endpoints:\n    enabled-by-default: true\t# 是否开启默认端点，默认值true\n\n\n上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过http请求查询此信息，还需要开启通过http请求查询的端点名称，使用“*”可以简化配置成开放所有端点的web端http请求权限。\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"  # 开放所有端点\n        # include: health, info  # 开放health和info两个端点，这里配置的是只能在web看到的信息\n\n\n整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。\n\nmanagement:\n  endpoint:\t\t# 具体端点的配置\n    health:\n      show-details: always\n    info:\n      enabled: true\n  endpoints:\t# 全部端点的配置\n    web:\n      exposure:\n        include: "*"\n    enabled-by-default: true\n\n\n\n\n\n\n\n\n总结\n\n 1. 被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能\n\n 2. 端点功能的开放与关闭可以通过配置进行控制\n\n 3. web端默认无法获取所有端点信息，通过配置开放端点功能\n\n\n# kf-6-4.自定义监控指标\n\n端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。\n\ninfo端点\n\ninfo端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息\n\n * 配置形式\n   \n   在yml文件中通过设置info节点的信息就可以快速配置端点信息\n   \n   info:\n     appname: @project.artifactid@\n     version: @project.version@\n     company: 传智教育\n     author: itheima\n   \n   \n   配置完毕后，对应信息显示在监控平台上\n   \n   也可以通过请求端点信息路径获取对应json信息\n\n * 编程形式\n   \n   通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存\n   \n   @component\n   public class infoconfig implements infocontributor {\n       @override\n       public void contribute(info.builder builder) {  // builder就是里面加各种信息\n           builder.withdetail("runtime",system.currenttimemillis());\t\t//添加单个信息\n           map infomap = new hashmap();\t\t\n           infomap.put("buildtime","2006");\n           builder.withdetails(infomap);\t\t\t\t\t\t\t\t\t//添加一组信息\n       }\n   }\n   \n\nhealth端点\n\nhealth端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。\n\n@component\npublic class healthconfig extends abstracthealthindicator {\n    @override\n    protected void dohealthcheck(health.builder builder) throws exception {\n        boolean condition = true;\n        if(condition) {\n            builder.status(status.up);\t\t\t\t\t//设置运行状态为启动状态\n            builder.withdetail("runtime", system.currenttimemillis());\n            map infomap = new hashmap();\n            infomap.put("buildtime", "2006");\n            builder.withdetails(infomap);\n        }else{\n            builder.status(status.out_of_service);\t\t//设置运行状态为不在服务状态\n            builder.withdetail("上线了吗？","你做梦");\n        }\n    }\n}\n\n\n当任意一个组件状态不为up时，整体应用对外服务状态为非up状态。\n\nmetrics端点\n\nmetrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。\n\n@service\npublic class bookserviceimpl extends serviceimpl<bookdao, book> implements ibookservice {\n    @autowired\n    private bookdao bookdao;\n\n    private counter counter;\n\n    public bookserviceimpl(meterregistry meterregistry){\n        counter = meterregistry.counter("用户付费操作次数：");\n    }\n\n    @override\n    public boolean delete(integer id) {\n        //每次执行删除业务等同于执行了付费业务\n        counter.increment();\n        return bookdao.deletebyid(id) > 0;\n    }\n}\n\n\n在性能指标中就出现了自定义的性能指标监控项\n\n自定义端点\n\n可以根据业务需要自定义端点，方便业务监控\n\n@component\n@endpoint(id="pay",enablebydefault = true)\npublic class payendpoint {\n    @readoperation\n    public object getpay(){\n        map paymap = new hashmap();\n        paymap.put("level 1","300");\n        paymap.put("level 2","291");\n        paymap.put("level 3","666");\n        return paymap;\n    }\n}\n\n\n由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过http请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。\n\n总结\n\n 1. 端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同\n 2. info端点通过配置和编程的方式都可以添加端点指标\n 3. health端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定\n 4. metrics指标通过在业务中添加监控操作设置指标\n 5. 可以自定义端点添加更多的指标\n\n\n# 开发实用篇完结\n\n开发实用篇到这里就暂时完结了，在开发实用篇中我们讲解了大量的第三方技术的整合方案，选择的方案都是市面上比较流行的常用方案，还有一些国内流行度较低的方案目前还没讲，留到番外篇中慢慢讲吧。\n\n整体开发实用篇中讲解的内容可以分为两大类知识：实用性知识与经验性知识。\n\n实用性知识就是新知识了，springboot整合各种技术，每种技术整合中都有一些特殊操作，整体来说其实就是三句话。加坐标做配置调接口。经验性知识是对前面两篇中出现的一些知识的补充，在学习基础篇时如果将精力放在这些东西上就有点学偏了，容易钻牛角尖，放到实用开发篇中结合实际开发说一些不常见的但是对系统功能又危害的操作解决方案，提升理解。\n\n开发实用篇做到这里就告一段落，下面就要着手准备原理篇了。市面上很多课程原理篇讲的过于高深莫测，在新手还没明白123的时候就开始讲微积分了，着实让人看了着急。至于原理篇我讲成什么样子？一起期待吧。',charsets:{cjk:!0}},{title:"MyBatis的各种查询功能",frontmatter:{title:"MyBatis的各种查询功能",date:"2022-03-06T00:00:00.000Z",permalink:"/mybatis/003/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/03.MyBatis%E7%9A%84%E5%90%84%E7%A7%8D%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD.html",relativePath:"07.框架/04.MyBatis/03.MyBatis的各种查询功能.md",key:"v-3fd3c7b5",path:"/mybatis/003/",headers:[{level:2,title:"查询一个实体类对象",slug:"查询一个实体类对象",normalizedTitle:"查询一个实体类对象",charIndex:285},{level:2,title:"查询一个List集合",slug:"查询一个list集合",normalizedTitle:"查询一个list集合",charIndex:529},{level:2,title:"查询单个数据",slug:"查询单个数据",normalizedTitle:"查询单个数据",charIndex:714},{level:2,title:"查询一条数据为map集合",slug:"查询一条数据为map集合",normalizedTitle:"查询一条数据为map集合",charIndex:1033},{level:2,title:"查询多条数据为map集合",slug:"查询多条数据为map集合",normalizedTitle:"查询多条数据为map集合",charIndex:1414},{level:3,title:"方法一",slug:"方法一",normalizedTitle:"方法一",charIndex:1431},{level:3,title:"方法二",slug:"方法二",normalizedTitle:"方法二",charIndex:1922},{level:2,title:"模糊查询",slug:"模糊查询",normalizedTitle:"模糊查询",charIndex:2483},{level:2,title:"批量删除",slug:"批量删除",normalizedTitle:"批量删除",charIndex:3232},{level:2,title:"动态设置表名",slug:"动态设置表名",normalizedTitle:"动态设置表名",charIndex:3924},{level:2,title:"添加功能获取自增的主键",slug:"添加功能获取自增的主键",normalizedTitle:"添加功能获取自增的主键",charIndex:4321}],headersStr:"查询一个实体类对象 查询一个List集合 查询单个数据 查询一条数据为map集合 查询多条数据为map集合 方法一 方法二 模糊查询 批量删除 动态设置表名 添加功能获取自增的主键",content:'# MyBatis的各种查询功能\n\n 1. 如果查询出的数据只有一条，可以通过\n    1. 实体类对象接收\n    2. List集合接收\n    3. Map集合接收，结果{password=123456, sex=男, id=1, age=23, username=admin}\n 2. 如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过\n    1. 实体类类型的LIst集合接收\n    2. Map类型的LIst集合接收\n    3. 在mapper接口的方法上添加@MapKey注解\n\n\n# 查询一个实体类对象\n\n/**\n * 根据用户id查询用户信息\n * @param id\n * @return\n */\nUser getUserById(@Param("id") int id);\n\n\n\x3c!--User getUserById(@Param("id") int id);--\x3e\n<select id="getUserById" resultType="User">\n\tselect * from t_user where id = #{id}\n</select>\n\n\n\n# 查询一个List集合\n\n/**\n * 查询所有用户信息\n * @return\n */\nList<User> getUserList();\n\n\n\x3c!--List<User> getUserList();--\x3e\n<select id="getUserList" resultType="User">\n\tselect * from t_user\n</select>\n\n\n\n# 查询单个数据\n\n/**  \n * 查询用户的总记录数  \n * @return  \n * 在MyBatis中，对于Java中常用的类型都设置了类型别名  \n * 例如：java.lang.Integer--\x3eint|integer  \n * 例如：int--\x3e_int|_integer  \n * 例如：Map--\x3emap, List--\x3elist  \n */  \nint getCount();\n\n\n\x3c!--int getCount();--\x3e\n<select id="getCount" resultType="_integer">\n\tselect count(id) from t_user\n</select>\n\n\n\n\n\n\n\n\n# 查询一条数据为map集合\n\n/**  \n * 根据用户id查询用户信息为map集合  \n * @param id  \n * @return  \n */  \nMap<String, Object> getUserToMap(@Param("id") int id);\n\n\n\x3c!--Map<String, Object> getUserToMap(@Param("id") int id);--\x3e\n\n\n\x3c!-- 返回的是map类型 --\x3e\n<select id="getUserToMap" resultType="map">\n\tselect * from t_user where id = #{id}\n</select>\n\x3c!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--\x3e\n\n\n\n# 查询多条数据为map集合\n\n\n# 方法一\n\n/**  \n * 查询所有用户信息为map集合  \n * @return  \n * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  \n */  \nList<Map<String, Object>> getAllUserToMap();\n\n\n\x3c!--Map<String, Object> getAllUserToMap();--\x3e  \n<select id="getAllUserToMap" resultType="map">  \n\tselect * from t_user  \n</select>\n\x3c!--\n\t结果：\n\t[{password=123456, sex=男, id=1, age=23, username=admin},\n\t{password=123456, sex=男, id=2, age=23, username=张三},\n\t{password=123456, sex=男, id=3, age=23, username=张三}]\n--\x3e\n\n\n\n# 方法二\n\n/**\n * 查询所有用户信息为map集合\n * @return\n * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合\n */\n\n@MapKey("id")  // Mapkey对应的值要唯一\nMap<String, Object> getAllUserToMap();\n\n\n\x3c!--Map<String, Object> getAllUserToMap();--\x3e\n<select id="getAllUserToMap" resultType="map">\n\tselect * from t_user\n</select>\n\x3c!--\n\t结果：\n\t{\n\t1={password=123456, sex=男, id=1, age=23, username=admin},\n\t2={password=123456, sex=男, id=2, age=23, username=张三},\n\t3={password=123456, sex=男, id=3, age=23, username=张三}\n\t}\n--\x3e\n\n\n\n# 特殊SQL的执行\n\n\n# 模糊查询\n\n/**\n * 根据用户名进行模糊查询\n * @param username \n * @return java.util.List<com.atguigu.mybatis.pojo.User>\n * @date 2022/2/26 21:56\n */\n\n /*\n * #{}在SQL的模糊查询中会定义为？，这个连接到模糊语法中会定义为字符\'?\'\n\n #被解析的时候就会被解析为一对单引号\n因此\n\t\x3c!--select * from t_user where username like \'%#{mohu}%\'--\x3e\n\t不能正确查询\n */ \nList<User> getUserByLike(@Param("username") String username);\n\n\n\x3c!--List<User> getUserByLike(@Param("username") String username);--\x3e\n<select id="getUserByLike" resultType="User">\n\x3c!-- 能够正确查询的三种方法 --\x3e\n\t\x3c!--select * from t_user where username like \'%${mohu}%\'--\x3e\n\t\x3c!--select * from t_user where username like concat(\'%\',#{mohu},\'%\')--\x3e\n\n\n\tselect * from t_user where username like "%"#{mohu}"%"\n</select>\n\n\n * 其中select * from t_user where username like "%"#{mohu}"%"是最常用的\n\n\n# 批量删除\n\n * 只能使用${}，如果使用#{}，则解析后的sql语句为delete from t_user where id in (\'1,2,3\')，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in (\'1\',\'2\',\'3\')\n\n/**\n * 根据id批量删除\n * @param ids \n * @return int\n * @date 2022/2/26 22:06\n */\nint deleteMore(@Param("ids") String ids);\n\n\n#{}在这里不能使用，会报错，因为会把变量解析为整体并给整体加上单引号，批量删除只能通过${}进行删除\n<delete id="deleteMore">\n\tdelete from t_user where id in (${ids})\n</delete>\n\n\n//测试类\n@Test\npublic void deleteMore() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tSQLMapper mapper = sqlSession.getMapper(SQLMapper.class);\n\tint result = mapper.deleteMore("1,2,3,8");\n\tSystem.out.println(result);\n}\n\n\n\n# 动态设置表名\n\n * 只能使用${}，因为表名不能加单引号\n\n/**\n * 查询指定表中的数据\n * @param tableName \n * @return java.util.List<com.atguigu.mybatis.pojo.User>\n * @date 2022/2/27 14:41\n */\nList<User> getUserByTable(@Param("tableName") String tableName);\n\n\n\x3c!--List<User> getUserByTable(@Param("tableName") String tableName);--\x3e\n<select id="getUserByTable" resultType="User">\n\tselect * from ${tableName}\n</select>\n\n\n上述三个只能使用${}\n\n\n# 添加功能获取自增的主键\n\n * 使用场景\n   * t_clazz(clazz_id,clazz_name)\n   * t_student(student_id,student_name,clazz_id)\n   1. 添加班级信息\n   2. 获取新添加的班级的id\n   3. 为班级分配学生，即将某学的班级id修改为新添加的班级的id\n * 在mapper.xml中设置两个属性\n   * useGeneratedKeys：设置使用自增的主键\n   * keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中\n\n/**\n * 添加用户信息\n * @param user \n * @date 2022/2/27 15:04\n */\nvoid insertUser(User user);\n\n\n\x3c!--void insertUser(User user);--\x3e\n<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">\n\tinsert into t_user values (null,#{username},#{password},#{age},#{sex},#{email})\n</insert>\n\n\n//测试类\n@Test\npublic void insertUser() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tSQLMapper mapper = sqlSession.getMapper(SQLMapper.class);\n\tUser user = new User(null, "ton", "123", 23, "男", "123@321.com");\n\tmapper.insertUser(user);\n\tSystem.out.println(user);\n\t//输出：user{id=10, username=\'ton\', password=\'123\', age=23, sex=\'男\', email=\'123@321.com\'}，自增主键存放到了user的id属性中\n}\n',normalizedContent:'# mybatis的各种查询功能\n\n 1. 如果查询出的数据只有一条，可以通过\n    1. 实体类对象接收\n    2. list集合接收\n    3. map集合接收，结果{password=123456, sex=男, id=1, age=23, username=admin}\n 2. 如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常toomanyresultsexception，可以通过\n    1. 实体类类型的list集合接收\n    2. map类型的list集合接收\n    3. 在mapper接口的方法上添加@mapkey注解\n\n\n# 查询一个实体类对象\n\n/**\n * 根据用户id查询用户信息\n * @param id\n * @return\n */\nuser getuserbyid(@param("id") int id);\n\n\n\x3c!--user getuserbyid(@param("id") int id);--\x3e\n<select id="getuserbyid" resulttype="user">\n\tselect * from t_user where id = #{id}\n</select>\n\n\n\n# 查询一个list集合\n\n/**\n * 查询所有用户信息\n * @return\n */\nlist<user> getuserlist();\n\n\n\x3c!--list<user> getuserlist();--\x3e\n<select id="getuserlist" resulttype="user">\n\tselect * from t_user\n</select>\n\n\n\n# 查询单个数据\n\n/**  \n * 查询用户的总记录数  \n * @return  \n * 在mybatis中，对于java中常用的类型都设置了类型别名  \n * 例如：java.lang.integer--\x3eint|integer  \n * 例如：int--\x3e_int|_integer  \n * 例如：map--\x3emap, list--\x3elist  \n */  \nint getcount();\n\n\n\x3c!--int getcount();--\x3e\n<select id="getcount" resulttype="_integer">\n\tselect count(id) from t_user\n</select>\n\n\n\n\n\n\n\n\n# 查询一条数据为map集合\n\n/**  \n * 根据用户id查询用户信息为map集合  \n * @param id  \n * @return  \n */  \nmap<string, object> getusertomap(@param("id") int id);\n\n\n\x3c!--map<string, object> getusertomap(@param("id") int id);--\x3e\n\n\n\x3c!-- 返回的是map类型 --\x3e\n<select id="getusertomap" resulttype="map">\n\tselect * from t_user where id = #{id}\n</select>\n\x3c!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--\x3e\n\n\n\n# 查询多条数据为map集合\n\n\n# 方法一\n\n/**  \n * 查询所有用户信息为map集合  \n * @return  \n * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  \n */  \nlist<map<string, object>> getallusertomap();\n\n\n\x3c!--map<string, object> getallusertomap();--\x3e  \n<select id="getallusertomap" resulttype="map">  \n\tselect * from t_user  \n</select>\n\x3c!--\n\t结果：\n\t[{password=123456, sex=男, id=1, age=23, username=admin},\n\t{password=123456, sex=男, id=2, age=23, username=张三},\n\t{password=123456, sex=男, id=3, age=23, username=张三}]\n--\x3e\n\n\n\n# 方法二\n\n/**\n * 查询所有用户信息为map集合\n * @return\n * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@mapkey注解设置map集合的键，值是每条数据所对应的map集合\n */\n\n@mapkey("id")  // mapkey对应的值要唯一\nmap<string, object> getallusertomap();\n\n\n\x3c!--map<string, object> getallusertomap();--\x3e\n<select id="getallusertomap" resulttype="map">\n\tselect * from t_user\n</select>\n\x3c!--\n\t结果：\n\t{\n\t1={password=123456, sex=男, id=1, age=23, username=admin},\n\t2={password=123456, sex=男, id=2, age=23, username=张三},\n\t3={password=123456, sex=男, id=3, age=23, username=张三}\n\t}\n--\x3e\n\n\n\n# 特殊sql的执行\n\n\n# 模糊查询\n\n/**\n * 根据用户名进行模糊查询\n * @param username \n * @return java.util.list<com.atguigu.mybatis.pojo.user>\n * @date 2022/2/26 21:56\n */\n\n /*\n * #{}在sql的模糊查询中会定义为？，这个连接到模糊语法中会定义为字符\'?\'\n\n #被解析的时候就会被解析为一对单引号\n因此\n\t\x3c!--select * from t_user where username like \'%#{mohu}%\'--\x3e\n\t不能正确查询\n */ \nlist<user> getuserbylike(@param("username") string username);\n\n\n\x3c!--list<user> getuserbylike(@param("username") string username);--\x3e\n<select id="getuserbylike" resulttype="user">\n\x3c!-- 能够正确查询的三种方法 --\x3e\n\t\x3c!--select * from t_user where username like \'%${mohu}%\'--\x3e\n\t\x3c!--select * from t_user where username like concat(\'%\',#{mohu},\'%\')--\x3e\n\n\n\tselect * from t_user where username like "%"#{mohu}"%"\n</select>\n\n\n * 其中select * from t_user where username like "%"#{mohu}"%"是最常用的\n\n\n# 批量删除\n\n * 只能使用${}，如果使用#{}，则解析后的sql语句为delete from t_user where id in (\'1,2,3\')，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in (\'1\',\'2\',\'3\')\n\n/**\n * 根据id批量删除\n * @param ids \n * @return int\n * @date 2022/2/26 22:06\n */\nint deletemore(@param("ids") string ids);\n\n\n#{}在这里不能使用，会报错，因为会把变量解析为整体并给整体加上单引号，批量删除只能通过${}进行删除\n<delete id="deletemore">\n\tdelete from t_user where id in (${ids})\n</delete>\n\n\n//测试类\n@test\npublic void deletemore() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tsqlmapper mapper = sqlsession.getmapper(sqlmapper.class);\n\tint result = mapper.deletemore("1,2,3,8");\n\tsystem.out.println(result);\n}\n\n\n\n# 动态设置表名\n\n * 只能使用${}，因为表名不能加单引号\n\n/**\n * 查询指定表中的数据\n * @param tablename \n * @return java.util.list<com.atguigu.mybatis.pojo.user>\n * @date 2022/2/27 14:41\n */\nlist<user> getuserbytable(@param("tablename") string tablename);\n\n\n\x3c!--list<user> getuserbytable(@param("tablename") string tablename);--\x3e\n<select id="getuserbytable" resulttype="user">\n\tselect * from ${tablename}\n</select>\n\n\n上述三个只能使用${}\n\n\n# 添加功能获取自增的主键\n\n * 使用场景\n   * t_clazz(clazz_id,clazz_name)\n   * t_student(student_id,student_name,clazz_id)\n   1. 添加班级信息\n   2. 获取新添加的班级的id\n   3. 为班级分配学生，即将某学的班级id修改为新添加的班级的id\n * 在mapper.xml中设置两个属性\n   * usegeneratedkeys：设置使用自增的主键\n   * keyproperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中\n\n/**\n * 添加用户信息\n * @param user \n * @date 2022/2/27 15:04\n */\nvoid insertuser(user user);\n\n\n\x3c!--void insertuser(user user);--\x3e\n<insert id="insertuser" usegeneratedkeys="true" keyproperty="id">\n\tinsert into t_user values (null,#{username},#{password},#{age},#{sex},#{email})\n</insert>\n\n\n//测试类\n@test\npublic void insertuser() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tsqlmapper mapper = sqlsession.getmapper(sqlmapper.class);\n\tuser user = new user(null, "ton", "123", 23, "男", "123@321.com");\n\tmapper.insertuser(user);\n\tsystem.out.println(user);\n\t//输出：user{id=10, username=\'ton\', password=\'123\', age=23, sex=\'男\', email=\'123@321.com\'}，自增主键存放到了user的id属性中\n}\n',charsets:{cjk:!0}},{title:"自定义映射resultMap",frontmatter:{title:"自定义映射resultMap",date:"2022-03-07T00:00:00.000Z",permalink:"/mybatis/004/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/04.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84resultMap.html",relativePath:"07.框架/04.MyBatis/04.自定义映射resultMap.md",key:"v-2f47d23e",path:"/mybatis/004/",headers:[{level:2,title:"resultMap处理字段和属性的映射关系",slug:"resultmap处理字段和属性的映射关系",normalizedTitle:"resultmap处理字段和属性的映射关系",charIndex:21},{level:2,title:"多对一映射处理",slug:"多对一映射处理",normalizedTitle:"多对一映射处理",charIndex:1330},{level:3,title:"级联方式处理映射关系",slug:"级联方式处理映射关系",normalizedTitle:"级联方式处理映射关系",charIndex:1553},{level:3,title:"使用association处理映射关系(第一种)",slug:"使用association处理映射关系-第一种",normalizedTitle:"使用association处理映射关系(第一种)",charIndex:2203},{level:3,title:"分步查询（第三种用的最多）",slug:"分步查询-第三种用的最多",normalizedTitle:"分步查询（第三种用的最多）",charIndex:2988},{level:4,title:"1. 查询员工信息",slug:"_1-查询员工信息",normalizedTitle:"1. 查询员工信息",charIndex:3005},{level:4,title:"2. 查询部门信息",slug:"_2-查询部门信息",normalizedTitle:"2. 查询部门信息",charIndex:3971},{level:2,title:"一对多映射处理",slug:"一对多映射处理",normalizedTitle:"一对多映射处理",charIndex:4589},{level:3,title:"collection",slug:"collection",normalizedTitle:"collection",charIndex:4728},{level:3,title:"分步查询",slug:"分步查询",normalizedTitle:"分步查询",charIndex:2988},{level:4,title:"1. 查询部门信息",slug:"_1-查询部门信息",normalizedTitle:"1. 查询部门信息",charIndex:5487},{level:4,title:"2. 根据部门id查询部门中的所有员工",slug:"_2-根据部门id查询部门中的所有员工",normalizedTitle:"2. 根据部门id查询部门中的所有员工",charIndex:6189},{level:2,title:"延迟加载",slug:"延迟加载",normalizedTitle:"延迟加载",charIndex:6606}],headersStr:"resultMap处理字段和属性的映射关系 多对一映射处理 级联方式处理映射关系 使用association处理映射关系(第一种) 分步查询（第三种用的最多） 1. 查询员工信息 2. 查询部门信息 一对多映射处理 collection 分步查询 1. 查询部门信息 2. 根据部门id查询部门中的所有员工 延迟加载",content:'# 自定义映射resultMap\n\n\n# resultMap处理字段和属性的映射关系\n\n * resultMap：设置自定义映射\n   * 属性：\n     * id：表示自定义映射的唯一标识，不能重复\n     * type：查询的数据要映射的实体类的类型\n   * 子标签：\n     * id：设置主键的映射关系\n     * result：设置普通字段的映射关系\n     * 子标签属性：\n       * property：设置映射关系中实体类中的属性名\n       * column：设置映射关系中表中的字段名\n * 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来\n\n<resultMap id="empResultMap" type="Emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empName" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n</resultMap>\n\x3c!--List<Emp> getAllEmp();--\x3e\n<select id="getAllEmp" resultMap="empResultMap">\n\tselect * from t_emp\n</select>\n\n\n * 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系\n   \n   1. 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致\n      \n      \x3c!--List<Emp> getAllEmp();--\x3e\n      <select id="getAllEmp" resultType="Emp">\n      \tselect eid,emp_name empName,age,sex,email from t_emp\n      </select>\n      \n   \n   2. 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解\n   \n   <settings>\n       <setting name="mapUnderscoreToCamelCase" value="true"/>\n   </settings>\n   \n\n\n# 多对一映射处理\n\n> 查询员工信息以及员工所对应的部门信息\n\npublic class Emp {  \n\tprivate Integer eid;  \n\tprivate String empName;  \n\tprivate Integer age;  \n\tprivate String sex;  \n\tprivate String email;  \n\tprivate Dept dept;\n\t//...构造器、get、set方法等\n}\n\n\n\n# 级联方式处理映射关系\n\n<resultMap id="empAndDeptResultMapOne" type="Emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empName" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n\t<result property="dept.did" column="did"></result>\n\t<result property="dept.deptName" column="dept_name"></result>\n</resultMap>\n\x3c!--Emp getEmpAndDept(@Param("eid")Integer eid);--\x3e\n<select id="getEmpAndDept" resultMap="empAndDeptResultMapOne">\n\tselect * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}\n</select>\n\n\n\n# 使用association处理映射关系(第一种)\n\n * association：处理多对一的映射关系\n * property：需要处理多对的映射关系的属性名\n * javaType：该属性的类型\n\n<resultMap id="empAndDeptResultMapTwo" type="Emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empName" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n\t<association property="dept" javaType="Dept">\n\t\t<id property="did" column="did"></id>\n\t\t<result property="deptName" column="dept_name"></result>\n\t</association>\n</resultMap>\n\x3c!--Emp getEmpAndDept(@Param("eid")Integer eid);--\x3e\n<select id="getEmpAndDept" resultMap="empAndDeptResultMapTwo">\n\tselect * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}\n</select>\n\n\n\n# 分步查询（第三种用的最多）\n\n# 1. 查询员工信息\n\n * select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）\n * column：设置分步查询的条件\n\n//EmpMapper里的方法\n/**\n * 通过分步查询，员工及所对应的部门信息\n * 分步查询第一步：查询员工信息\n * @param  \n * @return com.atguigu.mybatis.pojo.Emp\n * @date 2022/2/27 20:17\n */\nEmp getEmpAndDeptByStepOne(@Param("eid") Integer eid);\n\n\n<resultMap id="empAndDeptByStepResultMap" type="Emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empName" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n\t\x3c!-- column写的是分布查询的条件（部门的id） --\x3e\n\t<association property="dept"\n\t\t\t\t select="com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo"\n\n\t\t\t\t\n\t\t\t\t column="did"></association>\n</resultMap>\n\x3c!--Emp getEmpAndDeptByStepOne(@Param("eid") Integer eid);--\x3e\n<select id="getEmpAndDeptByStepOne" resultMap="empAndDeptByStepResultMap">\n\tselect * from t_emp where eid = #{eid}\n</select>\n\n\n# 2. 查询部门信息\n\n//DeptMapper里的方法\n/**\n * 通过分步查询，员工及所对应的部门信息\n * 分步查询第二步：通过did查询员工对应的部门信息\n * @param\n * @return com.atguigu.mybatis.pojo.Emp\n * @date 2022/2/27 20:23\n */\nDept getEmpAndDeptByStepTwo(@Param("did") Integer did);\n\n\n\x3c!--此处的resultMap仅是处理字段和属性的映射关系--\x3e\n<resultMap id="EmpAndDeptByStepTwoResultMap" type="Dept">\n\t<id property="did" column="did"></id>\n\t<result property="deptName" column="dept_name"></result>\n</resultMap>\n\x3c!--Dept getEmpAndDeptByStepTwo(@Param("did") Integer did);--\x3e\n<select id="getEmpAndDeptByStepTwo" resultMap="EmpAndDeptByStepTwoResultMap">\n\tselect * from t_dept where did = #{did}\n</select>\n\n\n\n# 一对多映射处理\n\npublic class Dept {\n    private Integer did;\n    private String deptName;\n    private List<Emp> emps;\n\t//...构造器、get、set方法等\n}\n\n\n\n# collection\n\n * collection：用来处理一对多的映射关系\n * ofType：表示该属性对应的集合中存储的数据的类型\n\n<resultMap id="DeptAndEmpResultMap" type="Dept">\n\t<id property="did" column="did"></id>\n\t<result property="deptName" column="dept_name"></result>\n\t<collection property="emps" ofType="Emp">\n\t\t<id property="eid" column="eid"></id>\n\t\t<result property="empName" column="emp_name"></result>\n\t\t<result property="age" column="age"></result>\n\t\t<result property="sex" column="sex"></result>\n\t\t<result property="email" column="email"></result>\n\t</collection>\n</resultMap>\n\x3c!--Dept getDeptAndEmp(@Param("did") Integer did);--\x3e\n<select id="getDeptAndEmp" resultMap="DeptAndEmpResultMap">\n\tselect * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did}\n</select>\n\n\n\n# 分步查询\n\n# 1. 查询部门信息\n\n/**\n * 通过分步查询，查询部门及对应的所有员工信息\n * 分步查询第一步：查询部门信息\n * @param did \n * @return com.atguigu.mybatis.pojo.Dept\n * @date 2022/2/27 22:04\n */\nDept getDeptAndEmpByStepOne(@Param("did") Integer did);\n\n\n<resultMap id="DeptAndEmpByStepOneResultMap" type="Dept">\n\t<id property="did" column="did"></id>\n\t<result property="deptName" column="dept_name"></result>\n\t<collection property="emps"\n\t\t\t\tselect="com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo"\n\t\t\t\tcolumn="did"></collection>\n</resultMap>\n\x3c!--Dept getDeptAndEmpByStepOne(@Param("did") Integer did);--\x3e\n<select id="getDeptAndEmpByStepOne" resultMap="DeptAndEmpByStepOneResultMap">\n\tselect * from t_dept where did = #{did}\n</select>\n\n\n\n\n\n\n# 2. 根据部门id查询部门中的所有员工\n\n/**\n * 通过分步查询，查询部门及对应的所有员工信息\n * 分步查询第二步：根据部门id查询部门中的所有员工\n * @param did\n * @return java.util.List<com.atguigu.mybatis.pojo.Emp>\n * @date 2022/2/27 22:10\n */\nList<Emp> getDeptAndEmpByStepTwo(@Param("did") Integer did);\n\n\n\x3c!--List<Emp> getDeptAndEmpByStepTwo(@Param("did") Integer did);--\x3e\n<select id="getDeptAndEmpByStepTwo" resultType="Emp">\n\tselect * from t_emp where did = #{did}\n</select>\n\n\n\n# 延迟加载\n\n * 分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：\n   * lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象（分布查询的第二步、第三步、。。。。）都会延迟加载\n   * aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载\n * 此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。\n * 此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType="lazy(延迟加载)|eager(立即加载)"\n * aggressiveLazyLoading设置为true则lazyLoadingEnabled失效\n\n<settings>\n\t\x3c!--开启延迟加载--\x3e\n\t<setting name="lazyLoadingEnabled" value="true"/>\n</settings>\n\n\n@Test\npublic void getEmpAndDeptByStepOne() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\tEmp emp = mapper.getEmpAndDeptByStepOne(1);\n\tSystem.out.println(emp.getEmpName());\n}\n\n\n * 关闭延迟加载，两条SQL语句都运行了\n * 开启延迟加载，只运行获取emp的SQL语句\n\n@Test\npublic void getEmpAndDeptByStepOne() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\tEmp emp = mapper.getEmpAndDeptByStepOne(1);\n\tSystem.out.println(emp.getEmpName());\n\tSystem.out.println("----------------");\n\tSystem.out.println(emp.getDept());\n}\n\n\n * 开启后，需要用到查询dept的时候才会调用相应的SQL语句\n\n * fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType="lazy(延迟加载)|eager(立即加载)"\n   \n   <resultMap id="empAndDeptByStepResultMap" type="Emp">\n   \t<id property="eid" column="eid"></id>\n   \t<result property="empName" column="emp_name"></result>\n   \t<result property="age" column="age"></result>\n   \t<result property="sex" column="sex"></result>\n   \t<result property="email" column="email"></result>\n   \t<association property="dept"\n   \t\t\t\t select="com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo"\n   \t\t\t\t column="did"\n   \t\t\t\t fetchType="lazy"></association>\n   </resultMap>\n   ',normalizedContent:'# 自定义映射resultmap\n\n\n# resultmap处理字段和属性的映射关系\n\n * resultmap：设置自定义映射\n   * 属性：\n     * id：表示自定义映射的唯一标识，不能重复\n     * type：查询的数据要映射的实体类的类型\n   * 子标签：\n     * id：设置主键的映射关系\n     * result：设置普通字段的映射关系\n     * 子标签属性：\n       * property：设置映射关系中实体类中的属性名\n       * column：设置映射关系中表中的字段名\n * 若字段名和实体类中的属性名不一致，则可以通过resultmap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来\n\n<resultmap id="empresultmap" type="emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empname" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n</resultmap>\n\x3c!--list<emp> getallemp();--\x3e\n<select id="getallemp" resultmap="empresultmap">\n\tselect * from t_emp\n</select>\n\n\n * 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系\n   \n   1. 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致\n      \n      \x3c!--list<emp> getallemp();--\x3e\n      <select id="getallemp" resulttype="emp">\n      \tselect eid,emp_name empname,age,sex,email from t_emp\n      </select>\n      \n   \n   2. 可以在mybatis的核心配置文件中的setting标签中，设置一个全局配置信息mapunderscoretocamelcase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapunderscoretocamelcase，此时字段名就会转换为username。核心配置文件详解\n   \n   <settings>\n       <setting name="mapunderscoretocamelcase" value="true"/>\n   </settings>\n   \n\n\n# 多对一映射处理\n\n> 查询员工信息以及员工所对应的部门信息\n\npublic class emp {  \n\tprivate integer eid;  \n\tprivate string empname;  \n\tprivate integer age;  \n\tprivate string sex;  \n\tprivate string email;  \n\tprivate dept dept;\n\t//...构造器、get、set方法等\n}\n\n\n\n# 级联方式处理映射关系\n\n<resultmap id="empanddeptresultmapone" type="emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empname" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n\t<result property="dept.did" column="did"></result>\n\t<result property="dept.deptname" column="dept_name"></result>\n</resultmap>\n\x3c!--emp getempanddept(@param("eid")integer eid);--\x3e\n<select id="getempanddept" resultmap="empanddeptresultmapone">\n\tselect * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}\n</select>\n\n\n\n# 使用association处理映射关系(第一种)\n\n * association：处理多对一的映射关系\n * property：需要处理多对的映射关系的属性名\n * javatype：该属性的类型\n\n<resultmap id="empanddeptresultmaptwo" type="emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empname" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n\t<association property="dept" javatype="dept">\n\t\t<id property="did" column="did"></id>\n\t\t<result property="deptname" column="dept_name"></result>\n\t</association>\n</resultmap>\n\x3c!--emp getempanddept(@param("eid")integer eid);--\x3e\n<select id="getempanddept" resultmap="empanddeptresultmaptwo">\n\tselect * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}\n</select>\n\n\n\n# 分步查询（第三种用的最多）\n\n# 1. 查询员工信息\n\n * select：设置分布查询的sql的唯一标识（namespace.sqlid或mapper接口的全类名.方法名）\n * column：设置分步查询的条件\n\n//empmapper里的方法\n/**\n * 通过分步查询，员工及所对应的部门信息\n * 分步查询第一步：查询员工信息\n * @param  \n * @return com.atguigu.mybatis.pojo.emp\n * @date 2022/2/27 20:17\n */\nemp getempanddeptbystepone(@param("eid") integer eid);\n\n\n<resultmap id="empanddeptbystepresultmap" type="emp">\n\t<id property="eid" column="eid"></id>\n\t<result property="empname" column="emp_name"></result>\n\t<result property="age" column="age"></result>\n\t<result property="sex" column="sex"></result>\n\t<result property="email" column="email"></result>\n\t\x3c!-- column写的是分布查询的条件（部门的id） --\x3e\n\t<association property="dept"\n\t\t\t\t select="com.atguigu.mybatis.mapper.deptmapper.getempanddeptbysteptwo"\n\n\t\t\t\t\n\t\t\t\t column="did"></association>\n</resultmap>\n\x3c!--emp getempanddeptbystepone(@param("eid") integer eid);--\x3e\n<select id="getempanddeptbystepone" resultmap="empanddeptbystepresultmap">\n\tselect * from t_emp where eid = #{eid}\n</select>\n\n\n# 2. 查询部门信息\n\n//deptmapper里的方法\n/**\n * 通过分步查询，员工及所对应的部门信息\n * 分步查询第二步：通过did查询员工对应的部门信息\n * @param\n * @return com.atguigu.mybatis.pojo.emp\n * @date 2022/2/27 20:23\n */\ndept getempanddeptbysteptwo(@param("did") integer did);\n\n\n\x3c!--此处的resultmap仅是处理字段和属性的映射关系--\x3e\n<resultmap id="empanddeptbysteptworesultmap" type="dept">\n\t<id property="did" column="did"></id>\n\t<result property="deptname" column="dept_name"></result>\n</resultmap>\n\x3c!--dept getempanddeptbysteptwo(@param("did") integer did);--\x3e\n<select id="getempanddeptbysteptwo" resultmap="empanddeptbysteptworesultmap">\n\tselect * from t_dept where did = #{did}\n</select>\n\n\n\n# 一对多映射处理\n\npublic class dept {\n    private integer did;\n    private string deptname;\n    private list<emp> emps;\n\t//...构造器、get、set方法等\n}\n\n\n\n# collection\n\n * collection：用来处理一对多的映射关系\n * oftype：表示该属性对应的集合中存储的数据的类型\n\n<resultmap id="deptandempresultmap" type="dept">\n\t<id property="did" column="did"></id>\n\t<result property="deptname" column="dept_name"></result>\n\t<collection property="emps" oftype="emp">\n\t\t<id property="eid" column="eid"></id>\n\t\t<result property="empname" column="emp_name"></result>\n\t\t<result property="age" column="age"></result>\n\t\t<result property="sex" column="sex"></result>\n\t\t<result property="email" column="email"></result>\n\t</collection>\n</resultmap>\n\x3c!--dept getdeptandemp(@param("did") integer did);--\x3e\n<select id="getdeptandemp" resultmap="deptandempresultmap">\n\tselect * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did}\n</select>\n\n\n\n# 分步查询\n\n# 1. 查询部门信息\n\n/**\n * 通过分步查询，查询部门及对应的所有员工信息\n * 分步查询第一步：查询部门信息\n * @param did \n * @return com.atguigu.mybatis.pojo.dept\n * @date 2022/2/27 22:04\n */\ndept getdeptandempbystepone(@param("did") integer did);\n\n\n<resultmap id="deptandempbysteponeresultmap" type="dept">\n\t<id property="did" column="did"></id>\n\t<result property="deptname" column="dept_name"></result>\n\t<collection property="emps"\n\t\t\t\tselect="com.atguigu.mybatis.mapper.empmapper.getdeptandempbysteptwo"\n\t\t\t\tcolumn="did"></collection>\n</resultmap>\n\x3c!--dept getdeptandempbystepone(@param("did") integer did);--\x3e\n<select id="getdeptandempbystepone" resultmap="deptandempbysteponeresultmap">\n\tselect * from t_dept where did = #{did}\n</select>\n\n\n\n\n\n\n# 2. 根据部门id查询部门中的所有员工\n\n/**\n * 通过分步查询，查询部门及对应的所有员工信息\n * 分步查询第二步：根据部门id查询部门中的所有员工\n * @param did\n * @return java.util.list<com.atguigu.mybatis.pojo.emp>\n * @date 2022/2/27 22:10\n */\nlist<emp> getdeptandempbysteptwo(@param("did") integer did);\n\n\n\x3c!--list<emp> getdeptandempbysteptwo(@param("did") integer did);--\x3e\n<select id="getdeptandempbysteptwo" resulttype="emp">\n\tselect * from t_emp where did = #{did}\n</select>\n\n\n\n# 延迟加载\n\n * 分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：\n   * lazyloadingenabled：延迟加载的全局开关。当开启时，所有关联对象（分布查询的第二步、第三步、。。。。）都会延迟加载\n   * aggressivelazyloading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载\n * 此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。\n * 此时可通过association和collection中的fetchtype属性设置当前的分步查询是否使用延迟加载，fetchtype="lazy(延迟加载)|eager(立即加载)"\n * aggressivelazyloading设置为true则lazyloadingenabled失效\n\n<settings>\n\t\x3c!--开启延迟加载--\x3e\n\t<setting name="lazyloadingenabled" value="true"/>\n</settings>\n\n\n@test\npublic void getempanddeptbystepone() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tempmapper mapper = sqlsession.getmapper(empmapper.class);\n\temp emp = mapper.getempanddeptbystepone(1);\n\tsystem.out.println(emp.getempname());\n}\n\n\n * 关闭延迟加载，两条sql语句都运行了\n * 开启延迟加载，只运行获取emp的sql语句\n\n@test\npublic void getempanddeptbystepone() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tempmapper mapper = sqlsession.getmapper(empmapper.class);\n\temp emp = mapper.getempanddeptbystepone(1);\n\tsystem.out.println(emp.getempname());\n\tsystem.out.println("----------------");\n\tsystem.out.println(emp.getdept());\n}\n\n\n * 开启后，需要用到查询dept的时候才会调用相应的sql语句\n\n * fetchtype：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchtype="lazy(延迟加载)|eager(立即加载)"\n   \n   <resultmap id="empanddeptbystepresultmap" type="emp">\n   \t<id property="eid" column="eid"></id>\n   \t<result property="empname" column="emp_name"></result>\n   \t<result property="age" column="age"></result>\n   \t<result property="sex" column="sex"></result>\n   \t<result property="email" column="email"></result>\n   \t<association property="dept"\n   \t\t\t\t select="com.atguigu.mybatis.mapper.deptmapper.getempanddeptbysteptwo"\n   \t\t\t\t column="did"\n   \t\t\t\t fetchtype="lazy"></association>\n   </resultmap>\n   ',charsets:{cjk:!0}},{title:"动态SQL",frontmatter:{title:"动态SQL",date:"2022-03-10T00:00:00.000Z",permalink:"/mybatis/005/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/05.%E5%8A%A8%E6%80%81SQL.html",relativePath:"07.框架/04.MyBatis/05.动态SQL.md",key:"v-4cee0db7",path:"/mybatis/005/",headers:[{level:2,title:"if",slug:"if",normalizedTitle:"if",charIndex:83},{level:2,title:"where",slug:"where",normalizedTitle:"where",charIndex:163},{level:2,title:"trim",slug:"trim",normalizedTitle:"trim",charIndex:1737},{level:2,title:"choose、when、otherwise",slug:"choose、when、otherwise",normalizedTitle:"choose、when、otherwise",charIndex:2755},{level:2,title:"foreach",slug:"foreach",normalizedTitle:"foreach",charIndex:3704},{level:2,title:"SQL片段",slug:"sql片段",normalizedTitle:"sql片段",charIndex:5566}],headersStr:"if where trim choose、when、otherwise foreach SQL片段",content:'# 动态SQL\n\n * Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题\n\n\n# if\n\n * if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行\n * 在where后面添加一个恒成立条件1=1\n   * 这个恒成立条件并不会影响查询的结果\n   * 这个1=1可以用来拼接and语句，例如：当empName为null时\n     * 如果不加上恒成立条件，则SQL语句为select * from t_emp where and age = ? and sex = ? and email = ?，此时where会与and连用，SQL语句会报错\n     * 如果加上一个恒成立条件，则SQL语句为select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?，此时不报错\n\n\x3c!--List<Emp> getEmpByCondition(Emp emp);--\x3e\n\x3c!-- test中直接使用属性名就可以，不用写成"Emp.属性名" --\x3e\n<select id="getEmpByCondition" resultType="Emp">\n\tselect * from t_emp where 1=1 \n\t<if test="empName != null and empName !=\'\'">\n\t\tand emp_name = #{empName}\n\t</if>\n\t<if test="age != null and age !=\'\'">\n\t\tand age = #{age}\n\t</if>\n\t<if test="sex != null and sex !=\'\'">\n\t\tand sex = #{sex}\n\t</if>\n\t<if test="email != null and email !=\'\'">\n\t\tand email = #{email}\n\t</if>\n</select>\n\n\n\n# where\n\n * where和if一般结合使用：\n   * 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字\n   * 若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉\n\n\x3c!--List<Emp> getEmpByCondition(Emp emp);--\x3e\n<select id="getEmpByCondition" resultType="Emp">\n\tselect * from t_emp\n\t<where>\n\t\t<if test="empName != null and empName !=\'\'">\n\t\t\temp_name = #{empName}\n\t\t</if>\n\t\t<if test="age != null and age !=\'\'">\n\t\t\tand age = #{age}\n\t\t</if>\n\t\t<if test="sex != null and sex !=\'\'">\n\t\t\tand sex = #{sex}\n\t\t</if>\n\t\t<if test="email != null and email !=\'\'">\n\t\t\tand email = #{email}\n\t\t</if>\n\t</where>\n</select>\n\n\n * 注意：where标签不能去掉条件后多余的and/or\n   \n   \x3c!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--\x3e\n   <if test="empName != null and empName !=\'\'">\n   emp_name = #{empName} and\n   </if>\n   <if test="age != null and age !=\'\'">\n   \tage = #{age}\n   </if>\n   \n\n\n# trim\n\n * trim用于去掉或添加标签中的内容\n * 常用属性\n   * prefix：在trim标签中的内容的前面添加某些内容\n   * suffix：在trim标签中的内容的后面添加某些内容\n   * prefixOverrides：在trim标签中的内容的前面去掉某些内容\n   * suffixOverrides：在trim标签中的内容的后面去掉某些内容\n * 若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下select * from t_emp\n\n\x3c!--List<Emp> getEmpByCondition(Emp emp);--\x3e\n<select id="getEmpByCondition" resultType="Emp">\n\tselect * from t_emp\n\t<trim prefix="where" suffixOverrides="and|or">\n\t\t<if test="empName != null and empName !=\'\'">\n\t\t\temp_name = #{empName} and\n\t\t</if>\n\t\t<if test="age != null and age !=\'\'">\n\t\t\tage = #{age} and\n\t\t</if>\n\t\t<if test="sex != null and sex !=\'\'">\n\t\t\tsex = #{sex} or\n\t\t</if>\n\t\t<if test="email != null and email !=\'\'">\n\t\t\temail = #{email}\n\t\t</if>\n\t</trim>\n</select>\n\n\n//测试类\n@Test\npublic void getEmpByCondition() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n\tList<Emp> emps= mapper.getEmpByCondition(new Emp(null, "张三", null, null, null, null));\n\tSystem.out.println(emps);\n}\n\n\n\n\n\n# choose、when、otherwise\n\n * choose、when、otherwise相当于if...else if..else（选择结构必然只能有一个条件进行执行，因此没有or|and 一说）\n * when至少要有一个，otherwise至多只有一个\n\n<select id="getEmpByChoose" resultType="Emp">\n\tselect * from t_emp\n\t<where>\n\t\t<choose>\n\t\t\t<when test="empName != null and empName != \'\'">\n\t\t\t\temp_name = #{empName}\n\t\t\t</when>\n\t\t\t<when test="age != null and age != \'\'">\n\t\t\t\tage = #{age}\n\t\t\t</when>\n\t\t\t<when test="sex != null and sex != \'\'">\n\t\t\t\tsex = #{sex}\n\t\t\t</when>\n\t\t\t<when test="email != null and email != \'\'">\n\t\t\t\temail = #{email}\n\t\t\t</when>\n\t\t\t<otherwise>\n\t\t\t\tdid = 1\n\t\t\t</otherwise>\n\t\t</choose>\n\t</where>\n</select>\n\n\n@Test\npublic void getEmpByChoose() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n\tList<Emp> emps = mapper.getEmpByChoose(new Emp(null, "张三", 23, "男", "123@qq.com", null));\n\tSystem.out.println(emps);\n}\n\n\n\n\n * 相当于if a else if b else if c else d，只会执行其中一个\n\n\n# foreach\n\nParam到底是把括号里面的变量绑定到形参还是把形参绑定到括号里面的 的？？这里需要搞清楚，感觉像是把形参绑定到param对应变量上面，后面的程序使用param变量\n\n * 属性：\n   \n   * collection：设置要循环的数组或集合\n   * item：表示集合或数组中的每一个数据\n   * separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如,\n   * open：设置foreach标签中的内容的开始符\n   * close：设置foreach标签中的内容的结束符\n\n * 批量删除\n   \n   \x3c!--int deleteMoreByArray(Integer[] eids);--\x3e\n   \n   \x3c!--int deleteMoreByArray(@Param("eids") Integer[] eids);--\x3e\n   <delete id="deleteMoreByArray">\n   \tdelete from t_emp where eid in\n   \t<foreach collection="eids" item="eid" separator="," open="(" close=")">\n   \t\t#{eid}\n   \t</foreach>\n   \t\x3c!-- 这里的foreach语句相当于生成了一个（6, 7, 8, 9）这样的格式 --\x3e  \n   </delete>\n   \n   \n   @Test\n   public void deleteMoreByArray() {\n   \tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n   \tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n   \tint result = mapper.deleteMoreByArray(new Integer[]{6, 7, 8, 9});\n   \tSystem.out.println(result);\n   }\n   \n   \n   \n   \n   这里还有另外写法, or前后会自动添加空格\n\n * 批量添加\n   \n   \x3c!--int insertMoreByList(@Param("emps") List<Emp> emps);--\x3e\n   <insert id="insertMoreByList">\n   \tinsert into t_emp values\n   \t<foreach collection="emps" item="emp" separator=",">\n   \t\t(null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null)\n   \t</foreach>\n   \t\x3c!-- foreach的open和close会在整个语句前面加上对应的起始符号和终止符合，所以这里不能加上，中间每个元素的小括号用","分割 --\x3e\n   </insert>\n   \n   \n   @Test\n   public void insertMoreByList() {\n   \tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n   \tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n   \tEmp emp1 = new Emp(null,"a",1,"男","123@321.com",null);\n   \tEmp emp2 = new Emp(null,"b",1,"男","123@321.com",null);\n   \tEmp emp3 = new Emp(null,"c",1,"男","123@321.com",null);\n   \tList<Emp> emps = Arrays.asList(emp1, emp2, emp3);\n   \tint result = mapper.insertMoreByList(emps);\n   \tSystem.out.println(result);\n   }\n   \n   \n   \n\n\n# SQL片段\n\n * sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入\n * 声明sql片段：<sql>标签\n\n<sql id="empColumns">eid,emp_name,age,sex,email</sql>\n\n\n * 引用sql片段：<include>标签\n\n\x3c!--List<Emp> getEmpByCondition(Emp emp);--\x3e\n<select id="getEmpByCondition" resultType="Emp">\n\tselect <include refid="empColumns"></include> from t_emp\n</select>\n',normalizedContent:'# 动态sql\n\n * mybatis框架的动态sql技术是一种根据特定条件动态拼装sql语句的功能，它存在的意义是为了解决拼接sql语句字符串时的痛点问题\n\n\n# if\n\n * if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行\n * 在where后面添加一个恒成立条件1=1\n   * 这个恒成立条件并不会影响查询的结果\n   * 这个1=1可以用来拼接and语句，例如：当empname为null时\n     * 如果不加上恒成立条件，则sql语句为select * from t_emp where and age = ? and sex = ? and email = ?，此时where会与and连用，sql语句会报错\n     * 如果加上一个恒成立条件，则sql语句为select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?，此时不报错\n\n\x3c!--list<emp> getempbycondition(emp emp);--\x3e\n\x3c!-- test中直接使用属性名就可以，不用写成"emp.属性名" --\x3e\n<select id="getempbycondition" resulttype="emp">\n\tselect * from t_emp where 1=1 \n\t<if test="empname != null and empname !=\'\'">\n\t\tand emp_name = #{empname}\n\t</if>\n\t<if test="age != null and age !=\'\'">\n\t\tand age = #{age}\n\t</if>\n\t<if test="sex != null and sex !=\'\'">\n\t\tand sex = #{sex}\n\t</if>\n\t<if test="email != null and email !=\'\'">\n\t\tand email = #{email}\n\t</if>\n</select>\n\n\n\n# where\n\n * where和if一般结合使用：\n   * 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字\n   * 若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉\n\n\x3c!--list<emp> getempbycondition(emp emp);--\x3e\n<select id="getempbycondition" resulttype="emp">\n\tselect * from t_emp\n\t<where>\n\t\t<if test="empname != null and empname !=\'\'">\n\t\t\temp_name = #{empname}\n\t\t</if>\n\t\t<if test="age != null and age !=\'\'">\n\t\t\tand age = #{age}\n\t\t</if>\n\t\t<if test="sex != null and sex !=\'\'">\n\t\t\tand sex = #{sex}\n\t\t</if>\n\t\t<if test="email != null and email !=\'\'">\n\t\t\tand email = #{email}\n\t\t</if>\n\t</where>\n</select>\n\n\n * 注意：where标签不能去掉条件后多余的and/or\n   \n   \x3c!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--\x3e\n   <if test="empname != null and empname !=\'\'">\n   emp_name = #{empname} and\n   </if>\n   <if test="age != null and age !=\'\'">\n   \tage = #{age}\n   </if>\n   \n\n\n# trim\n\n * trim用于去掉或添加标签中的内容\n * 常用属性\n   * prefix：在trim标签中的内容的前面添加某些内容\n   * suffix：在trim标签中的内容的后面添加某些内容\n   * prefixoverrides：在trim标签中的内容的前面去掉某些内容\n   * suffixoverrides：在trim标签中的内容的后面去掉某些内容\n * 若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下select * from t_emp\n\n\x3c!--list<emp> getempbycondition(emp emp);--\x3e\n<select id="getempbycondition" resulttype="emp">\n\tselect * from t_emp\n\t<trim prefix="where" suffixoverrides="and|or">\n\t\t<if test="empname != null and empname !=\'\'">\n\t\t\temp_name = #{empname} and\n\t\t</if>\n\t\t<if test="age != null and age !=\'\'">\n\t\t\tage = #{age} and\n\t\t</if>\n\t\t<if test="sex != null and sex !=\'\'">\n\t\t\tsex = #{sex} or\n\t\t</if>\n\t\t<if test="email != null and email !=\'\'">\n\t\t\temail = #{email}\n\t\t</if>\n\t</trim>\n</select>\n\n\n//测试类\n@test\npublic void getempbycondition() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tdynamicsqlmapper mapper = sqlsession.getmapper(dynamicsqlmapper.class);\n\tlist<emp> emps= mapper.getempbycondition(new emp(null, "张三", null, null, null, null));\n\tsystem.out.println(emps);\n}\n\n\n\n\n\n# choose、when、otherwise\n\n * choose、when、otherwise相当于if...else if..else（选择结构必然只能有一个条件进行执行，因此没有or|and 一说）\n * when至少要有一个，otherwise至多只有一个\n\n<select id="getempbychoose" resulttype="emp">\n\tselect * from t_emp\n\t<where>\n\t\t<choose>\n\t\t\t<when test="empname != null and empname != \'\'">\n\t\t\t\temp_name = #{empname}\n\t\t\t</when>\n\t\t\t<when test="age != null and age != \'\'">\n\t\t\t\tage = #{age}\n\t\t\t</when>\n\t\t\t<when test="sex != null and sex != \'\'">\n\t\t\t\tsex = #{sex}\n\t\t\t</when>\n\t\t\t<when test="email != null and email != \'\'">\n\t\t\t\temail = #{email}\n\t\t\t</when>\n\t\t\t<otherwise>\n\t\t\t\tdid = 1\n\t\t\t</otherwise>\n\t\t</choose>\n\t</where>\n</select>\n\n\n@test\npublic void getempbychoose() {\n\tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n\tdynamicsqlmapper mapper = sqlsession.getmapper(dynamicsqlmapper.class);\n\tlist<emp> emps = mapper.getempbychoose(new emp(null, "张三", 23, "男", "123@qq.com", null));\n\tsystem.out.println(emps);\n}\n\n\n\n\n * 相当于if a else if b else if c else d，只会执行其中一个\n\n\n# foreach\n\nparam到底是把括号里面的变量绑定到形参还是把形参绑定到括号里面的 的？？这里需要搞清楚，感觉像是把形参绑定到param对应变量上面，后面的程序使用param变量\n\n * 属性：\n   \n   * collection：设置要循环的数组或集合\n   * item：表示集合或数组中的每一个数据\n   * separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如,\n   * open：设置foreach标签中的内容的开始符\n   * close：设置foreach标签中的内容的结束符\n\n * 批量删除\n   \n   \x3c!--int deletemorebyarray(integer[] eids);--\x3e\n   \n   \x3c!--int deletemorebyarray(@param("eids") integer[] eids);--\x3e\n   <delete id="deletemorebyarray">\n   \tdelete from t_emp where eid in\n   \t<foreach collection="eids" item="eid" separator="," open="(" close=")">\n   \t\t#{eid}\n   \t</foreach>\n   \t\x3c!-- 这里的foreach语句相当于生成了一个（6, 7, 8, 9）这样的格式 --\x3e  \n   </delete>\n   \n   \n   @test\n   public void deletemorebyarray() {\n   \tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n   \tdynamicsqlmapper mapper = sqlsession.getmapper(dynamicsqlmapper.class);\n   \tint result = mapper.deletemorebyarray(new integer[]{6, 7, 8, 9});\n   \tsystem.out.println(result);\n   }\n   \n   \n   \n   \n   这里还有另外写法, or前后会自动添加空格\n\n * 批量添加\n   \n   \x3c!--int insertmorebylist(@param("emps") list<emp> emps);--\x3e\n   <insert id="insertmorebylist">\n   \tinsert into t_emp values\n   \t<foreach collection="emps" item="emp" separator=",">\n   \t\t(null,#{emp.empname},#{emp.age},#{emp.sex},#{emp.email},null)\n   \t</foreach>\n   \t\x3c!-- foreach的open和close会在整个语句前面加上对应的起始符号和终止符合，所以这里不能加上，中间每个元素的小括号用","分割 --\x3e\n   </insert>\n   \n   \n   @test\n   public void insertmorebylist() {\n   \tsqlsession sqlsession = sqlsessionutils.getsqlsession();\n   \tdynamicsqlmapper mapper = sqlsession.getmapper(dynamicsqlmapper.class);\n   \temp emp1 = new emp(null,"a",1,"男","123@321.com",null);\n   \temp emp2 = new emp(null,"b",1,"男","123@321.com",null);\n   \temp emp3 = new emp(null,"c",1,"男","123@321.com",null);\n   \tlist<emp> emps = arrays.aslist(emp1, emp2, emp3);\n   \tint result = mapper.insertmorebylist(emps);\n   \tsystem.out.println(result);\n   }\n   \n   \n   \n\n\n# sql片段\n\n * sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入\n * 声明sql片段：<sql>标签\n\n<sql id="empcolumns">eid,emp_name,age,sex,email</sql>\n\n\n * 引用sql片段：<include>标签\n\n\x3c!--list<emp> getempbycondition(emp emp);--\x3e\n<select id="getempbycondition" resulttype="emp">\n\tselect <include refid="empcolumns"></include> from t_emp\n</select>\n',charsets:{cjk:!0}},{title:"MyBatis的缓存",frontmatter:{title:"MyBatis的缓存",date:"2022-03-11T00:00:00.000Z",permalink:"/mybatis/006/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/06.MyBatis%E7%9A%84%E7%BC%93%E5%AD%98.html",relativePath:"07.框架/04.MyBatis/06.MyBatis的缓存.md",key:"v-78a4b30e",path:"/mybatis/006/",headers:[{level:2,title:"MyBatis的一级缓存",slug:"mybatis的一级缓存",normalizedTitle:"mybatis的一级缓存",charIndex:26},{level:2,title:"MyBatis的二级缓存",slug:"mybatis的二级缓存",normalizedTitle:"mybatis的二级缓存",charIndex:273},{level:2,title:"二级缓存的相关配置",slug:"二级缓存的相关配置",normalizedTitle:"二级缓存的相关配置",charIndex:678},{level:2,title:"MyBatis缓存查询的顺序",slug:"mybatis缓存查询的顺序",normalizedTitle:"mybatis缓存查询的顺序",charIndex:1238},{level:2,title:"整合第三方缓存EHCache（了解）",slug:"整合第三方缓存ehcache-了解",normalizedTitle:"整合第三方缓存ehcache（了解）",charIndex:1380},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:1403},{level:3,title:"各个jar包的功能",slug:"各个jar包的功能",normalizedTitle:"各个jar包的功能",charIndex:1732},{level:3,title:"创建EHCache的配置文件ehcache.xml",slug:"创建ehcache的配置文件ehcache-xml",normalizedTitle:"创建ehcache的配置文件ehcache.xml",charIndex:1901},{level:3,title:"设置二级缓存的类型",slug:"设置二级缓存的类型",normalizedTitle:"设置二级缓存的类型",charIndex:2544},{level:3,title:"加入logback日志",slug:"加入logback日志",normalizedTitle:"加入logback日志",charIndex:2646},{level:3,title:"EHCache配置文件说明",slug:"ehcache配置文件说明",normalizedTitle:"ehcache配置文件说明",charIndex:3507}],headersStr:"MyBatis的一级缓存 MyBatis的二级缓存 二级缓存的相关配置 MyBatis缓存查询的顺序 整合第三方缓存EHCache（了解） 添加依赖 各个jar包的功能 创建EHCache的配置文件ehcache.xml 设置二级缓存的类型 加入logback日志 EHCache配置文件说明",content:'# MyBatis的缓存（缓存只针对查询）\n\n\n# MyBatis的一级缓存\n\n * 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n\n * 使一级缓存失效的四种情况：\n   \n   1. 不同的SqlSession对应不同的一级缓存\n   2. 同一个SqlSession但是查询条件不同\n   3. 同一个SqlSession两次查询期间执行了任何一次增删改操作\n   4. 同一个SqlSession两次查询期间手动清空了缓存\n\n\n# MyBatis的二级缓存\n\n * 二级缓存是SqlSessionFactory（工厂）级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取\n\n * 二级缓存开启的条件\n   \n   1. 在核心配置文件中，设置全局配置属性cacheEnabled="true"，默认为true，不需要设置\n   2. 在映射文件中设置标签\n   3. 二级缓存必须在SqlSession关闭或提交之后有效(其他通过SqlSessionFactory创建的SqlSession关闭，另外一个通过该SqlSessionFactory建立的sqlsession会从缓存中访问)\n   4. 查询的数据所转换的实体类类型必须实现序列化的接口\n\n * 使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\n\n\n# 二级缓存的相关配置\n\n * 在mapper配置文件中添加的cache标签可以设置一些属性\n * eviction属性：缓存回收策略\n   * LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。\n   * FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。\n   * SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。\n   * WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。\n   * 默认的是 LRU\n * flushInterval属性：刷新间隔，单位毫秒\n   * 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新\n * size属性：引用数目，正整数\n   * 代表缓存最多可以存储多少个对象，太大容易导致内存溢出\n * readOnly属性：只读，true/false\n   * true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。\n   * false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false，因为返回的时拷贝的，所以对原始缓存不影响。\n\n\n# MyBatis缓存查询的顺序\n\n * 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用\n * 如果二级缓存没有命中，再查询一级缓存\n * 如果一级缓存也没有命中，则查询数据库\n * SqlSession关闭之后，一级缓存中的数据会写入二级缓存\n\n\n# 整合第三方缓存EHCache（了解）\n\n\n# 添加依赖\n\n\x3c!-- Mybatis EHCache整合包 --\x3e\n<dependency>\n\t<groupId>org.mybatis.caches</groupId>\n\t<artifactId>mybatis-ehcache</artifactId>\n\t<version>1.2.1</version>\n</dependency>\n\x3c!-- slf4j日志门面的一个具体实现 --\x3e\n<dependency>\n\t<groupId>ch.qos.logback</groupId>\n\t<artifactId>logback-classic</artifactId>\n\t<version>1.2.3</version>\n</dependency>\n\n\n\n# 各个jar包的功能\n\nJAR包名称            作用\nmybatis-ehcache   Mybatis和EHCache的整合包\nehcache           EHCache核心包\nslf4j-api         SLF4J日志门面包\nlogback-classic   支持SLF4J门面接口的一个具体实现\n\n\n# 创建EHCache的配置文件ehcache.xml\n\n * 名字必须叫ehcache.xml\n\n<?xml version="1.0" encoding="utf-8" ?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:noNamespaceSchemaLocation="../config/ehcache.xsd">\n    \x3c!-- 缓存磁盘保存路径 --\x3e\n    <diskStore path="D:\\atguigu\\ehcache"/>\n    <defaultCache\n            maxElementsInMemory="1000"\n            maxElementsOnDisk="10000000"\n            eternal="false"\n            overflowToDisk="true"\n            timeToIdleSeconds="120"\n            timeToLiveSeconds="120"\n            diskExpiryThreadIntervalSeconds="120"\n            memoryStoreEvictionPolicy="LRU">\n    </defaultCache>\n</ehcache>\n\n\n\n# 设置二级缓存的类型\n\n * 在xxxMapper.xml文件中设置二级缓存类型\n\n<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>\n\n\n\n# 加入logback日志\n\n * 存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件logback.xml，名字固定，不可改变\n\n<?xml version="1.0" encoding="UTF-8"?>\n<configuration debug="true">\n    \x3c!-- 指定日志输出的位置 --\x3e\n    <appender name="STDOUT"\n              class="ch.qos.logback.core.ConsoleAppender">\n        <encoder>\n            \x3c!-- 日志输出的格式 --\x3e\n            \x3c!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --\x3e\n            <pattern>[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n</pattern>\n        </encoder>\n    </appender>\n    \x3c!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --\x3e\n    \x3c!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --\x3e\n    <root level="DEBUG">\n        \x3c!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --\x3e\n        <appender-ref ref="STDOUT" />\n    </root>\n    \x3c!-- 根据特殊需求指定局部日志级别 --\x3e\n    <logger name="com.atguigu.crowd.mapper" level="DEBUG"/>\n</configuration>\n\n\n\n# EHCache配置文件说明\n\n属性名                               是否必须   作用\nmaxElementsInMemory               是      在内存中缓存的element的最大数目\nmaxElementsOnDisk                 是      在磁盘上缓存的element的最大数目，若是0表示无穷大\neternal                           是      设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效，\n                                         如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断\noverflowToDisk                    是      设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上\ntimeToIdleSeconds                 否      当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，\n                                         这些数据便会删除，默认值是0,也就是可闲置时间无穷大\ntimeToLiveSeconds                 否      缓存element的有效生命期，默认是0.,也就是element存活时间无穷大\ndiskSpoolBufferSizeMB             否      DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区\ndiskPersistent                    否      在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false\ndiskExpiryThreadIntervalSeconds   否      磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作\nmemoryStoreEvictionPolicy         否      当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。\n                                         默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出',normalizedContent:'# mybatis的缓存（缓存只针对查询）\n\n\n# mybatis的一级缓存\n\n * 一级缓存是sqlsession级别的，通过同一个sqlsession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n\n * 使一级缓存失效的四种情况：\n   \n   1. 不同的sqlsession对应不同的一级缓存\n   2. 同一个sqlsession但是查询条件不同\n   3. 同一个sqlsession两次查询期间执行了任何一次增删改操作\n   4. 同一个sqlsession两次查询期间手动清空了缓存\n\n\n# mybatis的二级缓存\n\n * 二级缓存是sqlsessionfactory（工厂）级别，通过同一个sqlsessionfactory创建的sqlsession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取\n\n * 二级缓存开启的条件\n   \n   1. 在核心配置文件中，设置全局配置属性cacheenabled="true"，默认为true，不需要设置\n   2. 在映射文件中设置标签\n   3. 二级缓存必须在sqlsession关闭或提交之后有效(其他通过sqlsessionfactory创建的sqlsession关闭，另外一个通过该sqlsessionfactory建立的sqlsession会从缓存中访问)\n   4. 查询的数据所转换的实体类类型必须实现序列化的接口\n\n * 使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\n\n\n# 二级缓存的相关配置\n\n * 在mapper配置文件中添加的cache标签可以设置一些属性\n * eviction属性：缓存回收策略\n   * lru（least recently used） – 最近最少使用的：移除最长时间不被使用的对象。\n   * fifo（first in first out） – 先进先出：按对象进入缓存的顺序来移除它们。\n   * soft – 软引用：移除基于垃圾回收器状态和软引用规则的对象。\n   * weak – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。\n   * 默认的是 lru\n * flushinterval属性：刷新间隔，单位毫秒\n   * 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新\n * size属性：引用数目，正整数\n   * 代表缓存最多可以存储多少个对象，太大容易导致内存溢出\n * readonly属性：只读，true/false\n   * true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。\n   * false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false，因为返回的时拷贝的，所以对原始缓存不影响。\n\n\n# mybatis缓存查询的顺序\n\n * 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用\n * 如果二级缓存没有命中，再查询一级缓存\n * 如果一级缓存也没有命中，则查询数据库\n * sqlsession关闭之后，一级缓存中的数据会写入二级缓存\n\n\n# 整合第三方缓存ehcache（了解）\n\n\n# 添加依赖\n\n\x3c!-- mybatis ehcache整合包 --\x3e\n<dependency>\n\t<groupid>org.mybatis.caches</groupid>\n\t<artifactid>mybatis-ehcache</artifactid>\n\t<version>1.2.1</version>\n</dependency>\n\x3c!-- slf4j日志门面的一个具体实现 --\x3e\n<dependency>\n\t<groupid>ch.qos.logback</groupid>\n\t<artifactid>logback-classic</artifactid>\n\t<version>1.2.3</version>\n</dependency>\n\n\n\n# 各个jar包的功能\n\njar包名称            作用\nmybatis-ehcache   mybatis和ehcache的整合包\nehcache           ehcache核心包\nslf4j-api         slf4j日志门面包\nlogback-classic   支持slf4j门面接口的一个具体实现\n\n\n# 创建ehcache的配置文件ehcache.xml\n\n * 名字必须叫ehcache.xml\n\n<?xml version="1.0" encoding="utf-8" ?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:nonamespaceschemalocation="../config/ehcache.xsd">\n    \x3c!-- 缓存磁盘保存路径 --\x3e\n    <diskstore path="d:\\atguigu\\ehcache"/>\n    <defaultcache\n            maxelementsinmemory="1000"\n            maxelementsondisk="10000000"\n            eternal="false"\n            overflowtodisk="true"\n            timetoidleseconds="120"\n            timetoliveseconds="120"\n            diskexpirythreadintervalseconds="120"\n            memorystoreevictionpolicy="lru">\n    </defaultcache>\n</ehcache>\n\n\n\n# 设置二级缓存的类型\n\n * 在xxxmapper.xml文件中设置二级缓存类型\n\n<cache type="org.mybatis.caches.ehcache.ehcachecache"/>\n\n\n\n# 加入logback日志\n\n * 存在slf4j时，作为简易日志的log4j将失效，此时我们需要借助slf4j的具体实现logback来打印日志。创建logback的配置文件logback.xml，名字固定，不可改变\n\n<?xml version="1.0" encoding="utf-8"?>\n<configuration debug="true">\n    \x3c!-- 指定日志输出的位置 --\x3e\n    <appender name="stdout"\n              class="ch.qos.logback.core.consoleappender">\n        <encoder>\n            \x3c!-- 日志输出的格式 --\x3e\n            \x3c!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --\x3e\n            <pattern>[%d{hh:mm:ss.sss}] [%-5level] [%thread] [%logger] [%msg]%n</pattern>\n        </encoder>\n    </appender>\n    \x3c!-- 设置全局日志级别。日志级别按顺序分别是：debug、info、warn、error --\x3e\n    \x3c!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --\x3e\n    <root level="debug">\n        \x3c!-- 指定打印日志的appender，这里通过“stdout”引用了前面配置的appender --\x3e\n        <appender-ref ref="stdout" />\n    </root>\n    \x3c!-- 根据特殊需求指定局部日志级别 --\x3e\n    <logger name="com.atguigu.crowd.mapper" level="debug"/>\n</configuration>\n\n\n\n# ehcache配置文件说明\n\n属性名                               是否必须   作用\nmaxelementsinmemory               是      在内存中缓存的element的最大数目\nmaxelementsondisk                 是      在磁盘上缓存的element的最大数目，若是0表示无穷大\neternal                           是      设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效，\n                                         如果为false那么还要根据timetoidleseconds、timetoliveseconds判断\noverflowtodisk                    是      设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上\ntimetoidleseconds                 否      当缓存在ehcache中的数据前后两次访问的时间超过timetoidleseconds的属性取值时，\n                                         这些数据便会删除，默认值是0,也就是可闲置时间无穷大\ntimetoliveseconds                 否      缓存element的有效生命期，默认是0.,也就是element存活时间无穷大\ndiskspoolbuffersizemb             否      diskstore(磁盘缓存)的缓存区大小。默认是30mb。每个cache都应该有自己的一个缓冲区\ndiskpersistent                    否      在vm重启的时候是否启用磁盘保存ehcache中的数据，默认是false\ndiskexpirythreadintervalseconds   否      磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次ehcache中数据的清理工作\nmemorystoreevictionpolicy         否      当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。\n                                         默认是lru（最近最少使用），可选的有lfu（最不常使用）和fifo（先进先出',charsets:{cjk:!0}},{title:"MyBatis的逆向工程",frontmatter:{title:"MyBatis的逆向工程",date:"2022-03-15T00:00:00.000Z",permalink:"/mybatis/007/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/07.MyBatis%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B.html",relativePath:"07.框架/04.MyBatis/07.MyBatis的逆向工程.md",key:"v-7af8ffe3",path:"/mybatis/007/",headers:[{level:2,title:"创建逆向工程的步骤",slug:"创建逆向工程的步骤",normalizedTitle:"创建逆向工程的步骤",charIndex:155},{level:3,title:"添加依赖和插件",slug:"添加依赖和插件",normalizedTitle:"添加依赖和插件",charIndex:169},{level:3,title:"创建MyBatis的核心配置文件",slug:"创建mybatis的核心配置文件",normalizedTitle:"创建mybatis的核心配置文件",charIndex:1649},{level:3,title:"创建逆向工程的配置文件（重新生成配置文件最好把之前的删除，防止因为文件内容追加造成错误）",slug:"创建逆向工程的配置文件-重新生成配置文件最好把之前的删除-防止因为文件内容追加造成错误",normalizedTitle:"创建逆向工程的配置文件（重新生成配置文件最好把之前的删除，防止因为文件内容追加造成错误）",charIndex:2537},{level:3,title:"执行MBG插件的generate目标",slug:"执行mbg插件的generate目标",normalizedTitle:"执行mbg插件的generate目标",charIndex:4581},{level:2,title:"QBC",slug:"qbc",normalizedTitle:"qbc",charIndex:4758},{level:3,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:4466},{level:3,title:"增改",slug:"增改",normalizedTitle:"增改",charIndex:5642}],headersStr:"创建逆向工程的步骤 添加依赖和插件 创建MyBatis的核心配置文件 创建逆向工程的配置文件（重新生成配置文件最好把之前的删除，防止因为文件内容追加造成错误） 执行MBG插件的generate目标 QBC 查询 增改",content:'# MyBatis的逆向工程\n\n * 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的\n * 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：\n   * Java实体类\n   * Mapper接口\n   * Mapper映射文件\n\n\n# 创建逆向工程的步骤\n\n\n# 添加依赖和插件\n\n<dependencies>\n\t\x3c!-- MyBatis核心依赖包 --\x3e\n\t<dependency>\n\t\t<groupId>org.mybatis</groupId>\n\t\t<artifactId>mybatis</artifactId>\n\t\t<version>3.5.9</version>\n\t</dependency>\n\t\x3c!-- junit测试 --\x3e\n\t<dependency>\n\t\t<groupId>junit</groupId>\n\t\t<artifactId>junit</artifactId>\n\t\t<version>4.13.2</version>\n\t\t<scope>test</scope>\n\t</dependency>\n\t\x3c!-- MySQL驱动 --\x3e\n\t<dependency>\n\t\t<groupId>mysql</groupId>\n\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t<version>8.0.27</version>\n\t</dependency>\n\t\x3c!-- log4j日志 --\x3e\n\t<dependency>\n\t\t<groupId>log4j</groupId>\n\t\t<artifactId>log4j</artifactId>\n\t\t<version>1.2.17</version>\n\t</dependency>\n</dependencies>\n\x3c!-- 控制Maven在构建过程中相关配置 --\x3e\n<build>\n\t\x3c!-- 构建过程中用到的插件 --\x3e\n\t<plugins>\n\t\t\x3c!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --\x3e\n\t\t<plugin>\n\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t<artifactId>mybatis-generator-maven-plugin</artifactId>\n\t\t\t<version>1.3.0</version>\n\t\t\t\x3c!-- 插件的依赖 --\x3e\n\t\t\t<dependencies>\n\t\t\t\t\x3c!-- 逆向工程的核心依赖 --\x3e\n\t\t\t\t<dependency>\n\t\t\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t\t\t<artifactId>mybatis-generator-core</artifactId>\n\t\t\t\t\t<version>1.3.2</version>\n\t\t\t\t</dependency>\n\t\t\t\t\x3c!-- 数据库连接池 --\x3e\n\t\t\t\t<dependency>\n\t\t\t\t\t<groupId>com.mchange</groupId>\n\t\t\t\t\t<artifactId>c3p0</artifactId>\n\t\t\t\t\t<version>0.9.2</version>\n\t\t\t\t</dependency>\n\t\t\t\t\x3c!-- MySQL驱动 --\x3e\n\t\t\t\t<dependency>\n\t\t\t\t\t<groupId>mysql</groupId>\n\t\t\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t\t\t<version>8.0.27</version>\n\t\t\t\t</dependency>\n\t\t\t</dependencies>\n\t\t</plugin>\n\t</plugins>\n</build>\n\n\n\n# 创建MyBatis的核心配置文件\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <properties resource="jdbc.properties"/>\n    <typeAliases>\n        <package name=""/>\n    </typeAliases>\n    <environments default="development">\n        <environment id="development">\n            <transactionManager type="JDBC"/>\n            <dataSource type="POOLED">\n                <property name="driver" value="${jdbc.driver}"/>\n                <property name="url" value="${jdbc.url}"/>\n                <property name="username" value="${jdbc.username}"/>\n                <property name="password" value="${jdbc.password}"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <package name=""/>\n    </mappers>\n</configuration>\n\n\n\n# 创建逆向工程的配置文件（重新生成配置文件最好把之前的删除，防止因为文件内容追加造成错误）\n\n * 文件名必须是：generatorConfig.xml\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorConfiguration>\n    \x3c!--\n    targetRuntime: 执行生成的逆向工程的版本\n    MyBatis3Simple: 生成基本的CRUD（清新简洁版）\n    MyBatis3（用的最多）: 生成带条件的CRUD（奢华尊享版）他比MyBatis3Simple生成的文件信息更加丰富\n    --\x3e\n    <context id="DB2Tables" targetRuntime="MyBatis3Simple">\n        \x3c!-- 数据库的连接信息 --\x3e\n        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"\n                        connectionURL="jdbc:mysql://localhost:3306/mybatis"\n                        userId="root"\n                        password="123456">\n        </jdbcConnection>\n        \x3c!-- javaBean（实体类）的生成策略--\x3e\n        <javaModelGenerator targetPackage="com.atguigu.mybatis.pojo" targetProject=".\\src\\main\\java">\n            <property name="enableSubPackages" value="true" />\n            <property name="trimStrings" value="true" />\n        </javaModelGenerator>\n        \x3c!-- SQL映射文件的生成策略 --\x3e\n        <sqlMapGenerator targetPackage="com.atguigu.mybatis.mapper"\n                         targetProject=".\\src\\main\\resources">\n            <property name="enableSubPackages" value="true" />\n        </sqlMapGenerator>\n        \x3c!-- Mapper接口的生成策略 --\x3e\n        <javaClientGenerator type="XMLMAPPER"\n                             targetPackage="com.atguigu.mybatis.mapper" targetProject=".\\src\\main\\java">\n            <property name="enableSubPackages" value="true" />\n        </javaClientGenerator>\n        \x3c!-- 逆向分析的表 --\x3e\n        \x3c!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --\x3e\n        \x3c!-- domainObjectName属性指定生成出来的实体类的类名 --\x3e\n        <table tableName="t_emp" domainObjectName="Emp"/>\n        <table tableName="t_dept" domainObjectName="Dept"/>\n    </context>\n</generatorConfiguration>\n\n\n奢华版的信息更加详细，实现的方法更多，查询更方便（能够以任意条件，任意需求进行增删改查）\n\n这里注意的区别是 updateByprimaryKey会根据主键把对应的每一个key进行修改 updateByprimaryKeySelective只会修改不为空的值\n\n\n# 执行MBG插件的generate目标\n\n * \n * 如果出现报错：Exception getting JDBC Driver，可能是pom.xml中，数据库驱动配置错误\n   * dependency中的驱动\n   * mybatis-generator-maven-plugin插件中的驱动\n   * 两者的驱动版本应该相同\n * 执行结果\n\n\n# QBC\n\n\n# 查询\n\n * selectByExample：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据\n * example.createCriteria().xxx：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系\n * example.or().xxx：将之前添加的条件通过or拼接其他条件\n\n@Test public void testMBG() throws IOException {\n\tInputStream is = Resources.getResourceAsStream("mybatis-config.xml");\n\tSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n\tSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n\tSqlSession sqlSession = sqlSessionFactory.openSession(true);\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\tEmpExample example = new EmpExample();\n\t//名字为张三，且年龄大于等于20\n\texample.createCriteria().andEmpNameEqualTo("张三").andAgeGreaterThanOrEqualTo(20);\n\t//或者did不为空\n\texample.or().andDidIsNotNull();\n\tList<Emp> emps = mapper.selectByExample(example);\n\temps.forEach(System.out::println);\n}\n\n\n\n\n\n# 增改\n\n * updateByPrimaryKey：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null\n   * mapper.updateByPrimaryKey(new Emp(1,"admin",22,null,"456@qq.com",3));\n   * \n * updateByPrimaryKeySelective()：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段\n   * mapper.updateByPrimaryKeySelective(new Emp(2,"admin2",22,null,"456@qq.com",3));\n   * ',normalizedContent:'# mybatis的逆向工程\n\n * 正向工程：先创建java实体类，由框架负责根据实体类生成数据库表。hibernate是支持正向工程的\n * 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：\n   * java实体类\n   * mapper接口\n   * mapper映射文件\n\n\n# 创建逆向工程的步骤\n\n\n# 添加依赖和插件\n\n<dependencies>\n\t\x3c!-- mybatis核心依赖包 --\x3e\n\t<dependency>\n\t\t<groupid>org.mybatis</groupid>\n\t\t<artifactid>mybatis</artifactid>\n\t\t<version>3.5.9</version>\n\t</dependency>\n\t\x3c!-- junit测试 --\x3e\n\t<dependency>\n\t\t<groupid>junit</groupid>\n\t\t<artifactid>junit</artifactid>\n\t\t<version>4.13.2</version>\n\t\t<scope>test</scope>\n\t</dependency>\n\t\x3c!-- mysql驱动 --\x3e\n\t<dependency>\n\t\t<groupid>mysql</groupid>\n\t\t<artifactid>mysql-connector-java</artifactid>\n\t\t<version>8.0.27</version>\n\t</dependency>\n\t\x3c!-- log4j日志 --\x3e\n\t<dependency>\n\t\t<groupid>log4j</groupid>\n\t\t<artifactid>log4j</artifactid>\n\t\t<version>1.2.17</version>\n\t</dependency>\n</dependencies>\n\x3c!-- 控制maven在构建过程中相关配置 --\x3e\n<build>\n\t\x3c!-- 构建过程中用到的插件 --\x3e\n\t<plugins>\n\t\t\x3c!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --\x3e\n\t\t<plugin>\n\t\t\t<groupid>org.mybatis.generator</groupid>\n\t\t\t<artifactid>mybatis-generator-maven-plugin</artifactid>\n\t\t\t<version>1.3.0</version>\n\t\t\t\x3c!-- 插件的依赖 --\x3e\n\t\t\t<dependencies>\n\t\t\t\t\x3c!-- 逆向工程的核心依赖 --\x3e\n\t\t\t\t<dependency>\n\t\t\t\t\t<groupid>org.mybatis.generator</groupid>\n\t\t\t\t\t<artifactid>mybatis-generator-core</artifactid>\n\t\t\t\t\t<version>1.3.2</version>\n\t\t\t\t</dependency>\n\t\t\t\t\x3c!-- 数据库连接池 --\x3e\n\t\t\t\t<dependency>\n\t\t\t\t\t<groupid>com.mchange</groupid>\n\t\t\t\t\t<artifactid>c3p0</artifactid>\n\t\t\t\t\t<version>0.9.2</version>\n\t\t\t\t</dependency>\n\t\t\t\t\x3c!-- mysql驱动 --\x3e\n\t\t\t\t<dependency>\n\t\t\t\t\t<groupid>mysql</groupid>\n\t\t\t\t\t<artifactid>mysql-connector-java</artifactid>\n\t\t\t\t\t<version>8.0.27</version>\n\t\t\t\t</dependency>\n\t\t\t</dependencies>\n\t\t</plugin>\n\t</plugins>\n</build>\n\n\n\n# 创建mybatis的核心配置文件\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    <properties resource="jdbc.properties"/>\n    <typealiases>\n        <package name=""/>\n    </typealiases>\n    <environments default="development">\n        <environment id="development">\n            <transactionmanager type="jdbc"/>\n            <datasource type="pooled">\n                <property name="driver" value="${jdbc.driver}"/>\n                <property name="url" value="${jdbc.url}"/>\n                <property name="username" value="${jdbc.username}"/>\n                <property name="password" value="${jdbc.password}"/>\n            </datasource>\n        </environment>\n    </environments>\n    <mappers>\n        <package name=""/>\n    </mappers>\n</configuration>\n\n\n\n# 创建逆向工程的配置文件（重新生成配置文件最好把之前的删除，防止因为文件内容追加造成错误）\n\n * 文件名必须是：generatorconfig.xml\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype generatorconfiguration\n        public "-//mybatis.org//dtd mybatis generator configuration 1.0//en"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n<generatorconfiguration>\n    \x3c!--\n    targetruntime: 执行生成的逆向工程的版本\n    mybatis3simple: 生成基本的crud（清新简洁版）\n    mybatis3（用的最多）: 生成带条件的crud（奢华尊享版）他比mybatis3simple生成的文件信息更加丰富\n    --\x3e\n    <context id="db2tables" targetruntime="mybatis3simple">\n        \x3c!-- 数据库的连接信息 --\x3e\n        <jdbcconnection driverclass="com.mysql.cj.jdbc.driver"\n                        connectionurl="jdbc:mysql://localhost:3306/mybatis"\n                        userid="root"\n                        password="123456">\n        </jdbcconnection>\n        \x3c!-- javabean（实体类）的生成策略--\x3e\n        <javamodelgenerator targetpackage="com.atguigu.mybatis.pojo" targetproject=".\\src\\main\\java">\n            <property name="enablesubpackages" value="true" />\n            <property name="trimstrings" value="true" />\n        </javamodelgenerator>\n        \x3c!-- sql映射文件的生成策略 --\x3e\n        <sqlmapgenerator targetpackage="com.atguigu.mybatis.mapper"\n                         targetproject=".\\src\\main\\resources">\n            <property name="enablesubpackages" value="true" />\n        </sqlmapgenerator>\n        \x3c!-- mapper接口的生成策略 --\x3e\n        <javaclientgenerator type="xmlmapper"\n                             targetpackage="com.atguigu.mybatis.mapper" targetproject=".\\src\\main\\java">\n            <property name="enablesubpackages" value="true" />\n        </javaclientgenerator>\n        \x3c!-- 逆向分析的表 --\x3e\n        \x3c!-- tablename设置为*号，可以对应所有表，此时不写domainobjectname --\x3e\n        \x3c!-- domainobjectname属性指定生成出来的实体类的类名 --\x3e\n        <table tablename="t_emp" domainobjectname="emp"/>\n        <table tablename="t_dept" domainobjectname="dept"/>\n    </context>\n</generatorconfiguration>\n\n\n奢华版的信息更加详细，实现的方法更多，查询更方便（能够以任意条件，任意需求进行增删改查）\n\n这里注意的区别是 updatebyprimarykey会根据主键把对应的每一个key进行修改 updatebyprimarykeyselective只会修改不为空的值\n\n\n# 执行mbg插件的generate目标\n\n * \n * 如果出现报错：exception getting jdbc driver，可能是pom.xml中，数据库驱动配置错误\n   * dependency中的驱动\n   * mybatis-generator-maven-plugin插件中的驱动\n   * 两者的驱动版本应该相同\n * 执行结果\n\n\n# qbc\n\n\n# 查询\n\n * selectbyexample：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据\n * example.createcriteria().xxx：创建条件对象，通过andxxx方法为sql添加查询添加，每个条件之间是and关系\n * example.or().xxx：将之前添加的条件通过or拼接其他条件\n\n@test public void testmbg() throws ioexception {\n\tinputstream is = resources.getresourceasstream("mybatis-config.xml");\n\tsqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder();\n\tsqlsessionfactory sqlsessionfactory = sqlsessionfactorybuilder.build(is);\n\tsqlsession sqlsession = sqlsessionfactory.opensession(true);\n\tempmapper mapper = sqlsession.getmapper(empmapper.class);\n\tempexample example = new empexample();\n\t//名字为张三，且年龄大于等于20\n\texample.createcriteria().andempnameequalto("张三").andagegreaterthanorequalto(20);\n\t//或者did不为空\n\texample.or().anddidisnotnull();\n\tlist<emp> emps = mapper.selectbyexample(example);\n\temps.foreach(system.out::println);\n}\n\n\n\n\n\n# 增改\n\n * updatebyprimarykey：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null\n   * mapper.updatebyprimarykey(new emp(1,"admin",22,null,"456@qq.com",3));\n   * \n * updatebyprimarykeyselective()：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段\n   * mapper.updatebyprimarykeyselective(new emp(2,"admin2",22,null,"456@qq.com",3));\n   * ',charsets:{cjk:!0}},{title:"分页插件",frontmatter:{title:"分页插件",date:"2022-03-20T00:00:00.000Z",permalink:"/mybatis/008/",categories:["框架","MyBatis"],tags:["MyBatis"],author:null},regularPath:"/07.%E6%A1%86%E6%9E%B6/04.MyBatis/08.%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6.html",relativePath:"07.框架/04.MyBatis/08.分页插件.md",key:"v-2451e369",path:"/mybatis/008/",headers:[{level:2,title:"分页插件使用步骤",slug:"分页插件使用步骤",normalizedTitle:"分页插件使用步骤",charIndex:11},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:24},{level:3,title:"配置分页插件",slug:"配置分页插件",normalizedTitle:"配置分页插件",charIndex:244},{level:2,title:"分页插件的使用",slug:"分页插件的使用",normalizedTitle:"分页插件的使用",charIndex:415},{level:3,title:"开启分页功能",slug:"开启分页功能",normalizedTitle:"开启分页功能",charIndex:427},{level:3,title:"分页相关数据",slug:"分页相关数据",normalizedTitle:"分页相关数据",charIndex:1091},{level:4,title:"方法一：直接输出",slug:"方法一-直接输出",normalizedTitle:"方法一：直接输出",charIndex:1101},{level:4,title:"方法二使用PageInfo",slug:"方法二使用pageinfo",normalizedTitle:"方法二使用pageinfo",charIndex:2129},{level:4,title:"常用数据：",slug:"常用数据",normalizedTitle:"常用数据：",charIndex:3641}],headersStr:"分页插件使用步骤 添加依赖 配置分页插件 分页插件的使用 开启分页功能 分页相关数据 方法一：直接输出 方法二使用PageInfo 常用数据：",content:"# 分页插件\n\n\n# 分页插件使用步骤\n\n\n# 添加依赖\n\n\x3c!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --\x3e\n<dependency>\n\t<groupId>com.github.pagehelper</groupId>\n\t<artifactId>pagehelper</artifactId>\n\t<version>5.2.0</version>\n</dependency>\n\n\n\n# 配置分页插件\n\n * 在MyBatis的核心配置文件（mybatis-config.xml）中配置插件\n * \n\n<plugins>\n\t\x3c!--设置分页插件--\x3e\n\t<plugin interceptor=\"com.github.pagehelper.PageInterceptor\"></plugin>\n</plugins>\n\n\n\n\n\n# 分页插件的使用\n\n\n# 开启分页功能\n\n * 在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能\n   * pageNum：当前页的页码\n   * pageSize：每页显示的条数\n\n\n\n@Test\npublic void testPageHelper() throws IOException {\n\tInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\tSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n\tSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n\tSqlSession sqlSession = sqlSessionFactory.openSession(true);\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\t//访问第一页，每页四条数据\n\tPageHelper.startPage(1,4);\n\tList<Emp> emps = mapper.selectByExample(null);\n\temps.forEach(System.out::println);\n}\n\n\n\n\n\n# 分页相关数据\n\n# 方法一：直接输出\n\n@Test\npublic void testPageHelper() throws IOException {\n\tInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\tSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n\tSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n\tSqlSession sqlSession = sqlSessionFactory.openSession(true);\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\t//访问第一页，每页四条数据\n\tPage<Object> page = PageHelper.startPage(1, 4);\n\tList<Emp> emps = mapper.selectByExample(null);\n\t//在查询到List集合后，打印分页数据\n\tSystem.out.println(page);\n}\n\n\n * 分页相关数据（一个page对象中的信息）：\n   \n   Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName='admin', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=2, empName='admin2', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=3, empName='王五', age=12, sex='女', email='123@qq.com', did=3}, Emp{eid=4, empName='赵六', age=32, sex='男', email='123@qq.com', did=1}]\n   \n\n# 方法二使用PageInfo\n\n * 在查询获取list集合之后，使用PageInfo<T> pageInfo = new PageInfo<>(List<T> list, intnavigatePages)获取分页相关数据\n   * list：分页之后的数据\n   * navigatePages：导航分页的页码数\n\n@Test\npublic void testPageHelper() throws IOException {\n\tInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\tSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n\tSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n\tSqlSession sqlSession = sqlSessionFactory.openSession(true);\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\tPageHelper.startPage(1, 4);\n\tList<Emp> emps = mapper.selectByExample(null);\n\tPageInfo<Emp> page = new PageInfo<>(emps,5);  // 5表示五个导航分页，即（1、2、3、4、5）或者（3、4、5、6、7），一般都为奇数\n\tSystem.out.println(page);\n}\n\n\n * 分页相关数据：\n   \n   PageInfo{\n   pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, \n   list=Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName='admin', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=2, empName='admin2', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=3, empName='王五', age=12, sex='女', email='123@qq.com', did=3}, Emp{eid=4, empName='赵六', age=32, sex='男', email='123@qq.com', did=1}], \n   prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}\n   \n\n * 其中list中的数据等同于方法一中直接输出的page数据\n\n# 常用数据：\n\n * pageNum：当前页的页码\n * pageSize：每页显示的条数\n * size：当前页显示的真实条数\n * total：总记录数\n * pages：总页数\n * prePage：上一页的页码\n * nextPage：下一页的页码\n * isFirstPage/isLastPage：是否为第一页/最后一页\n * hasPreviousPage/hasNextPage：是否存在上一页/下一页\n * navigatePages：导航分页的页码数\n * navigatepageNums：导航分页的页码，[1,2,3,4,5]",normalizedContent:"# 分页插件\n\n\n# 分页插件使用步骤\n\n\n# 添加依赖\n\n\x3c!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --\x3e\n<dependency>\n\t<groupid>com.github.pagehelper</groupid>\n\t<artifactid>pagehelper</artifactid>\n\t<version>5.2.0</version>\n</dependency>\n\n\n\n# 配置分页插件\n\n * 在mybatis的核心配置文件（mybatis-config.xml）中配置插件\n * \n\n<plugins>\n\t\x3c!--设置分页插件--\x3e\n\t<plugin interceptor=\"com.github.pagehelper.pageinterceptor\"></plugin>\n</plugins>\n\n\n\n\n\n# 分页插件的使用\n\n\n# 开启分页功能\n\n * 在查询功能之前使用pagehelper.startpage(int pagenum, int pagesize)开启分页功能\n   * pagenum：当前页的页码\n   * pagesize：每页显示的条数\n\n\n\n@test\npublic void testpagehelper() throws ioexception {\n\tinputstream is = resources.getresourceasstream(\"mybatis-config.xml\");\n\tsqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder();\n\tsqlsessionfactory sqlsessionfactory = sqlsessionfactorybuilder.build(is);\n\tsqlsession sqlsession = sqlsessionfactory.opensession(true);\n\tempmapper mapper = sqlsession.getmapper(empmapper.class);\n\t//访问第一页，每页四条数据\n\tpagehelper.startpage(1,4);\n\tlist<emp> emps = mapper.selectbyexample(null);\n\temps.foreach(system.out::println);\n}\n\n\n\n\n\n# 分页相关数据\n\n# 方法一：直接输出\n\n@test\npublic void testpagehelper() throws ioexception {\n\tinputstream is = resources.getresourceasstream(\"mybatis-config.xml\");\n\tsqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder();\n\tsqlsessionfactory sqlsessionfactory = sqlsessionfactorybuilder.build(is);\n\tsqlsession sqlsession = sqlsessionfactory.opensession(true);\n\tempmapper mapper = sqlsession.getmapper(empmapper.class);\n\t//访问第一页，每页四条数据\n\tpage<object> page = pagehelper.startpage(1, 4);\n\tlist<emp> emps = mapper.selectbyexample(null);\n\t//在查询到list集合后，打印分页数据\n\tsystem.out.println(page);\n}\n\n\n * 分页相关数据（一个page对象中的信息）：\n   \n   page{count=true, pagenum=1, pagesize=4, startrow=0, endrow=4, total=8, pages=2, reasonable=false, pagesizezero=false}[emp{eid=1, empname='admin', age=22, sex='男', email='456@qq.com', did=3}, emp{eid=2, empname='admin2', age=22, sex='男', email='456@qq.com', did=3}, emp{eid=3, empname='王五', age=12, sex='女', email='123@qq.com', did=3}, emp{eid=4, empname='赵六', age=32, sex='男', email='123@qq.com', did=1}]\n   \n\n# 方法二使用pageinfo\n\n * 在查询获取list集合之后，使用pageinfo<t> pageinfo = new pageinfo<>(list<t> list, intnavigatepages)获取分页相关数据\n   * list：分页之后的数据\n   * navigatepages：导航分页的页码数\n\n@test\npublic void testpagehelper() throws ioexception {\n\tinputstream is = resources.getresourceasstream(\"mybatis-config.xml\");\n\tsqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder();\n\tsqlsessionfactory sqlsessionfactory = sqlsessionfactorybuilder.build(is);\n\tsqlsession sqlsession = sqlsessionfactory.opensession(true);\n\tempmapper mapper = sqlsession.getmapper(empmapper.class);\n\tpagehelper.startpage(1, 4);\n\tlist<emp> emps = mapper.selectbyexample(null);\n\tpageinfo<emp> page = new pageinfo<>(emps,5);  // 5表示五个导航分页，即（1、2、3、4、5）或者（3、4、5、6、7），一般都为奇数\n\tsystem.out.println(page);\n}\n\n\n * 分页相关数据：\n   \n   pageinfo{\n   pagenum=1, pagesize=4, size=4, startrow=1, endrow=4, total=8, pages=2, \n   list=page{count=true, pagenum=1, pagesize=4, startrow=0, endrow=4, total=8, pages=2, reasonable=false, pagesizezero=false}[emp{eid=1, empname='admin', age=22, sex='男', email='456@qq.com', did=3}, emp{eid=2, empname='admin2', age=22, sex='男', email='456@qq.com', did=3}, emp{eid=3, empname='王五', age=12, sex='女', email='123@qq.com', did=3}, emp{eid=4, empname='赵六', age=32, sex='男', email='123@qq.com', did=1}], \n   prepage=0, nextpage=2, isfirstpage=true, islastpage=false, haspreviouspage=false, hasnextpage=true, navigatepages=5, navigatefirstpage=1, navigatelastpage=2, navigatepagenums=[1, 2]}\n   \n\n * 其中list中的数据等同于方法一中直接输出的page数据\n\n# 常用数据：\n\n * pagenum：当前页的页码\n * pagesize：每页显示的条数\n * size：当前页显示的真实条数\n * total：总记录数\n * pages：总页数\n * prepage：上一页的页码\n * nextpage：下一页的页码\n * isfirstpage/islastpage：是否为第一页/最后一页\n * haspreviouspage/hasnextpage：是否存在上一页/下一页\n * navigatepages：导航分页的页码数\n * navigatepagenums：导航分页的页码，[1,2,3,4,5]",charsets:{cjk:!0}},{title:"简介",frontmatter:{title:"简介",date:"2021-07-31T00:00:00.000Z",permalink:"/mybatis-plus/001/",categories:["框架","MyBatis-Plus"],tags:["MyBatis-Plus"]},regularPath:"/07.%E6%A1%86%E6%9E%B6/05.MyBatis-Plus/01.%E7%AE%80%E4%BB%8B.html",relativePath:"07.框架/05.MyBatis-Plus/01.简介.md",key:"v-57d76a9a",path:"/mybatis-plus/001/",headers:[{level:2,title:"1 、简介",slug:"_1-、简介",normalizedTitle:"1 、简介",charIndex:23},{level:2,title:"2、特性",slug:"_2、特性",normalizedTitle:"2、特性",charIndex:144},{level:2,title:"3、支持数据库",slug:"_3、支持数据库",normalizedTitle:"3、支持数据库",charIndex:851},{level:2,title:"4、框架结构",slug:"_4、框架结构",normalizedTitle:"4、框架结构",charIndex:1086},{level:2,title:"5 、代码及文档地址",slug:"_5-、代码及文档地址",normalizedTitle:"5 、代码及文档地址",charIndex:1097}],headersStr:"1 、简介 2、特性 3、支持数据库 4、框架结构 5 、代码及文档地址",content:"# 一、MyBatis-Plus简介\n\n\n# 1 、简介\n\nMyBatis-Plus（简称MP）是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。愿景是成为MyBatis最好的搭档，就像魂斗罗中的1P、2P，基友搭配，效率翻倍。\n\n\n# 2、特性\n\n * 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n * 损耗小：启动即会自动注入基本CURD，性能基本无损耗，直接面向对象操作\n * 强大的CRUD操作：内置通用Mapper、通用Service，仅仅通过少量配置即可实现单表大部分CRUD操作，更有强大的条件构造器，满足各类使用需求\n * 支持Lambda形式调用：通过Lambda表达式，方便的编写各类查询条件，无需再担心字段写错\n * 支持主键自动生成：支持多达4种主键策略（内含分布式唯一ID生成器-Sequence），可自由配置，完美解决主键问题\n * 支持ActiveRecord模式：支持ActiveRecord形式调用，实体类只需继承Model类即可进行强大的CRUD操作 -支持自定义全局通用操作：支持全局通用方法注入（Write once,use anywhere），内置代码生成器：采用代码或者Maven插件可快速生成Mapper、Model、Service、Controller层代码，支持模板引擎，更有超多自定义配置等您来使用\n * 内置分页插件：基于MyBatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询。分页插件支持多种数据库：支持MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer等多种数据库内置性能分析插件：可输出SQL语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询：内置全局拦截插件：提供全表delete、update操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n\n# 3、支持数据库\n\n任何能使用MyBatis进行CRUD,并且支持标准SQL的数据库，具体支持情况如下：MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库\n\n\n# 4、框架结构\n\n\n# 5 、代码及文档地址\n\n * 官方地址: http://mp.baomidou.com\n * 代码发布地址:\n   * Github: https://github.com/baomidou/mybatis-plus\n   * Gitee: https://gitee.com/baomidou/mybatis-plus\n   * 文档发布地址: https://baomidou.com/pages/24112f",normalizedContent:"# 一、mybatis-plus简介\n\n\n# 1 、简介\n\nmybatis-plus（简称mp）是一个mybatis的增强工具，在mybatis的基础上只做增强不做改变，为简化开发、提高效率而生。愿景是成为mybatis最好的搭档，就像魂斗罗中的1p、2p，基友搭配，效率翻倍。\n\n\n# 2、特性\n\n * 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n * 损耗小：启动即会自动注入基本curd，性能基本无损耗，直接面向对象操作\n * 强大的crud操作：内置通用mapper、通用service，仅仅通过少量配置即可实现单表大部分crud操作，更有强大的条件构造器，满足各类使用需求\n * 支持lambda形式调用：通过lambda表达式，方便的编写各类查询条件，无需再担心字段写错\n * 支持主键自动生成：支持多达4种主键策略（内含分布式唯一id生成器-sequence），可自由配置，完美解决主键问题\n * 支持activerecord模式：支持activerecord形式调用，实体类只需继承model类即可进行强大的crud操作 -支持自定义全局通用操作：支持全局通用方法注入（write once,use anywhere），内置代码生成器：采用代码或者maven插件可快速生成mapper、model、service、controller层代码，支持模板引擎，更有超多自定义配置等您来使用\n * 内置分页插件：基于mybatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通list查询。分页插件支持多种数据库：支持mysql、mariadb、oracle、db2、h2、hsql、sqlite、postgre、sqlserver等多种数据库内置性能分析插件：可输出sql语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询：内置全局拦截插件：提供全表delete、update操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n\n# 3、支持数据库\n\n任何能使用mybatis进行crud,并且支持标准sql的数据库，具体支持情况如下：mysql，oracle，db2，h2，hsql，sqlite，postgresql，sqlserver，phoenix，gauss，clickhouse，sybase，oceanbase，firebird，cubrid，goldilocks，csiidb达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库\n\n\n# 4、框架结构\n\n\n# 5 、代码及文档地址\n\n * 官方地址: http://mp.baomidou.com\n * 代码发布地址:\n   * github: https://github.com/baomidou/mybatis-plus\n   * gitee: https://gitee.com/baomidou/mybatis-plus\n   * 文档发布地址: https://baomidou.com/pages/24112f",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroImage:"/img/myhead.png",heroText:"心存感激，所遇皆温柔。",tagline:"《海街日记》",bannerBg:"none",postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-c70045c2",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{}}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"计算机基础",link:"/computerbasics/",items:[{text:"数据结构",link:"/datastructrue/001/"},{text:"计算机网络",link:"/computerinternet/001/"},{text:"操作系统",link:"/operatingsystem/001/"}]},{text:"开发工具",link:"/tools/",items:[{text:"Markdown",link:"/markdown/001/"},{text:"Git",link:"/git/001/"}]},{text:"算法",link:"/leetcode/001/"},{text:"Java",link:"/java/",items:[{text:"基础",link:"/basis/001/"},{text:"高级",link:"/high/001/"}]},{text:"JavaWeb",link:"/javaweb/",items:[{text:"基础",link:"/web/001/"}]},{text:"数据库",link:"/database/",items:[{text:"MySQL",link:"/mysql/001/"}]},{text:"框架",link:"/framework/",items:[{text:"Spring",link:"/spring/001/"},{text:"SpringMVC",link:"/springmvc/001/"},{text:"SpringBoot",link:"/springboot/001/"},{text:"MyBatis",link:"/mybatis/001/"},{text:"MyBatis-Plus",link:"/mybatis-plus/001/"}]}],sidebarDepth:2,searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/00.目录页/":[["01.计算机基础.md","计算机基础","/computerbasics/"],["02.开发工具.md","开发工具","/tools/"],["04.Java.md","更多","/java/"],["05.JavaWeb.md","技术","/javaweb/"],["06.数据库.md","更多","/database/"],["07.框架.md","框架","/framework/"]],catalogue:{"计算机基础":"/computerbasics/","开发工具":"/tools/",Java:"/java/",JavaWeb:"/javaweb/","数据库":"/database/","框架":"/framework/"},"/01.计算机基础/":[{title:"数据结构",collapsable:!0,children:[["01.数据结构/01.红黑树.md","红黑树","/datastructrue/001/"]]},{title:"计算机网络",collapsable:!0,children:[["02.计算机网络/01.常见状态码.md","常见状态码","/computerinternet/001/"]]},{title:"操作系统",collapsable:!0,children:[["03.操作系统/01.常见问题总结.md","常见问题","/operatingsystem/001/"]]}],"/02.开发工具/":[{title:"Markdown",collapsable:!0,children:[["01.Markdown/01.Markdown使用教程.md","Markdown","/markdown/001/"]]},{title:"Git",collapsable:!0,children:[["02.Git/01.Git使用手册.md","Git","/git/001/"]]}],"/03.算法/":[["01.LeetCode.md","LeetCode","/leetcode/001/"]],"/04.Java/":[{title:"基础",collapsable:!0,children:[["01.基础/01.IO.md","IO","/basis/001/"]]},{title:"高级",collapsable:!0,children:[["02.高级/01.反射.md","反射","/high/001/"]]}],"/05.JavaWeb/":[{title:"基础",collapsable:!0,children:[["01.基础/01.Web基础概念.md","Web基础概念简介","/web/001/"]]}],"/06.数据库/":[{title:"MySQL",collapsable:!0,children:[["01.MySQL/01.概述.md","概述","/mysql/001/"]]}],"/07.框架/":[{title:"Spring",collapsable:!0,children:[["01.Spring/01.概述.md","概述","/spring/001/"]]},{title:"SpringMVC",collapsable:!0,children:[["02.SpringMVC/01.SpringMVC简介.md","SpringMVC简介","/springmvc/001/"],["02.SpringMVC/02.HelloWorld.md","HelloWorld","/springmvc/002/"],["02.SpringMVC/03.RequestMapping注解.md","RequestMapping注解","/springmvc/003/"],["02.SpringMVC/04.SpringMVC获取请求参数.md","SpringMVC获取请求参数","/springmvc/004/"],["02.SpringMVC/05.域对象共享数据.md","域对象共享数据","/springmvc/005/"],["02.SpringMVC/06.SpringMVC的视图.md","SpringMVC的视图","/springmvc/006/"],["02.SpringMVC/07.RESTful.md","RESTful","/springmvc/007/"],["02.SpringMVC/08.RESTful案例.md","RESTful案例","/springmvc/008/"],["02.SpringMVC/09.文件上传和下载.md","文件上传和下载","/springmvc/009/"],["02.SpringMVC/10.拦截器.md","拦截器","/springmvc/010/"],["02.SpringMVC/11.异常处理器.md","异常处理器","/springmvc/011/"],["02.SpringMVC/12.注解配置SpringMVC.md","注解配置SpringMVC","/springmvc/012/"],["02.SpringMVC/13.SpringMVC执行流程.md","SpringMVC执行流程","/springmvc/013/"]]},{title:"SpringBoot",collapsable:!0,children:[["03.SpringBoot/01.快速入门.md","快速入门","/springboot/001/"],["03.SpringBoot/02.运维.md","运维","/springboot/002/"],["03.SpringBoot/03.开发实用篇.md","开发","/springboot/003/"],["03.SpringBoot/04.原理.md","原理","/springboot/004/"]]},{title:"MyBatis",collapsable:!0,children:[["04.MyBatis/01.简介及配置.md","简介及配置","/mybatis/001/"],["04.MyBatis/02.核心配置文件详解.md","核心配置文件详解","/mybatis/002/"],["04.MyBatis/03.MyBatis的各种查询功能.md","MyBatis的各种查询功能","/mybatis/003/"],["04.MyBatis/04.自定义映射resultMap.md","自定义映射resultMap","/mybatis/004/"],["04.MyBatis/05.动态SQL.md","动态SQL","/mybatis/005/"],["04.MyBatis/06.MyBatis的缓存.md","MyBatis的缓存","/mybatis/006/"],["04.MyBatis/07.MyBatis的逆向工程.md","MyBatis的逆向工程","/mybatis/007/"],["04.MyBatis/08.分页插件.md","分页插件","/mybatis/008/"]]},{title:"MyBatis-Plus",collapsable:!0,children:[["05.MyBatis-Plus/01.简介.md","简介","/mybatis-plus/001/"]]}]},sidebarOpen:!0,updateBar:{showToArticle:!1,moreArticle:"/archives"},titleBadge:!0,category:!1,tag:!1,archive:!1,social:{icons:[{iconClass:"icon-youjian",title:"本主页部分内容来自网络，侵权请联系1548362125@qq.com删除。",link:"mailto:894072666@qq.com"}]},footer:{createYear:2019,copyrightInfo:"Evan Xu | MIT License"},htmlModules:{pageT:'\n  <div class="wwads-cn wwads-horizontal page-ad" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .page-ad img{\n      width:70px!important;\n    }\n    .wwads-horizontal .wwads-content{\n      display: flex;\n      align-items: center;\n    }\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{\n      line-height:1;\n      flex: 1;\n      height: 100%;\n      display: flex;\n      align-items: center;\n    }\n    .wwads-horizontal .wwads-poweredby, .wwads-vertical .wwads-poweredby{display: none;!important;}\n  </style>\n  '}}};t(155),t(214),t(143);var ll=t(224),cl=t(225),pl=(t(391),t(240),t(42));var dl={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,i=e.home;return!(t||!1===r||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(pl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(pl.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(pl.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,i){var a=n[r].frontmatter,o=a.categories,s=a.tags;"array"===Object(pl.n)(o)&&o.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(pl.n)(s)&&s.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},i=0,a=n.length;i<a;i++)r(i);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var i in n.tags)t.push({key:i,length:n.tags[i].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Bi.component(ll.default),Bi.component(cl.default);function ul(n){return n.toString().padStart(2,"0")}t(395);Bi.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,538))})),Bi.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,224))})),Bi.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,225))}));t(396);var ml=[function(n){n.Vue,n.options;var e=n.router;n.siteData;n.isServer||e.afterEach((function(){var n;n=function(){setTimeout((function(){var n,e;void 0===window._AdBlockInit&&(n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content"),n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>万维</span><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>"))}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout((function(){var n=document.querySelector(".page-ad");if(n){var e=n.querySelector(".wwads-hide");e&&(e.onclick=function(){n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")}}),900)}))},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,i=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(ul(n.getUTCMonth()+1),"-").concat(ul(n.getUTCDate())," ").concat(ul(n.getUTCHours()),":").concat(ul(n.getUTCMinutes()),":").concat(ul(n.getUTCSeconds()))}(r)),i?n.author=i:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(dl)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{}],gl=[];t(217);function hl(n,e){return(hl=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(218),t(219);function vl(n){return(vl=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function fl(n,e){if(e&&("object"===Co(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function bl(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=vl(n);if(e){var i=vl(this).constructor;t=Reflect.construct(r,arguments,i)}else t=r.apply(this,arguments);return fl(this,t)}}var yl=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&hl(n,e)}(t,n);var e=bl(t);function t(){return cs(this,t),e.apply(this,arguments)}return ds(t)}(function(){function n(){cs(this,n),this.store=new Bi({data:{state:{}}})}return ds(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Bi.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(yl.prototype,{getPageAsyncComponent:Ho,getLayoutAsyncComponent:Vo,getAsyncComponent:Uo,getVueComponent:$o});var xl={install:function(n){var e=new yl;n.$vuepress=e,n.prototype.$vuepress=e}};function wl(n){n.beforeEach((function(e,t,r){if(Sl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var i=e.path.replace(/\/$/,"")+".html";Sl(n,i)?r(i):r()}else r();else{var a=e.path+"/",o=e.path+".html";Sl(n,o)?r(o):Sl(n,a)?r(a):r()}}))}function Sl(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var kl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Wo("pageKey",e),Bi.component(e)||Bi.component(e,Ho(e)),Bi.component(e)?n(e):n("")}},jl={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},ql={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Cl=(t(397),t(398),Object(il.a)(ql,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Il(){return(Il=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,i,a;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:sl.routerBase||sl.base,wl(r=new jo({base:t,mode:"history",fallback:!1,routes:ol,scrollBehavior:function(n,e,t){return t||(n.hash?!Bi.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(ml.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Bi,options:i,router:r,siteData:sl,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return a=new Bi(Object.assign(i,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},gl.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:a,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Bi.config.productionTip=!1,Bi.use(jo),Bi.use(xl),Bi.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bi;qo(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),i=new r,a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(a).reduce((function(n,e){return e.startsWith("$")&&(n[e]=a[e].get),n}),o),{computed:o}}((function(n){return function(){function e(){cs(this,e)}return ds(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var i in r)"/"===i?e=r[i]:0===this.$page.path.indexOf(i)&&(n=r[i]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),sl)),Bi.component("Content",kl),Bi.component("ContentSlotsDistributor",jl),Bi.component("OutboundLink",Cl),Bi.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Bi.component("Layout",Vo("Layout")),Bi.component("NotFound",Vo("NotFound")),Bi.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:""},function(n){return Il.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);